<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLES_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"(())\",\n\t\"()()\",\n\t\"))(((((\",\n\t\"())\",\n\t\"))(\",\n\t\")))\",\n\t\")())())\",\n];\n\nconst EXAMPLES_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\")\",\n\t\"()())\",\n];\n\n#[ test ]\nfn part_one () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq! (\"0\", puzzle.part_one (\u0026 [EXAMPLES_ONE [0]]) ?);\n\tassert_eq! (\"0\", puzzle.part_one (\u0026 [EXAMPLES_ONE [1]]) ?);\n\tassert_eq! (\"3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [2]]) ?);\n\tassert_eq! (\"-1\", puzzle.part_one (\u0026 [EXAMPLES_ONE [3]]) ?);\n\tassert_eq! (\"-1\", puzzle.part_one (\u0026 [EXAMPLES_ONE [4]]) ?);\n\tassert_eq! (\"-3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [5]]) ?);\n\tassert_eq! (\"-3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [6]]) ?);\n\tOk (())\n}\n\n#[ test ]\nfn part_two () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq! (\"1\", puzzle.part_two (\u0026 [EXAMPLES_TWO [0]]) ?);\n\tassert_eq! (\"5\", puzzle.part_two (\u0026 [EXAMPLES_TWO [1]]) ?);\n\tOk (())\n}\n","traces":[{"line":21,"address":[36272,36276],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":22,"address":[45342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[46388,46631,45489,47061,45363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[45506,46416,45628,46674,47047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[47009,46441,45645,45767,46717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[45784,45906,46466,46760,46995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[45923,46800,46981,46491,46045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[46840,46062,46967,46516,46184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[46201,46880,46953,46541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[36304,36308],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":35,"address":[47118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[47139,47708,47264,47454,47560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[47600,47281,47402,47479,47694],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","input.rs"],"content":"use super::*;\n\nuse model::Dir;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub dirs: Vec \u003cDir\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { dirs, params } = [ params, @collect dirs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[27658,26927],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","lib.rs"],"content":"//! Advent of Code 2015: Day 1: Not Quite Lisp\n//!\n//! [https://adventofcode.com/2015/day/1](https://adventofcode.com/2015/day/1)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Not Quite Lisp\";\n\tyear = 2015;\n\tday = 1;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[33704],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tOk (\n\t\tinput.dirs.iter ().copied ().enumerate ()\n\t\t\t.scan (0_i32, |floor, (idx, dir)| {\n\t\t\t\t* floor += dir.val ();\n\t\t\t\tSome ((idx, * floor))\n\t\t\t})\n\t\t\t.last ()\n\t\t\t.map_or (0_i32, |(_, floor)| floor)\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tOk (\n\t\tinput.dirs.iter ().copied ().enumerate ()\n\t\t\t.scan (0_i32, |floor, (idx, dir)| {\n\t\t\t\t* floor += dir.val ();\n\t\t\t\tSome ((idx, * floor))\n\t\t\t})\n\t\t\t.find_map (|(idx, floor)| (floor \u003c 0_i32).then_some (idx + 1))\n\t\t\t.ok_or (\"Never visited the basement\") ?\n\t)\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tuse model::Dir::{ self, Down, Up };\n\n\tfn make_input (dirs: impl IntoIterator \u003cItem = Dir\u003e) -\u003e Input {\n\t\tInput { dirs: dirs.into_iter ().collect (), params: default () }\n\t}\n\n\t#[ test ]\n\tfn part_one () {\n\t\tassert_eq_ok! (3, logic::part_one (\u0026 make_input ([Up, Up, Up])));\n\t\tassert_eq_ok! (-1, logic::part_one (\u0026 make_input ([Up, Down, Down])));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tassert_eq_ok! (3, logic::part_two (\u0026 make_input ([Up, Down, Down])));\n\t\tassert_err! (\"Never visited the basement\", logic::part_two (\u0026 make_input ([Up, Down])));\n\t}\n\n}\n","traces":[{"line":5,"address":[43264],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[37520],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":9,"address":[48188,48266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[37539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[37602,37600],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":17,"address":[43456],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":19,"address":[43666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[37616],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":21,"address":[47996,47909],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[37635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[31794,31858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[36192,36112],"length":1,"stats":{"Line":0},"fn_name":"make_input\u003c[aoc_2015_day_01::model::Dir; 3]\u003e"},{"line":37,"address":[36163,36235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[36336,36340],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":42,"address":[39770,39172,39158,39486,39547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[39426,39676,39615,39437],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[36372,36368],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":48,"address":[39937,39904,40315,40487,40254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[40534,40068,40502,40432,40197,40044],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":13,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","model.rs"],"content":"use super::*;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Dir {\n\t\tUp = [ \"(\" ],\n\t\tDown = [ \")\" ],\n\t}\n}\n\nimpl Dir {\n\n\t#[ must_use ]\n\tpub const fn val (\u0026 self) -\u003e i32 {\n\t\tmatch * self { Self::Up =\u003e 1_i32, Self::Down =\u003e -1_i32 }\n\t}\n\n}\n","traces":[{"line":14,"address":[43744],"length":1,"stats":{"Line":0},"fn_name":"val"}],"covered":0,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"2x3x4\", \"1x1x10\" ];\n\n#[ test ]\nfn part_one () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"58\", puzzle.part_one (\u0026 EXAMPLE [0 .. 1]));\n\tassert_eq_ok! (\"43\", puzzle.part_one (\u0026 EXAMPLE [1 .. 2]));\n\tassert_eq_ok! (\"101\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"34\", puzzle.part_two (\u0026 EXAMPLE [0 .. 1]));\n\tassert_eq_ok! (\"14\", puzzle.part_two (\u0026 EXAMPLE [1 .. 2]));\n\tassert_eq_ok! (\"48\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","input.rs"],"content":"use super::*;\n\nuse model::Dim;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub sizes: Vec \u003c(Dim, Dim, Dim)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { sizes, params } = [\n\t\tparams,\n\t\t@lines sizes {\n\t\t\ttype = (Dim, Dim, Dim);\n\t\t\t(w, h, l) = [ w, \"x\", h, \"x\", l ]\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","lib.rs"],"content":"//! Advent of Code 2015: Day 2: I Was Told There Would Be No Math\n//!\n//! [https://adventofcode.com/2015/day/2](https://adventofcode.com/2015/day/2)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"I Was Told There Would Be No Math\";\n\tyear = 2015;\n\tday = 2;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Dim;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cDim\u003e {\n\tOk (\n\t\tinput.sizes.iter ()\n\t\t\t.map (|\u0026 (l, w, h)| {\n\t\t\t\tlet sides = [ chk! (l * w) ?, chk! (w * h) ?, chk! (h * l) ? ];\n\t\t\t\tlet total = sides.into_iter ().try_fold (0, |sum, val| chk! (sum + val)) ?;\n\t\t\t\tlet smallest = sides.into_iter ().min ().unwrap ();\n\t\t\t\tchk! (2 * total + smallest)\n\t\t\t})\n\t\t\t.try_fold (0, |sum, val| { let val = val ?; chk! (sum + val) }) ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cDim\u003e {\n\tOk (\n\t\tinput.sizes.iter ()\n\t\t\t.map (|\u0026 (l, w, h)| {\n\t\t\t\tlet pairs = [ chk! (l + w) ?, chk! (w + h) ?, chk! (h + l) ? ];\n\t\t\t\tlet smallest = pairs.into_iter ().min ().unwrap ();\n\t\t\t\tlet product = [l, w, h].into_iter ().try_fold (1, |prod, val| chk! (prod * val)) ?;\n\t\t\t\tchk! (2 * smallest + product)\n\t\t\t})\n\t\t\t.try_fold (0, |sum, val| { let val = val ?; chk! (sum + val) }) ?\n\t)\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tfn make_input (sizes: impl IntoIterator \u003cItem = (Dim, Dim, Dim)\u003e) -\u003e Input {\n\t\tInput { sizes: sizes.into_iter ().collect (), params: default () }\n\t}\n\n\t#[ test ]\n\tfn part_one () {\n\t\tassert_eq_ok! (0, logic::part_one (\u0026 make_input ([ ])));\n\t\tassert_eq_ok! (101, logic::part_one (\u0026 make_input ([ (2, 3, 4), (1, 1, 10) ])));\n\t\tconst BIG: u32 = 24770;\n\t\tassert_is_ok! (logic::part_one (\u0026 make_input ([ (BIG, BIG, BIG) ])));\n\t\tassert_err! (\"Overflow\", logic::part_one (\u0026 make_input ([ (BIG + 1, BIG + 1, BIG + 1) ])));\n\t\tassert_err! (\"Overflow\", logic::part_one (\u0026 make_input ([ (BIG, BIG, BIG), (BIG, BIG, BIG) ])));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tassert_eq_ok! (0, logic::part_two (\u0026 make_input ([ ])));\n\t\tassert_eq_ok! (48, logic::part_two (\u0026 make_input ([ (2, 3, 4), (1, 1, 10) ])));\n\t\tconst BIG: u32 = 1625;\n\t\tassert_is_ok! (logic::part_two (\u0026 make_input ([ (BIG, BIG, BIG) ])));\n\t\tassert_err! (\"Overflow\", logic::part_two (\u0026 make_input ([ (BIG + 1, BIG + 1, BIG + 1) ])));\n\t\tassert_err! (\"Overflow\", logic::part_two (\u0026 make_input ([ (BIG, BIG, BIG), (BIG, BIG, BIG) ])));\n\t}\n\n}\n","traces":[{"line":6,"address":[19328],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[22751,21869,22693,21627,22090,22434,21382],"length":1,"stats":{"Line":5},"fn_name":null},{"line":9,"address":[12809,12784,13309,12798],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":10,"address":[12870,14160,12825,14096,14064,14032,14128,12914,14000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[13129,13294,13328,14192,14208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[13204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[14224,14256,14288,14304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[13349,14336,14320,13344],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":19,"address":[19456],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":21,"address":[19497],"length":1,"stats":{"Line":5},"fn_name":null},{"line":22,"address":[13902,13406,13392],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":23,"address":[14416,14432,13431,14368,13517,14352,13474,14384,14400],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[13603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[14480,13920,13887,14448,13788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[14592,14576,14512,14544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[13952,13957,14608,14624],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":37,"address":[15024,14928,14832],"length":1,"stats":{"Line":0},"fn_name":"make_input\u003c[(u32, u32, u32); 2]\u003e"},{"line":38,"address":[14984,15046,14888],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[15076,15072],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":43,"address":[22874,21477,21491,22813,23334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[21736,21722,22952,23013,23319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[23349,23082,21969,21977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[23109,23265,23384,23295,22288,22150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[22632,23369,23241,23151,22494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[15104,15108],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":53,"address":[25002,25462,23605,24941,23619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[23864,25080,25141,25447,23850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[25210,24105,25477,24097],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[25423,24278,25237,25512,24416,25393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[25279,24622,25497,24760,25369],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":25,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","model.rs"],"content":"pub type Dim = u32;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [\"\u003e\"]));\n\tassert_eq_ok! (\"4\", puzzle.part_one (\u0026 [\"^\u003ev\u003c\"]));\n\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [\"^v^v^v^v^v\"]));\n\tOk (())\n}\n\n#[ test ]\nfn part_two () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [\"^v\"]));\n\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [\"^\u003ev\u003c\"]));\n\tassert_eq_ok! (\"11\", puzzle.part_two (\u0026 [\"^v^v^v^v^v\"]));\n\tOk (())\n}\n","traces":[{"line":6,"address":[39972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[46401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[46831,47338,46520,46422,46897,46464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[47026,47300,46580,46639,46542,46965],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[47091,46661,46764,46705,47152,47259],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[40004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[47409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[47472,48346,47430,47528,47839,47905],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[47550,47588,47647,48034,47973,48308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[48160,47772,47669,48099,48267,47713],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","input.rs"],"content":"use super::*;\n\nuse model::Dir;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub moves: Vec \u003cDir\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { moves, params } = [\n\t\tparams,\n\t\t@collect moves {\n\t\t\ttype = Dir;\n\t\t\tDir::North = [ \"^\" ],\n\t\t\tDir::South = [ \"v\" ],\n\t\t\tDir::East = [ \"\u003e\" ],\n\t\t\tDir::West = [ \"\u003c\" ],\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[24282,23871],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","lib.rs"],"content":"//! Advent of Code 2015: Day 3: Perfectly Spherical Houses in a Vacuum\n//!\n//! [https://adventofcode.com/2015/day/3](https://adventofcode.com/2015/day/3)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Perfectly Spherical Houses in a Vacuum\";\n\tyear = 2015;\n\tday = 3;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[32760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[33080],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.moves.iter ()\n\t\t\t.scan (Pos::ZERO, |pos, \u0026 dir| { * pos += Pos::from (dir); Some (* pos) })\n\t\t\t.chain (iter::once (Pos::ZERO))\n\t\t\t.collect::\u003cHashSet \u003c_\u003e\u003e ()\n\t\t\t.len ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.moves.iter ()\n\t\t\t.scan ((Pos::ZERO, Pos::ZERO), |\u0026 mut (ref mut pos_0, ref mut pos_1), \u0026 dir| {\n\t\t\t\tmem::swap (pos_0, pos_1);\n\t\t\t\t* pos_0 += Pos::from (dir);\n\t\t\t\tSome (* pos_0)\n\t\t\t})\n\t\t\t.chain (iter::once (Pos::ZERO))\n\t\t\t.collect::\u003cHashSet \u003c_\u003e\u003e ()\n\t\t\t.len ()\n\t\t\t.pan_u32 ()\n\t)\n}\n","traces":[{"line":6,"address":[45917,45488],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[31960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[45936,46366],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[31612],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","model.rs"],"content":"use super::*;\n\npub type Dir = pos::DirGeo;\npub type Pos = pos::PosGeo \u003ci16\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","cli.rs"],"content":"#![ cfg (not (tarpaulin_include)) ]\n\nuse super::*;\n\nuse std::path::PathBuf;\n\nuse input::Input;\nuse std::io::Read as _;\nuse std::fs::File;\nuse std::sync::atomic::AtomicBool;\nuse std::sync::atomic::Ordering;\n\n#[ derive (clap::Parser) ]\npub struct RunArgs {\n\n\t#[ clap (from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n\n\t#[ clap (long) ]\n\tmax_threads: Option \u003cu32\u003e,\n\n\t#[ clap (long, default_value = \"5\") ]\n\tnum_zeros: u32,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\tlet input_lines: Vec \u003c_\u003e = input_string.trim ().split ('\\n').collect ();\n\tprintln! (\"Using input file: {}\", args.input.display ());\n\tprintln! (\"Looking for {} zeros\", args.num_zeros);\n\tlet mut input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tif let Some (max_threads) = args.max_threads { input.params.max_threads = max_threads; }\n\tlet result = logic::calc_result (\u0026 input, args.num_zeros) ?;\n\tprintln! (\"Result: {}\", result);\n\tOk (())\n}\n\n#[ derive (Clone, clap::Parser) ]\npub struct FindTestCaseArgs {\n\n\t#[ clap (long, default_value = \"16\") ]\n\tlen: usize,\n\n\t#[ clap (long, default_value = \"3999\") ]\n\tmax: usize,\n\n}\n\n#[ allow (clippy::needless_collect) ]\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::unnecessary_wraps) ]\npub fn find_test_case (args: FindTestCaseArgs) -\u003e GenResult \u003c()\u003e {\n\tassert! (args.len \u003e= 4);\n\tassert! (args.max \u003c 0x_0100_0000);\n\tlet complete = Arc::new (AtomicBool::new (false));\n\tlet threads: Vec \u003c_\u003e = (0_u32 .. 4_u32)\n\t\t.map (|_| {\n\t\t\tlet args = args.clone ();\n\t\t\tlet complete = Arc::clone (\u0026 complete);\n\t\t\tstd::thread::spawn (move || find_test_case_worker (args, complete))\n\t\t})\n\t\t.collect ();\n\tthreads.into_iter ().for_each (|thread| thread.join ().unwrap ());\n\tOk (())\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\n#[ allow (clippy::string_slice) ]\nfn find_test_case_worker (args: FindTestCaseArgs, complete: Arc \u003cAtomicBool\u003e) {\n\tlet mut rand = File::open (\"/dev/urandom\").unwrap ();\n\t'OUTER: loop {\n\t\tif complete.load (Ordering::Acquire) { break }\n\t\tlet num = loop {\n\t\t\tlet mut buf = [0; 3];\n\t\t\tassert_eq! (3, rand.read (\u0026 mut buf).unwrap ());\n\t\t\tlet num =\n\t\t\t\t(buf [0].pan_usize () \u003c\u003c 16_u32)\n\t\t\t\t\t| (buf [1].pan_usize () \u003c\u003c 8_u32)\n\t\t\t\t\t| buf [2].pan_usize ();\n\t\t\tif num \u003c= args.max { break num }\n\t\t};\n\t\tlet mut buffer = String::new ();\n\t\tfor _ in 0 .. args.len - 4 {\n\t\t\tlet ch = loop {\n\t\t\t\tlet mut buf = [0; 1];\n\t\t\t\tassert_eq! (1, rand.read (\u0026 mut buf).unwrap ());\n\t\t\t\tlet ch = buf [0].pan_char ();\n\t\t\t\tif ('a' ..= 'z').contains (\u0026 ch) { break ch }\n\t\t\t};\n\t\t\tbuffer.push (ch);\n\t\t}\n\t\tfor chars in ('a' ..= 'z').permutations (4) {\n\t\t\tbuffer.truncate (args.len - 4);\n\t\t\tfor ch in chars { buffer.push (ch); }\n\t\t\twrite! (buffer, \"{}\", num).unwrap ();\n\t\t\tlet hash = md5::md5_hash (buffer.as_bytes ());\n\t\t\tif hash [0] == 0 \u0026\u0026 hash [1] == 0 \u0026\u0026 hash [2] == 0 {\n\t\t\t\tfor num in 1 .. num {\n\t\t\t\t\tlet buffer = format! (\"{}{}\", \u0026 buffer [0 .. args.len], num);\n\t\t\t\t\tlet hash = md5::md5_hash (buffer.as_bytes ());\n\t\t\t\t\tif hash [0] == 0 \u0026\u0026 hash [1] == 0 \u0026\u0026 hash [2] \u0026 0xf0 == 0\n\t\t\t\t\t\t\t\u0026\u0026 hash [2] \u0026 0xf != 0 {\n\t\t\t\t\t\tprintln! (\"{:?}\", \u0026 buffer [0 .. args.len]);\n\t\t\t\t\t\tcomplete.store (true, Ordering::Release);\n\t\t\t\t\t\tbreak 'OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"xxebvswgx\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3206\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4846\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[93780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[195505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[195570,195817,195877,195975,195623,195528,195760],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[93684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[196145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[196517,196168,196263,196457,196210,196615,196400],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub seed: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { seed, params } = [\n\t\tparams,\n\t\t@str seed = (|ch| { ch.is_ascii_lowercase () }, 1 .. 100),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_zeros_one: u32 = (\"NUM_ZEROS_ONE=\", 5, 1_u32 .. ),\n\t\tpub num_zeros_two: u32 = (\"NUM_ZEROS_TWO=\", 6, 1_u32 .. ),\n\t\tpub max_threads: u32 = (\"MAX_THREADS=\", u32::MAX, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":11,"address":[178151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[178835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[178839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[178831],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","lib.rs"],"content":"//! Advent of Code 2015: Day 4: The Ideal Stocking Stuffer\n//!\n//! [https://adventofcode.com/2015/day/4](https://adventofcode.com/2015/day/4)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_md5 as md5;\nuse aoc_parallel::{ self as parallel, prelude::* };\n\npub mod cli;\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"The Ideal Stocking Stuffer\";\n\tyear = 2015;\n\tday = 4;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = cli::run; ),\n\t\t( name = \"find-test-case\"; method = cli::find_test_case; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse md5::Output;\n\nconst BATCH_SIZE: u32 = 10_000;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, input.params.num_zeros_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, input.params.num_zeros_two)\n}\n\npub fn calc_result (input: \u0026 Input, num_zeros: u32) -\u003e GenResult \u003cu32\u003e {\n\tlet check_fn = check_zeros_fn (num_zeros);\n\tlet mut base_iter = (1 .. ).step_by (BATCH_SIZE.pan_usize ());\n\tlet num_threads = parallel::num_cpus_max (input.params.max_threads);\n\tlet result = if 1 \u003c num_threads {\n\t\tlet seed = Arc::from (\u0026 * input.seed);\n\t\tbase_iter\n\t\t\t.thread_map (\n\t\t\t\tnum_threads.pan_usize (),\n\t\t\t\tmove |base| search_range (\u0026 seed, base .. base + BATCH_SIZE, \u0026 check_fn))\n\t\t\t.flatten ()\n\t\t\t.next ()\n\t} else {\n\t\tbase_iter\n\t\t\t.find_map (|base| search_range (\u0026 input.seed, base .. base + BATCH_SIZE, \u0026 check_fn))\n\t};\n\tOk (result.ok_or (\"No solution found\") ?)\n}\n\nfn search_range (\n\tinput: \u0026 str,\n\trange: Range \u003cu32\u003e,\n\tcheck_fn: \u0026 (dyn Fn (\u0026 Output) -\u003e bool + Send + Sync),\n) -\u003e Option \u003cu32\u003e {\n\tlet base = range.start;\n\tlet mut input_buf = format! (\"{input}{base}\").as_bytes ().to_vec ();\n\tfor num in range {\n\t\tlet hash = md5::md5_hash (\u0026 input_buf);\n\t\tif check_fn (\u0026 hash) { return Some (num) }\n\t\tlet mut num_zeros = 0;\n\t\twhile input.len () \u003c input_buf.len () {\n\t\t\tlet next_digit = match input_buf.pop ().unwrap () {\n\t\t\t\tb'0' =\u003e b'1', b'1' =\u003e b'2', b'2' =\u003e b'3',\n\t\t\t\tb'3' =\u003e b'4', b'4' =\u003e b'5', b'5' =\u003e b'6',\n\t\t\t\tb'6' =\u003e b'7', b'7' =\u003e b'8', b'8' =\u003e b'9',\n\t\t\t\tb'9' =\u003e {\n\t\t\t\t\tnum_zeros += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t};\n\t\t\tinput_buf.push (next_digit);\n\t\t\tbreak;\n\t\t}\n\t\tif input_buf.len () == input.len () { input_buf.push (b'1'); }\n\t\tinput_buf.extend (iter::repeat (b'0').take (num_zeros));\n\t}\n\tNone\n}\n\nfn check_zeros \u003cconst ZRS: usize\u003e (hash: \u0026 Output) -\u003e bool {\n\tfor idx in 0 .. hash.len () {\n\t\tif ZRS == idx * 2 + 1 \u0026\u0026 hash [idx] \u0026 0xf0 != 0 { return false }\n\t\tif ZRS \u003e= idx * 2 + 2 \u0026\u0026 hash [idx] != 0 { return false }\n\t}\n\ttrue\n}\n\nfn check_zeros_fn (num_zeros: u32) -\u003e fn (\u0026 Output) -\u003e bool {\n\tmatch num_zeros {\n\t\t0 =\u003e check_zeros::\u003c0\u003e, 1 =\u003e check_zeros::\u003c1\u003e, 2 =\u003e check_zeros::\u003c2\u003e,\n\t\t3 =\u003e check_zeros::\u003c3\u003e, 4 =\u003e check_zeros::\u003c4\u003e, 5 =\u003e check_zeros::\u003c5\u003e,\n\t\t6 =\u003e check_zeros::\u003c6\u003e, 7 =\u003e check_zeros::\u003c7\u003e, 8 =\u003e check_zeros::\u003c8\u003e,\n\t\t9 =\u003e check_zeros::\u003c9\u003e, 10 =\u003e check_zeros::\u003c10\u003e, 11 =\u003e check_zeros::\u003c11\u003e,\n\t\t12 =\u003e check_zeros::\u003c12\u003e, 13 =\u003e check_zeros::\u003c13\u003e, 14 =\u003e check_zeros::\u003c14\u003e,\n\t\t15 =\u003e check_zeros::\u003c15\u003e, 16 =\u003e check_zeros::\u003c16\u003e, 17 =\u003e check_zeros::\u003c17\u003e,\n\t\t18 =\u003e check_zeros::\u003c18\u003e, 19 =\u003e check_zeros::\u003c19\u003e, 20 =\u003e check_zeros::\u003c20\u003e,\n\t\t21 =\u003e check_zeros::\u003c21\u003e, 22 =\u003e check_zeros::\u003c22\u003e, 23 =\u003e check_zeros::\u003c23\u003e,\n\t\t24 =\u003e check_zeros::\u003c24\u003e, 25 =\u003e check_zeros::\u003c25\u003e, 26 =\u003e check_zeros::\u003c26\u003e,\n\t\t27 =\u003e check_zeros::\u003c27\u003e, 28 =\u003e check_zeros::\u003c28\u003e, 29 =\u003e check_zeros::\u003c29\u003e,\n\t\t30 =\u003e check_zeros::\u003c30\u003e, 31 =\u003e check_zeros::\u003c31\u003e, 32 =\u003e check_zeros::\u003c32\u003e,\n\t\t_ =\u003e unreachable! (),\n\t}\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn check_zeros_fn () {\n\t\tfn with_zeros (zeros: u32) -\u003e Output {\n\t\t\tlet mut hex = String::new ();\n\t\t\tfor _ in 0 .. zeros { hex.push ('0'); }\n\t\t\twhile hex.len () \u003c 32 { hex.push ('f'); }\n\t\t\tOutput::from_hex (\u0026 hex).unwrap ()\n\t\t}\n\t\tfor zeros in 0 ..= 32 {\n\t\t\tlet check_fn = logic::check_zeros_fn (zeros);\n\t\t\tlet should_pass = with_zeros (zeros);\n\t\t\tassert! (check_fn (\u0026 should_pass));\n\t\t\tif zeros \u003e 0 {\n\t\t\t\tlet should_fail = with_zeros (zeros - 1);\n\t\t\t\tassert! (! check_fn (\u0026 should_fail), \"Should fail for {} zeros: {}\", zeros, should_fail);\n\t\t\t}\n\t\t}\n\t}\n\n\t#[ test ]\n\t#[ should_panic ]\n\tfn check_zeros_fn_panic () {\n\t\tlet _ = logic::check_zeros_fn (33);\n\t}\n\n}\n","traces":[{"line":8,"address":[73344],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":9,"address":[73348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[73376],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":13,"address":[179844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[73408,73984],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":17,"address":[73454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[73481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[73542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[56747,56721,56720],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":30,"address":[86456,86417],"length":1,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[73785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[74000,75161],"length":1,"stats":{"Line":2},"fn_name":"search_range"},{"line":40,"address":[74043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[74052,75127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[74548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[74577,74612],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[74601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[74603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[74820,74636],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[75184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[75185,73425],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[134560,134564],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":98,"address":[82208,82559],"length":1,"stats":{"Line":1},"fn_name":"with_zeros"},{"line":101,"address":[82306,82421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[82321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[81963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[81997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[82007,82169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[82021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[82025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[82036,82134],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[82576],"length":1,"stats":{"Line":0},"fn_name":"check_zeros_fn_panic"}],"covered":30,"coverable":37},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-05","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"ugknbfddgicrmopn\",\n\t\"aaa\",\n\t\"jchzalrnumimnmhp\",\n\t\"haegwjzuvuyypxyu\",\n\t\"dvszwmarrgswjxmb\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"qjhvhtzxzqqjkmpb\",\n\t\"xxyxx\",\n\t\"uurcxstgmygtbstg\",\n\t\"ieodomkazucvgmuy\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":21,"address":[37824,38215],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":22,"address":[37834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[37945,38068,37893,37855,38002,38172],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[38224,38615],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":28,"address":[38234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[38255,38293,38468,38572,38402],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-05","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub strings: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { strings, params } = [\n\t\tparams,\n\t\t@lines strings { string = [\n\t\t\t@str string = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 100),\n\t\t] },\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[33556],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-05","lib.rs"],"content":"//! Advent of Code 2015: Day 5: Doesn't He Have Intern-Elves For This?\n//!\n//! [https://adventofcode.com/2015/day/5](https://adventofcode.com/2015/day/5)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Doesn't He Have Intern-Elves For This?\";\n\tyear = 2015;\n\tday = 5;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[47240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[47560],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-05","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.strings.iter ()\n\t\t\t.filter (|line| is_nice_one (line))\n\t\t\t.count ()\n\t\t\t.to_u32 () ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.strings.iter ()\n\t\t\t.filter (|line| is_nice_two (line))\n\t\t\t.count ()\n\t\t\t.to_u32 () ?\n\t)\n}\n\nfn is_nice_one (input: \u0026 str) -\u003e bool {\n\tif input.chars ()\n\t\t\t.filter (|ch| ['a', 'e', 'i', 'o', 'u'].contains (ch))\n\t\t\t.count () \u003c 3 {\n\t\treturn false;\n\t}\n\tif ! input.chars ()\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.any (|(ch_0, ch_1)| ch_0 == ch_1) {\n\t\treturn false;\n\t}\n\tif input.chars ()\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.any (|chars| [ ('a', 'b'), ('c', 'd'), ('p', 'q'), ('x', 'y') ]\n\t\t\t\t.contains (\u0026 chars)) {\n\t\treturn false;\n\t}\n\ttrue\n}\n\nfn is_nice_two (input: \u0026 str) -\u003e bool {\n\tif ! input.chars ()\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.enumerate ()\n\t\t\t.any (|(idx, chars_0)|\n\t\t\t\tinput.chars ().skip (idx + 2)\n\t\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t\t.any (|chars_1| chars_0 == chars_1)) {\n\t\treturn false;\n\t}\n\tif ! input.chars ()\n\t\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t\t.any (|(ch_0, _, ch_1)| ch_0 == ch_1) {\n\t\treturn false;\n\t}\n\ttrue\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn is_nice_one () {\n\t\tassert_eq! (true, logic::is_nice_one (\"ugknbfddgicrmopn\"));\n\t\tassert_eq! (true, logic::is_nice_one (\"aaa\"));\n\t\tassert_eq! (false, logic::is_nice_one (\"jchzalrnumimnmhp\"));\n\t\tassert_eq! (false, logic::is_nice_one (\"haegwjzuvuyypxyu\"));\n\t\tassert_eq! (false, logic::is_nice_one (\"dvszwmarrgswjxmb\"));\n\t}\n\n\t#[ test ]\n\tfn is_nice_two () {\n\t\tassert_eq! (true, logic::is_nice_two (\"qjhvhtzxzqqjkmpb\"));\n\t\tassert_eq! (true, logic::is_nice_two (\"xxyxx\"));\n\t\tassert_eq! (false, logic::is_nice_two (\"uurcxstgmygtbstg\"));\n\t\tassert_eq! (false, logic::is_nice_two (\"ieodomkazucvgmuy\"));\n\t}\n\n}\n","traces":[{"line":5,"address":[35360],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[35524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[32032,32055],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":14,"address":[35616],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[35780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[43748,43861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[35872],"length":1,"stats":{"Line":1},"fn_name":"is_nice_one"},{"line":24,"address":[35909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[32180,32096],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":29,"address":[36177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[54149,54981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[32208],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":37,"address":[32313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[36512],"length":1,"stats":{"Line":1},"fn_name":"is_nice_two"},{"line":44,"address":[36697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[32336,32350],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":48,"address":[32687,32362,32378],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[54825,55128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[54644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[44596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[38628,38758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[38653,38783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[38808,38678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[38833,38703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[38858,38728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[38912],"length":1,"stats":{"Line":2},"fn_name":"is_nice_two"},{"line":77,"address":[38916,39021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[39046,38941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[38966,39071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[38991,39096],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"turn on 0,0 through 999,999\",\n\t\"toggle 0,0 through 999,0\",\n\t\"turn off 499,499 through 500,500\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"turn on 0,0 through 0,0\",\n\t\"toggle 0,0 through 999,999\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"998996\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"999999\", puzzle.part_one (EXAMPLE_1));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1001996\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"2000001\", puzzle.part_two (EXAMPLE_1));\n}\n","traces":[{"line":17,"address":[41444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[52465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[52752,52527,52486,52580,52815,53074],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[52938,52690,52878,53038,52637,52600],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[41284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[53153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[53503,53174,53268,53762,53215,53440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[53566,53378,53626,53288,53726,53325],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","input.rs"],"content":"use super::*;\n\nuse model::Action;\nuse model::Coord;\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cInputStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @lines steps ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct InputStep {\n\tpub action: Action,\n\tpub origin: Pos,\n\tpub peak: Pos,\n}\n\nstruct_parser_display! {\n\tInputStep {\n\t\taction,\n\t\torigin: Pos { row: origin_row, col: origin_col },\n\t\tpeak: Pos { row: peak_row, col: peak_col },\n\t} = [\n\t\taction, \" \",\n\t\torigin_row = (Coord::MIN .. Coord::MAX), \",\", origin_col, \" through \",\n\t\tpeak_row, \",\", peak_col,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[40699],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","lib.rs"],"content":"//! Advent of Code 2015: Day 6: Probably a Fire Hazard\n//!\n//! [https://adventofcode.com/2015/day/6](https://adventofcode.com/2015/day/6)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Probably a Fire Hazard\";\n\tyear = 2015;\n\tday = 6;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[60344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[60664],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Action;\nuse model::Coord;\nuse model::Step;\nuse model::Steps;\nuse nums::Int;\n\npub type ModeFn = fn (Action, u8) -\u003e NumResult \u003cu8\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet steps = Steps::build (input) ?;\n\tcalc_result (\u0026 steps, mode_fn_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet steps = Steps::build (input) ?;\n\tcalc_result (\u0026 steps, mode_fn_two)\n}\n\n#[ allow (clippy::unnecessary_wraps) ]\nfn mode_fn_one (action: Action, old_active: u8) -\u003e NumResult \u003cu8\u003e {\n\tOk (match action {\n\t\tAction::On =\u003e 1,\n\t\tAction::Off =\u003e 0,\n\t\tAction::Toggle =\u003e u8::from (old_active == 0),\n\t})\n}\n\nfn mode_fn_two (action: Action, old_active: u8) -\u003e NumResult \u003cu8\u003e {\n\tOk (match action {\n\t\tAction::On =\u003e u8::add_2 (old_active, 1) ?,\n\t\tAction::Off =\u003e u8::saturating_sub (old_active, 1),\n\t\tAction::Toggle =\u003e u8::add_2 (old_active, 2) ?,\n\t})\n}\n\nfn calc_result (steps: \u0026 [Step], mode_fn: ModeFn) -\u003e GenResult \u003cu32\u003e {\n\tlet steps =\n\t\tsteps.iter ().copied ()\n\t\t\t.enumerate ()\n\t\t\t.sorted_by_key (|\u0026 (_, step)| step.origin)\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\tlet rows =\n\t\tsteps.iter ().copied ()\n\t\t\t.flat_map (|(_, step)| [ step.origin.row, step.peak.row ])\n\t\t\t.sorted ()\n\t\t\t.dedup ()\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\tlet mut cur_steps: Vec \u003c(usize, Step)\u003e = Vec::new ();\n\tlet mut sum = 0;\n\tlet mut prev_row = Coord::MIN;\n\tlet mut prev_active = 0;\n\tlet mut steps_iter = steps.into_iter ().peekable ();\n\tlet mut row_data: Vec \u003c(Coord, u8)\u003e = Vec::new ();\n\tlet mut row_data_temp = Vec::new ();\n\tfor row in rows {\n\t\tsum = u32::checked_add (sum,\n\t\t\tu32::checked_mul (\n\t\t\t\tu16::checked_sub (row, prev_row).unwrap ().pan_u32 (),\n\t\t\t\tprev_active.pan_u32 (),\n\t\t\t).unwrap (),\n\t\t).unwrap ();\n\t\tcur_steps.retain (|\u0026 (_, step)| row \u003c step.peak.row);\n\t\twhile let Some (\u0026 (_, step)) = steps_iter.peek () {\n\t\t\tif step.origin.row != row { break }\n\t\t\tcur_steps.push (steps_iter.next ().unwrap ());\n\t\t}\n\t\tcur_steps.sort_by_key (|\u0026 (idx, _)| idx);\n\t\trow_data.clear ();\n\t\t{\n\t\t\tlet mut steps = \u0026 * cur_steps;\n\t\t\ttrait RowIter: Iterator \u003cItem = NumResult \u003c(Coord, u8)\u003e\u003e {}\n\t\t\timpl \u003cSomeIter: Iterator \u003cItem = NumResult \u003c(Coord, u8)\u003e\u003e\u003e RowIter for SomeIter {}\n\t\t\t#[ inline ]\n\t\t\tfn update_once (iter: impl RowIter, step: Step, mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\tUpdateLineIter::new (iter, step.action, step.origin.col, step.peak.col, mode_fn)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn update_twice (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\tupdate_once (update_once (iter, steps [0].1, mode_fn), steps [1].1, mode_fn)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn update_four_x (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\tupdate_twice (update_twice (iter, \u0026 steps [0 .. 2], mode_fn), \u0026 steps [2 .. 4], mode_fn)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn update_eight_x (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\tupdate_four_x (update_four_x (iter, \u0026 steps [0 .. 4], mode_fn), \u0026 steps [4 .. 8], mode_fn)\n\t\t\t}\n\t\t\twhile steps.len () \u003e= 8 {\n\t\t\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\t\t\tassert! (row_data.is_empty ());\n\t\t\t\tfor item in\n\t\t\t\t\tupdate_eight_x (\n\t\t\t\t\t\trow_data_temp.drain ( .. ).map (Ok),\n\t\t\t\t\t\t\u0026 steps [0 .. 8 ],\n\t\t\t\t\t\tmode_fn) {\n\t\t\t\t\trow_data.push (item ?);\n\t\t\t\t}\n\t\t\t\tsteps = \u0026 steps [ 8 .. ];\n\t\t\t}\n\t\t\twhile ! steps.is_empty () {\n\t\t\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\t\t\tassert! (row_data.is_empty ());\n\t\t\t\tfor item in \n\t\t\t\t\tupdate_once (\n\t\t\t\t\t\trow_data_temp.drain ( .. ).map (Ok),\n\t\t\t\t\t\tsteps [0].1,\n\t\t\t\t\t\tmode_fn) {\n\t\t\t\t\trow_data.push (item ?);\n\t\t\t\t}\n\t\t\t\tsteps = \u0026 steps [ 1 .. ];\n\t\t\t}\n\t\t}\n\t\t/* old implementation:\n\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\tassert! (row_data.is_empty ());\n\t\tlet mut iter: Box \u003cdyn RowIter\u003e = Box::new (row_data.drain ( .. ));\n\t\tfor step in steps.iter ().copied () {\n\t\t\titer = Box::new (UpdateLineIter::new (iter, step.action, step.origin.col, step.peak.col));\n\t\t}\n\t\trow_data = iter.collect ();\n\t\t*/\n\t\tprev_row = row;\n\t\tprev_active =\n\t\t\trow_data.iter ().copied ()\n\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.map (|((start, val), (end, _))|\n\t\t\t\t\tInt::mul_2 (\n\t\t\t\t\t\tInt::sub_2 (end, start) ?.pan_u32 (),\n\t\t\t\t\t\tval.pan_u32 (),\n\t\t\t\t\t))\n\t\t\t\t.fold (Ok (0), |sum, val| Int::add_2 (sum ?, val ?)) ?;\n\t\tassert! (row_data.last ().copied ().map_or (0, |(_, val)| val) == 0);\n\t}\n\tOk (sum)\n}\n\nstruct UpdateLineIter \u003cInner: Iterator \u003cItem = NumResult \u003c(Coord, u8)\u003e\u003e\u003e {\n\tinner: Inner,\n\tnext: Option \u003c(Coord, u8)\u003e,\n\taction: Action,\n\tstep: ArrayVec \u003cCoord, 2\u003e,\n\told_active: u8,\n\tcur_active: u8,\n\tin_step: bool,\n\tmode_fn: ModeFn,\n}\n\nimpl \u003cInner\u003e UpdateLineIter \u003cInner\u003e\n\t\twhere Inner: Iterator \u003cItem = NumResult \u003c(Coord, u8)\u003e\u003e {\n\t#[ inline ]\n\tfn new (inner: Inner, action: Action, start: Coord, end: Coord, mode_fn: ModeFn) -\u003e Self {\n\t\tSelf {\n\t\t\tinner,\n\t\t\tnext: None,\n\t\t\taction,\n\t\t\tstep: [ end, start ].into_iter ().collect (),\n\t\t\told_active: 0,\n\t\t\tcur_active: 0,\n\t\t\tin_step: false,\n\t\t\tmode_fn,\n\t\t}\n\t}\n}\n\nimpl \u003cInner\u003e Iterator for UpdateLineIter \u003cInner\u003e\n\twhere Inner: Iterator \u003cItem = NumResult \u003c(Coord, u8)\u003e\u003e {\n\ttype Item = NumResult \u003c(Coord, u8)\u003e;\n\tfn next (\u0026 mut self) -\u003e Option \u003cNumResult \u003c(Coord, u8)\u003e\u003e {\n\t\tloop {\n\t\t\tif self.next.is_none () {\n\t\t\t\tself.next = match self.inner.next () {\n\t\t\t\t\tSome (Ok (val)) =\u003e Some (val),\n\t\t\t\t\tSome (Err (err)) =\u003e return Some (Err (err)),\n\t\t\t\t\tNone =\u003e None,\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet (pos, old_val, step) = match (self.next, self.step.last ().copied ()) {\n\t\t\t\t(Some ((pos, val)), None) =\u003e (pos, Some (val), false),\n\t\t\t\t(Some ((pos_0, val)), Some (pos_1)) if pos_0 \u003c pos_1 =\u003e (pos_0, Some (val), false),\n\t\t\t\t(Some ((pos_0, _)), Some (pos_1)) if pos_1 \u003c pos_0 =\u003e (pos_1, None, true),\n\t\t\t\t(Some ((pos_0, val)), Some (pos_1)) if pos_0 == pos_1 =\u003e (pos_0, Some (val), true),\n\t\t\t\t(None, Some (pos)) =\u003e (pos, None, true),\n\t\t\t\t(None, None) =\u003e return None,\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t};\n\t\t\tif let Some (val) = old_val { self.old_active = val; self.next = None; }\n\t\t\tif step { self.in_step = ! self.in_step; self.step.pop ().unwrap (); }\n\t\t\tlet want_active = if self.in_step {\n\t\t\t\tmatch (self.mode_fn) (self.action, self.old_active) {\n\t\t\t\t\tOk (val) =\u003e val,\n\t\t\t\t\tErr (err) =\u003e return Some (Err (err)),\n\t\t\t\t}\n\t\t\t} else { self.old_active };\n\t\t\tif self.cur_active != want_active {\n\t\t\t\tself.cur_active = want_active;\n\t\t\t\treturn Some (Ok ((pos, want_active)));\n\t\t\t}\n\t\t}\n\t}\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tuse model::Action::*;\n\tuse model::Pos;\n\n\tconst STEPS: \u0026 [Step] = \u0026 [\n\t\tStep { action: Toggle, origin: Pos { row: 0, col: 0 }, peak: Pos { row: 2, col: 9 }},\n\t\tStep { action: Off, origin: Pos { row: 4, col: 3 }, peak: Pos { row: 5, col: 8 }},\n\t\tStep { action: On, origin: Pos { row: 2, col: 2 }, peak: Pos { row: 9, col: 3 }},\n\t\tStep { action: Toggle, origin: Pos { row: 2, col: 4 }, peak: Pos { row: 9, col: 5 }},\n\t\tStep { action: Toggle, origin: Pos { row: 3, col: 3 }, peak: Pos { row: 8, col: 6 }},\n\t\tStep { action: Toggle, origin: Pos { row: 6, col: 3 }, peak: Pos { row: 9, col: 8 }},\n\t\tStep { action: Off, origin: Pos { row: 1, col: 0 }, peak: Pos { row: 1, col: 3 }},\n\t\tStep { action: Off, origin: Pos { row: 2, col: 2 }, peak: Pos { row: 5, col: 5 }},\n\t\tStep { action: Toggle, origin: Pos { row: 5, col: 5 }, peak: Pos { row: 9, col: 8 }},\n\t\tStep { action: Off, origin: Pos { row: 3, col: 4 }, peak: Pos { row: 7, col: 8 }},\n\t\tStep { action: On, origin: Pos { row: 4, col: 0 }, peak: Pos { row: 8, col: 8 }},\n\t\tStep { action: Off, origin: Pos { row: 1, col: 1 }, peak: Pos { row: 3, col: 5 }},\n\t\tStep { action: On, origin: Pos { row: 2, col: 4 }, peak: Pos { row: 6, col: 8 }},\n\t\tStep { action: On, origin: Pos { row: 1, col: 4 }, peak: Pos { row: 7, col: 8 }},\n\t\tStep { action: On, origin: Pos { row: 0, col: 3 }, peak: Pos { row: 6, col: 6 }},\n\t];\n\n\t#[ test ]\n\tfn calc_result () {\n\t\tassert_eq_ok! (59, logic::calc_result (STEPS, mode_fn_one));\n\t\tassert_eq_ok! (203, logic::calc_result (STEPS, mode_fn_two));\n\t}\n\n}\n","traces":[{"line":12,"address":[92658,92336],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":13,"address":[92594,92509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[92545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[92994,92672],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[92845,92930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[92881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[93008],"length":1,"stats":{"Line":0},"fn_name":"mode_fn_one"},{"line":24,"address":[93008],"length":1,"stats":{"Line":0},"fn_name":"mode_fn_one"},{"line":27,"address":[93032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[93056],"length":1,"stats":{"Line":1},"fn_name":"mode_fn_two"},{"line":32,"address":[93057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[93107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[93154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[93200,96271],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":40,"address":[93280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[32672],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":45,"address":[93429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[55956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[93564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[96171,93742,93688,93881],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[94032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[94005],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[93902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[79458,79628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[94239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[94253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[83958,88640,85011,84022,87050,84752,87172,83916,88771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[94856,94504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[94569],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[94832,95647,96158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[94655,94715],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[94753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[94883,95401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[94932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[96140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[95157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[94977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[95278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[95407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[95506,95435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[36304],"length":1,"stats":{"Line":1},"fn_name":"{closure#4}"},{"line":132,"address":[36337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[62432,62587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[40448,40450],"length":1,"stats":{"Line":1},"fn_name":"{closure#6}"},{"line":138,"address":[95813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":233,"address":[41252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[55009,54969,55101,55164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[55067,55290,55227,55027],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":65,"coverable":82},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub type Coord = u16;\npub type Pos = pos::PosRowCol \u003cCoord\u003e;\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct Steps {\n\t\tsteps: Vec \u003cStep\u003e,\n\t}\n}\n\nimpl Steps {\n\tpub fn build (input: \u0026 Input) -\u003e NumResult \u003cSelf\u003e {\n\t\tOk (Self {\n\t\t\tsteps: input.steps.iter ()\n\t\t\t\t.map (|step| Ok (Step {\n\t\t\t\t\taction: step.action,\n\t\t\t\t\torigin: step.origin,\n\t\t\t\t\tpeak: chk! (step.peak + Pos::new (1, 1)) ?,\n\t\t\t\t}))\n\t\t\t\t.try_collect () ?,\n\t\t})\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Step {\n\tpub action: Action,\n\tpub origin: Pos,\n\tpub peak: Pos,\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Action {\n\t\tOn = [ \"turn on\" ],\n\t\tOff = [ \"turn off\" ],\n\t\tToggle = [ \"toggle\" ],\n\t}\n}\n","traces":[{"line":16,"address":[52240],"length":1,"stats":{"Line":0},"fn_name":"build"},{"line":18,"address":[52364,52408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[30219,30992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[30926,30125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[30930,30130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[32292,30138,30164,32272,30938,30964,32288],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-07","input.rs"],"content":"use super::*;\n\nuse model::Wire;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub wires: Vec \u003cWire \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { wires, params } = [ params, @lines wires ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[28404],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-07","lib.rs"],"content":"//! Advent of Code 2015: Day 7: Some Assembly Required\n//!\n//! [https://adventofcode.com/2015/day/7](https://adventofcode.com/2015/day/7)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Some Assembly Required\";\n\tyear = 2015;\n\tday = 7;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-07","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::WireId;\nuse model::WireInput;\nuse model::WireVal;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcheck_input (input) ?;\n\tlet resolved = resolve (input, default ());\n\tlet a_id: WireId = \"a\".try_into ().unwrap ();\n\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\tOk (a_val)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcheck_input (input) ?;\n\tlet resolved = resolve (input, default ());\n\tlet a_id: WireId = \"a\".try_into ().unwrap ();\n\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\tlet b_id: WireId = \"b\".try_into ().unwrap ();\n\tlet resolved = resolve (input, HashMap::from_iter ([ (b_id, a_val) ]));\n\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\tOk (a_val)\n}\n\nfn resolve \u003c'inp\u003e (\n\tinput: \u0026 Input \u003c'inp\u003e,\n\tmut resolved: HashMap \u003cWireId \u003c'inp\u003e, WireVal\u003e,\n) -\u003e HashMap \u003cWireId \u003c'inp\u003e, WireVal\u003e {\n\n\t// setup data about each wire and their inter-dependencies\n\n\t#[ derive (Debug) ]\n\tstruct Wire \u003c'inp\u003e {\n\t\tid: WireId \u003c'inp\u003e,\n\t\tinput: WireInput \u003c'inp\u003e,\n\t\tinputs: ArrayVec \u003cWireId \u003c'inp\u003e, 2\u003e,\n\t\toutputs: Vec \u003cWireId \u003c'inp\u003e\u003e,\n\t}\n\n\tlet mut wires: HashMap \u003cWireId, Wire\u003e =\n\t\tinput.wires.iter ()\n\t\t\t.map (|wire| (wire.id.clone (), Wire {\n\t\t\t\tid: wire.id.clone (),\n\t\t\t\tinput: wire.input.clone (),\n\t\t\t\tinputs: wire.input.inputs ().iter ().copied ().cloned ().collect (),\n\t\t\t\toutputs: default (),\n\t\t\t}))\n\t\t\t.collect ();\n\n\t// work out which wires we can handle now and later\n\n\tlet mut queue = VecDeque::new ();\n\n\tfor wire in input.wires.iter () {\n\n\t\tfor inpt_id in wire.input.inputs () {\n\t\t\tlet inpt_wire = wires.get_mut (inpt_id).unwrap ();\n\t\t\tinpt_wire.outputs.push (wire.id.clone ());\n\t\t}\n\n\t\tif wire.input.inputs ().is_empty () {\n\t\t\tqueue.push_back (wire.id.clone ());\n\t\t}\n\n\t}\n\n\t// iterate the ready wires\n\n\twhile let Some (id) = queue.pop_front () {\n\t\tlet wire = wires.get_mut (\u0026 id).unwrap ();\n\t\tlet val = if let Some (\u0026 val) = resolved.get (\u0026 wire.id) {\n\t\t    val\n\t\t} else {\n\t\t\tmatch wire.input.clone () {\n\t\t\t\tWireInput::Static (val) =\u003e Some (val),\n\t\t\t\tWireInput::Wire (arg) =\u003e resolved.get (\u0026 arg).copied (),\n\t\t\t\tWireInput::Not (arg) =\u003e resolved.get (\u0026 arg).copied ().map (|arg| ! arg),\n\t\t\t\tWireInput::And (arg_0, arg_1) =\u003e\n\t\t\t\t\tresolved.get (\u0026 arg_0)\n\t\t\t\t\t\t.and_then (|\u0026 arg_0| resolved.get (\u0026 arg_1)\n\t\t\t\t\t\t\t.map (|\u0026 arg_1| arg_0 \u0026 arg_1)),\n\t\t\t\tWireInput::AndOne (arg) =\u003e resolved.get (\u0026 arg).map (|\u0026 arg| 1 \u0026 arg),\n\t\t\t\tWireInput::Or (arg_0, arg_1) =\u003e\n\t\t\t\t\tresolved.get (\u0026 arg_0)\n\t\t\t\t\t\t.and_then (|\u0026 arg_0| resolved.get (\u0026 arg_1)\n\t\t\t\t\t\t\t.map (|\u0026 arg_1| arg_0 | arg_1)),\n\t\t\t\tWireInput::LeftShift (arg_0, arg_1) =\u003e\n\t\t\t\t\tresolved.get (\u0026 arg_0).map (|\u0026 arg_0| arg_0 \u003c\u003c arg_1),\n\t\t\t\tWireInput::RightShift (arg_0, arg_1) =\u003e\n\t\t\t\t\tresolved.get (\u0026 arg_0).map (|\u0026 arg_0| arg_0 \u003e\u003e arg_1),\n\t\t\t}.unwrap ()\n\t\t};\n\t\tresolved.insert (wire.id.clone (), val);\n\t\tlet wire_id = wire.id.clone ();\n\t\tlet wire_outputs = mem::take (\u0026 mut wire.outputs);\n\t\tfor outp in wire_outputs {\n\t\t\tlet other = wires.get_mut (\u0026 outp).unwrap ();\n\t\t\tother.inputs.retain (|other_id| * other_id != wire_id);\n\t\t\tif ! other.inputs.is_empty () { continue }\n\t\t\tqueue.push_back (other.id.clone ());\n\t\t}\n\t}\n\n\tresolved\n\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tlet all_wire_ids =\n\t\tinput.wires.iter ()\n\t\t\t.map (|wire| wire.id.clone ())\n\t\t\t.collect::\u003cHashSet \u003c_\u003e\u003e ();\n\tif all_wire_ids.len () \u003c input.wires.len () {\n\t\tErr (\"Duplicate wire ids\") ?;\n\t}\n\tif let Some ((wire, input)) =\n\t\tinput.wires.iter ()\n\t\t\t.flat_map (|wire| {\n\t\t\t\tlet wire_id = wire.id.clone ();\n\t\t\t\twire.input.inputs ().clone ().iter ()\n\t\t\t\t\t.map (move |\u0026 input| (wire_id.clone (), input.clone ()))\n\t\t\t\t\t.collect::\u003cArrayVec \u003c_, 2\u003e\u003e ()\n\t\t\t})\n\t\t\t.find (|\u0026 (_, ref input)| ! all_wire_ids.contains (input)) {\n\t\tErr (format! (\"Wire {} refers to non-existant input {}\", wire, input)) ?;\n\t}\n\tOk (())\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn test_resolve () -\u003e GenResult \u003c()\u003e {\n\t\tlet input = input::Input::parse_from_lines (\u0026 [\n\t\t\t\"123 -\u003e x\",\n\t\t\t\"456 -\u003e y\",\n\t\t\t\"x AND y -\u003e d\",\n\t\t\t\"x OR y -\u003e e\",\n\t\t\t\"x LSHIFT 2 -\u003e f\",\n\t\t\t\"y RSHIFT 2 -\u003e g\",\n\t\t\t\"NOT x -\u003e h\",\n\t\t\t\"NOT y -\u003e i\",\n\t\t]) ?;\n\t\tlet resolved = resolve (\u0026 input, default ());\n\t\tassert_eq! (resolved.len (), 8);\n\t\tlet resolve = |id_str: \u0026 str| resolved [\u0026 id_str.try_into ().unwrap ()];\n\t\tassert_eq! (resolve (\"d\"), 72);\n\t\tassert_eq! (resolve (\"e\"), 507);\n\t\tassert_eq! (resolve (\"f\"), 492);\n\t\tassert_eq! (resolve (\"g\"), 114);\n\t\tassert_eq! (resolve (\"h\"), 65412);\n\t\tassert_eq! (resolve (\"i\"), 65079);\n\t\tassert_eq! (resolve (\"x\"), 123);\n\t\tassert_eq! (resolve (\"y\"), 456);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":27,"address":[60144,65487],"length":1,"stats":{"Line":1},"fn_name":"resolve"},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[23696,24617],"length":1,"stats":{"Line":2},"fn_name":"test_resolve"},{"line":139,"address":[24286,23748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[23911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[23930,24312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[23945],"length":1,"stats":{"Line":5},"fn_name":null},{"line":152,"address":[24358,23950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[23987,24386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[24028,24414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[24069,24439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[24106,24464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[24143,24489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[24184,24514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[24539,24221],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":38,"coverable":59},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-07","model.rs"],"content":"use super::*;\n\npub use wire::Wire;\npub use wire_id::WireId;\npub use wire_input::WireInput;\n\npub type WireVal = u16;\n\nmod wire {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Wire \u003c'inp\u003e {\n\t\tpub id: WireId \u003c'inp\u003e,\n\t\tpub input: WireInput \u003c'inp\u003e,\n\t}\n\n\tstruct_parser_display! {\n\t\tinput_lifetime = 'inp;\n\t\tWire \u003c'inp\u003e { id, input } = [ input, \" -\u003e \", id ]\n\t}\n\n}\n\nmod wire_id {\n\n\tuse super::*;\n\n\twrapper_deref! {\n\t\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialOrd, PartialEq) ]\n\t\tpub struct WireId \u003c'inp\u003e {\n\t\t\tid: InpStr \u003c'inp\u003e,\n\t\t}\n\t}\n\n\tstruct_parser_display! {\n\t\tinput_lifetime = 'inp;\n\t\tWireId \u003c'inp\u003e { id } = [ @str id = ('a' ..= 'z', 1 ..= 10) ]\n\t}\n\n\timpl TryFrom \u003c\u0026 str\u003e for WireId \u003c'static\u003e {\n\t\ttype Error = GenError;\n\t\tfn try_from (src: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\t\tif src.is_empty () {\n\t\t\t\treturn Err (\"Wire ID must have at least one character\".into ());\n\t\t\t}\n\t\t\tif ! src.chars ().all (|ch| ch.is_ascii_lowercase ()) {\n\t\t\t\treturn Err (\"Wire ID must be all lowercase ASCII\".into ());\n\t\t\t}\n\t\t\tOk (WireId {\n\t\t\t\tid: InpStr::alloc (src),\n\t\t\t})\n\t\t}\n\t}\n\n}\n\nmod wire_input {\n\n\tuse super::*;\n\n\tenum_decl_parser_display! {\n\t\tinput_lifetime = 'inp;\n\t\t#[ derive (Clone, Debug) ]\n\t\tpub enum WireInput \u003c'inp\u003e {\n\t\t\tNot (arg: WireId \u003c'inp\u003e) = [ \"NOT \", arg ],\n\t\t\tAndOne (arg: WireId \u003c'inp\u003e) = [ \"1 AND \", arg ],\n\t\t\tAnd (arg_0: WireId \u003c'inp\u003e, arg_1: WireId \u003c'inp\u003e) = [ arg_0, \" AND \", arg_1 ],\n\t\t\tOr (arg_0: WireId \u003c'inp\u003e, arg_1: WireId \u003c'inp\u003e) = [ arg_0, \" OR \", arg_1 ],\n\t\t\tLeftShift (arg_0: WireId \u003c'inp\u003e, arg_1: WireVal) = [ arg_0, \" LSHIFT \", arg_1 = 1 ..= 15 ],\n\t\t\tRightShift (arg_0: WireId \u003c'inp\u003e, arg_1: WireVal) = [ arg_0, \" RSHIFT \", arg_1 = 1 ..= 15 ],\n\t\t\tStatic (val: WireVal) = [ val ],\n\t\t\tWire (arg: WireId \u003c'inp\u003e) = [ arg ],\n\t\t}\n\t}\n\n\timpl \u003c'inp\u003e WireInput \u003c'inp\u003e {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn inputs (\u0026 self) -\u003e ArrayVec \u003c\u0026 WireId \u003c'inp\u003e, 2\u003e {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Static (_) =\u003e array_vec! [],\n\t\t\t\tSelf::Wire (ref arg) =\u003e array_vec! [ arg ],\n\t\t\t\tSelf::Not (ref arg) =\u003e array_vec! [ arg ],\n\t\t\t\tSelf::And (ref arg_0, ref arg_1) =\u003e array_vec! [ arg_0, arg_1 ],\n\t\t\t\tSelf::AndOne (ref arg) =\u003e array_vec! [ arg ],\n\t\t\t\tSelf::Or (ref arg_0, ref arg_1) =\u003e array_vec! [ arg_0, arg_1 ],\n\t\t\t\tSelf::LeftShift (ref arg_0, _) =\u003e array_vec! [ arg_0 ],\n\t\t\t\tSelf::RightShift (ref arg_0, _) =\u003e array_vec! [ arg_0 ],\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":21,"address":[30458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[25189,25386],"length":1,"stats":{"Line":8},"fn_name":null},{"line":44,"address":[43264],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":45,"address":[43284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[43389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[41984,41993],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":49,"address":[43517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[43497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[24912,25469,24925,25239,25355,25275,25497,25134,25324,25436],"length":1,"stats":{"Line":8},"fn_name":"clone"},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-08","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"\\\"\\\"\",\n\t\"\\\"abc\\\"\",\n\t\"\\\"aaa\\\\\\\"aaa\\\"\",\n\t\"\\\"\\\\x27\\\"\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"12\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"19\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[25456,25847],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":14,"address":[25466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[25634,25577,25525,25487,25700,25804],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[25856,26247],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":20,"address":[25866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[26204,26100,25887,25925,25977,26034],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-08","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub strings: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { strings, params } = [ params, @lines strings ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[26356],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-08","lib.rs"],"content":"//! Advent of Code 2015: Day 8: Matchsticks\n//!\n//! [https://adventofcode.com/2015/day/8](https://adventofcode.com/2015/day/8)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Matchsticks\";\n\tyear = 2015;\n\tday = 8;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-08","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tinput.strings.iter ()\n\t\t.map (|orig| Ok::\u003c_, GenError\u003e ((orig.chars ().count (), decoded_len (orig) ?)))\n\t\t.map_ok (|(orig_len, decoded_len)| orig_len - decoded_len)\n\t\t.try_fold (0, |sum, item| Ok::\u003c_, GenError\u003e (sum + item ?))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tOk (\n\t\tinput.strings.iter ()\n\t\t\t.map (|orig| (orig.chars ().count (), encoded_len (orig)))\n\t\t\t.map (|(orig_len, encoded_len)| encoded_len - orig_len)\n\t\t\t.sum ()\n\t)\n}\n\nfn decoded_len (input: \u0026 str) -\u003e GenResult \u003cusize\u003e {\n\tlet mut ch_iter = input.chars ();\n\tlet mut next_ch = || ch_iter.next ().ok_or (\"Unexpected end\");\n\tlet mut num = 0;\n\tif next_ch () ? != '\"' { return Err (\"Missing open quote\".into ()) }\n\tloop {\n\t\tmatch next_ch () ? {\n\t\t\t'\"' =\u003e break,\n\t\t\t'\\\\' =\u003e match next_ch () ? {\n\t\t\t\t'\"' | '\\\\' =\u003e num += 1,\n\t\t\t\t'x' =\u003e {\n\t\t\t\t\tlet (ch_0, ch_1) = (next_ch () ?, next_ch () ?);\n\t\t\t\t\tif ! ch_0.is_ascii_hexdigit () || ! ch_1.is_ascii_hexdigit () {\n\t\t\t\t\t\treturn Err (\"Invalid string escape\".into ());\n\t\t\t\t\t}\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t\t_ =\u003e return Err (\"Invalid string escape\".into ()),\n\t\t\t},\n\t\t\t_ =\u003e num += 1,\n\t\t}\n\t}\n\tif ch_iter.next ().is_some () { return Err (\"Extra chars at end\".into ()) }\n\tOk (num)\n}\n\nfn encoded_len (input: \u0026 str) -\u003e usize {\n\t2 + input.chars ()\n\t\t.map (|ch| match ch { '\\\\' | '\"' =\u003e 2, _ =\u003e 1 })\n\t\t.sum::\u003cusize\u003e ()\n}\n","traces":[{"line":5,"address":[43728],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":6,"address":[38298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[42311,42368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[31316,31338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[37726,37518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[43808],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":15,"address":[36201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[27524,27499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[43888],"length":1,"stats":{"Line":1},"fn_name":"decoded_len"},{"line":22,"address":[43917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[43628,43572,43568],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":25,"address":[43980,44046,43961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[44142,44023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[44227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[44496,44700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[44373,44320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[44716,44466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[44684,44158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[44574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[44626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[44752],"length":1,"stats":{"Line":1},"fn_name":"encoded_len"},{"line":48,"address":[44877,44925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[25200],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"London to Dublin = 464\",\n\t\"London to Belfast = 518\",\n\t\"Dublin to Belfast = 141\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"605\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"982\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[27988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[51882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[52116,51993,51941,52050,52220,51903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[27956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[52282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[52393,52303,52516,52450,52620,52341],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub dists: Vec \u003c(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e, u32)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { dists, params } = [\n\t\tparams, @lines dists {\n\t\t\ttype = (InpStr, InpStr, u32);\n\t\t\t(place_0, place_1, dist) = [\n\t\t\t\t@str place_0 = (|ch| { ch.is_ascii_alphabetic () }, 1 ..= 20), \" to \",\n\t\t\t\t@str place_1 = (|ch| { ch.is_ascii_alphabetic () }, 1 ..= 20), \" = \",\n\t\t\t\tdist,\n\t\t\t],\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[27259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[46471],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","lib.rs"],"content":"//! Advent of Code 2015: Day 9: All in a Single Night\n//!\n//! [https://adventofcode.com/2015/day/9](https://adventofcode.com/2015/day/9)\n//!\n//! # Input\n//!\n//! Each line represents the distance between two locations in the form \"$0 to $1 = $2\". The first\n//! two parameters are alphanumeric strings representing the locations, tand the third is a\n//! integer representing the distance.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_search::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"All in a Single Night\";\n\tyear = 2015;\n\tday = 9;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":26,"address":[79880],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[80200],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Dist;\nuse model::DistTable;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet dist_table = DistTable::build (input);\n\tOk (iter_distances (\u0026 dist_table).min ().unwrap ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet dist_table = DistTable::build (input);\n\tOk (iter_distances (\u0026 dist_table).max ().unwrap ())\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.dists.is_empty () { return Err (\"Must provide at least one distance\".into ()) }\n\tif input.dists.len () \u003e 60 { Err (\"Refusing to handle more than 60 distances\") ?; }\n\tlet num_places =\n\t\tinput.dists.iter ()\n\t\t\t.flat_map (|\u0026 (ref from, ref to, _)| [from, to])\n\t\t\t.fold (HashSet::new (), |mut set, item| { set.insert (item); set })\n\t\t\t.into_iter ()\n\t\t\t.count ();\n\tif num_places \u003e 10 {\n\t\tErr (\"Refusing to handle more than 10 places\") ?;\n\t}\n\tif input.dists.len () != num_places * (num_places - 1) / 2 {\n\t\tErr (\"Wrong number of distances for given number of places\") ?;\n\t}\n\tOk (())\n}\n\nfn iter_distances \u003c'out\u003e (\n\tdist_table: \u0026 'out DistTable \u003c'out\u003e,\n) -\u003e impl Iterator \u003cItem = Dist\u003e + 'out {\n\tlet mut perms_helper = PermutationsHelper::new (dist_table.len ());\n\titer::from_fn (move || {\n\t\tif ! perms_helper.next () { return None }\n\t\tSome (\n\t\t\tperms_helper.iter ()\n\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.map (|(\u0026 idx_0, \u0026 idx_1)| dist_table [(idx_0, idx_1)])\n\t\t\t\t.sum::\u003cu32\u003e ()\n\t\t)\n\t})\n}\n","traces":[{"line":7,"address":[62960,63257],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[62978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[63171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[63577,63280],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":14,"address":[63298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[63491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[64385,63600],"length":1,"stats":{"Line":1},"fn_name":"check_input"},{"line":20,"address":[63622,63647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[63624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[64205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[51536,51539],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":25,"address":[50811,50547,50498,50762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[64210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[64290,64230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[69104,68356,68884,68576],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub type Dist = u32;\n\nwrapper_deref_mut! {\n\tpub struct DistTable \u003c'inp\u003e {\n\t\tinner: PairsMap \u003cInpStr \u003c'inp\u003e, Dist\u003e,\n\t}\n}\n\nimpl \u003c'inp\u003e DistTable \u003c'inp\u003e {\n\n\t#[ must_use ]\n\tpub fn build (input: \u0026 Input \u003c'inp\u003e) -\u003e Self {\n\t\tSelf {\n\t\t\tinner: input.dists.iter ()\n\t\t\t\t.flat_map (|\u0026 (ref place_0, ref place_1, dist)| [\n\t\t\t\t\t(place_0.clone (), place_1.clone (), dist),\n\t\t\t\t\t(place_1.clone (), place_0.clone (), dist) ])\n\t\t\t\t.collect ()\n\t\t}\n\t}\n\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","cli.rs"],"content":"use super::*;\n\nuse model::State;\n\n#[ derive (Debug, clap::Parser) ]\npub struct RunArgs {\n\n\t#[ clap (long, default_value = \"inputs/day-10\") ]\n\tinput: String,\n\n\t#[ clap (conflicts_with = \"input\") ]\n\tstate: Option \u003cString\u003e,\n\n\t#[ clap (long) ]\n\tverbose: bool,\n\n\t#[ clap (long, default_value = \"15\") ]\n\tloops: u32,\n\n\t#[ clap (long, default_value = \"0\") ]\n\tkeep_end: usize,\n\n\t#[ clap (long, default_value = \"0\") ]\n\tkeep_start: usize,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet mut state = if let Some (state) = args.state.as_ref () {\n\t\tState::parse (state) ?\n\t} else {\n\t\tState::parse (\n\t\t\tfs::read_to_string (\u0026 args.input) ?\n\t\t\t\t.trim ()\n\t\t\t\t.split ('\\n')\n\t\t\t\t.next ().unwrap ()\n\t\t) ?\n\t};\n\tfor idx in 0 .. {\n\t\tprintln! (\"{:2} {:4} {}\", idx, state.len (), state);\n\t\tif idx == args.loops { break }\n\t\tstate = logic::one_round (\u0026 state);\n\t\tif (args.keep_start \u003e 0 || args.keep_end \u003e 0)\n\t\t\t\t\u0026\u0026 state.len () \u003e (args.keep_start + args.keep_end) {\n\t\t\tstate =\n\t\t\t\tstate [ .. args.keep_start].iter ().copied ()\n\t\t\t\t\t.chain (state [state.len () - args.keep_end .. ].iter ().copied ())\n\t\t\t\t\t.collect ();\n\t\t}\n\t}\n\tOk (())\n}\n\n#[ derive (Debug, clap::Parser) ]\npub struct InternalsArgs;\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\n#[ allow (clippy::unnecessary_wraps) ]\npub fn internals (_args: InternalsArgs) -\u003e GenResult \u003c()\u003e {\n\tprintln! (\"Data structures:\");\n\tfn show_struct \u003cType\u003e () {\n\t\tlet name = std::any::type_name::\u003cType\u003e ();\n\t\tlet size = mem::size_of::\u003cType\u003e ();\n\t\tlet align = mem::align_of::\u003cType\u003e ();\n\t\tprintln! (\" - {} {} bytes (align = {})\", name, size, align);\n\t}\n\tshow_struct::\u003ctracking::Item\u003e ();\n\tOk (())\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","cycles.rs"],"content":"#![ allow (clippy::else_if_without_else) ]\n\nuse super::*;\nuse model::State;\n\n#[ derive (Debug, clap::Parser) ]\npub struct Args {\n\n\t#[ clap (long, default_value = \"20\") ]\n\titerations: usize,\n\n\t#[ clap (long, default_value = \"10\") ]\n\tmax_length: usize,\n\n}\n\n#[ derive (Clone, Eq, Hash, PartialEq) ]\npub struct Span (Rc \u003c[u8]\u003e);\n\nimpl Span {\n\t/*\n\tfn split (\u0026 self) -\u003e Vec \u003cSpan\u003e {\n\t\titer::empty ()\n\t\t\t.chain (iter::once (0))\n\t\t\t.chain (self.iter ().skip (1)\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.filter_map (|(idx, (left, right))| (left != right).then_some (idx + 1)))\n\t\t\t.chain (iter::once (self.len ()))\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.map (|(start, end)| Span::from (\u0026 self [start .. end]))\n\t\t\t.collect ()\n\t}\n\tfn can_split (\u0026 self) -\u003e bool {\n\t\titer::empty ()\n\t\t\t.chain (self.iter ().skip (1)\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.filter_map (|(idx, (left, right))| (left != right).then_some (idx + 1)))\n\t\t\t.next ()\n\t\t\t.is_some ()\n\t}\n\t*/\n}\n\nimpl Debug for Span {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Span (\\\"{}\\\")\", self) ?;\n\t\tOk (())\n\t}\n}\n\nimpl Display for Span {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor \u0026 val in self.0.iter () {\n\t\t\twrite! (formatter, \"{}\", char::from_digit (val.pan_u32 (), 10).unwrap ()) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl Borrow \u003c[u8]\u003e for Span {\n\tfn borrow (\u0026 self) -\u003e \u0026 [u8] { \u0026 self.0 }\n}\n\nimpl From \u003c\u0026 [u8]\u003e for Span {\n\tfn from (other: \u0026 [u8]) -\u003e Self {\n\t\tSelf (other.into ())\n\t}\n}\n\nimpl TryFrom \u003c\u0026 str\u003e for Span {\n\ttype Error = GenError;\n\tfn try_from (src: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\tOk (Self::from (model::State::parse (src) ?.as_slice ()))\n\t}\n}\n\nimpl PartialEq \u003c[u8]\u003e for Span {\n\tfn eq (\u0026 self, other: \u0026 [u8]) -\u003e bool {\n\t\tself.0.as_ref () == other\n\t}\n}\n\nimpl PartialOrd for Span {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tSome (self.cmp (other))\n\t}\n}\n\nimpl Ord for Span {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tself.0.len ().cmp (\u0026 other.len ())\n\t\t\t.then (self.0.cmp (\u0026 other.0))\n\t}\n}\n\nimpl Deref for Span {\n\ttype Target = [u8];\n\tfn deref (\u0026 self) -\u003e \u0026 [u8] { self.0.as_ref () }\n}\n\n#[ derive (Clone, Debug, Eq, Ord, PartialEq, PartialOrd) ]\nenum Destiny {\n\tUnstable (Span),\n\tAtomic (Atomic),\n\tStable (Rc \u003c[Atomic]\u003e),\n}\n\n#[ derive (Clone, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct Atomic (Rc \u003cAtomicInner\u003e);\n\nimpl Borrow \u003c[u8]\u003e for Atomic {\n\tfn borrow (\u0026 self) -\u003e \u0026 [u8] { \u0026 self.deref ().key }\n}\n\nimpl Deref for Atomic {\n\ttype Target = AtomicInner;\n\tfn deref (\u0026 self) -\u003e \u0026 AtomicInner { \u0026 self.0 }\n}\n\nimpl From \u003cAtomicInner\u003e for Atomic {\n\tfn from (inner: AtomicInner) -\u003e Self {\n\t\tSelf (Rc::new (inner))\n\t}\n}\n\n#[ derive (Clone, Ord, PartialOrd) ]\nstruct AtomicInner {\n\tkey: Span,\n\tnext: Rc \u003c[Atomic]\u003e,\n\tfirst: [u8; 3],\n\tlast: u8,\n}\n\nimpl Debug for Atomic {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Atomic ({} next=\", self.key) ?;\n\t\tif self.next.is_empty () { write! (formatter, \"TODO\") ?; }\n\t\tfor (next_idx, next) in self.next.iter ().enumerate () {\n\t\t\tif next_idx \u003e 0 { write! (formatter, \",\") ?; }\n\t\t\twrite! (formatter, \"{}\", next.key) ?;\n\t\t}\n\t\twrite! (formatter, \" first=\") ?;\n\t\tfor item in self.first.iter ().copied () {\n\t\t\twrite! (formatter, \"{}\", char::from_digit (item.pan_u32 (), 10).unwrap ()) ?;\n\t\t}\n\t\twrite! (formatter, \" last={})\", self.last) ?;\n\t\tOk (())\n\t}\n}\n\nimpl PartialEq \u003c[u8]\u003e for AtomicInner {\n\tfn eq (\u0026 self, other: \u0026 [u8]) -\u003e bool { self.key == * other }\n}\n\nimpl PartialEq for AtomicInner {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool { self.key == other.key }\n}\n\nimpl Eq for AtomicInner {}\n\nimpl Hash for AtomicInner {\n\tfn hash \u003cHr: Hasher\u003e (\u0026 self, hasher: \u0026 mut Hr) {\n\t\tself.key.hash (hasher);\n\t}\n}\n\nimpl PartialOrd \u003c[u8]\u003e for AtomicInner {\n\tfn partial_cmp (\u0026 self, other: \u0026 [u8]) -\u003e Option \u003cOrdering\u003e {\n\t\tself.key.deref ().partial_cmp (other)\n\t}\n}\n\nconst fn compatible (prev: u8, next: \u0026 [u8]) -\u003e bool {\n\tprev != next [0] \u0026\u0026 prev != next [1] \u0026\u0026 prev != next [2]\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\n#[ allow (clippy::todo) ]\n#[ allow (clippy::too_many_lines) ]\npub fn run (args: Args) -\u003e GenResult \u003c()\u003e {\n\n\tlet stables = find_stables (args.max_length, args.iterations);\n\tprintln! (\"NUM STABLES: {}\", stables.len ());\n\tprintln! (\"NUM SINGULAR: {}\", stables.values ().filter (|stable|\n\t\tstable.as_ref ().map_or (false, |stable| stable.parts.len () == 1)).count ());\n\n\tlet mut destinies: HashMap \u003cSpan, Destiny\u003e = HashMap::new ();\n\tlet mut atomics: HashSet \u003cAtomic\u003e = HashSet::new ();\n\n\tfor length in (2 ..= args.max_length).step_by (2) {\n\n\t\t'STATE: for state in (0 .. length).map (|_| (1_u8 ..= 3_u8))\n\t\t\t.multi_cartesian_product ()\n\t\t\t.map (|nums| State::try_from (nums).unwrap ()) {\n\n\t\t\tlet has_long_run = {\n\t\t\t\tlet group_by_temp =\n\t\t\t\t\tstate.iter ().copied ()\n\t\t\t\t\t\t.group_by (|\u0026 item| item);\n\t\t\t\tgroup_by_temp.into_iter ()\n\t\t\t\t\t.any (|(_, group)| group.count () \u003e 3)\n\t\t\t};\n\t\t\tif has_long_run { continue }\n\n\t\t\tfor prefix_len in (2 ..= length.pan_usize () - 2).step_by (2) {\n\t\t\t\tmatch (\n\t\t\t\t\tatomics.get (\u0026 state [ .. prefix_len]),\n\t\t\t\t\tdestinies.get (\u0026 state [prefix_len .. ]).unwrap_or_else (||\n\t\t\t\t\t\tpanic! (\"Can't find destiny for {:?}\", \u0026 state [prefix_len .. ])),\n\t\t\t\t) {\n\t\t\t\t\t(Some (_), \u0026 Destiny::Unstable (_)) | (None, _) =\u003e continue,\n\t\t\t\t\t(Some (prefix), \u0026 Destiny::Atomic (ref suffix)) =\u003e {\n\t\t\t\t\t\tif ! compatible (prefix.last, \u0026 suffix.first) { continue }\n\t\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\t\tDestiny::Stable ([ prefix.clone (), suffix.clone () ].as_slice ().into ()));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t\t(Some (prefix), \u0026 Destiny::Stable (ref suffix)) =\u003e {\n\t\t\t\t\t\tif ! compatible (prefix.last, \u0026 suffix [0].first) { continue }\n\t\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\t\tDestiny::Stable (\n\t\t\t\t\t\t\t\titer::once (prefix.clone ())\n\t\t\t\t\t\t\t\t\t.chain (suffix.iter ().cloned ())\n\t\t\t\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t\t\t\t\t\t\t\t\t.into ()));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet mut seq_ord = Vec::new ();\n\t\t\tseq_ord.push (state.clone ());\n\t\t\tlet mut seq_set = HashSet::new ();\n\t\t\tseq_set.insert (state.clone ());\n\n\t\t\tlet mut prev_state = state.clone ();\n\t\t\tlet mut left_1 = state [0] == 1;\n\t\t\tlet mut left_2 = state [0] == 2;\n\t\t\tlet mut left_3 = state [0] == 3;\n\n\t\t\tfor _ in 0 .. args.iterations {\n\t\t\t\tlet next_state = logic::one_round (\u0026 prev_state);\n\n\t\t\t\tif let Some (_whatever) = destinies.get (next_state.as_slice ()) {\n\t\t\t\t\t//todo! (\"CHECK FOR EXISTING {} {}\", state, next_state); TODO\n\t\t\t\t}\n\n\t\t\t\tseq_ord.push (next_state.clone ());\n\t\t\t\tseq_set.insert (next_state.clone ());\n\n\t\t\t\tif next_state [0] == 1 { left_1 = true; }\n\t\t\t\tif next_state [0] == 2 { left_2 = true; }\n\t\t\t\tif next_state [0] == 3 { left_3 = true; }\n\n\t\t\t\tif left_1 \u0026\u0026 left_2 \u0026\u0026 left_3 {\n\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\tDestiny::Unstable (seq_ord [1].as_slice ().into ()));\n\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t}\n\n\t\t\t\tprev_state = next_state;\n\t\t\t}\n\n\t\t\tlet mut next_rest = \u0026 seq_ord [1] [ .. ];\n\t\t\tlet mut atomic_next = Vec::new ();\n\t\t\t'OUTER: while ! next_rest.is_empty () {\n\t\t\t\tfor prefix_len in (2 .. next_rest.len ()).step_by (2) {\n\t\t\t\t\tif let Some (prefix_atomic) = atomics.get (\u0026 seq_ord [1] [0 .. prefix_len]) {\n\t\t\t\t\t\tatomic_next.push (prefix_atomic.clone ());\n\t\t\t\t\t\tnext_rest = \u0026 next_rest [ prefix_len .. ];\n\t\t\t\t\t\tcontinue 'OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//unreachable! (\"Can't find atomics for: {}: {}\", state, seq_ord [1]);\n\t\t\t\tatomic_next.clear ();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet key: Span = state.as_slice ().into ();\n\t\t\tlet atomic: Atomic = AtomicInner {\n\t\t\t\tkey: key.clone (),\n\t\t\t\tnext: atomic_next.as_slice ().into (),\n\t\t\t\tfirst: [0, 1, 2].map (|idx| seq_ord [idx].first ().copied ().unwrap ()),\n\t\t\t\tlast: seq_ord [0].last ().copied ().unwrap (),\n\t\t\t}.into ();\n\t\t\tatomics.insert (atomic.clone ());\n\t\t\tdestinies.insert (key, Destiny::Atomic (atomic));\n\n\t\t}\n\n\t}\n\n\tprintln! (\"ATOMICS: count={}\", atomics.len ());\n\tfor atomic in atomics.iter ().sorted_by_key (|atomic| atomic.key.clone ()) {\n\t\tprintln! (\" - {:?}\", atomic);\n\t}\n\n\tprintln! (\"DESTINIES: count={}\", destinies.len ());\n\tfor (_key, _destiny) in destinies.iter ().sorted_by_key (|\u0026 (key, _)| key.clone ()) {\n\t\t//println! (\" - {:?}\", atomic);\n\t}\n\n\ttodo! ();\n\n}\n\nstruct Stable {\n\tparts: Vec \u003cSpan\u003e,\n\tfirst: [u8; 3],\n\tlast: u8,\n}\n\nfn find_stables (max_length: usize, iterations: usize) -\u003e HashMap \u003cSpan, Option \u003cStable\u003e\u003e {\n\n\tlet mut stables: HashMap \u003cSpan, Option \u003cStable\u003e\u003e = HashMap::new ();\n\n\tfor length in (2 ..= max_length).step_by (2) {\n\n\t\t'STATE: for state in (0 .. length).map (|_| (1_u8 ..= 3_u8))\n\t\t\t.multi_cartesian_product ()\n\t\t\t.map (|nums| State::try_from (nums).unwrap ()) {\n\n\t\t\tlet has_long_run = {\n\t\t\t\tlet group_by_temp =\n\t\t\t\t\tstate.iter ().copied ()\n\t\t\t\t\t\t.group_by (|\u0026 item| item);\n\t\t\t\tgroup_by_temp.into_iter ()\n\t\t\t\t\t.any (|(_, group)| group.count () \u003e 3)\n\t\t\t};\n\t\t\tif has_long_run { continue }\n\n\t\t\tfor prefix_len in (2 ..= length.pan_usize () - 2).step_by (2) {\n\t\t\t\tmatch (\n\t\t\t\t\tstables [\u0026 state [ .. prefix_len]].as_ref (),\n\t\t\t\t\tstables [\u0026 state [prefix_len .. ]].as_ref (),\n\t\t\t\t) {\n\t\t\t\t\t(Some (prefix), Some (suffix))\n\t\t\t\t\t\t\tif compatible (prefix.last, \u0026 suffix.first) =\u003e {\n\t\t\t\t\t\tassert_eq! (prefix.parts.len (), 1);\n\t\t\t\t\t\tstables.insert (state.as_slice ().into (), Some (Stable {\n\t\t\t\t\t\t\tparts: prefix.parts.iter ().cloned ()\n\t\t\t\t\t\t\t\t.chain (suffix.parts.iter ().cloned ())\n\t\t\t\t\t\t\t\t.collect (),\n\t\t\t\t\t\t\tfirst: prefix.first,\n\t\t\t\t\t\t\tlast: suffix.last,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e continue,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet mut sequence = Vec::new ();\n\t\t\tsequence.push (state.clone ());\n\n\t\t\tlet mut prev_state = state.clone ();\n\t\t\tlet mut first_seq: ArrayVec \u003cu8, 3\u003e = ArrayVec::new ();\n\t\t\tfirst_seq.push (state.first ().copied ().unwrap ());\n\n\t\t\tlet key = Span::from (state.as_slice ());\n\n\t\t\tfor step_idx in 0 .. iterations {\n\t\t\t\tlet next_state = logic::one_round (\u0026 prev_state);\n\t\t\t\tlet next_first = next_state.first ().copied ().unwrap ();\n\n\t\t\t\t/*\n\t\t\t\tif let Some (whatever) = stables.get (next_state.as_slice ()) {\n\t\t\t\t\ttodo! (\"CHECK FOR EXISTING {} {}\", state, next_state);\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tsequence.push (next_state.clone ());\n\n\t\t\t\tif ! first_seq.is_full () {\n\t\t\t\t\tfirst_seq.push (next_first);\n\t\t\t\t\tif [1, 2, 3].into_iter ()\n\t\t\t\t\t\t.all (|num_0| first_seq.iter ().copied ()\n\t\t\t\t\t\t\t.any (|num_1| num_0 == num_1)) {\n\t\t\t\t\t\tstables.insert (key.clone (), None);\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t}\n\t\t\t\t} else if first_seq [(step_idx + 1) % 3] != next_first {\n\t\t\t\t\tstables.insert (key.clone (), None);\n\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t}\n\n\t\t\t\tprev_state = next_state;\n\t\t\t}\n\n\t\t\tstables.insert (key.clone (), Some (Stable {\n\t\t\t\tparts: vec! [ key ],\n\t\t\t\tfirst: [ first_seq [0], first_seq [1], first_seq [2] ],\n\t\t\t\tlast: state.last ().copied ().unwrap (),\n\t\t\t}));\n\n\t\t}\n\n\t}\n\n\tstables\n\n}\n\npub trait Intern \u003cItem\u003e where Item: Eq + Hash {\n\ttype Shared;\n\tfn intern (self, item: Item) -\u003e Self::Shared;\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cSelf::Shared\u003e;\n}\n\nimpl \u003cItem\u003e Intern \u003cItem\u003e for \u0026 RefCell \u003cHashSet \u003cRc \u003cItem\u003e\u003e\u003e\n\t\twhere Item: Eq + Hash + Ord {\n\ttype Shared = Rc \u003cItem\u003e;\n\tfn intern (self, item: Item) -\u003e Rc \u003cItem\u003e {\n\t\tlet mut lock = self.borrow_mut ();\n\t\tlock.deref_mut ().intern (item)\n\t}\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cRc \u003cItem\u003e\u003e {\n\t\tlet lock = self.borrow ();\n\t\tlock.deref ().get (item).cloned ()\n\t}\n}\n\nimpl \u003cItem\u003e Intern \u003cItem\u003e for \u0026 mut HashSet \u003cRc \u003cItem\u003e\u003e\n\t\twhere Item: Eq + Hash + Ord {\n\ttype Shared = Rc \u003cItem\u003e;\n\tfn intern (self, item: Item) -\u003e Rc \u003cItem\u003e {\n\t\tif let Some (shared) = self.get (\u0026 item) {\n\t\t\treturn Rc::clone (shared);\n\t\t}\n\t\tlet shared = Rc::new (item);\n\t\t(* self).insert (Rc::clone (\u0026 shared));\n\t\tshared\n\t}\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cRc \u003cItem\u003e\u003e {\n\t\tself.get (item).cloned ()\n\t}\n}\n","traces":[{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nuse model::State;\n\n#[ test ]\nfn one_round () -\u003e GenResult \u003c()\u003e {\n\tlet mut state = State::parse (\"1\") ?;\n\tfor expect in [ \"11\", \"21\", \"1211\", \"111221\", \"312211\" ] {\n\t\tstate = logic::one_round (\u0026 state);\n\t\tlet expect = State::parse (expect) ?;\n\t\tassert_eq! (expect, state);\n\t}\n\tOk (())\n}\n","traces":[{"line":8,"address":[17424,18175],"length":1,"stats":{"Line":2},"fn_name":"one_round"},{"line":9,"address":[17902,17490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[17728,18152,17510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[17755,17771,18117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[17846,17962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[18040,17884],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub initial: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { initial, params } = [\n\t\tparams,\n\t\t@str initial = ('1' ..= '3', 1 .. ),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_iters_one: u32 = (\"NUM_ITERS_ONE=\", 40, 1 .. ),\n\t\tpub num_iters_two: u32 = (\"NUM_ITERS_TWO=\", 50, 1 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","lib.rs"],"content":"//! Advent of Code 2015: Day 10: Elves Look, Elves Say\n//!\n//! [https://adventofcode.com/2015/day/10](https://adventofcode.com/2015/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Elves Look, Elves Say\";\n\tyear = 2015;\n\tday = 10;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"internals\"; method = cli::internals; ),\n\t\t( name = \"run\"; method = cli::run; ),\n\t\t( name = \"tracking\"; method = tracking::run; ),\n\t\t( name = \"cycles\"; method = cycles::run; ),\n\t];\n}\n\nmod cli;\nmod cycles;\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\nmod tracking;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet state = State::parse (\u0026 input.initial) ?;\n\tOk (calc_result (state.iter ().copied (), input.params.num_iters_one))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet state = State::parse (\u0026 input.initial) ?;\n\tOk (calc_result (state.iter ().copied (), input.params.num_iters_two))\n}\n\nfn calc_result (iter: impl Iterator \u003cItem = u8\u003e, num_iters: u32) -\u003e u32 {\n\tlet mut iter: Box \u003cdyn Iterator \u003cItem = u8\u003e\u003e = Box::new (iter);\n\tfor _ in 0 .. num_iters {\n\t\titer = Box::new (make_iter (iter));\n\t}\n\titer.count ().pan_u32 ()\n}\n\n//#[ allow (clippy::unused_peekable) ] // clippy is being dumb\nfn make_iter (inner: impl Iterator \u003cItem = u8\u003e) -\u003e impl Iterator \u003cItem = u8\u003e {\n\tlet mut inner = inner.peekable ();\n\tlet mut last = 0xff;\n\tlet mut count = 0_u8;\n\titer::from_fn (move || {\n\t\twhile let Some (\u0026 next) = inner.peek () {\n\t\t\tif next != last \u0026\u0026 last != 0xff {\n\t\t\t\tlet result = [count.pan_u8 (), last];\n\t\t\t\tlast = 0xff;\n\t\t\t\tcount = 0_u8;\n\t\t\t\treturn Some (result);\n\t\t\t}\n\t\t\tinner.next ().unwrap ();\n\t\t\tlast = next;\n\t\t\tif count \u003c 9 { count += 1; }\n\t\t}\n\t\tif last != 0xff {\n\t\t\tlet result = [count.pan_u8 (), last];\n\t\t\tlast = 0xff;\n\t\t\tcount = 0;\n\t\t\treturn Some (result);\n\t\t}\n\t\tNone\n\t}).flatten ()\n}\n\n#[ must_use ]\npub fn one_round (state: \u0026 State) -\u003e State {\n\tlet group_by =\n\t\tstate.iter ().copied ()\n\t\t\t.group_by (|\u0026 val| val);\n\tgroup_by.into_iter ()\n\t\t.flat_map (|(val, group)| [ group.count ().pan_u8 (), val ])\n\t\t.collect ()\n}\n","traces":[{"line":52,"address":[29616,29312],"length":1,"stats":{"Line":1},"fn_name":"one_round"},{"line":53,"address":[29344],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[25536],"length":1,"stats":{"Line":0},"fn_name":"call_mut\u003c\u0026u8, u8, aoc_2015_day_10::logic::one_round::{closure_env#0}\u003e"},{"line":57,"address":[23922,24010,23899],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Eq, Hash, PartialEq) ]\npub struct State (Vec \u003cu8\u003e);\n\nimpl State {\n\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\tinput.chars ()\n\t\t\t.map (|ch| Ok (ch.to_digit (10).ok_or (\"Invalid input\") ?.pan_u8 ()))\n\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e ()\n\t}\n\tpub fn iter (\u0026 self) -\u003e SliceIter \u003c'_, u8\u003e {\n\t\tself.0.iter ()\n\t}\n}\n\nimpl Borrow \u003c[u8]\u003e for State {\n\tfn borrow (\u0026 self) -\u003e \u0026 [u8] {\n\t\tself.0.as_slice ()\n\t}\n}\n\nimpl Deref for State {\n\ttype Target = Vec \u003cu8\u003e;\n\tfn deref (\u0026 self) -\u003e \u0026 Vec \u003cu8\u003e {\n\t\t\u0026 self.0\n\t}\n}\n\nimpl FromIterator \u003cu8\u003e for State {\n\tfn from_iter \u003cIntoIter\u003e (iter: IntoIter) -\u003e Self\n\t\t\twhere IntoIter: IntoIterator \u003cItem = u8\u003e {\n\t\tSelf (iter.into_iter ().collect ())\n\t}\n}\n\nimpl TryFrom \u003cVec \u003cu8\u003e\u003e for State {\n\ttype Error = GenError;\n\tfn try_from (nums: Vec \u003cu8\u003e) -\u003e GenResult \u003cSelf\u003e {\n\t\tif nums.iter ().copied ().any (|num| (1 ..= 9).contains (\u0026 num)) {\n\t\t\tErr (\"Digits must be 1-9\") ?;\n\t\t}\n\t\tOk (Self (nums))\n\t}\n}\n\nimpl Debug for State {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"State (len={}, {})\", self.0.len (), self) ?;\n\t\tOk (())\n\t}\n}\n\nimpl Display for State {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor \u0026 val in self.0.iter () {\n\t\t\twrite! (formatter, \"{}\", char::from_digit (val.pan_u32 (), 10).unwrap ()) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl PartialOrd for State {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tSome (Ord::cmp (self, other))\n\t}\n}\n\nimpl Ord for State {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tOrd::cmp (\u0026 self.0.len (), \u0026 other.0.len ())\n\t\t\t.then (Ord::cmp (\u0026 self.0, \u0026 other.0))\n\t}\n}\n","traces":[{"line":9,"address":[31904,32003,31922],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":12,"address":[16848],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":13,"address":[16849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[32032],"length":1,"stats":{"Line":0},"fn_name":"from_iter\u003ccore::iter::adapters::GenericShunt\u003ccore::iter::adapters::map::Map\u003ccore::str::iter::Chars, aoc_2015_day_10::model::{impl#0}::parse::{closure_env#0}\u003e, core::result::Result\u003ccore::convert::Infallible, alloc::boxed::Box\u003cdyn core::error::Error, alloc::alloc::Global\u003e\u003e\u003e\u003e"},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[16880],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":49,"address":[16892,16998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[17056],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":56,"address":[17073,17343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[17324,17250,17361],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","tracking.rs"],"content":"use super::*;\n\n#[ derive (Debug, clap::Parser) ]\npub struct Args {\n\n\t#[ clap (required = true) ]\n\tstate: String,\n\n\t#[ clap (long, default_value = \"1000\") ]\n\tloops: u16,\n\n\t#[ clap (long, default_value = \"65536\") ]\n\tmax_length: usize,\n\n\t#[ clap (long, default_value = \"10\") ]\n\tmin_points: u16,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn run (args: Args) -\u003e GenResult \u003c()\u003e {\n\tlet mut states = Vec::new ();\n\tstates.push (State::parse (\u0026 args.state) ?);\n\tfor cur_gen in 0_u16 .. {\n\t\tif cur_gen == args.loops { break }\n\t\tlet cur_state = states.last ().unwrap ();\n\t\tlet next_state = {\n\t\t\tlet mut items_iter = cur_state.items.iter ().copied ().enumerate ().multipeek ();\n\t\t\tlet mut buffer = None;\n\t\t\tlet mut item_idx = 0;\n\t\t\titer::from_fn (move || {\n\t\t\t\titems_iter.reset_peek ();\n\t\t\t\tlet item_0 = items_iter.peek ().copied ();\n\t\t\t\tlet item_1 = items_iter.peek ().copied ();\n\t\t\t\t// deterine num to output\n\t\t\t\tlet num = match (buffer, item_0) {\n\t\t\t\t\t(Some (buf), _) =\u003e buf,\n\t\t\t\t\t(None, Some ((_, Item { run, .. }))) =\u003e run,\n\t\t\t\t\t(None, None) =\u003e return None,\n\t\t\t\t};\n\t\t\t\t// measure size of run\n\t\t\t\tlet (next_0, next_1) = match item_0 {\n\t\t\t\t\tSome ((_, Item { run, num, .. })) =\u003e (Some (run), Some (num)),\n\t\t\t\t\tNone =\u003e (None, None),\n\t\t\t\t};\n\t\t\t\tlet (next_2, next_3) = match item_1 {\n\t\t\t\t\tSome ((_, Item { run, num, .. })) =\u003e (Some (run), Some (num)),\n\t\t\t\t\tNone =\u003e (None, None),\n\t\t\t\t};\n\t\t\t\tlet buffer_run = buffer.iter ().count ();\n\t\t\t\tlet next_run =\n\t\t\t\t\t[next_0, next_1, next_2, next_3].into_iter ()\n\t\t\t\t\t\t.take_while (|\u0026 next| next == Some (num))\n\t\t\t\t\t\t.count ();\n\t\t\t\tlet run: u8 = (buffer_run + next_run).try_into ().unwrap ();\n\t\t\t\t//println! (\"buf={:?} next=[{:?} {:?} {:?} {:?}] num={} run={}+{}={}\", buffer, next_0, next_1, next_2, next_3, num, buffer_run, next_run, run);\n\t\t\t\t// work out gen and index\n\t\t\t\tlet (gen, idx) = if buffer.is_some () {\n\t\t\t\t\t(cur_gen + 1, item_idx)\n\t\t\t\t} else {\n\t\t\t\t\tlet (_, item_0) = item_0.unwrap ();\n\t\t\t\t\t(item_0.gen, item_0.idx)\n\t\t\t\t};\n\t\t\t\t// update state\n\t\t\t\tlet (iter_adv, buffer_new) = match next_run {\n\t\t\t\t\t0 =\u003e (0_i32, None),\n\t\t\t\t\t1 =\u003e (1_i32, Some (next_1.unwrap ())),\n\t\t\t\t\t2 =\u003e (1_i32, None),\n\t\t\t\t\t3 =\u003e (2_i32, Some (next_3.unwrap ())),\n\t\t\t\t\t_ =\u003e panic! (\"Found run of {} + {} = {}\", buffer_run, next_run, run),\n\t\t\t\t};\n\t\t\t\tfor _ in 0_i32 .. iter_adv { items_iter.next ().unwrap (); }\n\t\t\t\tbuffer = buffer_new;\n\t\t\t\titem_idx += 1;\n\t\t\t\t// produce value\n\t\t\t\tSome (Item { run, num, gen, idx })\n\t\t\t})\n\t\t}.take (args.max_length * 2 / 3).collect ();\n\t\tstates.push (next_state);\n\t}\n\t// print states\n\tfor (state_gen, state) in states.iter ().enumerate () {\n\t\tlet state_gen = state_gen.pan_u16 ();\n\t\tlet mut align_iter =\n\t\t\tstates.last ().unwrap ().items.iter ().copied ()\n\t\t\t\t.map (|Item { gen, idx, .. }| (gen, idx))\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(col, (gen, idx))| ((gen, idx), col * 3))\n\t\t\t\t.filter (|\u0026 ((gen, _), _)| gen \u003c= state_gen);\n\t\tlet (mut align_key, mut align_col) = align_iter.next ().unwrap ();\n\t\tlet mut col = 0;\n\t\tfor \u0026 Item { gen, idx, run, num } in state.items.iter () {\n\t\t\tlet item_key = (gen, idx);\n\t\t\tif item_key == align_key {\n\t\t\t\twhile col \u003c align_col { print! (\" \"); col += 1; }\n\t\t\t\tprint! (\"|\"); col += 1;\n\t\t\t\t(align_key, align_col) = align_iter.next ().unwrap_or (((0, 0), 0));\n\t\t\t}\n\t\t\t//print! (\"[{}:{}]\", gen, idx);\n\t\t\tprint! (\"{}{}\", run, num); col += 2;\n\t\t}\n\t\tprint! (\"\\n\");\n\t}\n\tOk (())\n}\n\npub struct State {\n\titems: Vec \u003cItem\u003e,\n}\n\nimpl State {\n\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet state = model::State::parse (input) ?.try_into () ?;\n\t\tOk (state)\n\t}\n}\n\nimpl FromIterator \u003cItem\u003e for State {\n\tfn from_iter \u003cIntoIter\u003e (iter: IntoIter) -\u003e Self\n\t\t\twhere IntoIter: IntoIterator \u003cItem = Item\u003e {\n\t\tSelf {\n\t\t\titems: iter.into_iter ().collect (),\n\t\t}\n\t}\n}\n\nimpl TryFrom \u003cmodel::State\u003e for State {\n\ttype Error = GenError;\n\tfn try_from (state: model::State) -\u003e GenResult \u003cSelf\u003e {\n\t\tif state.len () % 2 != 0 {\n\t\t\tErr (\"TrackingState requires an even numbers of items\") ?;\n\t\t}\n\t\tOk (Self {\n\t\t\titems: state.iter ().copied ()\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(idx, (run, num))|\n\t\t\t\t\tOk (Item {\n\t\t\t\t\t\tgen: 0,\n\t\t\t\t\t\tidx: idx.try_into () ?,\n\t\t\t\t\t\trun,\n\t\t\t\t\t\tnum,\n\t\t\t\t\t}))\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?,\n\t\t})\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Item { run: u8, num: u8, gen: u16, idx: u32 }\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-11","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub initial: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { initial, params } = [\n\t\tparams,\n\t\t@str initial = ('a' ..= 'z', 8 ..= 8),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-11","lib.rs"],"content":"//! Advent of Code 2015: Day 11: Corporate Policy\n//!\n//! [https://adventofcode.com/2015/day/11](https://adventofcode.com/2015/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Corporate Policy\";\n\tyear = 2015;\n\tday = 11;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-11","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\nconst ALL_CHARS: \u0026 [char] = \u0026 [\n\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v',\n\t'w', 'x', 'y', 'z',\n];\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet password = next_password (\u0026 input.initial) ?;\n\tOk (password)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet password_0 = next_password (\u0026 input.initial) ?;\n\tlet password_1 = next_password (\u0026 password_0) ?;\n\tOk (password_1)\n}\n\npub fn next_password (input: \u0026 str) -\u003e GenResult \u003cString\u003e {\n\tif input.chars ().count () != 8 {\n\t\treturn Err (\"Password must have eight characters\".into ());\n\t}\n\tlet mut char_idxs: Vec \u003cusize\u003e =\n\t\tinput.chars ()\n\t\t\t.map (|ch| ALL_CHARS.iter ().copied ()\n\t\t\t\t.position (|valid_ch| ch == valid_ch)\n\t\t\t\t.ok_or_else (|| format! (\"Input contains invalid character: {}\", ch).into ()))\n\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\tfn idxs_to_chars (char_idxs: \u0026 [usize]) -\u003e impl Iterator \u003cItem = char\u003e + '_ + Clone {\n\t\tchar_idxs.iter ().copied ().map (|idx| ALL_CHARS [idx])\n\t}\n\tlet new_password = loop {\n\t\tfor idx in (0 .. char_idxs.len ()).rev () {\n\t\t\tchar_idxs [idx] += 1;\n\t\t\tif char_idxs [idx] \u003c ALL_CHARS.len () \u0026\u0026 (idx \u003c char_idxs.len () - 2\n\t\t\t\t\t|| find_pair (idxs_to_chars (\u0026 char_idxs [ .. char_idxs.len () - 2]))\n\t\t\t\t\t\t.is_some ())\n\t\t\t\t{ break }\n\t\t\tchar_idxs [idx] = 0;\n\t\t}\n\t\tif is_valid (idxs_to_chars (\u0026 char_idxs)) {\n\t\t\tbreak char_idxs.iter ().copied ()\n\t\t\t\t.map (|idx| ALL_CHARS [idx])\n\t\t\t\t.collect::\u003cString\u003e ();\n\t\t}\n\t};\n\tOk (new_password)\n}\n\npub fn is_valid \u003cInpt\u003e (input: Inpt) -\u003e bool\n\t\twhere Inpt: Iterator \u003cItem = char\u003e + Clone {\n\tif ! input.clone ()\n\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t.any (|(a, b, c)| a.pan_u32 () + 1 == b.pan_u32 () \u0026\u0026 b.pan_u32 () + 1 == c.pan_u32 ()) {\n\t\treturn false;\n\t}\n\tlet (num_repeats, _, _) =\n\t\tinput.fold ((0_u32, None, None), |(sum, last, prev), next|\n\t\t\tif last == Some (next) \u0026\u0026 prev != Some (next) {\n\t\t\t\t(sum + 1, None, Some (next))\n\t\t\t} else {\n\t\t\t\t(sum, Some (next), prev)\n\t\t\t});\n\tif num_repeats \u003c 2 { return false }\n\ttrue\n}\n\npub fn find_pair \u003cInpt\u003e (input: Inpt) -\u003e Option \u003c(usize, char)\u003e\n\t\twhere Inpt: Iterator \u003cItem = char\u003e + Clone {\n\tinput\n\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t.filter (|\u0026 (a, b)| a == b)\n\t\t.map (|(a, _)| a)\n\t\t.enumerate ()\n\t\t.next ()\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn is_valid () {\n\t\tassert! (! logic::is_valid (\"hijklmmn\".chars ()));\n\t\tassert! (! logic::is_valid (\"abbceffg\".chars ()));\n\t\tassert! (! logic::is_valid (\"abbcegjk\".chars ()));\n\t}\n\n\t#[ test ]\n\tfn next_password () {\n\t\tassert_eq_ok! (\"abcdffaa\", logic::next_password (\"abcdefgh\"));\n\t\tassert_eq_ok! (\"ghjaabcc\", logic::next_password (\"ghhzzzzz\"));\n\t}\n\n}\n","traces":[{"line":21,"address":[29360,30189],"length":1,"stats":{"Line":1},"fn_name":"next_password"},{"line":22,"address":[29484,29434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[29440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[30018,29533],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[16880,16919],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[28769,28752,28833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[27708,27794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[20748,20636],"length":1,"stats":{"Line":8},"fn_name":null},{"line":35,"address":[29584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[29655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[29800,29682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[29731,29783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[29802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[29861,29840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[29885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[31480,31563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[29987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[17792,17392],"length":1,"stats":{"Line":2},"fn_name":"is_valid\u003ccore::str::iter::Chars\u003e"},{"line":54,"address":[17964,17704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[17718,17979,18880,18736,18893,18749,18086],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}\u003ccore::str::iter::Chars\u003e"},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[19024],"length":1,"stats":{"Line":1},"fn_name":"find_pair\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003cusize\u003e\u003e, aoc_2015_day_11::logic::next_password::idxs_to_chars::{closure_env#0}\u003e\u003e"},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[19508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[21635,21718],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[21668,21734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[21701,21750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[19476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[21896,22042,21840,21803,22347,22108],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[21955,21918,22173,22011,22234],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":33,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [\"[1,2,3]\"]));\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [\"{\\\"a\\\":2,\\\"b\\\":4}\"]));\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [\"[[[3]]]\"]));\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [\"{\\\"a\\\":{\\\"b\\\":4},\\\"c\\\":-1}\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [\"{\\\"a\\\":[-1,1]}\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [\"[-1,{\\\"a\\\":1}]\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [\"[]\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [\"{}\"]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_two (\u0026 [\"[1,2,3]\"]));\n\tassert_eq_ok! (\"4\", puzzle.part_two (\u0026 [\"[1,{\\\"c\\\":\\\"red\\\",\\\"b\\\":2},3]\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [\"{\\\"d\\\":\\\"red\\\",\\\"e\\\":[1,2,3,4],\\\"f\\\":5}\"]));\n\tassert_eq_ok! (\"6\", puzzle.part_two (\u0026 [\"[1,\\\"red\\\",5]\"]));\n}\n","traces":[{"line":6,"address":[28724,28720],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":7,"address":[30145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[30261,30208,30166,31155,31218,32473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[30319,31344,30281,30372,31284,32437],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[30392,30492,31470,30436,32398,31410],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[30512,30612,31536,30556,31596,32359],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[31662,31722,30676,30732,30632,32320],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[30796,30752,31788,30852,31848,32281],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[30872,31914,32242,30972,31974,30916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[30992,31092,32203,32097,31036,32037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[28756,28752],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[32545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[32608,33733,32566,33075,33138,32661],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[32681,33204,33264,32772,33697,32719],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[32892,33390,33658,32792,33330,32836],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[33619,33012,32956,32912,33453,33513],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","input.rs"],"content":"use super::*;\n\nuse model::Json;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub json: Json \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { json, params } = [ params, json ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","lib.rs"],"content":"//! Advent of Code 2015: Day 12: JSAbacusFramework.io\n//!\n//! [https://adventofcode.com/2015/day/12](https://adventofcode.com/2015/day/12)\n//!\n//! # Input\n//!\n//! A single line of a subset of JSON. Support for arrays, objects, integers and strings (without\n//! escapes).\n//!\n//! # Part one\n//!\n//! Sum of all numbers in the input.\n//!\n//! # Part two\n//!\n//! Sum of all numbers in the input, excluding any objects (and all children) which directly\n//! contain the value \"red\".\n//!\n//! # Algorithm\n//!\n//! This is very simple. Data is parsed into a data structure. A recursive function calculates the\n//! result for each part.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"JSAbacusFramework.io\";\n\tyear = 2015;\n\tday = 12;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":38,"address":[29321],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Json;\nuse model::Val;\nuse nums::NumResult;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tOk (calc_sum (\u0026 input.json, |_| true) ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tOk (calc_sum (\u0026 input.json, filter_red) ?)\n}\n\nfn filter_red (value: \u0026 Json) -\u003e bool {\n\tlet items = if let Json::Object (ref items) = * value { items } else { return true };\n\t! items.iter ().any (|\u0026 (_, ref value)| {\n\t\tmatches! (* value, Json::String (ref value) if value == \"red\")\n\t})\n}\n\nfn calc_sum (value: \u0026 Json, filter: fn (\u0026 Json) -\u003e bool) -\u003e NumResult \u003cVal\u003e {\n\tif ! filter (value) { return Ok (Val::ZERO) }\n\tmatch * value {\n\t\tJson::Array (ref items) =\u003e items.iter ()\n\t\t\t.try_fold (Val::ZERO, |sum, item| {\n\t\t\t\tlet item = calc_sum (item, filter) ?;\n\t\t\t\tOk (chk! (sum + item) ?)\n\t\t\t}),\n\t\tJson::Object (ref items) =\u003e items.iter ()\n\t\t\t.try_fold (Val::ZERO, |sum, \u0026 (_, ref item)| {\n\t\t\t\tlet item = calc_sum (item, filter) ?;\n\t\t\t\tOk (chk! (sum + item) ?)\n\t\t\t}),\n\t\tJson::Number (value) =\u003e Ok (value),\n\t\tJson::String (_) =\u003e Ok (Val::ZERO),\n\t}\n}\n\n#[ cfg (test) ]\nmod test {\n\n\tuse super::*;\n\n\tfn pj (src: \u0026 str) -\u003e Json {\n\t\tJson::parse_from_str (src).unwrap ()\n\t}\n\n\t#[ test ]\n\tfn filter_red () {\n\t\tassert! (super::filter_red (\u0026 pj (\"{\\\"abc\\\":[],\\\"red\\\":1}\")));\n\t\tassert! (super::filter_red (\u0026 pj (\"[{\\\"abc\\\":[],\\\"def\\\":\\\"red\\\"}]\")));\n\t\tassert! (super::filter_red (\u0026 pj (\"{\\\"key\\\":{\\\"abc\\\":[],\\\"def\\\":\\\"red\\\"}}\")));\n\t\tassert! (! super::filter_red (\u0026 pj (\"{\\\"abc\\\":[],\\\"def\\\":\\\"red\\\"}\")));\n\t}\n\n}\n","traces":[{"line":8,"address":[56048],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[40192],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":12,"address":[56272],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":13,"address":[29679,29778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[56352],"length":1,"stats":{"Line":1},"fn_name":"filter_red"},{"line":17,"address":[56365],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[40208],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":19,"address":[56493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[56560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[56581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[56590,56075],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[56123,56637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[40272],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":28,"address":[40275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[40328,40464,40480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[56175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[42009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[40375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[40496,40428,40512],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[56208,56910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[28784,28788],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":52,"address":[41303,41663,40707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[41379,41628,40877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[41047,41593,41452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[41525,41217],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":22,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","model.rs"],"content":"use super::*;\n\npub type Val = i32;\n\nenum_decl_parser_display! {\n\tinput_lifetime = 'inp;\n\t#[ derive (Clone, Debug) ]\n\tpub enum Json \u003c'inp\u003e {\n\t\tArray (items: Vec \u003cJson \u003c'inp\u003e\u003e) = [\n\t\t\t\"[\", @confirm, @delim \",\" items, \"]\",\n\t\t],\n\t\tObject (items: Vec \u003c(InpStr \u003c'inp\u003e, Json \u003c'inp\u003e)\u003e) = [\n\t\t\t\"{\", @confirm, @delim \",\" items {\n\t\t\t\ttype = (InpStr, Json);\n\t\t\t\t(key, value) = [\n\t\t\t\t\t\"\\\"\", @str key = (|ch| { ch != '\"' }, .. ), \"\\\":\", value,\n\t\t\t\t],\n\t\t\t}, \"}\",\n\t\t],\n\t\tNumber (value: Val) = [ value ],\n\t\tString (value: InpStr \u003c'inp\u003e) = [\n\t\t\t\"\\\"\", @confirm, @str value = (|ch| { ch != '\"' }, .. ), \"\\\"\",\n\t\t],\n\t}\n}\n","traces":[{"line":15,"address":[44738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[44864],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":22,"address":[45312],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Alice would gain 54 happiness units by sitting next to Bob.\",\n\t\"Alice would lose 79 happiness units by sitting next to Carol.\",\n\t\"Alice would lose 2 happiness units by sitting next to David.\",\n\t\"Bob would gain 83 happiness units by sitting next to Alice.\",\n\t\"Bob would lose 7 happiness units by sitting next to Carol.\",\n\t\"Bob would lose 63 happiness units by sitting next to David.\",\n\t\"Carol would lose 62 happiness units by sitting next to Alice.\",\n\t\"Carol would gain 60 happiness units by sitting next to Bob.\",\n\t\"Carol would gain 55 happiness units by sitting next to David.\",\n\t\"David would gain 46 happiness units by sitting next to Alice.\",\n\t\"David would lose 7 happiness units by sitting next to Bob.\",\n\t\"David would gain 41 happiness units by sitting next to Carol.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"330\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"286\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":21,"address":[41271,40880],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":22,"address":[40890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[40949,41001,40911,41058,41124,41228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[41280,41671],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":28,"address":[41290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[41311,41349,41524,41628,41458],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub pairs: Vec \u003c(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e, DiffSign, i32)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { pairs, params } = [\n\t\tparams, @lines pairs {\n\t\t\ttype = (InpStr, InpStr, DiffSign, i32);\n\t\t\t(person_0, person_1, sign, diff) = [\n\t\t\t\t@str person_0 = (|ch| { ch.is_ascii_alphabetic () }, 1 ..= 10),\n\t\t\t\t\" would \", sign, \" \",\n\t\t\t\tdiff = 0_i32 ..= i32::MAX,\n\t\t\t\t\" happiness units by sitting next to \",\n\t\t\t\t@str person_1 = (|ch| { ch.is_ascii_alphabetic () }, 1 ..= 10),\n\t\t\t\t\".\",\n\t\t\t],\n\t\t},\n\t]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum DiffSign {\n\t\tGain = [ \"gain\" ],\n\t\tLose = [ \"lose\" ],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[44411,43366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[35901],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","lib.rs"],"content":"//! Advent of Code 2015: Day 13: Knights of the Dinner Table\n//!\n//! [https://adventofcode.com/2015/day/13](https://adventofcode.com/2015/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_search::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Knights of the Dinner Table\";\n\tyear = 2015;\n\tday = 13;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[76760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[77080],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::HappinessTable;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tlet table = HappinessTable::build (\u0026 input.pairs) ?;\n\tlet mut perms_helper = PermutationsHelper::new_circular (table.len ());\n\tOk (\n\t\titer::from_fn (|| perms_helper.next ()\n\t\t\t\t.then (|| perms_helper.iter ()\n\t\t\t\t\t.circular_tuple_windows ()\n\t\t\t\t\t.map (|(\u0026 idx_0, \u0026 idx_1)| table [(idx_0, idx_1)] + table [(idx_1, idx_0)])\n\t\t\t\t\t.sum ()))\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tlet table = HappinessTable::build (\u0026 input.pairs) ?;\n\tlet mut perms_helper = PermutationsHelper::new_mirror (table.len ());\n\tOk (\n\t\titer::from_fn (|| perms_helper.next ()\n\t\t\t\t.then (|| perms_helper.iter ()\n\t\t\t\t\t.tuple_windows ()\n\t\t\t\t\t.map (|(\u0026 idx_0, \u0026 idx_1)| table [(idx_0, idx_1)] + table [(idx_1, idx_0)])\n\t\t\t\t\t.sum ()))\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n","traces":[{"line":6,"address":[37920,38700],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[38043,38260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[38521,38720,38735,38565],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":11,"address":[38992,39013,38754,38767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[39455,39230,39216,39325],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":14,"address":[38967,39198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[39488,40254],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[39824,39597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[40048,39999,40272,40279,40112],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[29591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[40847,40717,40608,40622],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":28,"address":[40317,40590],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","model.rs"],"content":"use super::*;\n\nuse input::DiffSign;\n\nwrapper_deref_mut! {\n\tpub struct HappinessTable \u003c'inp\u003e {\n\t\tinner: PairsMap \u003cInpStr \u003c'inp\u003e, i32\u003e,\n\t}\n}\n\nimpl \u003c'inp\u003e HappinessTable \u003c'inp\u003e {\n\tpub fn build (\n\t\tinput_pairs: \u0026 [(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e, DiffSign, i32)],\n\t) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet inner: PairsMap \u003cInpStr, i32\u003e =\n\t\t\tinput_pairs.iter ()\n\t\t\t\t.map (|\u0026 (ref person_0, ref person_1, sign, amnt)|\n\t\t\t\t\t(person_0.clone (), person_1.clone (), match sign {\n\t\t\t\t\t\tDiffSign::Gain =\u003e amnt,\n\t\t\t\t\t\tDiffSign::Lose =\u003e - amnt,\n\t\t\t\t\t}))\n\t\t\t\t.collect ();\n\t\tif 10 \u003c inner.len () { return Err (\"Max 10 people allowed\".into ()) }\n\t\tOk (Self { inner })\n\t}\n}\n","traces":[{"line":12,"address":[38646,40205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"RACE_TIME=1000\",\n\t\"Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds.\",\n\t\"Dancer can fly 16 km/s for 11 seconds, but then must rest for 162 seconds.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1120\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"689\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[46052,46048],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":13,"address":[53002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[53340,53113,53061,53170,53023,53236],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[46080,46084],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":19,"address":[53402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[53636,53513,53461,53570,53740,53423],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","input.rs"],"content":"use super::*;\n\nuse model::Reindeer;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub deers: Vec \u003cReindeer \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { deers, params } = [ params, @lines deers ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub race_time: u32 = (\"RACE_TIME=\", 2503, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":13,"address":[29488,28436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[39261],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","lib.rs"],"content":"//! Advent of Code 2015: Day 14: Reindeer Olympics\n//!\n//! [https://adventofcode.com/2015/day/14](https://adventofcode.com/2015/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Reindeer Olympics\";\n\tyear = 2015;\n\tday = 14;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[47042],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Reindeer;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet max_dist =\n\t\tinput.deers.iter ()\n\t\t\t.map (|deer| iter_distance (deer)\n\t\t\t\t.nth (input.params.race_time.pan_usize ())\n\t\t\t\t.unwrap ())\n\t\t\t.max ()\n\t\t\t.unwrap_or (0);\n\tOk (max_dist)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut iters: Vec \u003c_\u003e =\n\t\tinput.deers.iter ()\n\t\t\t.map (iter_distance)\n\t\t\t.collect ();\n\tlet mut scores = vec! [0; input.deers.len ()];\n\tfor _ in 0 .. input.params.race_time {\n\t\tlet (idx, _) = iters.iter_mut ()\n\t\t\t.map (|iter| iter.next ().unwrap ())\n\t\t\t.enumerate ()\n\t\t\t.max_by_key (|\u0026 (_, dist)| dist)\n\t\t\t.unwrap ();\n\t\tscores [idx] += 1;\n\t}\n\tOk (scores.iter ().copied ().max ().unwrap ())\n}\n\nfn iter_distance \u003c'inp\u003e (deer: \u0026 'inp Reindeer \u003c'inp\u003e) -\u003e impl Iterator \u003cItem = u64\u003e + 'inp {\n\tlet mut flying = false;\n\tlet mut time = 0;\n\tlet mut dist = 0_u64;\n\titer::from_fn (move || {\n\t\tif time == 0 {\n\t\t\tif flying { time = deer.rest_time; flying = false; }\n\t\t\telse { time = deer.fly_time; flying = true; }\n\t\t}\n\t\ttime -= 1;\n\t\tif flying { dist += deer.fly_speed.pan_u64 (); }\n\t\tSome (dist)\n\t})\n}\n","traces":[{"line":6,"address":[30992],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":7,"address":[46664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[31264,31659,30699],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[31281,30321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[31680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[46676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[31744,32442],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":23,"address":[31854,32111,31844],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[26283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[32496],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":29,"address":[32075,32101,32343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[32122,32254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":16,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Reindeer \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub fly_speed: u32,\n\tpub fly_time: u32,\n\tpub rest_time: u32,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tReindeer \u003c'inp\u003e { name, fly_speed, fly_time, rest_time } = [\n\t\t@str name = (|ch| { ch.is_ascii_alphabetic () }, 1 .. 20), \" can fly \",\n\t\tfly_speed, \" km/s for \",\n\t\tfly_time, \" seconds, but then must rest for \",\n\t\trest_time, \" seconds.\",\n\t]\n}\n","traces":[{"line":13,"address":[56883],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8\",\n\t\"Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"62842880\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"57600000\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[27744,27748],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":12,"address":[39306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[39644,39540,39417,39365,39327,39474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[27780,27776],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":18,"address":[39706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[40044,39727,39874,39765,39940,39817],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","input.rs"],"content":"use super::*;\n\nuse model::Ingredient;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub ingrs: Vec \u003cIngredient \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { ingrs, params } = [ params, @lines ingrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[37940],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","lib.rs"],"content":"//! Advent of Code 2015: Day 15: Science for Hungry People\n//!\n//! [https://adventofcode.com/2015/day/15](https://adventofcode.com/2015/day/15)\n//!\n//! # Input\n//!\n//! A list of ingredients in the following format, where `A`-`E` are integers:\n//!\n//! ```text\n//! Name: capacity A, durability B, flavor C, texture D, calories E\n//! ```\n//!\n//! # Part one\n//!\n//! Find the combination of exactly 100 ingredients with the highest score. The score is\n//! calculated by summing the capacity, durability, flavour and texture of each ingredient, then\n//! multiplying them together. If any attribute sums to less than zero then the score is zero.\n//!\n//! # Part two\n//!\n//! Same as part one, except the total number of calories must be exactly five hundred.\n//!\n//! # Algorithm\n//!\n//! Iterate every combination of exactly one hundred ingredients, filter on the number of calories\n//! for part two, then find the maximum.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Science for Hungry People\";\n\tyear = 2015;\n\tday = 15;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":42,"address":[36264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[36584],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Recipe;\n\n/// Part one: Find the combination of ingredients which gives the maximum possible score.\n///\n/// Iterates all valid recipes and returns the maximum score.\n///\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\titer_recipes (input)\n\t\t\t.map (|recipe| recipe.and_then (|recipe| recipe.score ()))\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ? ?\n\t)\n}\n\n/// Part two: Find the combination of ingredients which gives the maximum score and exactly 500\n/// calories in total.\n///\n/// Iterates all valid recipes, filters on those with exactly `500` calories, and returns the\n/// maximum score.\n///\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\titer_recipes (input)\n\t\t\t.filter (|recipe| recipe\n\t\t\t\t.map (|recipe| recipe.calories () == 500_i32)\n\t\t\t\t.unwrap_or (true))\n\t\t\t.map (|recipe| recipe.and_then (|recipe| recipe.score ()))\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ? ?\n\t)\n}\n\n/// Validate extra conditions on the input.\n///\npub fn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.ingrs.len () \u003c 2 { return Err (\"Must have at least two ingredients\".into ()) }\n\tif 6 \u003c input.ingrs.len () { return Err (\"Must have at most six ingredients\".into ()) }\n\tOk (())\n}\n\n/// Iterate through all recipes containing exactly 100 ingredients\n///\n/// We iterate through all values for all but the last ingredient, starting with all zero, then\n/// increasing the last ingredient which can be increased without exceeding 100 total, and setting\n/// all subsequent ingredients to zero. This gives for example, for four ingredients, `0, 0, 0`,\n/// then `0, 0, 1`, etc...\n///\n/// The last ingredient we always set specifically to get exactly 100 ingredients total.\n///\npub fn iter_recipes \u003c'dat\u003e (\n\tinput: \u0026 'dat Input,\n) -\u003e impl Iterator \u003cItem = NumResult \u003cRecipe\u003e\u003e + 'dat {\n\n\tlet mut recipe = Recipe::default ();\n\tlet mut finished = false;\n\n\titer::from_fn (move || {\n\n\t\tif finished { return None }\n\n\t\tlet mut result = recipe;\n\t\tif result.add_ingrs (\n\t\t\t\t\t\u0026 input.ingrs,\n\t\t\t\t\tinput.ingrs.len () - 1,\n\t\t\t\t\t(100 - result.num_ingrs).pan_i8 ())\n\t\t\t\t.is_err () {\n\t\t\tfinished = true;\n\t\t\treturn Some (Err (Overflow));\n\t\t}\n\n\t\tfor idx in (0 .. input.ingrs.len () - 1).rev () {\n\t\t\tif recipe.num_ingrs \u003c 100 {\n\t\t\t\tif recipe.add_ingrs (\u0026 input.ingrs, idx, 1).is_err () {\n\t\t\t\t\tfinished = true;\n\t\t\t\t\treturn Some (Err (Overflow));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif recipe.add_ingrs (\n\t\t\t\t\t\t\u0026 input.ingrs,\n\t\t\t\t\t\tidx,\n\t\t\t\t\t\t- recipe.ingrs [idx].pan_i8 ())\n\t\t\t\t\t.is_err () {\n\t\t\t\tfinished = true;\n\t\t\t\treturn Some (Err (Overflow));\n\t\t\t}\n\t\t\tif idx == 0 { finished = true; }\n\t\t}\n\n\t\tSome (Ok (result))\n\n\t})\n\n}\n","traces":[{"line":12,"address":[38816],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":13,"address":[38887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[38973,38944,38990],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[26752,26672,26788,26686,26744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[39056],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":29,"address":[39127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[39184,39213,39230],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[26800,25872],"length":1,"stats":{"Line":0},"fn_name":"call_mut\u003c(\u0026core::result::Result\u003caoc_2015_day_15::model::Recipe, aoc_nums::Overflow\u003e), aoc_2015_day_15::logic::part_two::{closure_env#0}\u003e"},{"line":33,"address":[50376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[26822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[26848,26928,26920,26862,26964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[39073,38833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[38853,39093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[27135,27190],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[27032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[27056,27683,27049],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[27068,27699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":23,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Ingredient \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub stats: [i32; 5],\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tIngredient \u003c'inp\u003e { name, stats: [ capacity, durability, flavour, texture, calories ] } = [\n\t\t@str name = (|ch| { ch.is_ascii_alphanumeric () }, 1 ..= 20), \": \",\n\t\t\"capacity \", capacity, \", \",\n\t\t\"durability \", durability, \", \",\n\t\t\"flavor \", flavour, \", \",\n\t\t\"texture \", texture, \", \",\n\t\t\"calories \", calories = 1_i32 ..= 500_i32,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug, Default) ]\npub struct Recipe {\n\tpub num_ingrs: i8,\n\tpub ingrs: [i8; 6],\n\tpub stats: [i32; 5],\n}\n\nimpl Recipe {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn calories (\u0026 self) -\u003e i32 {\n\t\tself.stats [4]\n\t}\n\n\t#[ inline ]\n\tpub fn score (\u0026 self) -\u003e NumResult \u003cu64\u003e {\n\t\tself.stats [0 .. 4].iter ()\n\t\t\t.map (|\u0026 item| cmp::max (item, 0_i32).pan_u64 ())\n\t\t\t.try_fold (1, |prod, item| chk! (prod * item))\n\t}\n\n\t#[ inline ]\n\tpub fn add_ingrs (\u0026 mut self, ingrs: \u0026 [Ingredient], ingr_idx: usize, num: i8) -\u003e GenResult \u003c()\u003e {\n\t\tself.num_ingrs += num;\n\t\tself.ingrs [ingr_idx] += num;\n\t\tlet num = num.pan_i32 ();\n\t\tfor stat_idx in 0 .. 5 {\n\t\t\tchk! (self.stats [stat_idx] += ingrs [ingr_idx].stats [stat_idx] * num) ?;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":11,"address":[32478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[31101,31092],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-16","input.rs"],"content":"use super::*;\n\nuse model::AuntSue;\n\n#[ derive (Clone, Debug) ]\npub struct Input  {\n\tpub sues: Vec \u003cAuntSue\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { sues, params } = [ params, @lines sues ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-16","lib.rs"],"content":"//! Advent of Code 2015: Day 16: Aunt Sue\n//!\n//! [https://adventofcode.com/2015/day/16](https://adventofcode.com/2015/day/16)\n//!\n//! # Input\n//!\n//! A list of \"aunt Sue\"s, with a numbered id and information known about each one. Each piece of\n//! information takes the form of the number of one of ten types of posession. The lines take the\n//! following form:\n//!\n//! ```text\n//! Sue 1: item_0: 2, item_1: 3\n//! ```\n//!\n//! There are ten types of posessions: `children`, `cats`, `samoyeds`, `pomeranians`, `akitas`,\n//! `viszlas`, `goldfish`, `trees`, `cars`, `perfumes`.\n//!\n//! Types of posession which are not specified could take any value.\n//!\n//! # Part one\n//!\n//! Return the id number of the sue with exactly 3 children, 7 cats, 2 samoyeds, 3 pomeranians, 0\n//! akitas, 0 vizslas, 5 goldfish, 3 trees, 2 cars and 1 perfume.\n//!\n//! # Part two\n//!\n//! Return the id number of the sue with exactly 3 children, more than 7 cats, 2 samoyeds, less\n//! than 3 pomeranians, 0 akitas, 0 vizslas, less than 5 goldfish, more than 3 trees, 2 cars and 1\n//! perfume.\n//!\n//! # Algorithm\n//!\n//! Iterate over the sues and apply the specified. Verify that there is exactly one match and\n//! return the id.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Aunt Sue\";\n\tyear = 2015;\n\tday = 16;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-16","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse model::Attr;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcalc_result (input, |attr, num| match attr {\n\t\tAttr::Children =\u003e num == 3,\n\t\tAttr::Cats =\u003e num == 7,\n\t\tAttr::Samoyeds =\u003e num == 2,\n\t\tAttr::Pomeranians =\u003e num == 3,\n\t\tAttr::Akitas =\u003e num == 0,\n\t\tAttr::Vizslas =\u003e num == 0,\n\t\tAttr::Goldfish =\u003e num == 5,\n\t\tAttr::Trees =\u003e num == 3,\n\t\tAttr::Cars =\u003e num == 2,\n\t\tAttr::Perfumes =\u003e num == 1,\n\t})\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcalc_result (input, |attr, num| match attr {\n\t\tAttr::Children =\u003e num == 3,\n\t\tAttr::Cats =\u003e num \u003e 7,\n\t\tAttr::Samoyeds =\u003e num == 2,\n\t\tAttr::Pomeranians =\u003e num \u003c 3,\n\t\tAttr::Akitas =\u003e num == 0,\n\t\tAttr::Vizslas =\u003e num == 0,\n\t\tAttr::Goldfish =\u003e num \u003c 5,\n\t\tAttr::Trees =\u003e num \u003e 3,\n\t\tAttr::Cars =\u003e num == 2,\n\t\tAttr::Perfumes =\u003e num == 1,\n\t})\n}\n\npub fn calc_result (input: \u0026 Input, ticker_fn: fn (Attr, u8) -\u003e bool) -\u003e GenResult \u003cu16\u003e {\n\tlet the_sue =\n\t\tinput.sues.iter ()\n\t\t\t.filter (|sue| sue.attrs.iter ().copied ()\n\t\t\t\t.all (|(attr, num)| ticker_fn (attr, num)))\n\t\t\t.exactly_one ()\n\t\t\t.map_err (|iter| format! (\"Expected exactly one match but found {}\", iter.count ())) ?;\n\tOk (the_sue.number)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-16","model.rs"],"content":"//! Representation of the puzzle input, etc.\n//!\n\nuse super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct AuntSue {\n\tpub number: u16,\n\tpub attrs: Vec \u003c(Attr, u8)\u003e,\n}\n\nstruct_parser_display! {\n\tAuntSue { number, attrs } = [\n\t\t\"Sue \", number, \": \",\n\t\t@delim \", \" attrs {\n\t\t\ttype = (Attr, u8);\n\t\t\t(attr, num) = [ attr, \": \", num ],\n\t\t},\n\t]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Attr {\n\t\tChildren = [ \"children\" ],\n\t\tCats = [ \"cats\" ],\n\t\tSamoyeds = [ \"samoyeds\" ],\n\t\tPomeranians = [ \"pomeranians\" ],\n\t\tAkitas = [ \"akitas\" ],\n\t\tVizslas = [ \"vizslas\" ],\n\t\tGoldfish = [ \"goldfish\" ],\n\t\tTrees = [ \"trees\" ],\n\t\tCars = [ \"cars\" ],\n\t\tPerfumes = [ \"perfumes\" ],\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-17","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"TARGET=25\",\n\t\"20\",\n\t\"15\",\n\t\"10\",\n\t\"5\",\n\t\"5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":15,"address":[40228,40224],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":16,"address":[48058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[48079,48292,48117,48226,48169,48396],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[40256,40260],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":22,"address":[48458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[48626,48796,48692,48517,48479,48569],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-17","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input  {\n\tpub sizes: Vec \u003cu32\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { sizes, params } = [ params, @lines sizes ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub target: u32 = (\"TARGET=\", 150, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":10,"address":[41979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[42301],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-17","lib.rs"],"content":"//! Advent of Code 2015: Day 17: No Such Thing as Too Much\n//!\n//! [https://adventofcode.com/2015/day/17](https://adventofcode.com/2015/day/17)\n//!\n//! # Input\n//!\n//! Each line is a decimal integer, representing the size of an available container.\n//!\n//! To run the examples given as tests, we also support a single input parameter giving a target\n//! size other than 150:\n//!\n//! ```text\n//! TARGET=25\n//! 20\n//! 15\n//! 10\n//! 5\n//! 5\n//! ```\n//!\n//! # Part one\n//!\n//! Work out the number of combinations of containers so that the size adds up to exactly 150. The\n//! containers count separately, even if they are the same size.\n//!\n//! # Part two\n//!\n//! Work out the minimum number of containers to hold exactly 150, then work out the total number\n//! of combinations of that many containers which can hold exactly 150.\n//!\n//! # Algorithm\n//!\n//! The [`combos`](logic::combos) function provides an iterator over all combinations of\n//! containers which sum to the target size.\n//!\n//! For part one, we just use [`count`](Iterator::count). For part two, we\n//! [`fold`](Iterator::fold) over the combinations, tracking the smallest number of containers so\n//! far and the number of combinations with that specific number.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"No Such Thing as Too Much\";\n\tyear = 2015;\n\tday = 17;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":53,"address":[42839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[43191],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-17","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet num_combos = combos (input).count ();\n\tOk (num_combos.pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet (_, num) =\n\t\tcombos (input)\n\t\t\t.fold ((u32::MAX, 0), |(min, num), combo_len|\n\t\t\t\tmatch combo_len.cmp (\u0026 min) {\n\t\t\t\t\tOrdering::Less =\u003e (combo_len, 1),\n\t\t\t\t\tOrdering::Equal =\u003e (min, num + 1),\n\t\t\t\t\tOrdering::Greater =\u003e (min, num),\n\t\t\t\t});\n\tOk (num)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.sizes.len () \u003e 20 {\n\t\treturn Err (\"Refusing to deal with more than 20 containers\".into ());\n\t}\n\tlet sum = input.sizes.iter ().try_fold (0, |sum, \u0026 item| chk! (sum + item)) ?;\n\tif sum \u003c input.params.target {\n\t\treturn Err (\"No solution found\".into ());\n\t}\n\tOk (())\n}\n\n/// Iterate over combinations of provided container given a specific total.\n///\n/// Returns an [`Iterator`] over the number of containers in each combination.\n///\npub fn combos (input: \u0026 Input) -\u003e impl Iterator \u003cItem = u32\u003e + '_ {\n\tlet sizes: Vec \u003cu32\u003e =\n\t\tinput.sizes.iter ().copied ()\n\t\t\t.sorted_by_key (|\u0026 size| cmp::Reverse (size))\n\t\t\t.collect ();\n\tlet target = input.params.target;\n\tlet mut state = iter::repeat (false).take (sizes.len ()).collect::\u003cVec \u003c_\u003e\u003e ();\n\tlet mut sum = 0;\n\titer::from_fn (move || loop {\n\t\tif state.is_empty () { return None }\n\t\tlet mut idx = state.len () - 1;\n\t\tloop {\n\t\t\tif state [idx] {\n\t\t\t\tstate [idx] = false;\n\t\t\t\tsum -= sizes [idx];\n\t\t\t\tif idx \u003e 0 { idx -= 1 } else { return None }\n\t\t\t} else if 150 \u003c sum\n\t\t\t\t\t|| sum + sizes.iter ().copied ().skip (idx).sum::\u003cu32\u003e () \u003c target {\n\t\t\t\tif idx \u003e 0 { idx -= 1 } else { return None }\n\t\t\t} else { break }\n\t\t}\n\t\tstate [idx] = true;\n\t\tsum += sizes [idx];\n\t\tif sum == target {\n\t\t\treturn Some (state.iter ().filter (|\u0026\u0026 state| state).count ().pan_u32 ())\n\t\t}\n\t})\n}\n","traces":[{"line":7,"address":[46880],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[46895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[46949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[47110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[47168],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":14,"address":[47186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[47237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[39472],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":18,"address":[59192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[59203,59244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[47325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[47424],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":27,"address":[47439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[47445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[40512,40528,39552],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":31,"address":[47672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[47678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[47712,48032],"length":1,"stats":{"Line":2},"fn_name":"combos"},{"line":42,"address":[47757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[61338,62266,61345,62016,62352,62273,60667,61930,60643,60699,61536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[47799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[39584],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":50,"address":[39619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[39652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[39669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[39632,40136,39719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[39744,39910],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[39884,40163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[39916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[39966,40188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[39985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[33584],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_STEPS=4\",\n\t\".#.#.#\",\n\t\"...##.\",\n\t\"#....#\",\n\t\"..#...\",\n\t\"#.#..#\",\n\t\"####..\"\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_STEPS=5\",\n\t\".#.#.#\",\n\t\"...##.\",\n\t\"#....#\",\n\t\"..#...\",\n\t\"#.#..#\",\n\t\"####..\"\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"17\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":26,"address":[33264,33268],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[64298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[64532,64357,64466,64409,64636,64319],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[33296,33300],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":33,"address":[64698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[64932,64719,65036,64809,64757,64866],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input  {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_steps: u32 = (\"NUM_STEPS=\", 100, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":18,"address":[76685],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","lib.rs"],"content":"//! Advent of Code 2015: Day 18: Like a GIF For Your Yard\n//!\n//! [https://adventofcode.com/2015/day/18](https://adventofcode.com/2015/day/18)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Like a GIF For Your Yard\";\n\tyear = 2015;\n\tday = 18;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[77233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[77601],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Grid;\nuse model::Light;\nuse model::Pos;\nuse nums::IntConv;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, |_| ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, |lights| {\n\t\tlights.set (Pos::new (lights.first_key ().y, lights.first_key ().x), Light::On);\n\t\tlights.set (Pos::new (lights.first_key ().y, lights.last_key ().x), Light::On);\n\t\tlights.set (Pos::new (lights.last_key ().y, lights.first_key ().x), Light::On);\n\t\tlights.set (Pos::new (lights.last_key ().y, lights.last_key ().x), Light::On);\n\t})\n}\n\nfn calc_result (\n\tinput: \u0026 Input,\n\toverride_fn: fn (\u0026 mut Grid),\n) -\u003e GenResult \u003cu32\u003e {\n\n\tif input.grid.size ().x \u003c 2 || input.grid.size ().y \u003c 2 {\n\t\treturn Err (\"Minimum grid size is 22\".into ());\n\t}\n\n\tlet mut lights = input.grid.clone ();\n\n\tlet offsets: Vec \u003c_\u003e =\n\t\tPos::ZERO.adjacent_8 ().iter ()\n\t\t\t.map (|\u0026 pos| lights.offset (pos).unwrap ())\n\t\t\t.collect ();\n\n\toverride_fn (\u0026 mut lights);\n\n\t// apply rules specified number of times\n\n\tfor _ in 0 .. input.params.num_steps {\n\t\tlights = lights.map (|cur| {\n\t\t\tlet num_adjacent =\n\t\t\t\toffsets.iter ()\n\t\t\t\t\t.filter_map (|\u0026 off| chk! (cur + off).ok ())\n\t\t\t\t\t.map (|cur| cur.get (\u0026 lights))\n\t\t\t\t\t.filter (|\u0026 light| matches! (light, Light::On))\n\t\t\t\t\t.count ();\n\t\t\tlet val = cur.get (\u0026 lights);\n\t\t\tlet on = matches! ((val, num_adjacent), (Light::On, 2) | (_, 3));\n\t\t\tif on { Light::On } else { Light::Off }\n\t\t});\n\t\toverride_fn (\u0026 mut lights);\n\t}\n\n\t// count active lights\n\n\tOk (\n\t\tlights.values ()\n\t\t\t.filter (|\u0026 val| matches! (val, Light::On))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n\n}\n","traces":[{"line":11,"address":[41424],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":15,"address":[42240],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[50064],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":17,"address":[50077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[50213],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[50341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[50573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[43053,42227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[42260,41444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[41943,42681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[42331,41513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[36194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[41606,41599,41846,42461,42429],"length":1,"stats":{"Line":5},"fn_name":null},{"line":45,"address":[42168,42641,41820,42997,41803],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[45703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[35463,35063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[40126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[51104],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":53,"address":[45791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[51120],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"}],"covered":16,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","model.rs"],"content":"//! Representation of the puzzle input, etc.\n\nuse super::*;\n\npub type Coord = i8;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Grid = GridBuf \u003cVec \u003cLight\u003e, Pos, 2\u003e;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Light {\n\t\t#[ default ]\n\t\tOff = [ \".\" ],\n\t\tOn = [ \"#\" ],\n\t}\n}\n","traces":[{"line":10,"address":[29712,33328,32377,30158,33344],"length":1,"stats":{"Line":6},"fn_name":"next\u003caoc_2015_day_18::model::Light\u003e"}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-19","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub replacements: Vec \u003c(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e)\u003e,\n\tpub medicine: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { replacements, medicine, params } = [\n\t\tparams,\n\t\t@lines replacements {\n\t\t\ttype = (InpStr, InpStr);\n\t\t\t(from, to) = [\n\t\t\t\t@str from = (|ch| { ch.is_ascii_alphabetic () }, 1 .. ),\n\t\t\t\t\" =\u003e \",\n\t\t\t\t@str to = (|ch| { ch.is_ascii_alphabetic () }, 1 .. ),\n\t\t\t],\n\t\t}, \"\\n\",\n\t\t\"\\n\",\n\t\tmedicine,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[36028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[53201],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-19","lib.rs"],"content":"//! Advent of Code 2015: Day 19: Medicine for Rudolph\n//!\n//! [https://adventofcode.com/2015/day/19](https://adventofcode.com/2015/day/19)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_list as list;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Medicine for Rudolph\";\n\tyear = 2015;\n\tday = 19;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"H =\u003e HO\",\n\t\t\"H =\u003e OH\",\n\t\t\"O =\u003e HH\",\n\t\t\"\",\n\t\t\"HOH\",\n\t];\n\n\tconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\t\"e =\u003e H\",\n\t\t\"e =\u003e O\",\n\t\t\"H =\u003e HO\",\n\t\t\"H =\u003e OH\",\n\t\t\"O =\u003e HH\",\n\t\t\"\",\n\t\t\"HOH\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE_ONE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE_TWO));\n\t}\n\n}\n","traces":[{"line":18,"address":[39842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[40226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[30352,30743],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":47,"address":[30362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[30596,30700,30473,30383,30421,30530],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[30752,31143],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":53,"address":[30762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[30930,30783,30996,31100,30873,30821],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-19","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse list::CharList;\nuse list::List;\n\n#[ allow (clippy::string_slice) ]\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut results = HashSet::new ();\n\tfor \u0026 (ref from, ref to) in input.replacements.iter () {\n\t\tlet mut last_pos = 0;\n\t\twhile let Some (pos) = input.medicine [last_pos .. ].find (\u0026 ** from) {\n\t\t\tlet pos = last_pos + pos;\n\t\t\tlet new_molecule = format! (\"{}{}{}\",\n\t\t\t\t\u0026 input.medicine [ .. pos],\n\t\t\t\tto,\n\t\t\t\t\u0026 input.medicine [pos + from.len () .. ],\n\t\t\t);\n\t\t\tresults.insert (new_molecule);\n\t\t\tlast_pos = pos + from.len ();\n\t\t}\n\t}\n\tOk (results.len ().pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\t// sanity checks\n\n\tif ! input.replacements.iter ().any (|\u0026 (ref from, _)| from == \"e\") {\n\t\tErr (\"Must have at least one replacement from \\\"e\\\"\") ?;\n\t}\n\n\tif input.medicine.len () \u003e 512 {\n\t\tErr (\"Medicine must be 512 chars or less\") ?;\n\t}\n\n\tif ! input.medicine.chars ().all (|ch| ch.is_ascii_alphanumeric ()) {\n\t\tErr (\"Medicine must be ASCII alphanumeric\") ?;\n\t}\n\n\tfor \u0026 (ref from, ref to) in input.replacements.iter () {\n\n\t\tif ! from.chars ().all (|ch| ch.is_ascii_alphanumeric ())\n\t\t\t\t|| ! to.chars ().all (|ch| ch.is_ascii_alphanumeric ()) {\n\t\t\tErr (\"All replacements must be ASCII alphanumeric\") ?;\n\t\t}\n\n\t\tif from.chars ()\n\t\t\t\t.filter (|ch| ch.is_ascii_uppercase () || ch.is_ascii_digit ())\n\t\t\t\t.count ()\n\t\t\t\u003e= to.chars ()\n\t\t\t\t.filter (|ch| ch.is_ascii_uppercase () || ch.is_ascii_digit ())\n\t\t\t\t.count () {\n\t\t\tErr (\"Replacements must always increase number of more ASCII uppercase/digits\") ?;\n\t\t}\n\n\t}\n\n\t// list of continuations to handle branching without recursion, and starting state\n\n\tlet mut todo: VecDeque \u003c(u32, List \u003cString\u003e, CharList)\u003e = VecDeque::new ();\n\ttodo.push_back ((0, List::new (), CharList::from (\u0026 * input.medicine)));\n\n\t// set of previous iterations to short circuit repeated evaluation of the same state\n\n\tlet mut seen: HashSet \u003c(List \u003cString\u003e, CharList)\u003e = HashSet::new ();\n\n\t// iterate over items from todo\n\n\tlet mut min_match = None;\n\t'OUTER: while let Some ((todo_steps, todo_prefix, todo_suffix)) = todo.pop_back () {\n\n\t\t// abort if it looks too complex, this is mostly to make fuzzing more practical\n\n\t\tif todo.len () \u003e= 1500 { Err (\"1500 states pending, giving up\") ?; }\n\t\tif seen.len () \u003e= 3000 { Err (\"3000 unique states seen, giving up\") ?; }\n\n\t\t// skip duplicated items\n\n\t\tif ! seen.insert ((todo_prefix.clone (), todo_suffix.clone ())) { continue }\n\n\t\t// output a message, disabled for now but could be added as a flag\n\n\t\tconst VERBOSE: bool = false;\n\t\t#[ allow (clippy::print_stdout) ]\n\t\tif VERBOSE {\n\t\t\tif todo_prefix.is_empty () {\n\t\t\t\tprintln! (\"queue={} steps={} {}\", todo.len (), todo_steps, todo_suffix);\n\t\t\t} else {\n\t\t\t\tprintln! (\"queue={} steps={} {} | {}\", todo.len (), todo_steps,\n\t\t\t\t\ttodo_prefix.iter ().join (\" | \"), todo_suffix);\n\t\t\t}\n\t\t}\n\n\t\t// add todo items for any replacements at the start of the suffix, also detect success\n\n\t\tfor \u0026 (ref from, ref to) in input.replacements.iter () {\n\t\t\tif from == \"e\" {\n\n\t\t\t\t// detect success\n\n\t\t\t\tif todo_prefix.is_empty () \u0026\u0026 ** to == todo_suffix {\n\t\t\t\t\t// TODO I am not entirely convinced that this is so simple, but I got the\n\t\t\t\t\t// right answer, so... I am /guessing/ that this has something to do with\n\t\t\t\t\t// this being an implementation of a greedy matcher, always trying to match\n\t\t\t\t\t// on the left first then recursing. But i would like to think about this a\n\t\t\t\t\t// bit more.\n\t\t\t\t\tmin_match = Some (todo_steps + 1);\n\t\t\t\t\tbreak 'OUTER;\n\t\t\t\t}\n\n\t\t\t\t// never reduce a partial match to \"e\", it's only valid if it replaces the\n\t\t\t\t// entire molecule\n\n\t\t\t} else if let Some (suffix) = todo_suffix.strip_prefix (to) {\n\t\t\t\tif todo_prefix.is_empty () {\n\n\t\t\t\t\t// no prefix: add the split with no prefix also\n\n\t\t\t\t\ttodo.push_back ((\n\t\t\t\t\t\ttodo_steps + 1,\n\t\t\t\t\t\tList::new (),\n\t\t\t\t\t\tsuffix.prepend (from),\n\t\t\t\t\t));\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// some prefix: continue with the last item removed\n\n\t\t\t\t\ttodo.push_back ((\n\t\t\t\t\t\ttodo_steps + 1,\n\t\t\t\t\t\ttodo_prefix.tail ().cloned ().unwrap (),\n\t\t\t\t\t\tsuffix.prepend (from)\n\t\t\t\t\t\t\t.prepend (todo_prefix.head ().unwrap ()),\n\t\t\t\t\t));\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// no match, carry on\n\t\t\t}\n\t\t}\n\n\t\t// add todo items for possible splits: at some point we have to match a replacement at\n\t\t// the start of the molecule, so we must be able to reduce some suffix of the current\n\t\t// molecule into something so that we can reduce the new combined prefix and suffix.\n\t\t// so, we iterate over prefixes but stop when our prefix is not itself a prefix of any\n\t\t// replacements, since we know that it can't possibly be reduced further whatever the\n\t\t// suffix changes into.\n\n\t\tlet mut prefix = String::new ();\n\t\tlet mut suffix = \u0026 todo_suffix;\n\t\twhile let Some ((\u0026 head, tail)) = suffix.cons () {\n\t\t\tprefix.push (head);\n\t\t\tsuffix = tail;\n\t\t\tif ! input.replacements.iter ().any (|\u0026 (_, ref to)| to.starts_with (\u0026 prefix)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttodo.push_back ((\n\t\t\t\ttodo_steps,\n\t\t\t\ttodo_prefix.with_push_front (prefix.clone ()),\n\t\t\t\tsuffix.clone (),\n\t\t\t));\n\t\t}\n\n\t}\n\n\t// return result or error\n\n\tOk (min_match.ok_or (\"No solution found\") ?)\n\n}\n","traces":[{"line":10,"address":[55696,56551],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[55930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[55984,56026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[56050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[56150,56282,56091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[56059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[56109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[56339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[56437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[56560,60748],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[56728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[56813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[52399,52368],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":44,"address":[57043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[52431,52400],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}"},{"line":47,"address":[52432,52463],"length":1,"stats":{"Line":1},"fn_name":"{closure#3}"},{"line":51,"address":[57454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[45545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[34553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[57682,60473,57711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[60389,58269,60246,58070,58029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[58322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[58334],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[60554,58387,58417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[58649,58624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[58717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[59379,58731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[60180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[58970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[58987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[59101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[59045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[59056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[59089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[59310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[58989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[59221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[59250,59290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[59457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[52553,52528],"length":1,"stats":{"Line":1},"fn_name":"{closure#6}"},{"line":161,"address":[59770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[59701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[59754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[58079,59956],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":44,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"1\" ]));\n\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"10\" ]));\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [ \"100\" ]));\n\tassert_eq_ok! (\"48\", puzzle.part_one (\u0026 [ \"1000\" ]));\n\tassert_eq_ok! (\"360\", puzzle.part_one (\u0026 [ \"10000\" ]));\n\tassert_eq_ok! (\"3120\", puzzle.part_one (\u0026 [ \"100000\" ]));\n\tassert_eq_ok! (\"27720\", puzzle.part_one (\u0026 [ \"1000000\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [ \"1\" ]));\n\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [ \"10\" ]));\n\tassert_eq_ok! (\"6\", puzzle.part_two (\u0026 [ \"100\" ]));\n\tassert_eq_ok! (\"36\", puzzle.part_two (\u0026 [ \"1000\" ]));\n\tassert_eq_ok! (\"336\", puzzle.part_two (\u0026 [ \"10000\" ]));\n\tassert_eq_ok! (\"2880\", puzzle.part_two (\u0026 [ \"100000\" ]));\n\tassert_eq_ok! (\"25200\", puzzle.part_two (\u0026 [ \"1000000\" ]));\n}\n","traces":[{"line":6,"address":[39156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[24513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[24534,24576,25507,24632,26631,25441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[24692,25636,24751,24654,26593,25575],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[24876,25704,24817,25765,24773,26552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[24942,25001,24898,25833,25894,26511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[25067,25962,25023,25126,26470,26023],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[25148,25251,26091,26429,26152,25192],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[26278,26217,26388,25376,25317,25273],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[28866,26688],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":19,"address":[26705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[26726,27633,28823,26824,26768,27699],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[27828,26943,26846,26884,27767,28785],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[27009,27896,27957,28744,26965,27068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[28703,28086,27090,27134,27193,28025],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[27259,28215,28154,27215,28662,27318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[27384,27443,27340,28283,28344,28621],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[27568,27509,28409,28470,27465,28580],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":18,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-20","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub target: Val,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { target, params } = [ params, target ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-20","lib.rs"],"content":"//! Advent of Code 2015: Day 20: Infinite Elves and Infinite Houses\n//!\n//! [https://adventofcode.com/2015/day/20](https://adventofcode.com/2015/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npub mod model {\n\tpub type Val = u32;\n}\n\npuzzle_info! {\n\tname = \"Infinite Elves and Infinite Houses\";\n\tyear = 2015;\n\tday = 20;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-20","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tOk (calc_result (input.target, 10, Val::MAX) ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tOk (calc_result (input.target, 11, 50) ?)\n}\n\npub fn calc_result (target: Val, mul: Val, lim: Val) -\u003e NumResult \u003cVal\u003e {\n\n\tlet mut divs = Vec::new ();\n\tlet mut extend_sqrt = Val::ONE;\n\tlet mut extend = Val::ONE;\n\n\tfor house in Val::ONE .. {\n\t\tlet mut total = Val::ZERO;\n\n\t\t// decrement all the values in `divs`, or if they are at zero then include the\n\t\t// corresponding \"elf\" and its complement in the total and reset to the elf's number\n\t\t// minus one\n\n\t\tlet mut div = Val::ZERO;\n\t\tfor next in divs.iter_mut () {\n\t\t\tdiv = Val::add_2 (div, Val::ONE) ?;\n\t\t\tif * next == Val::ZERO {\n\t\t\t\t* next = Val::sub_2 (div, 1) ?;\n\t\t\t\tlet comp =\n\t\t\t\t\tif div == Val::ONE { house }\n\t\t\t\t\telse if div == 2 { house \u003e\u003e 1_i32 }\n\t\t\t\t\telse { Val::div_2 (house, div) ? };\n\t\t\t\tif comp \u003c= lim {\n\t\t\t\t\ttotal = Val::add_2 (total, Val::mul_2 (div, mul) ?) ?;\n\t\t\t\t}\n\t\t\t\tif comp != div \u0026\u0026 div \u003c= lim {\n\t\t\t\t\ttotal = Val::add_2 (total, Val::mul_2 (comp, mul) ?) ?;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t* next = Val::sub_2 (* next, Val::ONE) ?;\n\t\t\t}\n\t\t}\n\n\t\t// once the house square root reaches a new integer we add it to divs, also we have to\n\t\t// include the corresponding elf in our total\n\n\t\tif house == extend {\n\t\t\tif divs.is_empty () {\n\t\t\t\tdivs.push (Val::ZERO);\n\t\t\t} else {\n\t\t\t\tdivs.push (Val::from_usize (divs.len ()) ?);\n\t\t\t}\n\t\t\ttotal = Val::add_2 (total, Val::mul_2 (extend_sqrt, mul) ?) ?;\n\t\t\textend_sqrt = Val::add_2 (extend_sqrt, Val::ONE) ?;\n\t\t\textend = Val::mul_2 (extend_sqrt, extend_sqrt) ?;\n\t\t}\n\n\t\t// return when we find a solution\n\n\t\tif total \u003e= target { return Ok (house) }\n\n\t}\n\n\tunreachable! ();\n\n}\n","traces":[{"line":8,"address":[23120],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":9,"address":[34593,34647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[23200],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":13,"address":[34881,34935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[24484,23280],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":30,"address":[23452],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[23485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[23520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[23586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[23611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[23660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[23681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[23745,23709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[23767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[23844,23808],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[23541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[23876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[23894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[23925,24404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[24062,24096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[24134,24312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[24176,24349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[24198],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLES: \u0026 [\u0026 [\u0026 str]] = \u0026 [\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 3\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 4\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 5\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 3\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 4\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 5\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 3\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 4\" ],\n\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 5\" ],\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"23\", puzzle.part_one (EXAMPLES [0]));\n\tassert_eq_ok! (\"38\", puzzle.part_one (EXAMPLES [1]));\n\tassert_eq_ok! (\"39\", puzzle.part_one (EXAMPLES [2]));\n\tassert_eq_ok! (\"38\", puzzle.part_one (EXAMPLES [3]));\n\tassert_eq_ok! (\"53\", puzzle.part_one (EXAMPLES [4]));\n\tassert_eq_ok! (\"59\", puzzle.part_one (EXAMPLES [5]));\n\tassert_eq_ok! (\"53\", puzzle.part_one (EXAMPLES [6]));\n\tassert_eq_ok! (\"71\", puzzle.part_one (EXAMPLES [7]));\n\tassert_eq_ok! (\"79\", puzzle.part_one (EXAMPLES [8]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"33\", puzzle.part_two (EXAMPLES [0]));\n\tassert_eq_ok! (\"58\", puzzle.part_two (EXAMPLES [1]));\n\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [2]));\n\tassert_eq_ok! (\"58\", puzzle.part_two (EXAMPLES [3]));\n\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [4]));\n\tassert_eq_ok! (\"133\", puzzle.part_two (EXAMPLES [5]));\n\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [6]));\n\tassert_eq_ok! (\"133\", puzzle.part_two (EXAMPLES [7]));\n\tassert_eq_ok! (\"158\", puzzle.part_two (EXAMPLES [8]));\n}\n","traces":[{"line":18,"address":[54644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[30001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[30022,30064,30120,31255,32721,31189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[32683,31384,30180,30142,30239,31323],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[32642,31513,30364,30261,31452,30305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[31642,32601,31581,30430,30386,30489],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[30511,31710,31771,32560,30555,30614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[30680,30636,30739,31839,31900,32519],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[31968,32478,30864,30761,30805,32029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[30886,32097,32437,32158,30930,30989],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[31055,32223,32396,31114,32284,31011],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[35564,32784],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":33,"address":[32801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[33989,34055,32920,32822,32864,35521],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[33039,32942,34123,35483,32980,34184],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[34313,33164,33061,34252,35442,33105],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[33230,33186,35401,34381,34442,33289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[33355,33414,34571,35360,34510,33311],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[33480,34700,35319,33436,33539,34639],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[33561,33605,35278,33664,34768,34829],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[33730,33789,34897,34958,33686,35237],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[33855,35196,33811,33914,35023,35084],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Stats;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub stats: Stats,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { stats, params } = [ params, stats ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","lib.rs"],"content":"//! Advent of Code 2015: Day 21: RPG Simulator 20XX\n//!\n//! [https://adventofcode.com/2015/day/21](https://adventofcode.com/2015/day/21)\n//!\n//! # Input\n//!\n//! Boss stats for a simple turn based fight game, including hit points, damage and armour. For\n//! example:\n//!\n//! ```text\n//! Hit Points: 100\n//! Damage: 10\n//! Armor: 5\n//! ```\n//!\n//! # Part one\n//!\n//! What is the smallest amount of \"gold\" the player can spend and still defeat this boss? They\n//! can choose to spend any combination of the following:\n//!\n//! * Exactly one of: damage `+4` for `8`, damage `+5` for `10`, damage `+6` for `25`, damage `+7`\n//!   for `40`, damage `+8` for `74`\n//! * Zero or one of: armour `+1` for `13`, armour `+2` for `31`, armour `+3` for `53`, armour\n//!   `+4` for `75`, armour `+5` for `102`.\n//! * Zero, one or two of: damage `+1` for `25`, damage `+2` for `50`, damage `+3` for `100`,\n//!   armour `+1` for `20`, armour `+2` for `40`, armour `+3` for `60`.\n//!\n//! To determine the winner the player and the boss take turns, player first, subtracting their\n//! total damage, minus the opponent's armour, from the opponent's hit points. If the amount to be\n//! subtracted is less than one then one is subtracted instead. The first party to reach zero hit\n//! points is the loser.\n//!\n//! # Part two\n//!\n//! Same as part one, but what is the *most* that can be spent which results in a loss for the\n//! player.\n//!\n//! # Algorithm\n//!\n//! We simplify the three types of item into a single table for each containing every option:\n//!\n//! * With exactly one option this list is the same\n//! * To make this optional we add a free option with no stats\n//! * We include zero items, similar to the previous item, plus each option alone, plus each\n//!   combination of two options.\n//!\n//! We then iterate over the cartesian product of these three dimensions working out the resulting\n//! stats and cost for the player. This is sorted according to the cost, in ascending order for\n//! part one and descending order for part two. Then we simulate the battle as described until we\n//! find a win for part one, or a lose for part two.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"RPG Simulator 20XX\";\n\tyear = 2015;\n\tday = 21;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":66,"address":[46756],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[47012],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Stats;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\titer_choices ()\n\t\t\t.sorted_by_key (|\u0026 (gold, _)| gold)\n\t\t\t.find (|\u0026 (_, player)| calc_outcome (player, input.stats))\n\t\t\t.map (|(gold, _)| gold)\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\titer_choices ()\n\t\t\t.sorted_by_key (|\u0026 (gold, _)| cmp::Reverse (gold))\n\t\t\t.find (|\u0026 (_, player)| ! calc_outcome (player, input.stats))\n\t\t\t.map (|(gold, _)| gold)\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\nfn iter_choices () -\u003e impl Iterator \u003cItem = (u32, Stats)\u003e {\n\tPLAYER_STATS [0].iter ()\n\t\t.cartesian_product (PLAYER_STATS [1].iter ())\n\t\t.cartesian_product (PLAYER_STATS [2].iter ())\n\t\t.map (|((\u0026 a, \u0026 b), \u0026 c)| (a, b, c))\n\t\t.map (|(\n\t\t\t\t(gld_0, dmg_0, arm_0),\n\t\t\t\t(gld_1, dmg_1, arm_1),\n\t\t\t\t(gld_2, dmg_2, arm_2),\n\t\t\t)| (\n\t\t\t\tgld_0 + gld_1 + gld_2,\n\t\t\t\tStats {\n\t\t\t\t\thit_points: 100,\n\t\t\t\t\tdamage: dmg_0 + dmg_1 + dmg_2,\n\t\t\t\t\tarmor: arm_0 + arm_1 + arm_2,\n\t\t\t\t},\n\t\t\t)\n\t\t)\n}\n\nconst fn calc_outcome (player: Stats, boss: Stats) -\u003e bool {\n\n\tlet mut player_hp = player.hit_points;\n\tlet mut boss_hp = boss.hit_points;\n\n\tlet player_attack = if player.damage \u003e boss.armor {\n\t\tplayer.damage - boss.armor\n\t} else { 1 };\n\n\tlet boss_attack = if boss.damage \u003e player.armor {\n\t\tboss.damage - player.armor\n\t} else { 1 };\n\n\tloop {\n\n\t\tif boss_hp \u003c= player_attack { return true }\n\t\tboss_hp -= player_attack;\n\n\t\tif player_hp \u003c= boss_attack { return false }\n\t\tplayer_hp -= boss_attack;\n\n\t}\n\n}\n\nconst PLAYER_STATS: \u0026 [\u0026 [(u32, u32, u32)]] = \u0026 [\n\n\t// weapons\n\t\u0026 [ (8, 4, 0), (10, 5, 0), (25, 6, 0), (40, 7, 0), (74, 8, 0) ],\n\n\t// armor\n\t\u0026 [ (0, 0, 0), (13, 0, 1), (31, 0, 2), (53, 0, 3), (75, 0, 4), (102, 0, 5) ],\n\n\t// rings\n\t\u0026 [\n\t\t(0, 0, 0), (25, 1, 0), (50, 2, 0), (100, 3, 0), (20, 0, 1), (40, 0, 2), (80, 0, 3),\n\t\t(75, 3, 0), (125, 4, 0), (45, 1, 1), (65, 1, 2), (105, 1, 3), (150, 5, 0), (70, 2, 1),\n\t\t(90, 2, 2), (130, 2, 3), (120, 3, 1), (140, 3, 2), (180, 3, 3), (60, 0, 3),\n\t\t(100, 0, 4), (120, 0, 5),\n\t],\n\n];\n","traces":[{"line":8,"address":[45344,45754],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[45669,45523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[52995,51539,52880,51930,50630,50606,50678,52039,51328],"length":1,"stats":{"Line":6},"fn_name":null},{"line":12,"address":[42995,42960,42980],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c(u32, aoc_2015_day_21::model::Stats), aoc_2015_day_21::logic::part_one::{closure_env#1}\u003e"},{"line":13,"address":[54224],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":18,"address":[46189,45776],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[45955,46104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[54240],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":22,"address":[42564,42544,42579],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c(u32, aoc_2015_day_21::model::Stats), aoc_2015_day_21::logic::part_two::{closure_env#1}\u003e"},{"line":23,"address":[54320],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":32,"address":[48039],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[53303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[53323,53267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[53339,53280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[53355,53293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[46208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[46231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[42551,42967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[42568,42984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[42997,42581],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","model.rs"],"content":"//! Data structures and types\n\nuse super::*;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Stats {\n\tpub hit_points: u32,\n\tpub damage: u32,\n\tpub armor: u32,\n}\n\nstruct_parser_display! {\n\tStats { hit_points, damage, armor } = [\n\t\t\"Hit Points: \", hit_points, \"\\n\",\n\t\t\"Damage: \", damage, \"\\n\",\n\t\t\"Armor: \", armor,\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"491\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"787\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"1249\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"734\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"900\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"1269\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"754\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 10\" ]));\n\tassert_eq_ok! (\"900\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 10\" ]));\n\tassert_eq_ok! (\"1309\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 10\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"734\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"900\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"1309\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 8\" ]));\n\tassert_eq_ok! (\"754\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"920\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"1309\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 9\" ]));\n\tassert_eq_ok! (\"794\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 10\" ]));\n\tassert_eq_ok! (\"1256\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 10\" ]));\n\tassert_eq_ok! (\"1442\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 10\" ]));\n}\n","traces":[{"line":6,"address":[55936,55940],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":7,"address":[37329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[38583,40049,37350,37448,37392,38517],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[37567,40011,38712,37470,38651,37508],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[39970,37692,38780,37589,37633,38841],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[38970,37817,37758,38909,39929,37714],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[39099,39888,37942,37883,39038,37839],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[38067,39847,39228,39167,37964,38008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[38089,38192,38133,39296,39357,39806],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[38214,39486,38317,38258,39425,39765],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[39551,38339,38383,38442,39724,39612],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[22884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[40129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[40150,40248,41383,42849,41317,40192],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[42811,40270,40367,41451,40308,41512],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[40492,41641,40389,40433,42770,41580],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[40617,41770,40514,41709,40558,42729],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[40639,40742,41838,40683,41899,42688],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[42647,40764,40808,41967,40867,42028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[40933,42157,42606,42096,40992,40889],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[42565,41014,41058,42286,42225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[41242,42412,42524,42351,41139,41183],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":22,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Boss;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub boss: Boss,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { boss, params } = [ params, boss ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","lib.rs"],"content":"//! Advent of Code 2015: Day 22: Wizard Simulator 20XX\n//!\n//! [https://adventofcode.com/2015/day/22](https://adventofcode.com/2015/day/22)\n//!\n//! # Input\n//!\n//! Boss stats for a simple deterministic turn-based battle, inlcuding hit points and damage. For\n//! example:\n//!\n//! ```text\n//! Hit Points: 100\n//! Damage: 10\n//! ```\n//!\n//! # Part one\n//!\n//! Work out the minimum amount of \"mana\" that can be spent to win the battle. In the battle each\n//! participant takes turns, starting with the player. The player must choose one of five spells\n//! to cast, or loses immediately if they don't have sufficient mana. The options are:\n//!\n//! * Spend `53` mana to cause `4` damage.\n//! * Spend `73` mana to cause `2` damage and to heal `2` hit points.\n//! * Spend `113` mana to increase the player's armour by `7` for six turns (three attacks).\n//! * Spend `173` mana to cause `3` damage at the start of the next six turns.\n//! * Spend `229` mana to gain `101` mana at the start of the next five turns.\n//!\n//! The multi-turn spells cannot be repeated until their effect has worn off. When it is the\n//! boss's turn they will cause the amount of damage indicated in the puzzle input. Damage is\n//! subtracted from the opponent's hit points, minus any amour from the player's spell, or one is\n//! subtracted if the amount would be less.\n//!\n//! The first participant to reach zero hit points loses, or the player if they have no mana left\n//! to cast any spell.\n//!\n//! # Part two\n//!\n//! Same as part one but the player loses one hit point at the very start of every turn.\n//!\n//! # Algorithm\n//!\n//! This uses a [`PrioritySearch`] with the amount of mana spent as the priority. Each node is\n//! a combination of the player and boss's stats, the spells which are continuing to have an\n//! effect and for how long, and whose turn it is. The total amount of mana spent is the distance\n//! or priority.\n//!\n//! To work out the next state, we take the existing state and apply any effects. If it is the\n//! player's turn, we then add a node for every spell which can be cast, or set hit points to zero\n//! if we can't cast a spell. For the boss's turn there is only one type of attack so we simply\n//! apply that.\n//!\n//! The first state we encounter which shows the player winning is the one which spends the least\n//! amount of mana, since we use that as our priority.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_search::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Wizard Simulator 20XX\";\n\tyear = 2015;\n\tday = 22;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Boss;\nuse model::Player;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcalc_result (Player::default (), input.boss, Difficulty::Easy)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcalc_result (Player::default (), input.boss, Difficulty::Hard)\n}\n\nfn calc_result (player: Player, boss: Boss, difficulty: Difficulty) -\u003e GenResult \u003cu16\u003e {\n\toutcomes (player, boss, difficulty)\n\t\t.filter (|outcome| outcome.winner == Contender::Player)\n\t\t.map (|outcome| outcome.mana)\n\t\t.next ()\n\t\t.ok_or (\"No solution found\".into ())\n}\n\nfn outcomes (\n\tplayer: Player,\n\tboss: Boss,\n\tdifficulty: Difficulty,\n) -\u003e impl Iterator \u003cItem = Outcome\u003e {\n\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|state: State, _, mut adder: PrioritySearchAdder \u003c'_, _, _, _\u003e|\n\t\t\tmatch (state.player.hit_points != 0, state.boss.hit_points != 0) {\n\t\t\t\t(true, false) =\u003e Some (Outcome { winner: Contender::Player, mana: state.mana }),\n\t\t\t\t(false, true) =\u003e Some (Outcome { winner: Contender::Boss, mana: state.mana }),\n\t\t\t\t(true, true) =\u003e {\n\t\t\t\t\tfor next_state in next_states (state) {\n\t\t\t\t\t\tadder.add (next_state, next_state.mana);\n\t\t\t\t\t}\n\t\t\t\t\tNone\n\t\t\t\t},\n\t\t\t\t(false, false) =\u003e unreachable! (),\n\t\t\t});\n\n\tsearch.push (State {\n\t\tplayer,\n\t\tboss,\n\t\teffects: Effects { shield: 0, poison: 0, recharge: 0 },\n\t\tturn: Contender::Player,\n\t\tdifficulty,\n\t\tmana: 0,\n\t}, 0);\n\n\tsearch.flatten ()\n\n}\n\nfn next_states (mut state: State) -\u003e ArrayVec \u003cState, 5\u003e {\n\n\tif state.effects.shield \u003e 0 {\n\t\tstate.effects.shield -= 1;\n\t}\n\n\tif state.effects.poison \u003e 0 {\n\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 3);\n\t\tif state.boss.hit_points == 0 { return array_vec! [ state ] }\n\t\tstate.effects.poison -= 1;\n\t}\n\n\tif state.effects.recharge \u003e 0 {\n\t\tstate.player.mana += 101;\n\t\tstate.effects.recharge -= 1;\n\t}\n\n\tif state.turn == Contender::Player {\n\n\t\tstate.turn = Contender::Boss;\n\n\t\tif state.player.mana \u003c 53 {\n\t\t\tstate.player.hit_points = 0;\n\t\t\treturn array_vec! [ state ];\n\t\t}\n\n\t\tif state.difficulty == Difficulty::Hard {\n\t\t\tstate.player.hit_points -= 1;\n\t\t\tif state.player.hit_points == 0 {\n\t\t\t\treturn array_vec! [ state ];\n\t\t\t}\n\t\t}\n\n\t\tlet mut results = ArrayVec::new ();\n\n\t\tif state.player.mana \u003e= 53 {\n\t\t\tlet mut state = state;\n\t\t\tstate.player.mana -= 53;\n\t\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 4);\n\t\t\tstate.mana += 53;\n\t\t\tresults.push (state);\n\t\t}\n\n\t\tif state.player.mana \u003e= 73 {\n\t\t\tlet mut state = state;\n\t\t\tstate.player.hit_points += 2;\n\t\t\tstate.player.mana -= 73;\n\t\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 2);\n\t\t\tstate.mana += 73;\n\t\t\tresults.push (state);\n\t\t}\n\n\t\tif state.player.mana \u003e= 113 \u0026\u0026 state.effects.shield == 0 {\n\t\t\tlet mut state = state;\n\t\t\tstate.player.mana -= 113;\n\t\t\tstate.effects.shield = 6;\n\t\t\tstate.mana += 113;\n\t\t\tresults.push (state);\n\t\t}\n\n\t\tif state.player.mana \u003e= 173 \u0026\u0026 state.effects.poison == 0 {\n\t\t\tlet mut state = state;\n\t\t\tstate.player.mana -= 173;\n\t\t\tstate.effects.poison = 6;\n\t\t\tstate.mana += 173;\n\t\t\tresults.push (state);\n\t\t}\n\n\t\tif state.player.mana \u003e= 229 \u0026\u0026 state.effects.recharge == 0 {\n\t\t\tlet mut state = state;\n\t\t\tstate.player.mana -= 229;\n\t\t\tstate.effects.recharge = 5;\n\t\t\tstate.mana += 229;\n\t\t\tresults.push (state);\n\t\t}\n\n\t\tresults\n\n\t} else {\n\n\t\tstate.turn = Contender::Player;\n\n\t\tlet armor = if state.effects.shield \u003e 0 { 7 } else { 0 };\n\t\tlet attack = if state.boss.damage \u003c= armor { 1 } else { state.boss.damage - armor };\n\t\tstate.player.hit_points -= cmp::min (state.player.hit_points, attack);\n\t\tarray_vec! [ state ]\n\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct Outcome {\n\twinner: Contender,\n\tmana: u16,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct Effects {\n\tshield: u8,\n\tpoison: u8,\n\trecharge: u8,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct State {\n\tplayer: Player,\n\tboss: Boss,\n\teffects: Effects,\n\tturn: Contender,\n\tdifficulty: Difficulty,\n\tmana: u16,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum Contender { Player, Boss }\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum Difficulty { Easy, Hard }\n","traces":[{"line":9,"address":[30240],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":10,"address":[30244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[30288],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":14,"address":[30292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[30929,30336],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":22,"address":[30765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[30898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[56773,56288],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":33,"address":[56605,56310],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[56617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[56609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[56758,56541,56342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[56552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[56700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[30654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[30944,32710],"length":1,"stats":{"Line":2},"fn_name":"next_states"},{"line":60,"address":[30964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[30972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[30978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[32176,30987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[31018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[32251,31024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[31037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[32192,31046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[32219,31066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[31083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[31151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[31156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[31167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[31237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[32302,31239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[31256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[31266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[31291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[31339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[31352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[31446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[31456],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[31461],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[31473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[31504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[31528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[31546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[31649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[31682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[31670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[31687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[31707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[31805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[31857],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[31850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[31835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[31980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[31999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[32010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[32027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[32122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[31085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[31092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[31105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[31123,32235],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":57,"coverable":61},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","model.rs"],"content":"//! Representation of the puzzle input, etc.\n\nuse super::*;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Player {\n\tpub hit_points: u8,\n\tpub mana: u16,\n}\n\nimpl Default for Player {\n\tfn default () -\u003e Self {\n\t\tSelf {\n\t\t\thit_points: 50,\n\t\t\tmana: 500,\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Boss {\n\tpub hit_points: u8,\n\tpub damage: u8,\n}\n\nstruct_parser_display! {\n\tBoss { hit_points, damage } = [\n\t\t\"Hit Points: \", hit_points = 1 ..= 100, \"\\n\",\n\t\t\"Damage: \", damage = 1 ..= 15,\n\t]\n}\n","traces":[{"line":12,"address":[52496],"length":1,"stats":{"Line":0},"fn_name":"default"}],"covered":0,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"jio a, +5\",\n\t\"inc a\",\n\t\"tpl a\",\n\t\"tpl a\",\n\t\"jmp +3\",\n\t\"inc a\",\n\t\"tpl a\",\n\t\"jio a, +4\",\n\t\"hlf a\",\n\t\"inc b\",\n\t\"jmp -3\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":20,"address":[38884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[59978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[60089,60212,60037,59999,60146,60316],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[38692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[60378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[60437,60716,60489,60546,60612,60399],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[36052],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","lib.rs"],"content":"//! Advent of Code 2015: Day 23: Opening the Turing Lock\n//!\n//! [https://adventofcode.com/2015/day/23](https://adventofcode.com/2015/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Opening the Turing Lock\";\n\tyear = 2015;\n\tday = 23;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse model::Instr;\nuse model::Reg;\nuse model::Val;\nuse nums::Int;\nuse nums::IntConv;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet (_, reg_b) = emulate (input, 0, 0, 0, 0x10000) ?;\n\tOk (reg_b)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet (_, reg_b) = emulate (input, 1, 0, 0, 0x10000) ?;\n\tOk (reg_b)\n}\n\nfn emulate (\n\tinput: \u0026 Input,\n\tmut reg_a: Val,\n\tmut reg_b: Val,\n\tmut next: Val,\n\tmut max_loops: usize,\n) -\u003e Result \u003c(Val, Val), EmulateError\u003e {\n\n\t// main loop\n\n\tlet mut seen = HashSet::new ();\n\tlet instrs_len = Val::from_usize (input.instrs.len ()) ?;\n\twhile next \u003c instrs_len {\n\n\t\t// abort when we reach max_loops\n\n\t\tif max_loops == 0 { return Err (EmulateError::MaxLoops) }\n\t\tmax_loops -= 1;\n\n\t\t// detect infinite loops and abort\n\n\t\tif ! seen.insert ((reg_a, reg_b, next)) { return Err (EmulateError::InfiniteLoop) }\n\n\t\t// execute next instruction\n\n\t\tlet instr = input.instrs [next.pan_usize ()];\n\t\tmatch instr {\n\t\t\tInstr::Hlf (Reg::A) =\u003e reg_a /= 2,\n\t\t\tInstr::Hlf (Reg::B) =\u003e reg_b /= 2,\n\t\t\tInstr::Tpl (Reg::A) =\u003e reg_a = chk! (reg_a * 3) ?,\n\t\t\tInstr::Tpl (Reg::B) =\u003e reg_b = chk! (reg_b * 3) ?,\n\t\t\tInstr::Inc (Reg::A) =\u003e reg_a = chk! (reg_a + 1_u32) ?,\n\t\t\tInstr::Inc (Reg::B) =\u003e reg_b = chk! (reg_b + 1_u32) ?,\n\t\t\tInstr::Jmp (offset) =\u003e { next = next.add_signed (offset) ?; continue },\n\t\t\tInstr::Jie (Reg::A, offset) =\u003e {\n\t\t\t\tif reg_a \u0026 1 == 0 { next = next.add_signed (offset) ?; continue }\n\t\t\t},\n\t\t\tInstr::Jie (Reg::B, offset) =\u003e {\n\t\t\t\tif reg_b \u0026 1 == 0 { next = next.add_signed (offset) ?; continue }\n\t\t\t},\n\t\t\tInstr::Jio (Reg::A, offset) =\u003e {\n\t\t\t\tif reg_a == 1 { next = next.add_signed (offset) ?; continue }\n\t\t\t},\n\t\t\tInstr::Jio (Reg::B, offset) =\u003e {\n\t\t\t\tif reg_b == 1 { next = next.add_signed (offset) ?; continue }\n\t\t\t},\n\t\t}\n\n\t\t// move to next instruction, jump instructions skip this bit\n\n\t\tchk! (next += 1_u32) ?;\n\n\t}\n\n\t// return the two registers\n\n\tOk ((reg_a, reg_b))\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\nenum EmulateError {\n\tInfiniteLoop,\n\tOverflow,\n\tMaxLoops,\n}\n\nimpl Error for EmulateError {\n}\n\nimpl From \u003cOverflow\u003e for EmulateError {\n\tfn from (_: Overflow) -\u003e Self {\n\t\tSelf::Overflow\n\t}\n}\n\nimpl Display for EmulateError {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::InfiniteLoop =\u003e write! (formatter, \"Infinite loop\") ?,\n\t\t\tSelf::Overflow =\u003e write! (formatter, \"Arithmetic overflow\") ?,\n\t\t\tSelf::MaxLoops =\u003e write! (formatter, \"Max loops reached\") ?,\n\t\t}\n\t\tOk (())\n\t}\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn emulate () {\n\t\tuse input::InputParams;\n\t\tuse Instr::*;\n\t\tuse Reg::*;\n\t\tfn emul (instrs: impl IntoIterator \u003cItem = Instr\u003e) -\u003e Result \u003c(Val, Val), EmulateError\u003e {\n\t\t\tlogic::emulate (\n\t\t\t\t\u0026 Input {\n\t\t\t\t\tinstrs: instrs.into_iter ().collect (),\n\t\t\t\t\tparams: InputParams::default (),\n\t\t\t\t},\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t100)\n\t\t}\n\t\t// inc, hlf, tpl\n\t\tassert_eq_ok! ((2, 0), emul ([ Inc (A), Tpl (A), Inc (A), Hlf (A) ]));\n\t\tassert_eq_ok! ((0, 2), emul ([ Inc (B), Tpl (B), Inc (B), Hlf (B) ]));\n\t\t// jmp\n\t\tassert_eq_ok! ((1, 1), emul ([ Inc (A), Jmp (2), Tpl (A), Inc (B) ]));\n\t\t// jio\n\t\tassert_eq_ok! ((1, 1), emul ([ Inc (A), Jio (A, 2), Inc (B), Inc (B) ]));\n\t\tassert_eq_ok! ((0, 2), emul ([ Jio (A, 2), Inc (B), Inc (B) ]));\n\t\tassert_eq_ok! ((1, 1), emul ([ Inc (B), Jio (B, 2), Inc (A), Inc (A) ]));\n\t\tassert_eq_ok! ((2, 0), emul ([ Jio (B, 2), Inc (A), Inc (A) ]));\n\t\t// jie\n\t\tassert_eq_ok! ((1, 2), emul ([ Inc (A), Jie (A, 2), Inc (B), Inc (B) ]));\n\t\tassert_eq_ok! ((0, 1), emul ([ Jie (A, 2), Inc (B), Inc (B) ]));\n\t\tassert_eq_ok! ((2, 1), emul ([ Inc (B), Jie (B, 2), Inc (A), Inc (A) ]));\n\t\tassert_eq_ok! ((1, 0), emul ([ Jie (B, 2), Inc (A), Inc (A) ]));\n\t\t// errors\n\t\tassert_err! (\"Infinite loop\", emul ([ Jmp (0) ]));\n\t\tassert_err! (\"Max loops reached\", emul ([ Inc (A), Jmp (-1) ]));\n\t\tassert_err! (\"Arithmetic overflow\", emul ([ Inc (A), Tpl (A), Jmp (-1) ]));\n\t}\n\n}\n","traces":[{"line":12,"address":[43360],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":13,"address":[43397,43374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[43457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[43504],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[43544,43518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[43604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[43648,44908],"length":1,"stats":{"Line":1},"fn_name":"emulate"},{"line":33,"address":[43818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[44780,44555,43914],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[43971,44833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[44019,44847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[44104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[44304,44208,44586,44571,44623],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[44576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[44665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[28656,28688],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":52,"address":[28720,28752],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":53,"address":[28800,28784],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":54,"address":[28816,28832],"length":1,"stats":{"Line":1},"fn_name":"{closure#3}"},{"line":55,"address":[44179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[44317,44372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[44519,44459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[44221,44276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[44392,44447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[28848],"length":1,"stats":{"Line":1},"fn_name":"{closure#4}"},{"line":78,"address":[44798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[44928],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":99,"address":[44944],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":100,"address":[44951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[45123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[45024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[45218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[36116,36112],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":119,"address":[36144,36288,36419,36269,36432,36560,36676,36551],"length":1,"stats":{"Line":0},"fn_name":"emul\u003c[aoc_2015_day_23::model::Instr; 4]\u003e"},{"line":131,"address":[45465,47916,47977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[48017,48078,45615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[48118,48179,45780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[48219,48280,45951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[48320,46115,48381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[48482,46285,48421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[48583,48522,46449],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[46619,48684,48623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[48785,48724,46783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[48825,46953,48886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[47117,48981,48920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[49079,49739,47259,47381],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[49699,47508,47630,49157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[49248,49659,47764,47886],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":44,"coverable":48},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","model.rs"],"content":"//! Representation of the puzzle input, etc.\n\nuse super::*;\n\npub type Val = u32;\npub type Offset = i32;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Instr {\n\t\tHlf (reg: Reg) = [ \"hlf \", reg ],\n\t\tTpl (reg: Reg) = [ \"tpl \", reg ],\n\t\tInc (reg: Reg) = [ \"inc \", reg ],\n\t\tJmp (off: Offset) = [ \"jmp \", off ],\n\t\tJie (reg: Reg, off: Offset) = [ \"jie \", reg, \", \", off ],\n\t\tJio (reg: Reg, off: Offset) = [ \"jio \", reg, \", \", off ],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Reg {\n\t\tA = [ \"a\" ],\n\t\tB = [ \"b\" ],\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-24","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"1\", \"2\", \"3\", \"4\", \"5\", \"7\", \"8\", \"9\", \"10\", \"11\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"99\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"44\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-24","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub weights: Vec \u003cu32\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { weights, params } = [ params, @lines weights ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-24","lib.rs"],"content":"//! Advent of Code 2015: Day 24: It Hangs in the Balance\n//!\n//! [https://adventofcode.com/2015/day/24](https://adventofcode.com/2015/day/24)\n//!\n//! # Input\n//!\n//! Each line contains a decimal integer, representing the weight of a single package.\n//!\n//! # Part one\n//!\n//! Split the packages into three piles of equal weight. Optimise so that one pile has the fewest\n//! possible number of packages. Further optimize so that the product of the weights of the\n//! packages in the first pile is as small as possible. Produce that product as a result.\n//!\n//! # Part two\n//!\n//! The same as part one, but with four piles instead of three.\n//!\n//! # Algorithm\n//!\n//! - Iteratively build up a list of items to assign to each pile, always in order from heavier to\n//!   lighter. This ensures that we find a solution with the smallest possible number of packages\n//!   in the first pile before any other.\n//! - Once we find a solution for all three piles, record the size and product of the first pile,\n//!   and only consider solutions with a first pile which would signify an improvement.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"It Hangs in the Balance\";\n\tyear = 2015;\n\tday = 24;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-24","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\nuse nums::Int;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result::\u003c3\u003e (input)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result::\u003c4\u003e (input)\n}\n\nfn calc_result \u003cconst PILES: usize\u003e (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\n\t// make sure the weights are in reverse order\n\n\tlet weights: Vec \u003cu32\u003e =\n\t\tinput.weights.iter ().copied ()\n\t\t\t.sorted_by_key (|\u0026 weight| cmp::Reverse (weight))\n\t\t\t.collect ();\n\n\t// sanity check (mainly for fuzzing)\n\n\tif weights.len () \u003e 50 {\n\t\tErr (\"Refusing to deal with more than 50 items\") ?;\n\t}\n\n\tif weights.iter ().dedup ().count () != weights.len () {\n\t\tErr (\"Refusing to deal with duplicated weights\") ?;\n\t}\n\n\tif weights.iter ().copied ().any (|weight| weight \u003e 200) {\n\t\tErr (\"Refusing to deal with weights over 200\") ?;\n\t}\n\n\t// work out the balanced weight of each pile\n\n\tlet total_weight: u32 =\n\t\tweights.iter ().copied ()\n\t\t\t.fold (Ok (0), |sum, item| sum\n\t\t\t\t.and_then (|sum| u32::add_2 (sum, item))) ?;\n\tlet want_pile_weight = total_weight / PILES.pan_u32 ();\n\tif want_pile_weight * PILES.pan_u32 () != total_weight {\n\t\tErr (format! (\"Total weight is not a multiple of {}\", PILES)) ?;\n\t}\n\n\t// once we find one solution we can rule out any first piles which are bigger or have a\n\t// higher quantum entanglement\n\n\tlet mut max_len_0 = usize::MAX;\n\tlet mut max_quantum_0 = u64::MAX;\n\n\t// stack holds a list of piles and the indexes of their contents\n\n\tlet mut stack: Vec \u003cVec \u003cusize\u003e\u003e = vec! [ vec! [] ];\n\n\t// todo holds continuations, first value is number of piles to retain, second is number of\n\t// items in top pile, third is new index to push to top pile, for initial state we have a\n\t// single pile and branch for the full list of weights as the next item in it\n\n\tlet mut todo: Vec \u003c(usize, usize, usize)\u003e =\n\t\t(0 .. weights.len ())\n\t\t\t.rev ()\n\t\t\t.map (|idx| (1, 0, idx))\n\t\t\t.collect ();\n\n\t// iterate through continuations, shortcircuit allows us to quickly get back to the first\n\t// pile when we find a new solution, because we don't really care about the other piles, so\n\t// long as we know there's at least one solution for them\n\n\tlet mut shortcircuit = false;\n\twhile let Some ((trunc_0, trunc_1, idx)) = todo.pop () {\n\t\tif shortcircuit \u0026\u0026 trunc_0 \u003e 1 { continue }\n\t\tshortcircuit = false;\n\n\t\t// truncate the number of piles according to the continuation\n\n\t\tstack.truncate (trunc_0);\n\n\t\t// truncate the items in the top pile according to the continuation\n\n\t\tlet pile_stack = stack.last_mut ().unwrap ();\n\t\tpile_stack.truncate (trunc_1);\n\n\t\t// add on the next item from the continuation\n\n\t\tpile_stack.push (idx);\n\t\tlet pile_stack_len = pile_stack.len ();\n\n\t\t// work out the top pile's weight, abort if it is too heavy\n\n\t\tlet pile_weight: u32 =\n\t\t\tpile_stack.iter ().copied ().map (|idx| weights [idx]).sum ();\n\t\tif pile_weight \u003e want_pile_weight { continue }\n\n\t\t// for the first pile only, check the quantum and abort if it's already too high\n\n\t\tif stack.len () == 1 {\n\t\t\tif max_len_0 \u003c stack [0].len () { continue }\n\t\t\tlet quantum_0 =\n\t\t\t\tstack [0].iter ().copied ()\n\t\t\t\t\t.map (|idx| weights [idx].pan_u64 ())\n\t\t\t\t\t.fold (Ok (1), |prod, item| prod\n\t\t\t\t\t\t.and_then (|prod| u64::mul_2 (prod, item))) ?;\n\t\t\tif max_quantum_0 \u003c= quantum_0 { continue }\n\t\t}\n\n\t\t// if this pile is now the right weight we start the next pile, or record a solution if\n\t\t// this is the last pile\n\n\t\tif pile_weight == want_pile_weight {\n\t\t\tif stack.len () \u003c PILES {\n\t\t\t\tstack.push (vec! []);\n\t\t\t\tfor idx in (0 .. weights.len ()).rev () {\n\t\t\t\t\tif stack.iter ()\n\t\t\t\t\t\t.any (|pile_stack| pile_stack.iter ().copied ()\n\t\t\t\t\t\t\t.any (|existing_idx| idx == existing_idx))\n\t\t\t\t\t\t{ continue }\n\t\t\t\t\ttodo.push ((stack.len (), 0, idx));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax_len_0 = stack [0].len ();\n\t\t\t\tmax_quantum_0 =\n\t\t\t\t\tstack [0].iter ().copied ()\n\t\t\t\t\t\t.map (|idx| weights [idx].pan_u64 ())\n\t\t\t\t\t\t.fold (Ok (1), |prod, item| prod\n\t\t\t\t\t\t\t.and_then (|prod| u64::mul_2 (prod, item))) ?;\n\t\t\t\tshortcircuit = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// branch out for every possible next weight to add to the top pile\n\n\t\tlet min_idx =\n\t\t\tstack.last ().unwrap ().iter ().copied ()\n\t\t\t\t.map (|idx| idx + 1).max ().unwrap_or (0);\n\t\tfor idx in (min_idx .. weights.len ()).rev () {\n\t\t\tif stack.iter ()\n\t\t\t\t.any (|pile_stack| pile_stack.iter ().copied ()\n\t\t\t\t\t.any (|existing_idx| idx == existing_idx))\n\t\t\t\t{ continue }\n\t\t\ttodo.push ((stack.len (), pile_stack_len, idx));\n\t\t}\n\n\t}\n\n\tif max_quantum_0 == u64::MAX { Err (\"No solution found\") ?; }\n\tOk (max_quantum_0)\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tuse input::InputParams;\n\n\t#[ test ]\n\tfn calc_result () {\n\t\tfn invoke \u003cconst PIL: usize\u003e (weights: impl IntoIterator \u003cItem = u32\u003e) -\u003e GenResult \u003cu64\u003e {\n\t\t\tlet input = Input {\n\t\t\t\tweights: weights.into_iter ().collect (),\n\t\t\t\tparams: InputParams::default (),\n\t\t\t};\n\t\t\tlogic::calc_result::\u003cPIL\u003e (\u0026 input)\n\t\t}\n\t\tassert_eq_ok! (5, invoke::\u003c3\u003e (1 ..= 5));\n\t\tassert_err! (\"No solution found\", invoke::\u003c3\u003e (1 ..= 3));\n\t\tassert_err! (\"Refusing to deal with more than 50 items\", invoke::\u003c3\u003e (0 ..= 50));\n\t\tassert_err! (\"Refusing to deal with duplicated weights\", invoke::\u003c3\u003e ([ 1, 1, 1 ]));\n\t\tassert_err! (\"Total weight is not a multiple of 3\", invoke::\u003c3\u003e ([ 1, 2, 3, 4 ]));\n\t}\n\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[39476,37920],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":165,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":172,"address":[38888,37957,37973,38825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[38052,38975,38176,39400,38025,39425],"length":1,"stats":{"Line":3},"fn_name":null},{"line":174,"address":[38231,39036,39378,38382,39353,38258],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[39331,38420,38591,39097,39306,38467],"length":1,"stats":{"Line":3},"fn_name":null},{"line":176,"address":[38665,38619,38789,39184,39281],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":51,"coverable":81},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-25","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub row: u64,\n\tpub col: u64,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { row, col, params } = [\n\t\tparams,\n\t\t\"To continue, please consult the code grid in the manual.  Enter the code at row \",\n\t\trow = (1 .. ), \", column \",\n\t\tcol = (1 .. ), \".\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-25","lib.rs"],"content":"//! Advent of Code 2015: Day 25: Let It Snow\n//!\n//! [https://adventofcode.com/2015/day/25](https://adventofcode.com/2015/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Let It Snow\";\n\tyear = 2015;\n\tday = 25;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tmacro_rules! ex {\n\t\t\t($row:literal, $col_1:literal, $col_2:literal, $col_3:literal, $col_4:literal,\n\t\t\t\t\t$col_5:literal, $col_6:literal) =\u003e {\n\t\t\t\tex! (@one, $row, \"column 1\", $col_1); ex! (@one, $row, \"column 2\", $col_2);\n\t\t\t\tex! (@one, $row, \"column 3\", $col_3); ex! (@one, $row, \"column 4\", $col_4);\n\t\t\t\tex! (@one, $row, \"column 5\", $col_5); ex! (@one, $row, \"column 6\", $col_6);\n\t\t\t};\n\t\t\t(@one, $row:literal, $col:literal, $expect:literal) =\u003e {\n\t\t\t\tassert_eq_ok! ($expect, puzzle.part_one (\u0026 [ \u0026 format! (\n\t\t\t\t\t\"To continue, please consult the code grid in the manual.  Enter the code at \\\n\t\t\t\t\t{}, {}.\", $row, $col) ]));\n\t\t\t};\n\t\t}\n\t\tex! (\"row 1\", \"20151125\", \"18749137\", \"17289845\", \"30943339\", \"10071777\", \"33511524\");\n\t\tex! (\"row 2\", \"31916031\", \"21629792\", \"16929656\", \"7726640\", \"15514188\", \"4041754\");\n\t\tex! (\"row 3\", \"16080970\", \"8057251\", \"1601130\", \"7981243\", \"11661866\", \"16474243\");\n\t\tex! (\"row 4\", \"24592653\", \"32451966\", \"21345942\", \"9380097\", \"10600672\", \"31527494\");\n\t\tex! (\"row 5\", \"77061\", \"17552253\", \"28094349\", \"6899651\", \"9250759\", \"31663883\");\n\t\tex! (\"row 6\", \"33071741\", \"6796745\", \"25397450\", \"24659492\", \"1534922\", \"27995004\");\n\t}\n\n}\n\n","traces":[{"line":17,"address":[35280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[24564,24560],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[35601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[35622,37247,36785,37019,36134,37075,35839,46960,37216,37365,46330,46270,36926,36190,35738,36632,36425,36071,36331,46582,36957,46834,36729,37309,35769,36362,46456,36040,46708,35895,36481,52048,36663,51405],"length":1,"stats":{"Line":25},"fn_name":null},{"line":42,"address":[39015,38843,38694,38131,38725,37516,47338,47026,38497,37810,39133,51291,51946,37903,38553,38249,47212,38400,47590,37547,37959,37669,38984,38100,39077,38193,37613,47086,37841,47716,47464,38431,38787,37387],"length":1,"stats":{"Line":25},"fn_name":null},{"line":43,"address":[40168,40017,40901,39284,40752,39578,47782,47842,39671,40462,39961,48346,39899,40845,40493,48472,40321,48094,51177,40199,40783,40265,47968,40611,39868,39315,48220,51844,39155,39609,39727,39437,40555,39381],"length":1,"stats":{"Line":25},"fn_name":null},{"line":44,"address":[42089,51063,41083,41636,51742,42520,48724,42230,42261,42551,41936,42613,42379,41052,41439,48976,41967,41205,41495,42669,41729,49102,48598,42033,41667,41346,49228,48538,40923,41377,41785,42323,48850,41149],"length":1,"stats":{"Line":25},"fn_name":null},{"line":45,"address":[43207,44319,49354,43145,43801,43735,43553,44288,42917,44091,49606,42691,44437,43114,51640,43435,42973,42851,43497,43998,49858,49984,49294,43704,43404,49480,50949,44029,44147,43263,42820,43857,44381,49732],"length":1,"stats":{"Line":25},"fn_name":null},{"line":46,"address":[45031,45503,44685,45766,45859,44619,50362,44882,44913,44459,46143,51517,50236,45265,45569,45797,46087,50488,46196,45321,50110,44588,50835,50737,44975,45625,50614,45172,45915,44741,45203,50050,51553,45472,46056],"length":1,"stats":{"Line":25},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-25","logic.rs"],"content":"//! Logic for solving the puzzles.\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet diag_num = chk! (input.row + input.col - 2) ?;\n\tlet diag_seq = chk! (diag_num * (diag_num + 1_u64) / 2) ?;\n\tlet mut cell_seq = chk! (diag_seq + input.col - 1) ?;\n\tlet mut code = 20_151_125_u64;\n\tlet mut mul = 252_533;\n\twhile cell_seq != 0 {\n\t\tif cell_seq \u0026 1 == 1 { code = chk! (code * mul % 33_554_393) ?; }\n\t\tcell_seq \u003e\u003e= 1_i32;\n\t\tmul = chk! (mul * mul % 33_554_393) ?;\n\t}\n\tOk (code)\n}\n","traces":[{"line":7,"address":[28848],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[22572],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[22419,22753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[23100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[29398,29146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[22337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[29392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[22993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[29411],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2015_day_01 as day_01;\npub use aoc_2015_day_02 as day_02;\npub use aoc_2015_day_03 as day_03;\npub use aoc_2015_day_04 as day_04;\npub use aoc_2015_day_05 as day_05;\npub use aoc_2015_day_06 as day_06;\npub use aoc_2015_day_07 as day_07;\npub use aoc_2015_day_08 as day_08;\npub use aoc_2015_day_09 as day_09;\npub use aoc_2015_day_10 as day_10;\npub use aoc_2015_day_11 as day_11;\npub use aoc_2015_day_12 as day_12;\npub use aoc_2015_day_13 as day_13;\npub use aoc_2015_day_14 as day_14;\npub use aoc_2015_day_15 as day_15;\npub use aoc_2015_day_16 as day_16;\npub use aoc_2015_day_17 as day_17;\npub use aoc_2015_day_18 as day_18;\npub use aoc_2015_day_19 as day_19;\npub use aoc_2015_day_20 as day_20;\npub use aoc_2015_day_21 as day_21;\npub use aoc_2015_day_22 as day_22;\npub use aoc_2015_day_23 as day_23;\npub use aoc_2015_day_24 as day_24;\npub use aoc_2015_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","cpu","cpu.rs"],"content":"use super::*;\n\n#[ derive (Default) ]\npub struct Cpu {\n\tpub instrs: Rc \u003cVec \u003cInstr\u003e\u003e,\n\tpub reg_a: i32,\n\tpub reg_b: i32,\n\tpub reg_c: i32,\n\tpub reg_d: i32,\n\tpub limit: u32,\n\tpub next: u32,\n}\n\nimpl Cpu {\n\n\t#[ inline ]\n\tconst fn load (\u0026 self, arg: Arg) -\u003e i32 {\n\t\tmatch arg {\n\t\t\tArg::RegA =\u003e self.reg_a,\n\t\t\tArg::RegB =\u003e self.reg_b,\n\t\t\tArg::RegC =\u003e self.reg_c,\n\t\t\tArg::RegD =\u003e self.reg_d,\n\t\t\tArg::Imm (val) =\u003e val,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn store (\u0026 mut self, arg: Arg, val: i32) {\n\t\tmatch arg {\n\t\t\tArg::RegA =\u003e self.reg_a = val,\n\t\t\tArg::RegB =\u003e self.reg_b = val,\n\t\t\tArg::RegC =\u003e self.reg_c = val,\n\t\t\tArg::RegD =\u003e self.reg_d = val,\n\t\t\tArg::Imm (_) =\u003e (),\n\t\t}\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn exec (\u0026 mut self) -\u003e GenResult \u003cOption \u003ci32\u003e\u003e {\n\t\twhile self.next.qck_usize () \u003c self.instrs.len () {\n\t\t\tif self.limit == 0 { return Err (\"Reached ops limit\".into ()) }\n\t\t\tself.limit -= 1;\n\t\t\t#[ allow (clippy::match_on_vec_items) ]\n\t\t\tmatch self.instrs [self.next.qck_usize ()] {\n\t\t\t\tInstr::Cpy (src, dst) =\u003e self.store (dst, self.load (src)),\n\t\t\t\tInstr::Inc (reg) =\u003e self.store (reg, i32::add_2 (self.load (reg), 1_i32) ?),\n\t\t\t\tInstr::Dec (reg) =\u003e self.store (reg, i32::sub_2 (self.load (reg), 1_i32) ?),\n\t\t\t\tInstr::Jnz (src, dst) =\u003e { self.jnz (src, dst) ?; continue }\n\t\t\t\tInstr::Tgl (dst) =\u003e {\n\t\t\t\t\tlet idx = u32::add_signed (self.next, self.load (dst)) ?;\n\t\t\t\t\tif let Some (instr) =\n\t\t\t\t\t\tRc::make_mut (\u0026 mut self.instrs)\n\t\t\t\t\t\t\t.get_mut (idx.qck_usize ()) {\n\t\t\t\t\t\t* instr = match * instr {\n\t\t\t\t\t\t\tInstr::Cpy (src, dst) =\u003e Instr::Jnz (src, dst),\n\t\t\t\t\t\t\tInstr::Jnz (src, dst) =\u003e Instr::Cpy (src, dst),\n\t\t\t\t\t\t\tInstr::Inc (arg) =\u003e Instr::Dec (arg),\n\t\t\t\t\t\t\tInstr::Dec (arg) | Instr::Tgl (arg) | Instr::Out (arg) =\u003e\n\t\t\t\t\t\t\t\tInstr::Inc (arg),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstr::Out (arg) =\u003e {\n\t\t\t\t\tself.next += 1;\n\t\t\t\t\treturn Ok (Some (self.load (arg)));\n\t\t\t\t},\n\t\t\t}\n\t\t\tself.next += 1;\n\t\t}\n\t\tOk (None)\n\t}\n\n\tfn jnz (\u0026 mut self, src: Arg, dst: Arg) -\u003e GenResult \u003c()\u003e {\n\n\t\t// ignore if src is zero\n\n\t\tif self.load (src) == 0_i32 {\n\t\t\tself.next += 1;\n\t\t\treturn Ok (());\n\t\t}\n\n\t\t// check if this can be optimized\n\n\t\tif self.next \u003e= 2 {\n\t\t\tmatch \u003c[Instr; 3]\u003e::try_from (\n\t\t\t\t\u0026 self.instrs [self.next.qck_usize () - 2 .. self.next.qck_usize () + 1],\n\t\t\t).unwrap () {\n\t\t\t\t[\n\t\t\t\t\tInstr::Dec (arg),\n\t\t\t\t\tInstr::Inc (dst),\n\t\t\t\t\tInstr::Jnz (arg_0, Arg::Imm (-2_i32)),\n\t\t\t\t] | [\n\t\t\t\t\tInstr::Inc (dst),\n\t\t\t\t\tInstr::Dec (arg),\n\t\t\t\t\tInstr::Jnz (arg_0, Arg::Imm (-2_i32)),\n\t\t\t\t] if arg == arg_0 \u0026\u0026 dst != arg \u0026\u0026 arg.is_reg () \u0026\u0026 dst.is_reg () =\u003e {\n\t\t\t\t\tself.store (dst, i32::add_2 (self.load (dst), self.load (arg)) ?);\n\t\t\t\t\tself.store (arg, 0);\n\t\t\t\t\treturn Ok (());\n\t\t\t\t},\n\t\t\t\t_ =\u003e (),\n\t\t\t}\n\t\t}\n\n\t\tif self.next \u003e= 4 {\n\t\t\tmatch \u003c[Instr; 5]\u003e::try_from (\n\t\t\t\t\u0026 self.instrs [self.next.qck_usize () - 4 .. self.next.qck_usize () + 1],\n\t\t\t).unwrap () {\n\t\t\t\t[\n\t\t\t\t\tInstr::Jnz (arg, Arg::Imm (2_i32)),\n\t\t\t\t\tInstr::Jnz (Arg::Imm (1_i32), Arg::Imm (4_i32)),\n\t\t\t\t\tInstr::Dec (dst),\n\t\t\t\t\tInstr::Dec (arg_0),\n\t\t\t\t\tInstr::Jnz (Arg::Imm (1_i32), Arg::Imm (-4_i32)),\n\t\t\t\t] if arg == arg_0 \u0026\u0026 arg != dst \u0026\u0026 arg.is_reg () \u0026\u0026 dst.is_reg () =\u003e {\n\t\t\t\t\tself.store (dst, i32::sub_2 (\n\t\t\t\t\t\tself.load (dst),\n\t\t\t\t\t\tself.load (arg),\n\t\t\t\t\t) ?);\n\t\t\t\t\tself.store (arg, 0);\n\t\t\t\t},\n\t\t\t\t_ =\u003e (),\n\t\t\t}\n\t\t}\n\n\t\tif self.next \u003e= 5 {\n\t\t\tmatch \u003c[Instr; 6]\u003e::try_from (\n\t\t\t\t\u0026 self.instrs [self.next.qck_usize () - 5 .. self.next.qck_usize () + 1],\n\t\t\t).unwrap () {\n\t\t\t\t[\n\t\t\t\t\tInstr::Cpy (arg, tmp),\n\t\t\t\t\tInstr::Inc (dst),\n\t\t\t\t\tInstr::Dec (tmp_0),\n\t\t\t\t\tInstr::Jnz (tmp_1, Arg::Imm (-2_i32)),\n\t\t\t\t\tInstr::Dec (ctr),\n\t\t\t\t\tInstr::Jnz (ctr_0, Arg::Imm (-5_i32)),\n\t\t\t\t] if tmp == tmp_0 \u0026\u0026 tmp == tmp_1 \u0026\u0026 ctr == ctr_0 \u0026\u0026 arg != tmp \u0026\u0026 arg != dst\n\t\t\t\t\t\t\u0026\u0026 arg != ctr \u0026\u0026 tmp != dst \u0026\u0026 tmp != ctr \u0026\u0026 dst != ctr \u0026\u0026 dst.is_reg ()\n\t\t\t\t\t\t\u0026\u0026 tmp.is_reg () \u0026\u0026 ctr.is_reg () =\u003e {\n\t\t\t\t\tself.store (dst, i32::add_2 (\n\t\t\t\t\t\tself.load (dst),\n\t\t\t\t\t\ti32::mul_2 (self.load (arg), self.load (ctr)) ?,\n\t\t\t\t\t) ?);\n\t\t\t\t\tself.store (tmp, 0);\n\t\t\t\t\tself.store (ctr, 0);\n\t\t\t\t\treturn Ok (());\n\t\t\t\t},\n\t\t\t\t_ =\u003e (),\n\t\t\t}\n\t\t}\n\n\t\tif self.next \u003e= 7 {\n\t\t\tmatch \u003c[Instr; 8]\u003e::try_from (\n\t\t\t\t\u0026 self.instrs [self.next.qck_usize () - 7 .. self.next.qck_usize () + 1],\n\t\t\t).unwrap () {\n\t\t\t\t[\n\t\t\t\t\tInstr::Cpy (Arg::Imm (div), rem),\n\t\t\t\t\tInstr::Jnz (mul, Arg::Imm (2_i32)),\n\t\t\t\t\tInstr::Jnz (Arg::Imm (1_i32), Arg::Imm (6_i32)),\n\t\t\t\t\tInstr::Dec (mul_0),\n\t\t\t\t\tInstr::Dec (rem_0),\n\t\t\t\t\tInstr::Jnz (rem_1, Arg::Imm (-4_i32)),\n\t\t\t\t\tInstr::Inc (out),\n\t\t\t\t\tInstr::Jnz (Arg::Imm (1_i32), Arg::Imm (-7_i32)),\n\t\t\t\t] if rem != mul \u0026\u0026 rem != out \u0026\u0026 mul != out \u0026\u0026 mul == mul_0 \u0026\u0026 rem == rem_0\n\t\t\t\t\t\t\u0026\u0026 rem == rem_1 \u0026\u0026 rem.is_reg () \u0026\u0026 mul.is_reg () \u0026\u0026 out.is_reg () =\u003e {\n\t\t\t\t\tself.store (out, i32::add_2 (\n\t\t\t\t\t\tself.load (out),\n\t\t\t\t\t\ti32::div_2 (self.load (mul), div) ?,\n\t\t\t\t\t) ?);\n\t\t\t\t\tlet rem_val = self.load (mul) % div;\n\t\t\t\t\tself.store (rem, if rem_val == 0 { div } else { rem_val });\n\t\t\t\t\tself.store (mul, 0);\n\t\t\t\t\tself.next += 1;\n\t\t\t\t\treturn Ok (())\n\t\t\t\t},\n\t\t\t\t_ =\u003e (),\n\t\t\t}\n\t\t}\n\n\t\t// if not then jump as described\n\n\t\tself.next = u32::add_signed (self.next, self.load (dst)) ?;\n\t\tOk (())\n\n\t}\n\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","cpu","instr.rs"],"content":"use super::*;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Arg {\n\t\tRegA = [ \"a\" ],\n\t\tRegB = [ \"b\" ],\n\t\tRegC = [ \"c\" ],\n\t\tRegD = [ \"d\" ],\n\t\tImm (val: i32) = [ val ],\n\t}\n}\n\nimpl Arg {\n\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub const fn is_reg (\u0026 self) -\u003e bool {\n\t\tmatches! (* self, Self::RegA | Self::RegB | Self::RegC | Self::RegD)\n\t}\n\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Instr {\n\t\tCpy (arg_0: Arg, arg_1: Arg) = [ \"cpy \", arg_0, \" \", arg_1 ],\n\t\tInc (arg: Arg) = [ \"inc \", arg ],\n\t\tDec (arg: Arg) = [ \"dec \", arg ],\n\t\tJnz (arg_0: Arg, arg_1: Arg) = [ \"jnz \", arg_0, \" \", arg_1 ],\n\t\tTgl (arg: Arg) = [ \"tgl \", arg ],\n\t\tOut (arg: Arg) = [ \"out \", arg ],\n\t}\n}\n\nimpl Instr {\n\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub const fn is_v1 (\u0026 self) -\u003e bool {\n\t\tuse Instr::{ Cpy, Dec, Inc, Jnz };\n\t\tmatches! (* self, Cpy (_, _) | Inc (_) | Dec (_) | Jnz (_, _))\n\t}\n\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub const fn is_v2 (\u0026 self) -\u003e bool {\n\t\tuse Instr::{ Cpy, Dec, Inc, Jnz, Tgl };\n\t\tmatches! (* self, Cpy (_, _) | Inc (_) | Dec (_) | Jnz (_, _) | Tgl (_))\n\t}\n\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub const fn is_v3 (\u0026 self) -\u003e bool {\n\t\tuse Instr::{ Cpy, Dec, Inc, Jnz, Out };\n\t\tmatches! (* self, Cpy (_, _) | Inc (_) | Dec (_) | Jnz (_, _) | Out (_))\n\t}\n\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","cpu","lib.rs"],"content":"//! Advent of Code 2016: CPU\n//!\n//! CPU used in the following puzzles:\n//!\n//! - [https://adventofcode.com/2016/day/12](https://adventofcode.com/2016/day/12)\n//! - [https://adventofcode.com/2016/day/23](https://adventofcode.com/2016/day/23)\n//! - [https://adventofcode.com/2016/day/25](https://adventofcode.com/2016/day/25)\n\n#![ allow (clippy::inline_always) ]\n\nuse aoc_common::*;\n\nmod cpu;\nmod instr;\n\npub use cpu::*;\npub use instr::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-01","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Coord;\nuse model::Turn;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003c(Turn, Coord)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [\n\t\tparams,\n\t\t@delim \", \" steps {\n\t\t\ttype = (Turn, Coord);\n\t\t\t(turn, dist) = [\n\t\t\t\tturn {\n\t\t\t\t\ttype = Turn;\n\t\t\t\t\tTurn::Left = [ \"L\" ],\n\t\t\t\t\tTurn::Right = [ \"R\" ],\n\t\t\t\t},\n\t\t\t\tdist = (Coord::ONE .. ),\n\t\t\t],\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[30326,30859],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-01","lib.rs"],"content":"//! Advent of Code 2016: Day 1: No Time for a Taxicab\n//!\n//! [https://adventofcode.com/2016/day/1](https://adventofcode.com/2016/day/1)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"No Time for a Taxicab\";\n\tyear = 2016;\n\tday = 1;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLES: \u0026 [\u0026 str] = \u0026 [\n\t\t\"R2, L3\",\n\t\t\"R2, R2, R2\",\n\t\t\"R5, L5, R5, R3\",\n\t\t\"R8, R4, R4, R8\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"5\", puzzle.part_one (\u0026 [EXAMPLES [0]]));\n\t\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [EXAMPLES [1]]));\n\t\tassert_eq_ok! (\"12\", puzzle.part_one (\u0026 [EXAMPLES [2]]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"4\", puzzle.part_two (\u0026 [EXAMPLES [3]]));\n\t}\n\n}\n","traces":[{"line":18,"address":[49948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[50444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[43996,42944],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":36,"address":[42961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[43512,43953,43099,43446,42982,43043],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[43121,43237,43915,43580,43178,43641],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[43874,43322,43706,43767,43381,43259],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[44016,44426],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":44,"address":[44026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[44156,44383,44047,44213,44279,44104],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-01","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Dir;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet hq_pos = iter_posns (input)\n\t\t.take (1_000)\n\t\t.fold (Ok (Pos::ZERO), Result::and) ?;\n\tOk (hq_pos.n.unsigned_abs () + hq_pos.e.unsigned_abs ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet hq_pos = iter_posns (input)\n\t\t.take (1_000)\n\t\t.scan (HashSet::new (), |seen, pos| {\n\t\t\tmatch pos {\n\t\t\t\tOk (pos) =\u003e Some ((! seen.insert (pos)).then_some (Ok (pos))),\n\t\t\t\tErr (err) =\u003e Some (Some (Err (err))),\n\t\t\t}\n\t\t})\n\t\t.flatten ()\n\t\t.next ()\n\t\t.ok_or (\"No solution found\") ? ?;\n\tOk (hq_pos.n.unsigned_abs () + hq_pos.e.unsigned_abs ())\n}\n\npub fn iter_posns (input: \u0026 Input) -\u003e impl Iterator \u003cItem = NumResult \u003cPos\u003e\u003e + '_ {\n\tlet mut dir = Dir::North;\n\tlet mut pos = Pos::ZERO;\n\tlet mut dist = Coord::ZERO;\n\tlet mut steps_iter = input.steps.iter ();\n\titer::from_fn (move || {\n\t\tif dist == Coord::ZERO {\n\t\t\tlet \u0026 (turn, new_dist) = steps_iter.next () ?;\n\t\t\tdir = dir + turn;\n\t\t\tdist = new_dist;\n\t\t}\n\t\ttrue.then (|| {\n\t\t\tpos = (pos + (dir, Coord::ONE)) ?;\n\t\t\tdist -= Coord::ONE;\n\t\t\tOk (pos)\n\t\t})\n\t})\n}\n","traces":[{"line":8,"address":[44944],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[45072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[45127,45155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[45703,45184],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[45427,45431,45408],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[41152],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":19,"address":[47348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[22223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[41165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[45617,45653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[44981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[40608,40274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[40342,40653,40313,40681],"length":1,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[40326,40664,40347,40684],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[40350,40688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[41232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[27420,27456],"length":1,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[27522,27473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[27483],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-01","model.rs"],"content":"pub type Coord = i32;\npub type Dir = aoc_pos::DirGeo;\npub type Pos = aoc_pos::PosGeo \u003cCoord\u003e;\npub type Turn = aoc_pos::Turn2d;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"ULL\",\n\t\"RRDDD\",\n\t\"LURDL\",\n\t\"UUUUD\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1985\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5DB3\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[32820,32816],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":14,"address":[33098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[33119,33266,33332,33209,33436,33157],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[32848,32852],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[33498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[33732,33666,33609,33519,33836,33557],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-02","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Button;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub buttons: Vec \u003cButton\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { buttons, params } = [ params, @lines buttons ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[35734,36363],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-02","lib.rs"],"content":"//! Advent of Code 2016: Day 2: Bathroom Security\n//!\n//! [https://adventofcode.com/2016/day/2](https://adventofcode.com/2016/day/2)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Bathroom Security\";\n\tyear = 2016;\n\tday = 2;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[22364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[22732],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-02","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Button;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet digits = |pos| match pos {\n\t\tPos { row: 0, col: 0 } =\u003e Some ('1'),\n\t\tPos { row: 0, col: 1 } =\u003e Some ('2'),\n\t\tPos { row: 0, col: 2 } =\u003e Some ('3'),\n\t\tPos { row: 1, col: 0 } =\u003e Some ('4'),\n\t\tPos { row: 1, col: 1 } =\u003e Some ('5'),\n\t\tPos { row: 1, col: 2 } =\u003e Some ('6'),\n\t\tPos { row: 2, col: 0 } =\u003e Some ('7'),\n\t\tPos { row: 2, col: 1 } =\u003e Some ('8'),\n\t\tPos { row: 2, col: 2 } =\u003e Some ('9'),\n\t\t_ =\u003e None,\n\t};\n\tlet code = calc_code (\u0026 input.buttons, digits, Pos { row: 1, col: 1 }) ?;\n\tOk (code)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet digits = |pos| match pos {\n\t\tPos { row: 0, col: 2 } =\u003e Some ('1'),\n\t\tPos { row: 1, col: 1 } =\u003e Some ('2'),\n\t\tPos { row: 1, col: 2 } =\u003e Some ('3'),\n\t\tPos { row: 1, col: 3 } =\u003e Some ('4'),\n\t\tPos { row: 2, col: 0 } =\u003e Some ('5'),\n\t\tPos { row: 2, col: 1 } =\u003e Some ('6'),\n\t\tPos { row: 2, col: 2 } =\u003e Some ('7'),\n\t\tPos { row: 2, col: 3 } =\u003e Some ('8'),\n\t\tPos { row: 2, col: 4 } =\u003e Some ('9'),\n\t\tPos { row: 3, col: 1 } =\u003e Some ('A'),\n\t\tPos { row: 3, col: 2 } =\u003e Some ('B'),\n\t\tPos { row: 3, col: 3 } =\u003e Some ('C'),\n\t\tPos { row: 4, col: 2 } =\u003e Some ('D'),\n\t\t_ =\u003e None,\n\t};\n\tlet code = calc_code (\u0026 input.buttons, digits, Pos { row: 2, col: 0 }) ?;\n\tOk (code)\n}\n\nfn calc_code (\n\tbuttons: \u0026 [Button],\n\tlayout_fn: fn (Pos) -\u003e Option \u003cchar\u003e,\n\tmut pos: Pos,\n) -\u003e GenResult \u003cString\u003e {\n\tlet mut result = String::new ();\n\tfor button in buttons.iter () {\n\t\tfor \u0026 step in \u0026 button.steps {\n\t\t\tlet step_one = (step, 1);\n\t\t\tlet new_pos = chk! (pos + step_one) ?;\n\t\t\tif layout_fn (new_pos).is_some () { pos = new_pos; }\n\t\t}\n\t\tresult.push (layout_fn (pos).unwrap ());\n\t}\n\tOk (result)\n}\n","traces":[{"line":7,"address":[31072],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[25301,25296,25344,25332],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[31780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[31952],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":25,"address":[25360,25427,25365,25441,25415],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":41,"address":[32644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[31939,32803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[32053,31170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[31274,32154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[25504,25508,25472],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":55,"address":[31408,32320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[32726,31862],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":11,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-02","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Dir = pos::Dir2d;\npub type Pos = pos::PosRowCol \u003cCoord\u003e;\n\n#[ derive (Clone, Debug) ]\npub struct Button {\n\tpub steps: Vec \u003cDir\u003e,\n}\n\nstruct_parser_display! {\n\tButton { steps } = [\n\t\t@collect steps {\n\t\t\ttype = Dir;\n\t\t\tDir::Up = [ \"U\" ],\n\t\t\tDir::Down = [ \"D\" ],\n\t\t\tDir::Left = [ \"L\" ],\n\t\t\tDir::Right = [ \"R\" ],\n\t\t},\n\t]\n}\n","traces":[{"line":13,"address":[24403],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"2 2 3\",\n\t\"4 6 8\",\n\t\"5 10 25\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[31636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[34922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[35156,35260,35090,34943,34981,35033],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[31604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[35322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[35660,35343,35490,35381,35556,35433],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-03","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Triangle;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub triangles: Vec \u003cTriangle\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { triangles, params } = [\n\t\tparams,\n\t\t@lines triangles {\n\t\t\ttype = Triangle;\n\t\t\t(a, b, c) = [ @skip \"\", a, @skip \" \", b, @skip \" \", c ],\n\t\t}\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[26022,26475],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-03","lib.rs"],"content":"//! Advent of Code 2016: Day 3: Squares With Three Sides\n//!\n//! [https://adventofcode.com/2016/day/3](https://adventofcode.com/2016/day/3)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Squares With Three Sides\";\n\tyear = 2016;\n\tday = 3;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[23864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[24184],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-03","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Side;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tsanity_check (input) ?;\n\tlet num_possible =\n\t\tinput.triangles.iter ()\n\t\t\t.map (|\u0026 (a, b, c)| [a, b, c])\n\t\t\t.map (|mut sides| { sides.sort (); sides })\n\t\t\t.filter (|\u0026 [a, b, c]| c \u003c a + b)\n\t\t\t.count ();\n\tOk (num_possible)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tsanity_check (input) ?;\n\tlet num_possible =\n\t\tinput.triangles.iter ()\n\t\t\t.tuples::\u003c(_, _, _)\u003e ()\n\t\t\t.flat_map (\n\t\t\t\t|(\u0026 (a0, a1, a2), \u0026 (b0, b1, b2), \u0026 (c0, c1, c2))|\n\t\t\t\t\t[(a0, b0, c0), (a1, b1, c1), (a2, b2, c2) ])\n\t\t\t.map (|(a, b, c)| [a, b, c])\n\t\t\t.map (|mut sides| { sides.sort (); sides })\n\t\t\t.filter (|\u0026 [a, b, c]| c \u003c a + b)\n\t\t\t.count ();\n\tOk (num_possible)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.triangles.iter ()\n\t\t\t.any (|\u0026 (a, b, c)| Side::add_3 (a, b, c).is_err ()) {\n\t\treturn Err (\"Overflow\".into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[30032],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[30217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[50792,49920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[50822,49948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[50875,50833,50031,49959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[30289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[30320],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[30508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[50643,49418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[33588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[33632,33635],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":26,"address":[44032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[29925,29883,29669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[30626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[30175,30463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[27396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[30477,30188],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":13,"coverable":17},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-03","model.rs"],"content":"pub type Side = u16;\npub type Triangle = (Side, Side, Side);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-04","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"aaaaa-bbb-z-y-x-123[abxyz]\",\n\t\"a-b-c-d-e-f-g-h-987[abcde]\",\n\t\"not-a-real-room-404[oarel]\",\n\t\"totally-real-room-200[decoy]\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1514\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_err! (\"No solution found\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[48356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[63802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[63913,63970,63823,63861,64140,64036],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[48324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[64204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[64622,64265,64649,64514,64389,64225],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-04","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Room;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub rooms: Vec \u003cRoom \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { rooms, params } = [ params, @lines rooms ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[41499,40358],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-04","lib.rs"],"content":"//! Advent of Code 2016: Day 4: Security Through Obscurity\n//!\n//! [https://adventofcode.com/2016/day/4](https://adventofcode.com/2016/day/4)\n//!\n//! # Input\n//!\n//! A series of \"encrypted\" room names, each on its own line. A room name consists of one or more\n//! sequences of lowercase ASCII letters separated by a single hyphen, followed by a hyphen and a\n//! positive integer sector number, and finally a checksum in square brackets consisting of five\n//! lowercase ASCII letters.\n//!\n//! # Part one\n//!\n//! Verify the checksums of each room and add up the sector numbers of the ones which are valid.\n//! The checksum is valid if it consists of the five most common letters in the name, in order.\n//!\n//! # Part two\n//!\n//! Find the room name which decrypts to \"northpole object storage\". To decode a room name, rotate\n//! each letter by the sector number, and replace hypen with space.\n//!\n//! # Algorithm\n//!\n//! This is fairly straightforward, just a little tricky. We have a function to verify if the\n//! checksum is valid which we use to filter the entries, and another which is used in part two to\n//! decode it and find the right room. With both of these it's fairly simple to construct a\n//! chain of iterator adaptors.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Security Through Obscurity\";\n\tyear = 2016;\n\tday = 4;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":43,"address":[32392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[32712],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-04","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Room;\nuse nums::IntConv;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.rooms.iter ()\n\t\t\t.filter (|room| room_is_valid (room))\n\t\t\t.map (|room| room.sector)\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.rooms.iter ()\n\t\t\t.filter (|room| room_is_valid (room))\n\t\t\t.filter (|room| room_name_decode (room).eq (\"northpole object storage\".chars ()))\n\t\t\t.map (|room| room.sector)\n\t\t\t.next ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\n/// Decode a room name according to the sector number.\n///\n/// This returns an [`Iterator \u003cItem = char\u003e`] to prevent allocations.\n///\nfn room_name_decode \u003c'dat\u003e (room: \u0026 'dat Room) -\u003e impl Iterator \u003cItem = char\u003e + 'dat {\n\tlet rotate = room.sector % 26;\n\troom.name.chars ()\n\t\t.map (move |ch| if ch == '-' { ' ' } else {\n\t\t\tlet mut ord = ch.pan_u32 () - 'a'.pan_u32 () + rotate;\n\t\t\tif 26 \u003c= ord { ord -= 26; }\n\t\t\t('a'.pan_u32 () + ord).pan_char ()\n\t\t})\n}\n\n/// Check if a room's checksum is valid for its name.\n///\n/// The checksum should be the five most common alphabetic characters in the encoded name, in\n/// order.\n///\n/// We use an efficient algorithm which does not allocate. An array is collected with the 26\n/// letters in order and a count, which is then used to count each letter. This is then sorted,\n/// and the first five characters are compared to the checksum.\n///\nfn room_is_valid (room: \u0026 Room) -\u003e bool {\n\tlet mut char_counts: [(char, u32); 26] = array::from_fn (|idx|\n\t\t(('a'.pan_u32 () + idx.pan_u32 ()).pan_char (), 0_u32));\n\tfor ch in room.name.chars () {\n\t\tif ! ch.is_ascii_lowercase () { continue }\n\t\tchar_counts [(ch.pan_u32 () - 'a'.pan_u32 ()).pan_usize ()].1 += 1;\n\t}\n\tchar_counts.sort_by_key (|\u0026 (_, num)| cmp::Reverse (num));\n\tchar_counts.into_iter ().take (5).map (|(ch, _)| ch).eq (room.checksum.chars ())\n}\n","traces":[{"line":7,"address":[45888],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[45731,45971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[56560],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":16,"address":[46080],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[46367,46400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[46332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[55563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[46359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[46544,47399],"length":1,"stats":{"Line":2},"fn_name":"room_is_valid"},{"line":51,"address":[56960],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":52,"address":[57054,57152],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[47044,46747,46695],"length":1,"stats":{"Line":6},"fn_name":null},{"line":54,"address":[47061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[47140,47195,47024],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[38195,38918,38219,39546,39043,38251,39894,39648,39987],"length":1,"stats":{"Line":11},"fn_name":null},{"line":58,"address":[46787,47367],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":18,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-04","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Room \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub sector: u32,\n\tpub checksum: InpStr \u003c'inp\u003e,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tRoom \u003c'inp\u003e { name, sector, checksum } = [\n\t\tname = room_name_parse,\n\t\t\"-\",\n\t\tsector,\n\t\t\"[\", @str checksum = (|ch| { ch.is_ascii_lowercase () }, 5 ..= 5), \"]\",\n\t]\n}\n\nfn room_name_parse \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tlet mut last_ch = None;\n\tlet mut num_chars = 0_u32;\n\tfor ch in parser.peek_rest ().chars () {\n\t\tmatch (last_ch, ch) {\n\t\t\t(Some ('-'), 'a' ..= 'z') =\u003e num_chars += 2,\n\t\t\t(_, 'a' ..= 'z') =\u003e num_chars += 1,\n\t\t\t(Some ('a' ..= 'z'), '-') =\u003e (),\n\t\t\t_ =\u003e break,\n\t\t}\n\t\tlast_ch = Some (ch);\n\t}\n\tif num_chars \u003c 2 { return Err (parser.err ()) }\n\tparser.take_exactly (num_chars)\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn test_room_name_parse () {\n\t\tassert_eq_ok! (\"abc-def\", room_name_parse (\u0026 mut Parser::new (\"abc-def\")));\n\t\tassert_eq_ok! (\"abc-def\", room_name_parse (\u0026 mut Parser::new (\"abc-def-\")));\n\t\tassert_eq_ok! (\"abc-def\", room_name_parse (\u0026 mut Parser::new (\"abc-def--ghi\")));\n\t\tassert_eq_ok! (\"abc-def\", room_name_parse (\u0026 mut Parser::new (\"abc-def-123\")));\n\t\tassert_is_err! (room_name_parse (\u0026 mut Parser::new (\"-abc-def\")));\n\t\tassert_is_err! (room_name_parse (\u0026 mut Parser::new (\"BLAH\")));\n\t}\n\n}\n","traces":[{"line":12,"address":[58979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[44196,44192],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":43,"address":[35986,35962,36059,36913,37672,36979],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[36182,37656,37108,36158,36255,37047],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[37237,36378,37176,37640,36354,36451],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[36550,36574,36647,37366,37624,37305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[37495,37434,36743,36756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[36849,36836,37581,37515],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":15,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-05","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_ZEROS=1\",\n\t\"MAX_THREADS=1\",\n\t\"abc\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0500f456\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"36790f5e\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[46724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[88778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[89012,88799,89116,88837,88889,88946],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[46628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[89178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[89346,89199,89516,89237,89412,89289],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-05","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub door_id: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { door_id, params } = [ params, door_id ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_zeros: u8 = (\"NUM_ZEROS=\", 5, 1_u8 .. ),\n\t\tpub max_threads: u32 = (\"MAX_THREADS=\", u32::MAX, 1_u32 .. ),\n\t\tpub password_len: usize = (\"PASSWORD_LEN=\", 8, 1_usize ..= 8),\n\t\tpub batch_size: usize = (\"BATCH_SIZE=\", 10_000, 1_usize .. ),\n\t}\n}\n","traces":[{"line":13,"address":[80276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[95892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[95897],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[95503,95901],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[95906],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-05","lib.rs"],"content":"//! Advent of Code 2016: Day 5: How About a Nice Game of Chess?\n//!\n//! [https://adventofcode.com/2016/day/5](https://adventofcode.com/2016/day/5)\n//!\n//! # Input\n//!\n//! Any string, used as a cryptographic salt. Only a single line is used. For testing purposes, we\n//! also accept a prefix line in the form `\"NUM_ZEROS=n\"` where n is the number of zeros to match\n//! at the start of the generated hash.\n//!\n//! # Part one\n//!\n//! Construct a password by searching for integers which can be appended to the input string which\n//! give an md5 hash having at least 5 zeros at the start of its hex representation. The password\n//! is built by appending the 6th hex digit each time. Once eight characters are obtained, the\n//! password is complete.\n//!\n//! # Part two\n//!\n//! The sixth character of the hex hash now represents the position of the character in the\n//! password, and the seventh is the character itself.\n//!\n//! # Algorithm\n//!\n//! We use the md5 implementation in [`aoc_common`]. Iterate over integers to append until we find\n//! a match and build up the password. To make things faster we use [`aoc_parallel::ThreadMap`] to\n//! generate hashes parallely in separate threads.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_parallel::{ self as parallel, prelude::* };\nuse aoc_md5 as md5;\nuse md5::md5_hash;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"How About a Nice Game of Chess?\";\n\tyear = 2016;\n\tday = 5;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":45,"address":[71207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[71655],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-05","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut password = String::new ();\n\tfor hash in iter_hashes (input) {\n\t\tif password.len () == input.params.password_len { break }\n\t\tpassword.push (char::from_digit ((hash [2] \u0026 0xf).pan_u32 (), 16).unwrap ());\n\t}\n\tOk (password)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut password: ArrayVec \u003cOption \u003cchar\u003e, 8\u003e =\n\t\titer::repeat (None)\n\t\t\t.take (input.params.password_len)\n\t\t\t.collect ();\n\tfor hash in iter_hashes (input) {\n\t\tif ! password.iter ().any (Option::is_none) { break }\n\t\tlet pos = (hash [2] \u0026 0xf).pan_usize ();\n\t\tif input.params.password_len \u003c= pos { continue }\n\t\tif password [pos].is_some () { continue }\n\t\tlet ch = char::from_digit ((hash [3] \u003e\u003e 4_u32).pan_u32 (), 16).unwrap ();\n\t\tpassword [pos] = Some (ch);\n\t}\n\tOk (\n\t\tpassword.iter ()\n\t\t\t.map (|\u0026 ch| ch.unwrap ())\n\t\t\t.collect ()\n\t)\n}\n\nfn iter_hashes (input: \u0026 Input) -\u003e impl Iterator \u003cItem = md5::Output\u003e {\n\tlet door_id: Arc \u003cstr\u003e = Arc::from (input.door_id.as_str ());\n\tlet num_zeros = input.params.num_zeros;\n\tlet batch_size = input.params.batch_size;\n\tlet map_fn = move |num_start| {\n\t\tlet mut hashes = Vec::new ();\n\t\tlet mut buffer = door_id.deref ().to_owned ();\n\t\tfor num in (num_start .. ).take (batch_size) {\n\t\t\tbuffer.truncate (door_id.len ());\n\t\t\twrite! (buffer, \"{}\", num).unwrap ();\n\t\t\tlet hash = md5_hash (buffer.as_bytes ());\n\t\t\tif hash.num_zeros () \u003c num_zeros { continue }\n\t\t\thashes.push (hash);\n\t\t}\n\t\thashes\n\t};\n\tThreadMap::start (\n\t\t\t(0_u32 .. ).step_by (input.params.batch_size),\n\t\t\tmap_fn,\n\t\t\tparallel::num_cpus_max (input.params.max_threads).pan_usize ())\n\t\t.flatten ()\n}\n","traces":[{"line":5,"address":[44007,43504],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[43551,43640,43981,43732],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[43759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[43899],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[44807,44016],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[44041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[44171,44073,44782,44244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[44362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[44376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[44430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[44445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[44480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[44568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[44817,44816,44826],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":34,"address":[44864,45316],"length":1,"stats":{"Line":1},"fn_name":"iter_hashes"},{"line":36,"address":[44976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[44981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[45328,46250,44985],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":41,"address":[45419,45546],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[45661,45732],"length":1,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[46039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[46049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[45034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[45099,45278],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":24},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-06","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"eedadn\",\n\t\"drvtee\",\n\t\"eandsr\",\n\t\"raavrd\",\n\t\"atevrs\",\n\t\"tsrnev\",\n\t\"sdttsa\",\n\t\"rasrtv\",\n\t\"nssdts\",\n\t\"ntnada\",\n\t\"svetve\",\n\t\"tesnvt\",\n\t\"vntsnd\",\n\t\"vrdear\",\n\t\"dvrsen\",\n\t\"enarar\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"easter\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"advent\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":25,"address":[30231,29840],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":26,"address":[29850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[30084,30188,29961,29871,30018,29909],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[30240,30631],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":32,"address":[30250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[30588,30309,30271,30361,30418,30484],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-06","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub lines: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { lines, params } = [ params, @lines lines ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[41659],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-06","lib.rs"],"content":"//! Advent of Code 2016: Day 6: Signals and Noise\n//!\n//! [https://adventofcode.com/2016/day/6](https://adventofcode.com/2016/day/6)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Signals and Noise\";\n\tyear = 2016;\n\tday = 6;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-06","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\n\t\t\u0026 input.lines,\n\t\t|col_counts| col_counts.iter ()\n\t\t\t.max_by_key (|\u0026 (_, num)| num)\n\t\t\t.map (|(\u0026 ch, _)| ch)\n\t\t\t.unwrap ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\n\t\t\u0026 input.lines,\n\t\t|col_counts| col_counts.iter ()\n\t\t\t.min_by_key (|\u0026 (_, num)| num)\n\t\t\t.map (|(\u0026 ch, _)| ch)\n\t\t\t.unwrap ())\n}\n\npub fn calc_result (\n\tlines: \u0026 [InpStr],\n\tmap_fn: fn (HashMap \u003cchar, usize\u003e) -\u003e char,\n) -\u003e GenResult \u003cString\u003e {\n\tOk (\n\t\tlines.iter ()\n\t\t\t.fold (\n\t\t\t\titer::repeat (HashMap::new ())\n\t\t\t\t\t.take (lines [0].chars ().count ())\n\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e (),\n\t\t\t\t|mut all_counts, line| {\n\t\t\t\t\tall_counts.iter_mut ()\n\t\t\t\t\t\t.zip (line.chars ())\n\t\t\t\t\t\t.for_each (|(col_counts, ch)|\n\t\t\t\t\t\t\t* col_counts.entry (ch).or_insert (0) += 1_usize);\n\t\t\t\t\tall_counts\n\t\t\t\t})\n\t\t\t.into_iter ()\n\t\t\t.map (map_fn)\n\t\t\t.collect ()\n\t)\n}\n","traces":[{"line":5,"address":[27104],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[29026,28925,28864],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":9,"address":[29040],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":10,"address":[47573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[28954,29008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[27168],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":17,"address":[29133,29234,29072],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":18,"address":[29248],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":19,"address":[47589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[29216,29162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[27232,27729],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":28,"address":[27561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[27689,27366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[29630,29280],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":34,"address":[31311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[29648],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":37,"address":[29788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[29572],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":13,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-07","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"abba[mnop]qrst\",\n\t\"abcd[bddb]xyyx\",\n\t\"aaaa[qwer]tyui\",\n\t\"ioxxoj[asdfgh]zxcvbn\",\n\t\"aba[bab]xyz\",\n\t\"xyx[xyx]xyx\",\n\t\"aaa[kek]eke\",\n\t\"zazbz[bzb]cdb\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":17,"address":[32800,33191],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":18,"address":[32810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[32978,32869,33044,32831,32921,33148],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[33200,33591],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":24,"address":[33210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[33444,33231,33321,33548,33378,33269],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-07","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub lines: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { lines, params } = [ params, @lines lines ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[37126,37627],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-07","lib.rs"],"content":"//! Advent of Code 2016: Day 7: Internet Protocol Version 7\n//!\n//! [https://adventofcode.com/2016/day/7](https://adventofcode.com/2016/day/7)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Internet Protocol Version 7\";\n\tyear = 2016;\n\tday = 7;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-07","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tOk (\n\t\tinput.lines.iter ()\n\t\t\t.filter (|line| has_abba_unbracketed (line) \u0026\u0026 ! has_abba_bracketed (line))\n\t\t\t.count ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tOk (\n\t\tinput.lines.iter ()\n\t\t\t.filter (|line| iter_abas_unbracketed (line)\n\t\t\t\t.any (|(a, b)| has_bab_bracketed (line, a, b)))\n\t\t\t.count ()\n\t)\n}\n\nfn has_abba_unbracketed (addr: \u0026 str) -\u003e bool {\n\taddr.chars ()\n\t\t.scan (true, |state, ch| {\n\t\t\tSome (match ch {\n\t\t\t\t'[' =\u003e { * state = false; Some ('[') },\n\t\t\t\t']' =\u003e { * state = true; Some (']') },\n\t\t\t\t_ =\u003e (* state).then_some (ch),\n\t\t\t})\n\t\t})\n\t\t.flatten ()\n\t\t.tuple_windows::\u003c(_, _, _, _)\u003e ()\n\t\t.any (|(a, b, c, d)| a == d \u0026\u0026 b == c \u0026\u0026 a != b)\n}\n\nfn has_abba_bracketed (addr: \u0026 str) -\u003e bool {\n\taddr.chars ()\n\t\t.scan (false, |state, ch| {\n\t\t\tSome (match ch {\n\t\t\t\t'[' =\u003e { * state = true; Some ('[') },\n\t\t\t\t']' =\u003e { * state = false; Some (']') },\n\t\t\t\t_ =\u003e (* state).then_some (ch),\n\t\t\t})\n\t\t})\n\t\t.flatten ()\n\t\t.tuple_windows::\u003c(_, _, _, _)\u003e ()\n\t\t.any (|(a, b, c, d)| a == d \u0026\u0026 b == c \u0026\u0026 a != b)\n}\n\nfn iter_abas_unbracketed (addr: \u0026 str) -\u003e impl Iterator \u003cItem = (char, char)\u003e + '_ {\n\taddr.chars ()\n\t\t.scan (true, |state, ch| {\n\t\t\tSome (match ch {\n\t\t\t\t'[' =\u003e { * state = false; Some ('[') },\n\t\t\t\t']' =\u003e { * state = true; Some (']') },\n\t\t\t\t_ =\u003e (* state).then_some (ch),\n\t\t\t})\n\t\t})\n\t\t.flatten ()\n\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t.filter (|\u0026 (a, b, c)| a == c \u0026\u0026 a != b)\n\t\t.map (|(a, b, _)| (a, b))\n}\n\nfn has_bab_bracketed (addr: \u0026 str, a: char, b: char) -\u003e bool {\n\taddr.chars ()\n\t\t.scan (false, |state, ch| {\n\t\t\tSome (match ch {\n\t\t\t\t'[' =\u003e { * state = true; Some ('[') },\n\t\t\t\t']' =\u003e { * state = false; Some (']') },\n\t\t\t\t_ =\u003e (* state).then_some (ch),\n\t\t\t})\n\t\t})\n\t\t.flatten ()\n\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t.any (|(a1, b1, c1)| a == b1 \u0026\u0026 b == a1 \u0026\u0026 b == c1)\n}\n","traces":[{"line":5,"address":[30368],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[33668,34636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[30576],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":16,"address":[42516,42432,42439],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":17,"address":[23510,23486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[30784],"length":1,"stats":{"Line":1},"fn_name":"has_abba_unbracketed"},{"line":24,"address":[42576],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":25,"address":[27911,26503],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[28997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[28986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[22079,25215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[22922,22912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[30992],"length":1,"stats":{"Line":1},"fn_name":"has_abba_bracketed"},{"line":38,"address":[42656],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":39,"address":[27303,28487],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[22371,25555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[22353,25537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[25599,22415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[23072,23082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[31200],"length":1,"stats":{"Line":0},"fn_name":"iter_abas_unbracketed"},{"line":52,"address":[42736],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":53,"address":[21671,24726],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[24754,21699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[28209,26033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[26095,28271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[23472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[42816],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":65,"address":[31312],"length":1,"stats":{"Line":1},"fn_name":"has_bab_bracketed"},{"line":66,"address":[34521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[42832],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":68,"address":[22679,24310],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[22707,24338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[24320,22689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[22751,24383],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[23248],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-08","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"WIDTH=7\",\n\t\"HEIGHT=3\",\n\t\"rect 3x2\",\n\t\"rotate column x=1 by 1\",\n\t\"rotate row y=0 by 4\",\n\t\"rotate column x=1 by 1\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_err! (\"Unrecognised character: 0x402804 \u003c\u003c 96 in position 1\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":15,"address":[55044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[61834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[61893,62172,62068,62002,61855,61945],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[55076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[62236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[62546,62257,62654,62681,62297,62421],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-08","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Coord;\nuse model::Step;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @lines steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub width: Coord = (\"WIDTH=\", 50, 1_u32 .. ),\n\t\tpub height: Coord = (\"HEIGHT=\", 6, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":15,"address":[68556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[79763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[79767],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-08","lib.rs"],"content":"//! Advent of Code 2016: Day 8: Two-Factor Authentication\n//!\n//! [https://adventofcode.com/2016/day/8](https://adventofcode.com/2016/day/8)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_ocr as ocr;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Two-Factor Authentication\";\n\tyear = 2016;\n\tday = 8;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":22,"address":[58584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[59123],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-08","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Step;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tlet grid = calc_result (input);\n\tOk (grid.values ().filter (|\u0026 val| val).count ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet grid = calc_result (input);\n\tlet code = ocr::read_dots (\n\t\tgrid.iter ()\n\t\t\t.filter_map (|(pos, val)| val\n\t\t\t\t.then_some ((pos.row, pos.col)))) ?;\n\tOk (code)\n}\n\nfn calc_result (input: \u0026 Input) -\u003e GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e {\n\tlet mut grid: GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e =\n\t\tGridBuf::new_size (Pos::new (input.params.height, input.params.width));\n\tfor \u0026 step in input.steps.iter () {\n\t\tmatch step {\n\t\t\tStep::Rect { width, height } =\u003e {\n\t\t\t\tfor row in 0 .. cmp::min (height, input.params.height) {\n\t\t\t\t\tfor col in 0 .. cmp::min (width, input.params.width) {\n\t\t\t\t\t\tgrid.set (Pos { row, col }, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tStep::RotateRow { row, dist } =\u003e {\n\t\t\t\tif input.params.height \u003c= row { continue }\n\t\t\t\tlet temp: Vec \u003cbool\u003e =\n\t\t\t\t\t(0 .. input.params.width)\n\t\t\t\t\t\t.map (|col| grid.get (Pos { row, col }).unwrap ())\n\t\t\t\t\t\t.collect ();\n\t\t\t\tfor old_col in 0 .. input.params.width {\n\t\t\t\t\tlet col = (old_col + dist) % input.params.width;\n\t\t\t\t\tgrid.set (Pos { row, col }, temp [old_col.pan_usize ()]);\n\t\t\t\t}\n\t\t\t},\n\t\t\tStep::RotateCol { col, dist } =\u003e {\n\t\t\t\tif input.params.width \u003c= col { continue }\n\t\t\t\tlet temp: Vec \u003cbool\u003e =\n\t\t\t\t\t(0 .. input.params.height)\n\t\t\t\t\t\t.map (|row| grid.get (Pos { row, col }).unwrap ())\n\t\t\t\t\t\t.collect ();\n\t\t\t\tfor old_row in 0 .. input.params.height {\n\t\t\t\t\tlet row = (old_row + dist) % input.params.height;\n\t\t\t\t\tgrid.set (Pos { row, col }, temp [old_row.pan_usize ()]);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\tgrid\n}\n","traces":[{"line":7,"address":[44330,44128],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[44147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[57936],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":12,"address":[44620,44352],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":13,"address":[44377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[72707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[44539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[45768,44640],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":22,"address":[44660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[44810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[44858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[45183,45142,45120],"length":1,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[45218,45201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[45227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[44884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[44888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[37152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[45004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[45564,45010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[45083,45030],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[45252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[45256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[38128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[45369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[45375,45591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[45394,45447],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":26,"coverable":26},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-08","model.rs"],"content":"use super::*;\n\npub type Coord = u32;\npub type Pos = pos::PosRowCol \u003cCoord\u003e;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Step {\n\t\tRect { width: Coord, height: Coord } = [ \"rect \", width, \"x\", height ],\n\t\tRotateRow { row: Coord, dist: Coord } = [ \"rotate row y=\", row, \" by \", dist ],\n\t\tRotateCol { col: Coord, dist: Coord } = [ \"rotate column x=\", col, \" by \", dist ],\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-09","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLES_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"ADVENT\",\n\t\"A(1x5)BC\",\n\t\"(3x3)XYZ\",\n\t\"A(2x2)BCD(2x2)EFG\",\n\t\"(6x1)(1x3)A\",\n\t\"X(8x2)(3x3)ABCY\",\n];\n\nconst EXAMPLES_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"(3x3)XYZ\",\n\t\"X(8x2)(3x3)ABCY\",\n\t\"(27x12)(20x12)(13x14)(7x10)(1x12)A\",\n\t\"(25x3)(3x3)ABC(2x3)XY(5x2)PQRSTX(18x9)(3x2)TWO(5x7)SEVEN\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [0]]));\n\tassert_eq_ok! (\"7\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [1]]));\n\tassert_eq_ok! (\"9\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [2]]));\n\tassert_eq_ok! (\"11\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [3]]));\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [4]]));\n\tassert_eq_ok! (\"18\", puzzle.part_one (\u0026 [\u0026 EXAMPLES_ONE [5]]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"9\", puzzle.part_two (\u0026 [\u0026 EXAMPLES_TWO [0]]));\n\tassert_eq_ok! (\"20\", puzzle.part_two (\u0026 [\u0026 EXAMPLES_TWO [1]]));\n\tassert_eq_ok! (\"241920\", puzzle.part_two (\u0026 [\u0026 EXAMPLES_TWO [2]]));\n\tassert_eq_ok! (\"445\", puzzle.part_two (\u0026 [\u0026 EXAMPLES_TWO [3]]));\n}\n","traces":[{"line":22,"address":[29760,29764],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":23,"address":[32289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[32310,32371,33173,33236,32424,34161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[34125,32444,32554,33362,33302,32501],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[32574,33428,33488,32693,34086,32637],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[34047,32832,32776,32713,33554,33614],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[33680,33740,32971,32852,32915,34008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[33969,33803,32991,33054,33863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[29792,29796],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":34,"address":[34241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[35505,34376,34847,34323,34262,34910],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[34453,35036,34976,34506,34396,35469],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[35430,34645,35102,34589,34526,35162],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[35285,34784,35225,35391,34728,34665],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-09","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub stream: Vec \u003cToken\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { stream, params } = [ params, @collect stream ]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum Token {\n\t\tLetter (ch: char) = [ ch = ('A' ..= 'Z') ],\n\t\tRepeat (len: u16, num: u8) = [ \"(\", len, \"x\", num, \")\" ],\n\t}\n}\n\nimpl Token {\n\n\t#[ must_use ]\n\tpub fn display_len (self) -\u003e u32 {\n\t\tfn num_digits (num: u32) -\u003e u32 {\n\t\t\tmatch num {\n\t\t\t\t0 ..= 9 =\u003e 1,\n\t\t\t\t10 ..= 99 =\u003e 2,\n\t\t\t\t100 ..= 999 =\u003e 3,\n\t\t\t\t1_000 ..= 9_999 =\u003e 4,\n\t\t\t\t10_000 ..= 99_999 =\u003e 5,\n\t\t\t\t100_000 ..= 999_999 =\u003e 6,\n\t\t\t\t1_000_000 ..= 9_999_999 =\u003e 7,\n\t\t\t\t10_000_000 ..= 99_999_999 =\u003e 8,\n\t\t\t\t100_000_000 ..= 999_999_999 =\u003e 9,\n\t\t\t\t1_000_000_000 ..= 0x_ffff_ffff =\u003e 10,\n\t\t\t}\n\t\t}\n\t\tmatch self {\n\t\t\tSelf::Letter (_) =\u003e 1,\n\t\t\tSelf::Repeat (len, num) =\u003e\n\t\t\t\t3 + num_digits (len.pan_u32 ()) + num_digits (num.pan_u32 ()),\n\t\t}\n\t}\n\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[30474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[41952],"length":1,"stats":{"Line":1},"fn_name":"display_len"},{"line":29,"address":[42030,42185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[42195,42040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[42050,42205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[42218,42062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[42074,42231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[42086,42244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[42257,42098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[42270,42110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[42117,42278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[41957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[42292],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-09","lib.rs"],"content":"//! Advent of Code 2016: Day 9: Explosives in Cyberspace\n//!\n//! [https://adventofcode.com/2016/day/9](https://adventofcode.com/2016/day/9)\n//!\n//! # Input\n//!\n//! A stream of capital letters or repetition markers in the form `(2x3)`, where `2` is the length\n//! and `3` is the number of repetitions.\n//!\n//! # Part one\n//!\n//! Determine the uncompressed length, assuming the repetitions apply to the compressed stream\n//! directly, without recursively expanding nested repetitions inside the repeated portion.\n//!\n//! # Part two\n//!\n//! Same as part one but recursively expanded nested repeated sections.\n//!\n//! # Algorithm\n//!\n//! For part one we simply count letters directly, or count `len  num` for repeated sections,\n//! skipping the appropiate amount of data from the stream.\n//!\n//! For part two, we keep a stack of repeated sections, along with the number of repetitions at\n//! the current level, and the position in the stream where each repeated section ends.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Explosives in Cyberspace\";\n\tyear = 2016;\n\tday = 9;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":40,"address":[48456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[48776],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-09","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse input::Token;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut stream_iter = input.stream.iter ().copied ();\n\tlet mut count = 0_u32;\n\twhile let Some (token) = stream_iter.next () {\n\t\tmatch token {\n\t\t\tToken::Letter (_) =\u003e count += 1,\n\t\t\tToken::Repeat (len, num) =\u003e {\n\t\t\t\tcount += len.pan_u32 () * num.pan_u32 ();\n\t\t\t\ttake_len (\u0026 mut stream_iter, len.pan_u32 ()) ?;\n\t\t\t},\n\t\t}\n\t}\n\tOk (count)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut count = 0_u64;\n\tlet mut pos = 0;\n\tlet mut stack = Vec::new ();\n\tlet mut mul = 1_u64;\n\tlet mut next = u32::MAX;\n\tfor \u0026 token in \u0026 input.stream {\n\t\tif matches! (token, Token::Letter (_)) { chk! (count += mul) ?; }\n\t\tpos += token.display_len ();\n\t\twhile next \u003c= pos {\n\t\t\tif next \u003c pos { return Err (\"Invalid token stream\".into ()) }\n\t\t\t(mul, next) = stack.pop ().unwrap ();\n\t\t}\n\t\tif let Token::Repeat (len, num) = token {\n\t\t\tstack.push ((mul, next));\n\t\t\tchk! (mul *= num.pan_u64 ()) ?;\n\t\t\tnext = pos + len.pan_u32 ();\n\t\t}\n\t}\n\tOk (count)\n}\n\nfn take_len (mut stream_iter: impl Iterator \u003cItem = Token\u003e, mut len: u32) -\u003e GenResult \u003c()\u003e {\n\twhile 0 \u003c len {\n\t\tif let Some (token) = stream_iter.next () {\n\t\t\tlet token_len = token.display_len ();\n\t\t\tif len \u003c token_len { return Err (\"Invalid token stream\".into ()) }\n\t\t\tlen -= token_len;\n\t\t} else {\n\t\t\treturn Err (\"Invalid token stream\".into ());\n\t\t}\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[43664],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[43758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[43798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[44172,43728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[44188,43920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[44097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[44146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[45038,44256],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":27,"address":[44375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[44453,44408,44630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[44477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[44512,44607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[44528,44857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[44635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[44778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[44839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[44935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[51040],"length":1,"stats":{"Line":0},"fn_name":"take_len\u003c\u0026mut core::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003caoc_2016_day_09::input::Token\u003e\u003e\u003e"},{"line":44,"address":[43986,44052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[44037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[44043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[44048],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"value 5 goes to bot 2\",\n\t\"bot 2 gives low to bot 1 and high to bot 0\",\n\t\"value 3 goes to bot 1\",\n\t\"bot 1 gives low to output 1 and high to bot 0\",\n\t\"bot 0 gives low to output 2 and high to output 0\",\n\t\"value 2 goes to bot 2\",\n];\n\n#[ test ]\nfn part_one () {\n\tuse parser::with_params;\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 with_params ([\"LOW=3\", \"HIGH=5\"], EXAMPLE)));\n\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 with_params ([\"LOW=2\", \"HIGH=3\"], EXAMPLE)));\n\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 with_params ([\"LOW=2\", \"HIGH=5\"], EXAMPLE)));\n\tassert_err! (\"No solution found\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"30\", puzzle.part_two (EXAMPLE));\n\tassert_err! (\"No solution found\", puzzle.part_one (\u0026 EXAMPLE [1 .. ]));\n}\n","traces":[{"line":15,"address":[35956,38608,40665],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":17,"address":[38625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[39851,40561,39791,40432,38823,38881,38937],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[39131,39917,39241,40386,40547,39980,39185],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[40531,40046,39538,39428,40340,39482,40109],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[40230,40484,39715,39559,40509,39596],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[35924,41504,40688],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":26,"address":[40701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[41453,40825,40766,40722,41101,41167],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[41429,41030,40906,40880,41291,41402],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-10","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Step;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @lines steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub low: Val = (\"LOW=\", 17, .. ),\n\t\tpub high: Val = (\"HIGH=\", 61, .. ),\n\t}\n}\n","traces":[{"line":15,"address":[34571],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-10","lib.rs"],"content":"//! Advent of Code 2016: Day 10: Balance Bots\n//!\n//! [https://adventofcode.com/2016/day/10](https://adventofcode.com/2016/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Balance Bots\";\n\tyear = 2016;\n\tday = 10;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[77687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[78034],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-10","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Step;\nuse model::Target;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tfor event in events (input) ? {\n\t\tif event.low_chip == input.params.low \u0026\u0026 event.high_chip == input.params.high {\n\t\t\treturn Ok (event.from_bot);\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut output_0 = None;\n\tlet mut output_1 = None;\n\tlet mut output_2 = None;\n\tfor event in events (input) ? {\n\t\tfor (chip, target) in [\n\t\t\t(event.low_chip, event.low_target),\n\t\t\t(event.high_chip, event.high_target),\n\t\t] {\n\t\t\tif target == Target::Output (0) { output_0 = Some (chip); }\n\t\t\tif target == Target::Output (1) { output_1 = Some (chip); }\n\t\t\tif target == Target::Output (2) { output_2 = Some (chip); }\n\t\t}\n\t}\n\tmatch (output_0, output_1, output_2) {\n\t\t(Some (output_0), Some (output_1), Some (output_2)) =\u003e\n\t\t\tOk (output_0.pan_u64 () * output_1.pan_u64 () * output_2.pan_u64 ()),\n\t\t_ =\u003e Err (\"No solution found\".into ()),\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\nstruct Event {\n\tfrom_bot: Val,\n\tlow_chip: Val,\n\thigh_chip: Val,\n\tlow_target: Target,\n\thigh_target: Target,\n}\n\nfn events (input: \u0026 Input) -\u003e GenResult \u003cVec \u003cEvent\u003e\u003e {\n\n\tlet (mut bots, mut todo) = get_initial_state (input) ?;\n\n\tlet mut events: Vec \u003cEvent\u003e = Vec::new ();\n\twhile let Some (from_bot) = todo.pop () {\n\t\tlet from_bot_state = bots.get_mut (\u0026 from_bot).unwrap ();\n\n\t\tlet \u0026 low_chip = from_bot_state.chips.iter ().min ().unwrap ();\n\t\tlet \u0026 high_chip = from_bot_state.chips.iter ().max ().unwrap ();\n\t\tfrom_bot_state.chips.clear ();\n\n\t\tlet (low_target, high_target) = from_bot_state.gives.unwrap ();\n\t\tfor (chip, target) in [(low_chip, low_target), (high_chip, high_target)] {\n\n\t\t\tif let Target::Bot (to_bot) = target {\n\t\t\t\tlet to_bot_state = some_or! (\n\t\t\t\t\tbots.get_mut (\u0026 to_bot),\n\t\t\t\t\treturn Err (format! (\"Bot {from_bot} gives to unknown bot {to_bot}\")\n\t\t\t\t\t\t.into ()));\n\t\t\t\tif to_bot_state.chips.is_full () {\n\t\t\t\t\tErr (format! (\"Bot {to_bot} has too many chips\")) ?;\n\t\t\t\t}\n\t\t\t\tto_bot_state.chips.push (chip);\n\t\t\t\tif to_bot_state.chips.is_full () \u0026\u0026 to_bot_state.gives.is_some () {\n\t\t\t\t\ttodo.push (to_bot);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tevents.push (Event { from_bot, low_chip, high_chip, low_target, high_target });\n\n\t}\n\n\tOk (events)\n\n}\n\n#[ derive (Debug, Default) ]\nstruct BotState {\n\tchips: ArrayVec \u003cVal, 2\u003e,\n\tgives: Option \u003c(Target, Target)\u003e,\n}\n\nfn get_initial_state (input: \u0026 Input) -\u003e GenResult \u003c(HashMap \u003cVal, BotState\u003e, Vec \u003cVal\u003e)\u003e {\n\tlet mut bots: HashMap \u003cVal, BotState\u003e = HashMap::new ();\n\tlet mut todo: Vec \u003cVal\u003e = Vec::new ();\n\tfor step in input.steps.iter () {\n\t\tmatch * step {\n\t\t\tStep::Input { bot, val } =\u003e {\n\t\t\t\tlet bot_state = bots.entry (bot).or_default ();\n\t\t\t\tif bot_state.chips.is_full () {\n\t\t\t\t\treturn Err (format! (\"Bot {bot} has too many chips\").into ());\n\t\t\t\t}\n\t\t\t\tbot_state.chips.push (val);\n\t\t\t\tif bot_state.chips.is_full () \u0026\u0026 bot_state.gives.is_some () {\n\t\t\t\t\ttodo.push (bot);\n\t\t\t\t}\n\t\t\t},\n\t\t\tStep::Give { bot, low, high } =\u003e {\n\t\t\t\tlet bot_state = bots.entry (bot).or_default ();\n\t\t\t\tif bot_state.gives.is_some () {\n\t\t\t\t\treturn Err (format! (\"Bot {bot} gives more than once\").into ());\n\t\t\t\t}\n\t\t\t\tbot_state.gives = Some ((low, high));\n\t\t\t\tif bot_state.chips.is_full () \u0026\u0026 bot_state.gives.is_some () {\n\t\t\t\t\ttodo.push (bot);\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\tOk ((bots, todo))\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tuse input::InputParams;\n\n\t#[ test ]\n\tfn events () {\n\t\tassert_err! (\"Bot 0 gives to unknown bot 1\", logic::events (\u0026 Input {\n\t\t\tsteps: vec! [\n\t\t\t\tStep::Input { val: 1, bot: 0 },\n\t\t\t\tStep::Input { val: 2, bot: 0 },\n\t\t\t\tStep::Give { bot: 0, low: Target::Bot (1), high: Target::Bot (2) },\n\t\t\t],\n\t\t\tparams: InputParams::default (),\n\t\t}));\n\t\tassert_err! (\"Bot 0 has too many chips\", logic::events (\u0026 Input {\n\t\t\tsteps: vec! [\n\t\t\t\tStep::Input { val: 1, bot: 0 },\n\t\t\t\tStep::Input { val: 2, bot: 0 },\n\t\t\t\tStep::Input { val: 3, bot: 0 },\n\t\t\t],\n\t\t\tparams: InputParams::default (),\n\t\t}));\n\t\tassert_err! (\"Bot 0 gives more than once\", logic::events (\u0026 Input {\n\t\t\tsteps: vec! [\n\t\t\t\tStep::Give { bot: 0, low: Target::Bot (1), high: Target::Bot (2) },\n\t\t\t\tStep::Give { bot: 0, low: Target::Bot (3), high: Target::Bot (4) },\n\t\t\t],\n\t\t\tparams: InputParams::default (),\n\t\t}));\n\t}\n\n}\n","traces":[{"line":8,"address":[49056],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[49193,49133,49264,49078,49100],"length":1,"stats":{"Line":4},"fn_name":null},{"line":10,"address":[49226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[49242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[49301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[50227,49344],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[49366,49389,49542,49430,50092,50212],"length":1,"stats":{"Line":4},"fn_name":null},{"line":22,"address":[49582,50202,49734],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[49787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[49815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[49825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[49857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[50167,50066,49995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[50119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[52531,50240],"length":1,"stats":{"Line":2},"fn_name":"events"},{"line":49,"address":[50268,50391],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[50603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[50962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[51115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[51131,51146],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[51167,51386,51288,52483],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[51388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[51562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[52035,52163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[51571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[51675,51717,51577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[51768,51779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[51785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[51856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[52324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[54385,52544],"length":1,"stats":{"Line":2},"fn_name":"get_initial_state"},{"line":95,"address":[52815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[52855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[52866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[53477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[54059,54145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[53506,53513],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[53739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[53088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[53668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[54012,53926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[53674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[53697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[53703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[53810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[35892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[62914,61511,61698,62396,61574,62941],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[61466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[61997,62503,61873,62853,62880,61810],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[61772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[62622,62819,62792,62151,62088,62275],"length":1,"stats":{"Line":3},"fn_name":null},{"line":148,"address":[62071],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":52},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-10","model.rs"],"content":"use super::*;\n\npub type Val = u16;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Step {\n\t\tInput { val: Val, bot: Val } = [\n\t\t\t\"value \", val, \" goes to bot \", bot,\n\t\t],\n\t\tGive { bot: Val, low: Target, high: Target } = [\n\t\t\t\"bot \", bot, \" gives low to \", low, \" and high to \", high,\n\t\t],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Target {\n\t\tBot (bot: Val) = [ \"bot \", bot ],\n\t\tOutput (out: Val) = [ \"output \", out ],\n\t}\n}\n","traces":[{"line":18,"address":[49774,49801],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"The first floor contains a hydrogen-compatible microchip and a lithium-compatible microchip.\",\n\t\"The second floor contains a hydrogen generator.\",\n\t\"The third floor contains a lithium generator.\",\n\t\"The fourth floor contains nothing relevant.\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"The first floor contains a hydrogen generator.\",\n\t\"The second floor contains a lithium generator.\",\n\t\"The third floor contains a hydrogen-compatible microchip and a lithium-compatible microchip.\",\n\t\"The fourth floor contains nothing relevant.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"11\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"29\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":20,"address":[72132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[104314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[104652,104373,104335,104548,104425,104482],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[72196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[104714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[104773,104882,105052,104825,104735,104948],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub floors: [Floor \u003c'inp\u003e; 4],\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { floors: [ floor_0, floor_1, floor_2, floor_3 ], params } = [\n\t\tparams,\n\t\t\"The first floor contains \", floor_0, \".\\n\",\n\t\t\"The second floor contains \", floor_1, \".\\n\",\n\t\t\"The third floor contains \", floor_2, \".\\n\",\n\t\t\"The fourth floor contains \", floor_3, \".\",\n\t]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct Floor \u003c'inp\u003e {\n\t\tcomponents: Vec \u003cComponent \u003c'inp\u003e\u003e,\n\t}\n}\n\nimpl \u003c'inp\u003e Display for Floor \u003c'inp\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tif self.components.is_empty () {\n\t\t\treturn write! (formatter, \"nothing relevant\");\n\t\t}\n\t\tfor (component_idx, component) in self.components.iter ().enumerate () {\n\t\t\tif component_idx == 0 {\n\t\t\t\twrite! (formatter, \"a \") ?;\n\t\t\t} else if self.components.len () == 2 {\n\t\t\t\twrite! (formatter, \" and a \") ?;\n\t\t\t} else if component_idx \u003c self.components.len () - 1 {\n\t\t\t\twrite! (formatter, \", a \") ?;\n\t\t\t} else {\n\t\t\t\twrite! (formatter, \", and a \") ?;\n\t\t\t}\n\t\t\tDisplay::fmt (component, formatter) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Floor \u003c'inp\u003e {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet components = parser.any ()\n\t\t\t.of (|parser| {\n\t\t\t\tparser.expect (\"nothing relevant\") ?.confirm ();\n\t\t\t\tOk (vec! [])\n\t\t\t})\n\t\t\t.of (|parser| {\n\t\t\t\tlet comp = parser.expect (\"a \") ?.item () ?;\n\t\t\t\tlet mut comps = vec! [ comp ];\n\t\t\t\tloop {\n\t\t\t\t\tif parser.peek_rest ().starts_with (\", and a \") {\n\t\t\t\t\t\tlet comp: Component = parser.expect (\", and a \") ?.item () ?;\n\t\t\t\t\t\tcomps.push (comp);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlet comp = parser.expect (\", a \") ?.item () ?;\n\t\t\t\t\tcomps.push (comp);\n\t\t\t\t}\n\t\t\t\tOk (comps)\n\t\t\t})\n\t\t\t.of (|parser| {\n\t\t\t\tlet comp_0 = parser.expect (\"a \") ?.item () ?;\n\t\t\t\tlet comp_1 = parser.expect (\" and a \") ?.confirm ().item () ?;\n\t\t\t\tOk (vec! [ comp_0, comp_1 ])\n\t\t\t})\n\t\t\t.of (|parser| {\n\t\t\t\tlet comp: Component = parser.expect (\"a \") ?.item () ?;\n\t\t\t\tOk (vec! [ comp ])\n\t\t\t})\n\t\t\t.done () ?;\n\t\tOk (Self { components })\n\t}\n}\n\nenum_decl_parser_display! {\n\tinput_lifetime = 'inp;\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub enum Component \u003c'inp\u003e {\n\t\tGenerator (name: InpStr \u003c'inp\u003e) = [\n\t\t\t@str name = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 16),\n\t\t\t\" generator\",\n\t\t],\n\t\tMicrochip (name: InpStr \u003c'inp\u003e) = [\n\t\t\t@str name = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 16),\n\t\t\t\"-compatible microchip\",\n\t\t],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[145919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[146224,146270],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[108800],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[108897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[108928,110244],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":58,"address":[109256,108951,109197],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[109333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[109400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[113162,112858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[70915],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":18,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","lib.rs"],"content":"//! Advent of Code 2016: Day 11: Radioisotope Thermoelectric Generators\n//!\n//! [https://adventofcode.com/2016/day/11](https://adventofcode.com/2016/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod tools;\n\npuzzle_info! {\n\tname = \"Radioisotope Thermoelectric Generators\";\n\tyear = 2016;\n\tday = 11;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"corpus-gen\"; method = tools::corpus_gen; ),\n\t];\n}\n","traces":[{"line":21,"address":[116998],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","logic.rs"],"content":"use super::*;\n\nuse input::Component;\nuse input::Input;\nuse model::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tcalc_result (input)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tlet mut input = input.clone ();\n\tinput.floors [0].push (Component::Generator (InpStr::borrow (\"elerium\")));\n\tinput.floors [0].push (Component::Microchip (InpStr::borrow (\"elerium\")));\n\tinput.floors [0].push (Component::Generator (InpStr::borrow (\"dilithium\")));\n\tinput.floors [0].push (Component::Microchip (InpStr::borrow (\"dilithium\")));\n\tcalc_result (\u0026 input)\n}\n\nfn calc_result (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tlet (mut start_state, _names) = State::from_input (input) ?;\n\tstart_state.comps [ .. start_state.comps_len.pan_usize ()].sort ();\n\tlet mut seen = HashSet::new ();\n\tseen.insert (start_state.compact ());\n\tlet mut todo = VecDeque::new ();\n\ttodo.push_back ((start_state.compact (), 0));\n\tlet mut next_states = Vec::new ();\n\twhile let Some ((state_compact, steps)) = todo.pop_front () {\n\t\tlet state = state_compact.expand (start_state.comps_len);\n\t\tif state.is_done () { return Ok (steps) }\n\t\tnext_states.clear ();\n\t\tstate.next_states (\u0026 mut next_states);\n\t\tfor \u0026 next_state_compact in next_states.iter () {\n\t\t\tif ! seen.insert (next_state_compact) { continue }\n\t\t\ttodo.push_back ((next_state_compact, steps + 1));\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n","traces":[{"line":7,"address":[90464],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[116326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[90480,91229],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":13,"address":[90625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[90733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[90839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[90942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[91043],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[91280,92711],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":21,"address":[91305,91361,91662],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[91619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[91805],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[92019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[92025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[92042,92411],"length":1,"stats":{"Line":4},"fn_name":null},{"line":32,"address":[92080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[92207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[92245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[92551,92249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[92310],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","model.rs"],"content":"use super::*;\n\nuse input::Component;\nuse input::Input;\n\npub type Val = u16;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct State {\n\tpub comps: [[u8; 2]; 7],\n\tpub comps_len: u8,\n\tpub elevator: u8,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct StateCompact {\n\tdata: u32,\n}\n\nimpl State {\n\n\tpub fn from_input \u003c'inp\u003e (input: \u0026 Input \u003c'inp\u003e) -\u003e GenResult \u003c(Self, Vec \u003cInpStr \u003c'inp\u003e\u003e)\u003e {\n\t\tlet names: Vec \u003cInpStr\u003e =\n\t\t\tinput.floors.iter ()\n\t\t\t\t.flat_map (|floor| floor.iter ()\n\t\t\t\t\t.map (|comp| match * comp {\n\t\t\t\t\t\tComponent::Generator (ref name) =\u003e name.clone (),\n\t\t\t\t\t\tComponent::Microchip (ref name) =\u003e name.clone (),\n\t\t\t\t\t}))\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.collect ();\n\t\tif names.is_empty () { return Err (\"Must have at least one component type\".into ()) }\n\t\tif names.len () \u003e 7 { return Err (\"Only support seven types of component\".into ()) }\n\t\tlet comp_floor = |comp|\n\t\t\tinput.floors.iter ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.flat_map (|(floor_idx, floor)| floor.iter ()\n\t\t\t\t\t.map (move |comp| ((floor_idx + 1).pan_u8 (), comp)))\n\t\t\t\t.filter (|\u0026 (_, some_comp)| * some_comp == comp)\n\t\t\t\t.map (|(floor, _)| floor)\n\t\t\t\t.exactly_one ()\n\t\t\t\t.map_err (|_err| \"Must have exactly one generator of each type\");\n\t\tOk ((Self {\n\t\t\tcomps: names.iter ()\n\t\t\t\t.map (|name| Ok::\u003c_, GenError\u003e ([\n\t\t\t\t\tcomp_floor (Component::Generator (name.clone ())) ?,\n\t\t\t\t\tcomp_floor (Component::Microchip (name.clone ())) ?,\n\t\t\t\t]))\n\t\t\t\t.chain (iter::from_fn (|| Some (Ok ([1, 1]))))\n\t\t\t\t.take (7)\n\t\t\t\t.try_array () ?,\n\t\t\tcomps_len: names.len ().pan_u8 (),\n\t\t\televator: 1,\n\t\t}, names))\n\t}\n\n\tpub fn next_states (\u0026 self, results: \u0026 mut Vec \u003cStateCompact\u003e) {\n\t\tlet mut next_floors = ArrayVec::\u003cu8, 2\u003e::new ();\n\t\tif self.elevator \u003e 1 { next_floors.push (self.elevator - 1); }\n\t\tif self.elevator \u003c 4 { next_floors.push (self.elevator + 1); }\n\t\tfor name_idx_0 in 0 .. self.comps_len.pan_usize () {\n\t\t\tfor comp_idx_0 in 0 .. 2 {\n\t\t\t\tif self.comps [name_idx_0] [comp_idx_0] != self.elevator { continue }\n\t\t\t\tfor \u0026 next_floor in next_floors.iter () {\n\t\t\t\t\tlet mut next_state = * self;\n\t\t\t\t\tnext_state.elevator = next_floor;\n\t\t\t\t\tnext_state.comps [name_idx_0] [comp_idx_0] = next_floor;\n\t\t\t\t\tif next_state.is_valid () {\n\t\t\t\t\t\tnext_state.comps [ .. next_state.comps_len.pan_usize ()].sort ();\n\t\t\t\t\t\tresults.push (next_state.compact ());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor name_idx_1 in name_idx_0 .. self.comps_len.pan_usize () {\n\t\t\t\t\tfor comp_idx_1 in 0 .. 2 {\n\t\t\t\t\t\tif self.comps [name_idx_1] [comp_idx_1] != self.elevator { continue }\n\t\t\t\t\t\tif (name_idx_0, comp_idx_0) \u003e= (name_idx_1, comp_idx_1) { continue }\n\t\t\t\t\t\tfor \u0026 next_floor in next_floors.iter () {\n\t\t\t\t\t\t\tlet mut next_state = * self;\n\t\t\t\t\t\t\tnext_state.elevator = next_floor;\n\t\t\t\t\t\t\tnext_state.comps [name_idx_0] [comp_idx_0] = next_floor;\n\t\t\t\t\t\t\tnext_state.comps [name_idx_1] [comp_idx_1] = next_floor;\n\t\t\t\t\t\t\tif next_state.is_valid () {\n\t\t\t\t\t\t\t\tnext_state.comps [ .. next_state.comps_len.pan_usize ()].sort ();\n\t\t\t\t\t\t\t\tresults.push (next_state.compact ());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfn is_valid (\u0026 self) -\u003e bool {\n\t\tfor name_idx_0 in 0 .. self.comps_len.pan_usize () {\n\t\t\tif self.comps [name_idx_0] [1] == self.comps [name_idx_0] [0] { continue }\n\t\t\tfor name_idx_1 in 0 .. self.comps_len.pan_usize () {\n\t\t\t\tif name_idx_1 == name_idx_0 { continue }\n\t\t\t\tif self.comps [name_idx_0] [1] == self.comps [name_idx_1] [0] { return false }\n\t\t\t}\n\t\t}\n\t\ttrue\n\t}\n\n\t#[ must_use ]\n\tpub fn is_done (\u0026 self) -\u003e bool {\n\t\tself.comps.iter ()\n\t\t\t.take (self.comps_len.pan_usize ())\n\t\t\t.all (|\u0026 [gen, chip]| gen == 4 \u0026\u0026 chip == 4)\n\t}\n\n\t#[ must_use ]\n\tpub fn compact (\u0026 self) -\u003e StateCompact {\n\t\tlet mut data = BitPusher::new ();\n\t\tfor \u0026 [ gen, chip ] in \u0026 self.comps {\n\t\t\tdata.push (gen.pan_u64 () - 1, 2);\n\t\t\tdata.push (chip.pan_u64 () - 1, 2);\n\t\t}\n\t\tdata.push (self.elevator.pan_u64 () - 1, 2);\n\t\tStateCompact { data: data.finish () }\n\t}\n\n}\n\nimpl StateCompact {\n\n\t#[ must_use ]\n\tpub fn expand (self, comps_len: u8) -\u003e State {\n\t\tlet mut data = BitPopper::new (self.data);\n\t\tlet comps = array::from_fn (|_| [\n\t\t\tdata.pop::\u003cu8\u003e (2) + 1,\n\t\t\tdata.pop::\u003cu8\u003e (2) + 1,\n\t\t]);\n\t\tlet elevator = data.pop::\u003cu8\u003e (2) + 1;\n\t\tState { comps, comps_len, elevator }\n\t}\n\n}\n","traces":[{"line":22,"address":[55606,55008],"length":1,"stats":{"Line":1},"fn_name":"from_input"},{"line":23,"address":[55066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[106420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[55183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[55185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":38,"address":[111760],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":39,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[106323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":45,"address":[55311,55428,55337],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[56984,55616],"length":1,"stats":{"Line":2},"fn_name":"next_states"},{"line":59,"address":[55636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[55650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[56846,55686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[55781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[55828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[55884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[55931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[56012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[56020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[56024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[56027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[56115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[56252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[56312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[56385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[56458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[56540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[56548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[56552],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[56555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[56559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[56647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[56992],"length":1,"stats":{"Line":2},"fn_name":"is_valid"},{"line":95,"address":[57066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[57160,57344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[57232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[57279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[57284,57318],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[57376],"length":1,"stats":{"Line":2},"fn_name":"is_done"},{"line":109,"address":[57509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[57632],"length":1,"stats":{"Line":2},"fn_name":"compact"},{"line":115,"address":[57871,57696,57857],"length":1,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[58001,57754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[57824,58017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[57953,58044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[58096],"length":1,"stats":{"Line":2},"fn_name":"expand"},{"line":129,"address":[58107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[112496],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":131,"address":[54120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[58250],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":55,"coverable":68},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-11","tools.rs"],"content":"use super::*;\n\nuse std::fs::File;\nuse std::io::Read as _;\nuse std::io::Write as _;\nuse std::path::PathBuf;\nuse std::process::Command;\nuse std::process::Stdio;\n\n#[ derive (clap::Parser) ]\npub struct CorpusGenArgs {\n\n\t#[ clap (long, default_value = \"fuzz/corpus/2016-day-11\") ]\n\toutput_dir: PathBuf,\n\n\t#[ clap (long, default_value = \"10\") ]\n\tnum_files: usize,\n\n\t#[ clap (long, default_value = \"5\") ]\n\tnum_comps: usize,\n\n\t#[ clap (long, default_value = \"4\") ]\n\tname_len: usize,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\npub fn corpus_gen (args: CorpusGenArgs) -\u003e GenResult \u003c()\u003e {\n\tlet mut rand = File::open (\"/dev/urandom\") ?;\n\tfor _ in 0 .. args.num_files {\n\t\tlet names =\n\t\t\titer::from_fn (\n\t\t\t\t\t|| -\u003e Option \u003cString\u003e {\n\t\t\t\t\t\tlet mut name = String::new ();\n\t\t\t\t\t\twhile name.len () \u003c args.name_len {\n\t\t\t\t\t\t\tlet mut buf = [0];\n\t\t\t\t\t\t\tassert_eq! (rand.read (\u0026 mut buf).unwrap (), 1);\n\t\t\t\t\t\t\tlet ch = ok_or! (buf [0].to_char (), continue);\n\t\t\t\t\t\t\tif ! ch.is_ascii_lowercase () { continue }\n\t\t\t\t\t\t\tname.push (ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSome (name)\n\t\t\t\t\t})\n\t\t\t\t.take (args.num_comps)\n\t\t\t\t.collect::\u003cVec \u003cString\u003e\u003e ();\n\t\tlet comps =\n\t\t\titer::from_fn (\n\t\t\t\t\t|| -\u003e Option \u003c[u8; 2]\u003e {\n\t\t\t\t\t\tlet mut buf = [0];\n\t\t\t\t\t\tassert_eq! (rand.read (\u0026 mut buf).unwrap (), 1);\n\t\t\t\t\t\tSome ([(buf [0] \u0026 0x3) + 1, ((buf [0] \u003e\u003e 2_u32) \u0026 0x3) + 1])\n\t\t\t\t\t})\n\t\t\t\t.take (7)\n\t\t\t\t.collect::\u003cVec \u003c[u8; 2]\u003e\u003e ();\n\t\tlet mut output = String::new ();\n\t\tfor floor in 1 ..= 4 {\n\t\t\tlet mut items = Vec::new ();\n\t\t\tfor (name, [gen, chip]) in\n\t\t\t\tnames.iter ()\n\t\t\t\t\t.zip (comps.iter ().copied ())\n\t\t\t\t\t.take (args.num_comps) {\n\t\t\t\tif gen == floor {\n\t\t\t\t\titems.push (format! (\"{} generator\", name));\n\t\t\t\t}\n\t\t\t\tif chip == floor {\n\t\t\t\t\titems.push (format! (\"{}-compatible microchip\", name));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet floor_name = match floor {\n\t\t\t\t1 =\u003e \"first\", 2 =\u003e \"second\", 3 =\u003e \"third\", 4 =\u003e \"fourth\",\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t};\n\t\t\tif items.is_empty () {\n\t\t\t\twriteln! (\u0026 mut output, \"The {} floor contains nothing relevant.\",\n\t\t\t\t\tfloor_name).unwrap ();\n\t\t\t} else if items.len () == 1 {\n\t\t\t\twriteln! (\u0026 mut output, \"The {} floor contains a {}.\", floor_name,\n\t\t\t\t\titems [0]).unwrap ();\n\t\t\t} else if items.len () == 2 {\n\t\t\t\twriteln! (\u0026 mut output, \"The {} floor contains a {} and a {}.\", floor_name,\n\t\t\t\t\titems [0], items [1]).unwrap ();\n\t\t\t} else {\n\t\t\t\twrite! (\u0026 mut output, \"The {} floor contains a {}\", floor_name, items [0]).unwrap ();\n\t\t\t\tfor item in \u0026 items [1 .. items.len () - 1] {\n\t\t\t\t\twrite! (\u0026 mut output, \", a {}\", item).unwrap ();\n\t\t\t\t}\n\t\t\t\twriteln! (\u0026 mut output, \", and a {}.\", items [items.len () - 1]).unwrap ();\n\t\t\t}\n\t\t}\n\t\tlet mut sum_command =\n\t\t\tCommand::new (\"sha1sum\")\n\t\t\t\t.stdin (Stdio::piped ())\n\t\t\t\t.stdout (Stdio::piped ())\n\t\t\t\t.spawn ()\n\t\t\t\t.unwrap ();\n\t\tlet mut sum_stdin = sum_command.stdin.take ().unwrap ();\n\t\tsum_stdin.write_all (output.as_bytes ()).unwrap ();\n\t\tdrop (sum_stdin);\n\t\tlet sum_output = sum_command.wait_with_output ().unwrap ();\n\t\tlet sum_output_vec = sum_output.stdout [0 .. 40].to_vec ();\n\t\tlet sum_output_str = String::from_utf8 (sum_output_vec).unwrap ();\n\t\tlet mut output_path = args.output_dir.clone ();\n\t\toutput_path.push (sum_output_str);\n\t\tlet mut output_file = File::create (output_path).unwrap ();\n\t\toutput_file.write_all (output.as_bytes ()).unwrap ();\n\t}\n\tOk (())\n}\n","traces":[{"line":28,"address":[134560,130128],"length":1,"stats":{"Line":0},"fn_name":"corpus_gen"},{"line":29,"address":[130226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[130276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[83473,82992],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":35,"address":[83036,83106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[83115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[83120,83404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[83256],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[83358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[130359],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[83488],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":49,"address":[58373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[58463,58378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[58432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[132663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[130484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[130811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[130783,130495,130627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[130623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[130819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[130828,130937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[130988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[130997,131106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[131168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[131199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[131286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[131399,131305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[131456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[131477,131514,131622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[131494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[131680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[131900,131776,131738,131701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[131718,131753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[131943,132088],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[132126,132192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[132365,132268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[132533,132399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[132777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[132743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[132760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[132858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[132888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[132923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[132945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[133343,133127],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[133404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[133468,133533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[133554],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":48},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"cpy 41 a\",\n\t\"inc a\",\n\t\"inc a\",\n\t\"dec a\",\n\t\"jnz a 2\",\n\t\"dec a\",\n\t\"dec c\",\n\t\"jnz c 3\",\n\t\"dec a\",\n\t\"dec a\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"42\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"40\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[26432,26823],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":20,"address":[26442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[26676,26463,26553,26780,26501,26610],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[27223,26832],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":26,"address":[26842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[27076,26863,26953,27180,26901,27010],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-12","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse cpu::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub ops_limit: u32 = (\"OPS_LIMIT=\", 100_000_000, 1 .. ),\n\t}\n}\n","traces":[{"line":14,"address":[31285,31760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[38061],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-12","lib.rs"],"content":"//! Advent of Code 2016: Day 12: Leonardo's Monorail\n//!\n//! [https://adventofcode.com/2016/day/12](https://adventofcode.com/2016/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2016_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Leonardo's Monorail\";\n\tyear = 2016;\n\tday = 12;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[45351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[45703],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-12","logic.rs"],"content":"use super::*;\n\nuse cpu::Cpu;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tcheck_input (input) ?;\n\tlet mut cpu = Cpu {\n\t\tinstrs: Rc::new (input.instrs.clone ()),\n\t\tlimit: input.params.ops_limit,\n\t\t.. Cpu::default ()\n\t};\n\tcpu.exec () ?;\n\tOk (cpu.reg_a)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tcheck_input (input) ?;\n\tlet mut cpu = Cpu {\n\t\tinstrs: Rc::new (input.instrs.clone ()),\n\t\treg_c: 1,\n\t\tlimit: input.params.ops_limit,\n\t\t.. Cpu::default ()\n\t};\n\tcpu.exec () ?;\n\tOk (cpu.reg_a)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif let Some (\u0026 instr) = input.instrs.iter ().find (|\u0026 instr| ! instr.is_v1 ()) {\n\t\treturn Err (format! (\"Invalid instrucction: {instr:?}\").into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[33184,33493],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[33199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[33253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[33279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[33409,33358,33379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[33414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[33504,33820],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[33519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[33573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[33599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[33685,33706,33736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[33741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[33840],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":30,"address":[33872,33849,34031,33909],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[34018,33934],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"END_X=7\", \"END_Y=4\", \"MAX_DIST=20\", \"COUNT_DIST=10\", \"10\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"11\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"18\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[31524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[49738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[49906,49759,49972,50076,49797,49849],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[31492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[50138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[50476,50306,50372,50159,50197,50249],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-13","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\nuse model::Coord;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub seed: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { seed, params } = [ params, seed ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub start_x: Coord = (\"START_X=\", 1, 1 .. ),\n\t\tpub start_y: Coord = (\"START_Y=\", 1, 1 .. ),\n\t\tpub end_x: Coord = (\"END_X=\", 31, 1 .. ),\n\t\tpub end_y: Coord = (\"END_Y=\", 39, 1 .. ),\n\t\tpub max_dist: u32 = (\"MAX_DIST=\", 500, 1 .. ),\n\t\tpub count_dist: u32 = (\"COUNT_DIST=\", 50, 1.. ),\n\t}\n}\n","traces":[{"line":20,"address":[56693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[56697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[56701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[56705],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[56709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[56713],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-13","lib.rs"],"content":"//! Advent of Code 2016: Day 13: A Maze of Twisty Little Cubicles\n//!\n//! [https://adventofcode.com/2016/day/13](https://adventofcode.com/2016/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"A Maze of Twisty Little Cubicles\";\n\tyear = 2016;\n\tday = 13;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[43161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[43465],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-13","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\titer_posns (input)\n\t\t\t.take_while (|\u0026 (_, dist)| dist \u003c= input.params.max_dist)\n\t\t\t.find (|\u0026 (pos, _)| pos == Pos::new (input.params.end_x, input.params.end_y))\n\t\t\t.map (|(_, dist)| dist)\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\titer_posns (input)\n\t\t\t.take_while (|\u0026 (_, dist)| dist \u003c= input.params.count_dist)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\nfn iter_posns (input: \u0026 Input) -\u003e impl Iterator \u003cItem = (Pos, u32)\u003e + '_ {\n\tlet mut todo = VecDeque::new ();\n\ttodo.push_back ((Pos::new (input.params.start_x, input.params.start_y), 0_u32));\n\tlet mut seen = HashSet::new ();\n\tseen.insert (Pos::new (input.params.start_x, input.params.start_y));\n\titer::from_fn (move || {\n\t\tlet (pos, dist) = some_or! (todo.pop_front (), return None);\n\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\tlet Pos { x, y } = adj_pos;\n\t\t\tif (x*x + 3*x + 2*x*y + y + y*y + input.seed).count_ones () \u0026 1 == 1 { continue }\n\t\t\ttodo.push_back ((adj_pos, dist + 1));\n\t\t}\n\t\tSome ((pos, dist))\n\t})\n}\n","traces":[{"line":6,"address":[33488,33773],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[33516,33682],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[30710,33572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[47692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[41824],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":16,"address":[33792],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[33816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[41840],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":25,"address":[34761,34128],"length":1,"stats":{"Line":2},"fn_name":"iter_posns"},{"line":27,"address":[34306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[34521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[34539],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[41933],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[42120,41969,42604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[42140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[42266,42144],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[42272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[42344],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-13","model.rs"],"content":"use super::*;\n\npub type Coord = u32;\npub type Pos = pos::PosXY \u003cCoord\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_KEYS=16\",\n\t\"NUM_NEXT=1000\",\n\t\"HASH_REPS=16\",\n\t\"MAX_THREADS=2\",\n\t\"abc\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1144\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4684\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[22708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[77353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[77622,77692,77374,77519,77408,77450],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[22612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[77737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[77758,78076,78006,77834,77903,77792],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-14","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub salt: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { salt, params } = [\n\t\tparams,\n\t\t@str salt = (|ch| { ch.is_ascii_lowercase () }, 1 .. ),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_keys: u32 = (\"NUM_KEYS=\", 64, 1 ..= 100),\n\t\tpub num_next: u32 = (\"NUM_NEXT=\", 1000, 1 ..= 2000),\n\t\tpub hash_reps: u32 = (\"HASH_REPS=\", 2016, 1 ..= 3000),\n\t\tpub max_threads: usize = (\"MAX_THREADS=\", usize::MAX, 1 .. ),\n\t\tpub batch_size: usize = (\"BATCH_SIZE=\", 1000, 1 .. 10_000),\n\t}\n}\n","traces":[{"line":13,"address":[78293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[79488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[79492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[79496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[79500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[79483],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":5,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-14","lib.rs"],"content":"//! Advent of Code 2016: Day 14: One-Time Pad\n//!\n//! [https://adventofcode.com/2016/day/14](https://adventofcode.com/2016/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_md5 as md5;\nuse aoc_parallel as parallel;\nuse parallel::ThreadMap;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"One-Time Pad\";\n\tyear = 2016;\n\tday = 14;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":21,"address":[72798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[73198],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-14","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tkey_indexes (input, 0)\n\t\t\t.nth (input.params.num_keys.pan_usize () - 1)\n\t\t\t.unwrap ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tkey_indexes (input, input.params.hash_reps)\n\t\t\t.nth (input.params.num_keys.pan_usize () - 1)\n\t\t\t.unwrap ()\n\t)\n}\n\nstruct KeyIndexIter \u003cHashesIter: Iterator\u003e {\n\thashes: MultiPeek \u003cHashesIter\u003e,\n\tidx: u32,\n\tnum_next: u32,\n}\n\n#[ inline ]\nfn key_indexes (\n\tinput: \u0026 Input,\n\thash_reps: u32,\n) -\u003e KeyIndexIter \u003cimpl Iterator \u003cItem = [u8; 32]\u003e\u003e {\n\tKeyIndexIter {\n\t\thashes: hashes_iter (input, hash_reps).multipeek (),\n\t\tidx: 0,\n\t\tnum_next: input.params.num_next,\n\t}\n}\n\nimpl \u003cHashesIter\u003e Iterator for KeyIndexIter \u003cHashesIter\u003e\n\twhere HashesIter: Iterator \u003cItem = [u8; 32]\u003e {\n\n\ttype Item = u32;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cu32\u003e {\n\t\tloop {\n\t\t\tlet hash_0 = self.hashes.next ().unwrap ();\n\t\t\tif let Some (ch_0) = find_triple (\u0026 hash_0) {\n\t\t\t\tfor _ in 0 .. self.num_next.pan_usize () {\n\t\t\t\t\tif ! has_quintuple (self.hashes.peek ().unwrap (), ch_0) { continue }\n\t\t\t\t\tself.idx += 1;\n\t\t\t\t\treturn Some (self.idx - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.idx += 1;\n\t\t}\n\t}\n\n}\n\nfn find_triple (hash: \u0026 [u8; 32]) -\u003e Option \u003cu8\u003e {\n\thash.iter ()\n\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t.filter (|\u0026 (\u0026 a, \u0026 b, \u0026 c)| a == b \u0026\u0026 a == c)\n\t\t.map (|(\u0026 a, _, _)| a)\n\t\t.next ()\n}\n\nfn has_quintuple (hash: \u0026 [u8; 32], ch_0: u8) -\u003e bool {\n\thash.iter ()\n\t\t.fold ((false, 0_u32), |(matched, count), \u0026 ch_1|\n\t\t\tif matched || (ch_0 == ch_1 \u0026\u0026 count == 4) { (true, 0) }\n\t\t\telse if ch_0 == ch_1 { (false, count + 1) }\n\t\t\telse { (false, 0) }\n\t\t).0\n}\n\nfn hashes_iter (\n\tinput: \u0026 Input,\n\thash_reps: u32,\n) -\u003e impl Iterator \u003cItem = [u8; 32]\u003e {\n\tlet salt = input.salt.to_owned ();\n\tlet batch_size = input.params.batch_size;\n\tlet map_fn = move |num_start| {\n\t\tlet mut buffer = salt.clone ();\n\t\t(num_start .. )\n\t\t\t.take (batch_size)\n\t\t\t.map (|num| {\n\t\t\t\tbuffer.truncate (salt.len ());\n\t\t\t\twrite! (\u0026 mut buffer, \"{}\", num).unwrap ();\n\t\t\t\tstretched_hash (\u0026 buffer, hash_reps)\n\t\t\t})\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t};\n\tThreadMap::start (\n\t\t\t(0_i32 .. ).step_by (batch_size),\n\t\t\tmap_fn,\n\t\t\tparallel::num_cpus_max (input.params.max_threads))\n\t\t.flatten ()\n}\n\n#[ inline ]\nfn stretched_hash (input: \u0026 str, hash_reps: u32) -\u003e [u8; 32] {\n\tlet mut hasher = md5::MD5::new ();\n\thasher.update (input.as_bytes ());\n\tlet mut hash = hasher.finish_reset ();\n\tfor _ in 0 .. hash_reps {\n\t\thasher.update (\u0026 hash.as_hex_bytes ());\n\t\thash = hasher.finish_reset ();\n\t}\n\thash.as_hex_bytes ()\n}\n","traces":[{"line":5,"address":[69728,70201],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[70108,70025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[70697,70224],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":15,"address":[70242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[70522,70604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[69754,70253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[70004,70501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[55360],"length":1,"stats":{"Line":1},"fn_name":"next\u003ccore::iter::adapters::flatten::Flatten\u003caoc_parallel::ThreadMap\u003ccore::iter::adapters::step_by::StepBy\u003ccore::ops::range::RangeFrom\u003ci32\u003e\u003e, alloc::vec::Vec\u003c[u8; 32], alloc::alloc::Global\u003e\u003e\u003e\u003e"},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[70720],"length":1,"stats":{"Line":0},"fn_name":"find_triple"},{"line":64,"address":[53381,52976,55566,55586,55545,55604],"length":1,"stats":{"Line":7},"fn_name":null},{"line":65,"address":[53011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[70880],"length":1,"stats":{"Line":0},"fn_name":"has_quintuple"},{"line":71,"address":[70926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[56024,55732,55722,56031],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[80452,80467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[56071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[71449,71008],"length":1,"stats":{"Line":1},"fn_name":"hashes_iter"},{"line":83,"address":[71123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[52215],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[51412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[51433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[56112],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":89,"address":[56131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[56208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[56313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[71186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[71419,71236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":31,"coverable":43},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Disc #1 has 5 positions; at time=0, it is at position 4.\",\n\t\"Disc #2 has 2 positions; at time=0, it is at position 1.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"85\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[32132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[44698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[44809,44719,45036,44932,44757,44866],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[32084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[45098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[45209,45119,45266,45332,45436,45157],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-15","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub discs: Vec \u003cDisc\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { discs, params } = [ params, @lines discs ]\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\npub struct Disc {\n\tpub delay: u8,\n\tpub num_posns: u8,\n\tpub start_pos: u8,\n}\n\nstruct_parser_display! {\n\tDisc { delay, num_posns, start_pos } = [\n\t\t\"Disc #\", delay = 0 ..= 100, \" \",\n\t\t\"has \", num_posns = 1 ..= 100, \" positions; \",\n\t\t\"at time=0, it is at position \", start_pos, \".\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[31691],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-15","lib.rs"],"content":"//! Advent of Code 2016: Day 15: Timing is Everything\n//!\n//! [https://adventofcode.com/2016/day/15](https://adventofcode.com/2016/day/15)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Timing is Everything\";\n\tyear = 2016;\n\tday = 15;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[48056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[48376],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-15","logic.rs"],"content":"use super::*;\n\nuse input::Disc;\nuse input::Input;\n\n/// Implementation for part one\n///\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (\u0026 input.discs)\n}\n\n/// Implementation for part two\n///\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (\n\t\t\u0026 input.discs.iter ().copied ()\n\t\t\t.chain (iter::once (Disc {\n\t\t\t\tdelay: input.discs.len ().pan_u8 () + 1,\n\t\t\t\tnum_posns: 11,\n\t\t\t\tstart_pos: 0,\n\t\t\t}))\n\t\t\t.collect::\u003cVec \u003cDisc\u003e\u003e ()\n\t)\n}\n\n/// Main logic for both parts, takes a list of discs and calculates the start time.\n///\n/// We iterate over each disc, finding the first start time at which all discs up to this point\n/// will be in the right positions. We start off with start time zero and add one each time,\n/// but we also increase the stepping each time to the lowest common multiplier of all discs so\n/// far.\n/// \npub fn calc_result (discs: \u0026 [Disc]) -\u003e GenResult \u003cu64\u003e {\n\tlet (time, _) = discs.iter ()\n\t\t.fold (Ok ((0_u64, 1_u64)), |state, disc|\n\t\t\tstate.and_then (|(time, step)| Ok::\u003c_, GenError\u003e ((\n\t\t\t\t(time .. )\n\t\t\t\t\t.step_by (step.pan_usize ())\n\t\t\t\t\t.take (disc.num_posns.pan_usize ())\n\t\t\t\t\t.find (|time|\n\t\t\t\t\t\t(time + disc.delay.pan_u64 () + disc.start_pos.pan_u64 ())\n\t\t\t\t\t\t\t% disc.num_posns.pan_u64 () == 0)\n\t\t\t\t\t.ok_or (\"No solution found\") ?,\n\t\t\t\t(step .. )\n\t\t\t\t\t.step_by (step.pan_usize ())\n\t\t\t\t\t.find (|step| step % disc.num_posns.pan_u64 () == 0)\n\t\t\t\t\t.unwrap (),\n\t\t\t)))) ?;\n\tOk (time)\n}\n","traces":[{"line":8,"address":[43840],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":14,"address":[44671,44160],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[44271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[44256,44595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[44521,44057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[36608],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":36,"address":[36672,37043,36615],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":37,"address":[36908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[37152],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":41,"address":[37282,37385,37160,37341],"length":1,"stats":{"Line":6},"fn_name":null},{"line":42,"address":[37363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[37021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[37440,37444,37516],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":49,"address":[44556,44095],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-16","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"DISK_SIZE_ONE=20\",\n\t\"DISK_SIZE_TWO=80\",\n\t\"10000\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"01100\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"11010\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[34756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[48234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[48255,48293,48345,48402,48468,48572],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[34724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[48634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[48655,48802,48693,48745,48868,48972],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-16","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub initial_state: Vec \u003cBit\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { initial_state, params } = [\n\t\tparams,\n\t\t@collect_some_max 63 initial_state,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\npub struct Disc {\n\tpub delay: u8,\n\tpub num_posns: u8,\n\tpub start_pos: u8,\n}\n\nstruct_parser_display! {\n\tDisc { delay, num_posns, start_pos } = [\n\t\t\"Disc #\", delay = 0 ..= 100, \" \",\n\t\t\"has \", num_posns = 1 ..= 100, \" positions; \",\n\t\t\"at time=0, it is at position \", start_pos, \".\",\n\t]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Bit {\n\t\tZero = [ \"0\" ],\n\t\tOne = [ \"1\" ],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub disk_size_one: u32 = (\"DISK_SIZE_ONE=\", 272, 1 .. ),\n\t\tpub disk_size_two: u32 = (\"DISK_SIZE_TWO=\", 35_651_584, 1 .. ),\n\t}\n}\n","traces":[{"line":12,"address":[36478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[36528],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":44,"address":[37315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[37319],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-16","lib.rs"],"content":"//! Advent of Code 2016: Day 16: Dragon Checksum\n//!\n//! [https://adventofcode.com/2016/day/16](https://adventofcode.com/2016/day/16)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Dragon Checksum\";\n\tyear = 2016;\n\tday = 16;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-16","logic.rs"],"content":"use super::*;\n\nuse input::Bit;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tOk (calc_result (\u0026 input.initial_state, input.params.disk_size_one))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tOk (calc_result (\u0026 input.initial_state, input.params.disk_size_two))\n}\n\nfn calc_result (state: \u0026 [Bit], disk_size: u32) -\u003e String {\n\n\t// iterator over packed integers with bits from sequence\n\n\tlet mut extend_iter = ExtendIter::new (state);\n\n\t// work out checksum size and number of bits they span in the original\n\n\tlet mut sum_bits = disk_size;\n\tlet mut span_bits = 1_u32;\n\twhile sum_bits \u0026 1 == 0 { sum_bits /= 2; span_bits *= 2; }\n\n\t// iterate to build up the result string\n\n\tlet mut result = String::new ();\n\tlet mut cur = 0;\n\tlet mut cur_bits = 0;\n\tfor _ in 0 .. sum_bits {\n\n\t\t// iterate over the appropriate number of bits\n\n\t\tlet mut span_rem = span_bits;\n\t\tlet mut sum = 0;\n\t\twhile span_rem \u003e 0 {\n\n\t\t\t// get another packed word from the iterator\n\n\t\t\tif cur_bits == 0 {\n\t\t\t\tcur = extend_iter.next ().unwrap ();\n\t\t\t\tcur_bits = 64;\n\t\t\t}\n\n\t\t\t// count the relevant one bits\n\n\t\t\tif cur_bits \u003c= span_rem {\n\t\t\t\tsum += cur.count_ones ();\n\t\t\t\tspan_rem -= cur_bits;\n\t\t\t\tcur_bits = 0;\n\t\t\t} else {\n\t\t\t\tsum += (cur \u003e\u003e (64 - span_rem)).count_ones ();\n\t\t\t\tcur \u003c\u003c= span_rem;\n\t\t\t\tcur_bits -= span_rem;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t// append the result to the string\n\n\t\twrite! (\u0026 mut result, \"{}\", (sum \u0026 1) ^ 1).unwrap ();\n\n\t}\n\n\tresult\n\n}\n\nstruct ExtendIter {\n\tdata: u64,\n\tdata_rev: u64,\n\tdata_bits: u32,\n\tcur: u64,\n\tcur_bits: u32,\n\trev: bool,\n\tcount: usize,\n}\n\nimpl ExtendIter {\n\n\tfn new (data_vec: \u0026 [Bit]) -\u003e Self {\n\n\t\tlet data_bits = data_vec.len ().pan_u32 ();\n\n\t\t// convert vec to bit pattern\n\n\t\tlet mut data = 0_u64;\n\t\tfor bit in data_vec.iter ().copied () {\n\t\t\tdata \u003c\u003c= 1_u32;\n\t\t\tif bit == Bit::One { data |= 1; }\n\t\t}\n\n\t\t// also convert to inverted and reversed bit pattern\n\n\t\tlet mut data_rev = 0_u64;\n\t\tfor bit in data_vec.iter ().rev ().copied () {\n\t\t\tdata_rev \u003c\u003c= 1_u32;\n\t\t\tif bit == Bit::Zero { data_rev |= 1; }\n\t\t}\n\n\t\t// construct\n\n\t\tSelf {\n\t\t\tdata,\n\t\t\tdata_rev,\n\t\t\tdata_bits,\n\t\t\tcur: 0,\n\t\t\tcur_bits: 0,\n\t\t\trev: false,\n\t\t\tcount: usize::MAX,\n\t\t}\n\n\t}\n\n\tfn calc_sep_bit (old_count: usize) -\u003e u64 {\n\t\tlet new_count = old_count + 1;\n\t\tlet changes = old_count ^ new_count;\n\t\tlet bit_idx = usize::BITS - changes.leading_zeros ();\n\t\tu64::from (new_count \u0026 (1 \u003c\u003c bit_idx) != 0)\n\t}\n\n}\n\nimpl Iterator for ExtendIter {\n\n\ttype Item = u64;\n\n\tfn next (\u0026 mut self) -\u003e Option \u003cu64\u003e {\n\n\t\t// build up packed bits iteratively\n\n\t\tlet mut val = 0;\n\t\tlet mut val_bits = 0;\n\t\twhile val_bits \u003c 64 {\n\n\t\t\t// work out next chunk of bits - single 0 or 1, plus data or data_rev\n\n\t\t\tif self.cur_bits == 0 {\n\t\t\t\tself.cur = 0;\n\t\t\t\tif self.count == usize::MAX {\n\t\t\t\t\tself.count = 0;\n\t\t\t\t} else {\n\t\t\t\t\tself.cur = Self::calc_sep_bit (self.count);\n\t\t\t\t\tself.count += 1;\n\t\t\t\t\tself.cur_bits = 1;\n\t\t\t\t}\n\t\t\t\tself.cur \u003c\u003c= self.data_bits;\n\t\t\t\tself.cur |= if self.rev { self.data_rev } else { self.data };\n\t\t\t\tself.cur_bits += self.data_bits;\n\t\t\t\tself.rev = ! self.rev;\n\t\t\t}\n\n\t\t\t// append bits to result\n\n\t\t\tif val_bits + self.cur_bits \u003c= 64 {\n\t\t\t\tval |= self.cur \u003c\u003c (64 - val_bits - self.cur_bits);\n\t\t\t\tval_bits += self.cur_bits;\n\t\t\t\tself.cur_bits = 0;\n\t\t\t} else {\n\t\t\t\tval |= self.cur \u003e\u003e (self.cur_bits + val_bits - 64);\n\t\t\t\tself.cur_bits -= 64 - val_bits;\n\t\t\t\tval_bits = 64;\n\t\t\t}\n\n\t\t}\n\n\t\t// return packed value\n\n\t\tSome (val)\n\n\t}\n\n}\n","traces":[{"line":6,"address":[50400],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":7,"address":[45351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[50480],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":11,"address":[45815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[50560,51450],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":18,"address":[50589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[50600,51395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[50708,51223],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[50762,50921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[50768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[50773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[50813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[50900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[50909],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[50944,51057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[51066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[51082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[51183,51096],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[51472],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":90,"address":[51597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[51610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[51656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[51672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[52299,51864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[51876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[51910,52326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[51923,52353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[51760],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":136,"address":[51833],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[51842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[51850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[51858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[51891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[51942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[51946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[51950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[52267,51966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[51978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[51995,52283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[52007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[52018,52132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[52151,52030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[52208,52064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[52086,52235],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":42,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-17","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub passcode: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { passcode, params } = [\n\t\tparams,\n\t\t@str passcode = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 16),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-17","lib.rs"],"content":"//! Advent of Code 2016: Day 17: Two Steps Forward\n//!\n//! [https://adventofcode.com/2016/day/17](https://adventofcode.com/2016/day/17)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_md5 as md5;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Two Steps Forward\";\n\tyear = 2016;\n\tday = 17;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Dir = aoc_pos::Dir2d;\n\tpub type Pos = aoc_pos::PosYX \u003cu8\u003e;\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLES: \u0026 [\u0026 str] = \u0026 [\n\t\t\"ihgpwlah\",\n\t\t\"kglvqrro\",\n\t\t\"ulqzkmiv\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"DDRRRD\", puzzle.part_one (\u0026 [ EXAMPLES [0] ]));\n\t\tassert_eq_ok! (\"DDUDRLRRUDRD\", puzzle.part_one (\u0026 [ EXAMPLES [1] ]));\n\t\tassert_eq_ok! (\"DRURDRUDDLLDLUURRDULRLDUUDDDRR\", puzzle.part_one (\u0026 [ EXAMPLES [2] ]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"370\", puzzle.part_two (\u0026 [ EXAMPLES [0] ]));\n\t\tassert_eq_ok! (\"492\", puzzle.part_two (\u0026 [ EXAMPLES [1] ]));\n\t\tassert_eq_ok! (\"830\", puzzle.part_two (\u0026 [ EXAMPLES [2] ]));\n\t}\n\n}\n","traces":[{"line":18,"address":[38574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[38942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[26668,25616],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":40,"address":[25633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[25715,26625,26184,25654,25771,26118],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[26313,26252,26587,25793,25909,25850],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[25931,26053,26378,26439,26546,25994],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[26688,27740],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":48,"address":[26705],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[26843,27256,27190,26787,27697,26726],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[27659,27324,26922,27385,26865,26981],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[27450,27618,27003,27511,27066,27125],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-17","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tOk (\n\t\troutes_iter (input)\n\t\t\t.next ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\troutes_iter (input)\n\t\t\t.last ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t\t\t.chars ()\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\nfn routes_iter (input: \u0026 Input) -\u003e RoutesIter {\n\tRoutesIter::new (\n\t\tPos::ZERO,\n\t\tPos::new (3, 3),\n\t\tPos::new (4, 4),\n\t\tinput.passcode.to_string ())\n}\n\nstruct RoutesIter {\n\ttodo: VecDeque \u003c(Pos, String)\u003e,\n\tend: Pos,\n\tsize: Pos,\n\tpasscode: String,\n}\n\nimpl RoutesIter {\n\tfn new (start: Pos, end: Pos, size: Pos, passcode: String) -\u003e Self {\n\t\tlet mut todo = VecDeque::new ();\n\t\ttodo.push_back ((start, \"\".to_owned ()));\n\t\tSelf { todo, end, size, passcode }\n\t}\n}\n\nimpl Iterator for RoutesIter {\n\n\ttype Item = String;\n\n\tfn next (\u0026 mut self) -\u003e Option \u003cString\u003e {\n\t\twhile let Some ((pos, route)) = self.todo.pop_front () {\n\t\t\tif pos == self.end { return Some (route) }\n\t\t\tlet hash = md5::md5_hash (format! (\"{}{}\", self.passcode, route).as_bytes ());\n\t\t\tlet hash_hex = hash.as_hex_bytes ();\n\t\t\tfor (dir_idx, dir_tag, dir) in [\n\t\t\t\t(0, \"U\", Dir::Up), (1, \"D\", Dir::Down),\n\t\t\t\t(2, \"L\", Dir::Left), (3, \"R\", Dir::Right),\n\t\t\t] {\n\t\t\t\tlet adj_pos = ok_or! (pos.try_add ((dir, 1)), continue);\n\t\t\t\tif adj_pos.y \u003e= self.size.y || adj_pos.x \u003e= self.size.x { continue }\n\t\t\t\tif hash_hex [dir_idx] \u003e b'a' {\n\t\t\t\t\tself.todo.push_back ((adj_pos, format! (\"{}{}\", route, dir_tag)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tNone\n\t}\n}\n","traces":[{"line":7,"address":[49148,48432],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[48929,48966],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[50327,49216],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[49962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[50396,49204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[48743,49539],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[50416,51923],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":54,"address":[50497,50572],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[51780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[50773,51874,50980,50639],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[50991],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[51354,51012,51897],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[51415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[51463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[51823,51500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[51524,51678],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[51771],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":16,"coverable":17},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_ROWS_ONE=10\",\n\t\"NUM_ROWS_TWO=20\",\n\t\".^^.^.^^^^\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"38\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"93\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[23156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[42746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[42805,42857,43084,42767,42980,42914],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[22980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[43146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[43205,43380,43484,43257,43167,43314],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-18","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub first_row: Vec \u003cTile\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { first_row, params } = [ params, @collect first_row ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_rows_one: u32 = (\"NUM_ROWS_ONE=\", 40, 1 .. ),\n\t\tpub num_rows_two: u32 = (\"NUM_ROWS_TWO=\", 400_000, 1 .. ),\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub enum Tile {\n\t\tTrap = [ \"^\" ],\n\t\tSafe = [ \".\" ],\n\t}\n}\n","traces":[{"line":12,"address":[36902,37388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[44835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[44839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[44864],"length":1,"stats":{"Line":0},"fn_name":"eq"}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-18","lib.rs"],"content":"//! Advent of Code 2016: Day 18: Like a Rogue\n//!\n//! [https://adventofcode.com/2016/day/18](https://adventofcode.com/2016/day/18)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Like a Rogue\";\n\tyear = 2016;\n\tday = 18;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-18","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse input::Tile;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (\u0026 input.first_row, input.params.num_rows_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (\u0026 input.first_row, input.params.num_rows_two)\n}\n\nfn calc_result (first_row: \u0026 [Tile], num_rows: u32) -\u003e GenResult \u003cu32\u003e {\n\tif first_row.is_empty () { return Err (\"Max row size is 1 tile\".into ()) }\n\tif first_row.len () \u003e 128 { return Err (\"Max row size is 128 tiles\".into ()) }\n\tlet mut row: u128 = 0;\n\tlet mut mask: u128 = 0;\n\tfor tile in first_row.iter ().copied () {\n\t\trow \u003c\u003c= 1_u32;\n\t\tif tile == Tile::Trap { row |= 1; }\n\t\tmask \u003c\u003c= 1_u32;\n\t\tmask |= 1;\n\t}\n\tlet num_tiles = mask.count_ones ();\n\tlet mut num_safe = 0;\n\tfor _ in 0 .. num_rows {\n\t\tnum_safe += num_tiles - row.count_ones ();\n\t\trow = ((row \u003c\u003c 1_u32) ^ (row \u003e\u003e 1_u32)) \u0026 mask;\n\t}\n\tOk (num_safe)\n}\n","traces":[{"line":6,"address":[33152],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":7,"address":[33181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[33216],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":11,"address":[33245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[33280],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":15,"address":[33300,33325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[33302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[33425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[33436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[33441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[33450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[33455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[33830,33741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[33752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[33801],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":13,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-19","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tfor (input, expected) in [\n\t\t(2, 1), (3, 3), (4, 1), (5, 3), (6, 5), (7, 7), (8, 1), (9, 3), (10, 5), (11, 7),\n\t\t(12, 9), (13, 11), (14, 13), (15, 15), (16, 1), (17, 3), (18, 5), (19, 7), (20, 9),\n\t].into_iter () {\n\t\tassert_eq_ok! (expected.to_string (), puzzle.part_one (\u0026 [\u0026 input.to_string ()]));\n\t}\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tfor (input, expected) in [\n\t\t(2, 1), (3, 3), (4, 1), (5, 2), (6, 3), (7, 5), (8, 7), (9, 9), (10, 1), (11, 2),\n\t\t(12, 3), (13, 4), (14, 5), (15, 6), (16, 7), (17, 8), (18, 9), (19, 11), (20, 13),\n\t].into_iter () {\n\t\tassert_eq_ok! (expected.to_string (), puzzle.part_two (\u0026 [\u0026 input.to_string ()]));\n\t}\n}\n","traces":[{"line":6,"address":[25744,26988],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":7,"address":[25761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[25802,26088,26952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[26194,26697,26848,26434,26580,26250,26334,26891],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[27008,28252],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":18,"address":[27025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[27352,27066,28216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[28112,27458,27961,28155,27598,27698,27844,27514],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-19","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Input {\n\tpub num_elves: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { num_elves, params } = [ params, num_elves = 2 .. ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-19","lib.rs"],"content":"//! Advent of Code 2016: Day 19: An Elephant Named Joseph\n//!\n//! [https://adventofcode.com/2016/day/19](https://adventofcode.com/2016/day/19)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"An Elephant Named Joseph\";\n\tyear = 2016;\n\tday = 19;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[28753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[29009],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-19","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.num_elves \u003c 2 { return Err (\"Must have at least two elves\".into ()) }\n\tlet mut first_with = 0;\n\tlet mut sep = 1;\n\tlet mut rem = input.num_elves;\n\tlet mut take = false;\n\twhile rem \u003e 1 {\n\t\tlet odd = (rem \u0026 1) == 1;\n\t\tif ! take \u0026\u0026 odd { rem = (rem + 1) / 2; } else { rem /= 2; }\n\t\tif take { first_with += sep; }\n\t\tif odd { take = ! take; }\n\t\tsep = u32::mul_2 (sep, 2) ?;\n\t}\n\tOk (first_with + 1)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.num_elves \u003c 2 { return Err (\"Must have at least two elves\".into ()) }\n\tlet mut elves =\n\t\t((input.num_elves + 2) / 2 ..= input.num_elves)\n\t\t\t.chain (1 .. (input.num_elves + 2) / 2)\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\tlet mut seq = 1 + (input.num_elves) % 2;\n\twhile elves.len () \u003e 3 {\n\t\tlet next_seq = (seq + elves.len ().pan_u32 ()) % 3;\n\t\telves = elves.iter ()\n\t\t\t.scan (seq, |state, \u0026 elf| {\n\t\t\t\tlet seq = * state;\n\t\t\t\t* state += 1;\n\t\t\t\tif * state == 3 { * state = 0; }\n\t\t\t\tSome ((seq, elf))\n\t\t\t})\n\t\t\t.filter (|\u0026 (seq, _)| seq == 0)\n\t\t\t.map (|(_, elf)| elf)\n\t\t\t.collect ();\n\t\tseq = next_seq;\n\t}\n\twhile elves.len () \u003e 1 {\n\t\tlet elf = elves.remove (0);\n\t\tif seq == 0 { elves.push (elf); }\n\t\tseq = (seq + 1) % 3;\n\t}\n\tOk (elves [0])\n}\n","traces":[{"line":5,"address":[43872],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":6,"address":[43886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[44053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[44120,43952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[44136,43989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[44035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[44016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[44163,44058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[44192,44900],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[44209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[44807,44248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[44313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[44325,44522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[44413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[44854,44472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[46765],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[37153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[34022,33948,33559,33620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[33954,33565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[37174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[33973,33582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[44542,44708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[44636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[44684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[44739],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":24,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"5-8\", \"0-2\", \"4-7\" ]));\n\tassert_eq_ok! (\"4294967295\", puzzle.part_one (\u0026 [ \"0-4294967294\" ]));\n\tassert_err! (\"No solution found\", puzzle.part_one (\u0026 [ \"0-4294967295\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4294967288\", puzzle.part_two (\u0026 [ \"5-8\", \"0-2\", \"4-7\" ]));\n\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [ \"0-4294967294\" ]));\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [ \"0-4294967295\" ]));\n}\n","traces":[{"line":6,"address":[38240,39347],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":7,"address":[38257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[38328,38769,38281,39277,38387,38835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[38452,38903,38964,39253,38409,38511],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[38530,38569,38693,39202,39088,39229],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[39360,40355],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":15,"address":[39377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[39440,39496,39805,39871,40312,39398],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[39556,39518,39615,39939,40274,40000],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[40126,39637,39740,40065,39681,40233],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-20","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub rules: Vec \u003cRule\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { rules, params } = [ params, @lines rules ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Rule {\n\tpub start: u32,\n\tpub end: u32,\n}\n\nstruct_parser_display! {\n\tRule { start, end } = [ start, \"-\", end ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[31387,30886],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-20","lib.rs"],"content":"//! Advent of Code 2016: Day 20: Firewall Rules\n//!\n//! [https://adventofcode.com/2016/day/20](https://adventofcode.com/2016/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Firewall Rules\";\n\tyear = 2016;\n\tday = 20;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[43528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[43848],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-20","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse input::Rule;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet rules: Vec \u003cRule\u003e =\n\t\tinput.rules.iter ().copied ()\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tlet mut first = 0;\n\tfor rule in rules {\n\t\tif rule.end \u003c rule.start { continue }\n\t\tif first \u003c rule.start { continue }\n\t\tif rule.end == u32::MAX { return Err (\"No solution found\".into ()) }\n\t\tfirst = cmp::max (first, rule.end + 1);\n\t}\n\tOk (first)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.rules.is_empty () { return Err (\"Overflow\".into ()) }\n\tlet rules: Vec \u003cRule\u003e =\n\t\tinput.rules.iter ().copied ()\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tlet mut last = 0;\n\tlet mut valid = 0;\n\tfor rule in rules {\n\t\tif rule.end \u003c rule.start { continue }\n\t\tif last \u003c rule.start {\n\t\t\tvalid += rule.start - last - 1;\n\t\t}\n\t\tlast = cmp::max (last, rule.end);\n\t}\n\tOk (valid + (u32::MAX - last))\n}\n","traces":[{"line":6,"address":[45408,45769],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[45464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[45531,45754,45588,45504],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[45593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[45679,45610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[45615,45719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[45650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[45792,46211],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[46068,45816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[45852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[45892,45919,45986,46196],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[45991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[46001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[46008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[46022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[46046,46113],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-21","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"START_ONE=abcde\",\n\t\"START_TWO=fbdecgha\",\n\t\"swap position 4 with position 0\",\n\t\"swap letter d with letter b\",\n\t\"reverse positions 0 through 4\",\n\t\"rotate left 1 step\",\n\t\"move position 1 to position 4\",\n\t\"move position 3 to position 0\",\n\t\"rotate based on position of letter b\",\n\t\"rotate based on position of letter d\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"decab\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"abcdefgh\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[44048,44052],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[45674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[45842,45908,46012,45695,45733,45785],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[44084,44080],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[46074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[46242,46412,46133,46308,46095,46185],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-21","input.rs"],"content":"//! Data structures to model the puzzle input\n\nuse super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub ops: Vec \u003cScrambleOp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { ops, params } = [ params, @lines ops ]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\n\tpub enum ScrambleOp {\n\t\tSwapPosns (pos_0: u32, pos_1: u32) = [\n\t\t\t\"swap position \", pos_0, \" with position \", pos_1,\n\t\t],\n\t\tSwapChars (ch_0: char, ch_1: char) = [\n\t\t\t\"swap letter \", ch_0, \" with letter \", ch_1,\n\t\t],\n\t\tRotLeft (num: u32) = [\n\t\t\t\"rotate left \", num { 1 = [ \"1 step\" ], num = [ num, \" steps\" ] },\n\t\t],\n\t\tRotRight (num: u32) = [\n\t\t\t\"rotate right \", num { 1 = [ \"1 step\" ], num = [ num, \" steps\" ] },\n\t\t],\n\t\tRotChar (ch: char) = [\n\t\t\t\"rotate based on position of letter \", ch,\n\t\t],\n\t\tReverse (pos_0: u32, pos_1: u32) = [\n\t\t\t\"reverse positions \", pos_0, \" through \", pos_1,\n\t\t],\n\t\tMove (pos_0: u32, pos_1: u32) = [\n\t\t\t\"move position \", pos_0, \" to position \", pos_1,\n\t\t],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub start_one: String = (\"START_ONE=\", \"abcdefgh\".to_owned (), .. ),\n\t\tpub start_two: String = (\"START_TWO=\", \"fbgdceah\".to_owned (), .. ),\n\t}\n}\n","traces":[{"line":12,"address":[50176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[53290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[53316],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-21","lib.rs"],"content":"//! Advent of Code 2016: Day 21: Scrambled Letters and Hash\n//!\n//! [https://adventofcode.com/2016/day/21](https://adventofcode.com/2016/day/21)\n//!\n//! # Input\n//!\n//! A series of operations, one per line, to perform on a password consisting of a series of\n//! lowercase letters. The operations are as follows:\n//!\n//! * `swap position P0 with position P1`, where `P0` and `P1` are valid zero-based positions for\n//!   the password length, swaps the letters at the named positions.\n//! * `swap letter C0 with letter C1`, where `C0` and `C1` are lowercase letters, swaps the two\n//!   mentioned charaters.\n//! * `rotate left N steps` or `rotate right N steps`, where `N` is an integer between zero and\n//!   the password length, rotates the characters as you would expect.\n//! * `rotate based on position of letter C`, where `C` is a lowercase letter, rotates the string\n//!   to the right a number of times equal to the zero-based index of the letter plus one.\n//! * `reverse positions P0 through P1`, where `P0` and `P1` are valid zero-based positions for\n//!   the password length, reverses the characters between those positions, inclusively.\n//! * `move position P0 to position P1`, where `P0` and `P1` are valid zero-based positions for\n//!   the password length, removes the character at the first position and reinserts it at the\n//!   second.\n//!\n//! # Part one\n//!\n//! Apply the operations to the password `abcdefgh` and return the result.\n//!\n//! # Part two\n//!\n//! Determine the password to which you can apply the operations to get the result `fbgdceah`.\n//!\n//! # Algorithm\n//!\n//! We basically just apply the indicated operations as described. Reversing the operations for\n//! part two is fairly simple. The operation to rotate based on the position of a character\n//! requires a little analysis to do in reverse, but this turns out to be fairly simply as well.\n//!\n//! We do all of this very efficiently, without allocation, and this runs extremely quickly. Most\n//! of the forward and reverse operations share code, for example all four of the rotation\n//! operations share a single implementation with some logic to reverse the amount as appropriate.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod ops;\n\npuzzle_info! {\n\tname = \"Scrambled Letters and Hash\";\n\tyear = 2016;\n\tday = 21;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Mode { Scramble, Unscramble }\n\n\tpub type State = Vec \u003cchar\u003e;\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-21","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse input::ScrambleOp;\nuse model::Mode;\nuse model::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\u0026 input.ops, \u0026 input.params.start_one, Mode::Scramble)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\u0026 input.ops, \u0026 input.params.start_two, Mode::Unscramble)\n}\n\nfn calc_result (ops: \u0026 [ScrambleOp], start: \u0026 str, mode: Mode) -\u003e GenResult \u003cString\u003e {\n\n\t// sanity checks\n\n\tif ! (1 ..= 26).contains (\u0026 start.len ()) {\n\t\treturn Err (\"Password must have between one and sixteen characters\".into ());\n\t}\n\tif ! start.chars ().all (|ch| ch.is_ascii_lowercase ()) {\n\t\treturn Err (\"Password must contains only lowercase ASCII characters\".into ());\n\t}\n\tif start.chars ().duplicates ().next ().is_some () {\n\t\treturn Err (\"Password must contain only unique characters\".into ());\n\t}\n\tif mode == Mode::Unscramble \u0026\u0026 start.chars ().count () != 8 {\n\t\treturn Err (\"Can only unscramble password with length 8\".into ());\n\t}\n\n\t// convert password to chars, allocate temp buffer\n\n\tlet mut state: State = start.chars ().collect ();\n\tlet mut state_temp: State = Vec::with_capacity (state.len ());\n\n\t// iterate over operations, in reverse order for unscramble\n\n\tmatch mode {\n\t\tMode::Scramble =\u003e {\n\t\t\tfor \u0026 op in ops {\n\t\t\t\tops::apply (\u0026 mut state, \u0026 mut state_temp, mode, op) ?;\n\t\t\t}\n\t\t},\n\t\tMode::Unscramble =\u003e {\n\t\t\tfor \u0026 op in ops.iter ().rev () {\n\t\t\t\tops::apply (\u0026 mut state, \u0026 mut state_temp, mode, op) ?;\n\t\t\t}\n\t\t},\n\t};\n\n\t// collect back into string and return\n\n\tOk (state.into_iter ().collect ())\n\n}\n","traces":[{"line":8,"address":[72176],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":9,"address":[60638,60660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[72272],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":13,"address":[61182,61204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[72368,73620],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":20,"address":[72396],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[72526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[44041,44032],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":24,"address":[72775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[73605,72794,72860],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[72865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[72919,72988],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[73528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[73018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[73096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[73269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[73276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[73170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[73176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[73397,73484],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":14,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-21","ops.rs"],"content":"use super::*;\n\nuse input::ScrambleOp;\nuse model::Mode;\nuse model::State;\n\n/// Apply the provided [`ScrambleOp`], in the provided [`Mode`], to the provided [`State`].\n///\n/// This operates in-place on a mutable reference.\n///\n/// We also requires the passing of a second, temporary buffer which is used for some operations\n/// to allow a simple and efficient algorithm without requiring memory allocation. The contents of\n/// this buffer after the operation are undefined.\n///\npub fn apply (\n\tstate: \u0026 mut State,\n\tstate_temp: \u0026 mut State,\n\tmode: Mode,\n\top: ScrambleOp,\n) -\u003e GenResult \u003c()\u003e {\n\tmatch (mode, op) {\n\t\t(_, ScrambleOp::SwapPosns (pos_0, pos_1)) =\u003e\n\t\t\tops::swap_posns (state, pos_0.pan_usize (), pos_1.pan_usize ()),\n\t\t(_, ScrambleOp::SwapChars (ch_0, ch_1)) =\u003e\n\t\t\tops::swap_chars (state, ch_0, ch_1),\n\t\t(Mode::Scramble, ScrambleOp::RotLeft (num)) |\n\t\t(Mode::Unscramble, ScrambleOp::RotRight (num)) =\u003e\n\t\t\tops::rotate (state, state_temp, num.pan_usize ()),\n\t\t(Mode::Scramble, ScrambleOp::RotRight (num)) |\n\t\t(Mode::Unscramble, ScrambleOp::RotLeft (num)) =\u003e {\n\t\t\tlet num = chk! (state.len () - num.pan_usize ()) ?;\n\t\t\tops::rotate (state, state_temp, num)\n\t\t},\n\t\t(Mode::Scramble, ScrambleOp::RotChar (ch)) =\u003e\n\t\t\tops::rotate_char_scramble (state, state_temp, ch),\n\t\t(Mode::Unscramble, ScrambleOp::RotChar (ch)) =\u003e\n\t\t\tops::rotate_char_unscramble (state, state_temp, ch),\n\t\t(_, ScrambleOp::Reverse (pos_0, pos_1)) =\u003e\n\t\t\tops::reverse (state, pos_0.pan_usize (), pos_1.pan_usize ()),\n\t\t(Mode::Scramble, ScrambleOp::Move (pos_0, pos_1)) |\n\t\t(Mode::Unscramble, ScrambleOp::Move (pos_1, pos_0)) =\u003e\n\t\t\tops::move_shift (state, pos_0.pan_usize (), pos_1.pan_usize ()),\n\t}\n}\n\npub fn swap_posns (\n\tstate: \u0026 mut State,\n\tpos_0: usize,\n\tpos_1: usize,\n) -\u003e GenResult \u003c()\u003e {\n\tif pos_0 \u003e= state.len () || pos_1 \u003e= state.len () {\n\t\treturn Err (\"Swap positions must be inside password\".into ());\n\t}\n\tlet ch_0 = state [pos_0];\n\tlet ch_1 = state [pos_1];\n\tstate [pos_0] = ch_1;\n\tstate [pos_1] = ch_0;\n\tOk (())\n}\n\npub fn swap_chars (\n\tstate: \u0026 mut State,\n\tch_0: char,\n\tch_1: char,\n) -\u003e GenResult \u003c()\u003e {\n\tfor ch in state.iter_mut () {\n\t\t* ch = match * ch {\n\t\t\tch if ch == ch_0 =\u003e ch_1,\n\t\t\tch if ch == ch_1 =\u003e ch_0,\n\t\t\tch =\u003e ch,\n\t\t}\n\t}\n\tOk (())\n}\n\npub fn rotate (\n\tstate: \u0026 mut State,\n\tstate_temp: \u0026 mut State,\n\tnum: usize,\n) -\u003e GenResult \u003c()\u003e {\n\tstate_temp.clear ();\n\tstate_temp.extend (state.iter ().skip (num).copied ());\n\tstate_temp.extend (state.iter ().take (num).copied ());\n\tmem::swap (state, state_temp);\n\tOk (())\n}\n\npub fn rotate_char_scramble (\n\tstate: \u0026 mut State,\n\tstate_temp: \u0026 mut State,\n\tch: char,\n) -\u003e GenResult \u003c()\u003e {\n\tif let Some (pos) = state.iter ().position (|\u0026 some_ch| some_ch == ch) {\n\t\tlet num = (if pos \u003e= 4 { 2 } else { 1 } + pos) % state.len ();\n\t\tstate_temp.clear ();\n\t\tstate_temp.extend (state.iter ().skip (state.len () - num).copied ());\n\t\tstate_temp.extend (state.iter ().take (state.len () - num).copied ());\n\t\tmem::swap (state, state_temp);\n\t}\n\tOk (())\n}\n\npub fn rotate_char_unscramble (\n\tstate: \u0026 mut State,\n\tstate_temp: \u0026 mut State,\n\tch: char,\n) -\u003e GenResult \u003c()\u003e {\n\tif let Some (pos) = state.iter ().position (|\u0026 some_ch| some_ch == ch) {\n\t\tlet num = match pos {\n\t\t\t0 =\u003e 1, 1 =\u003e 1, 2 =\u003e 6, 3 =\u003e 2,\n\t\t\t4 =\u003e 7, 5 =\u003e 3, 6 =\u003e 0, 7 =\u003e 4,\n\t\t\t_ =\u003e unreachable! (),\n\t\t};\n\t\tstate_temp.clear ();\n\t\tstate_temp.extend (state.iter ().skip (num).copied ());\n\t\tstate_temp.extend (state.iter ().take (num).copied ());\n\t\tmem::swap (state, state_temp);\n\t}\n\tOk (())\n}\n\npub fn reverse (\n\tstate: \u0026 mut State,\n\tmut pos_0: usize,\n\tmut pos_1: usize,\n) -\u003e GenResult \u003c()\u003e {\n\tif state.len () \u003c= pos_0 || state.len () \u003c= pos_1 {\n\t\treturn Err (\"Reverse range outside of password length\".into ());\n\t}\n\twhile pos_0 \u003c pos_1 {\n\t\tlet ch_0 = state [pos_0];\n\t\tlet ch_1 = state [pos_1];\n\t\tstate [pos_0] = ch_1;\n\t\tstate [pos_1] = ch_0;\n\t\tpos_0 += 1;\n\t\tpos_1 -= 1;\n\t}\n\tOk (())\n}\n\npub fn move_shift (\n\tstate: \u0026 mut State,\n\tpos_0: usize,\n\tpos_1: usize,\n) -\u003e GenResult \u003c()\u003e {\n\tif pos_0 \u003e= state.len () || pos_1 \u003e= state.len () {\n\t\treturn Err (\"Move position outside of password length\".into ());\n\t}\n\tlet ch = state.remove (pos_0);\n\tstate.insert (pos_1, ch);\n\tOk (())\n}\n","traces":[{"line":15,"address":[31472],"length":1,"stats":{"Line":2},"fn_name":"apply"},{"line":21,"address":[31489,31976,32127,31851,31778],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[31623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[31837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[31931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[32422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[32389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[31984,31970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[32105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[32480],"length":1,"stats":{"Line":1},"fn_name":"swap_posns"},{"line":51,"address":[32495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[32601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[32525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[32543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[32568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[32593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[31762,31693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[31738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[31720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[32720],"length":1,"stats":{"Line":1},"fn_name":"rotate"},{"line":82,"address":[32774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[33021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[33248],"length":1,"stats":{"Line":1},"fn_name":"rotate_char_scramble"},{"line":93,"address":[37696],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":94,"address":[33399,33373,33959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[34002,33458,33433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[33706,33731,34018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[34048],"length":1,"stats":{"Line":1},"fn_name":"rotate_char_unscramble"},{"line":108,"address":[42400],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[34190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[34306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[34554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[34848],"length":1,"stats":{"Line":1},"fn_name":"reverse"},{"line":127,"address":[34871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[35076],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[34895,35053],"length":1,"stats":{"Line":3},"fn_name":null},{"line":131,"address":[34945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[34975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[35002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[35033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[35037,35185],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[32249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[32399],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":40,"coverable":43},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"root@ebhq-gridcenter# df -h\",\n\t\"Filesystem              Size  Used  Avail  Use%\",\n\t\"/dev/grid/node-x0-y0     93T   68T    25T   73%\",\n\t\"/dev/grid/node-x0-y1     91T   69T    22T   75%\",\n\t\"/dev/grid/node-x0-y2     92T   68T    24T   73%\",\n\t\"/dev/grid/node-x0-y3     92T   73T    19T   79%\",\n\t\"/dev/grid/node-x0-y4     89T   69T    20T   77%\",\n\t\"/dev/grid/node-x1-y0     89T   65T    24T   73%\",\n\t\"/dev/grid/node-x1-y1     89T   71T    18T   79%\",\n\t\"/dev/grid/node-x1-y2     88T   73T    15T   82%\",\n\t\"/dev/grid/node-x1-y3     93T   68T    25T   73%\",\n\t\"/dev/grid/node-x1-y4     91T   68T    23T   74%\",\n\t\"/dev/grid/node-x2-y0     94T   73T    21T   77%\",\n\t\"/dev/grid/node-x2-y1     93T   67T    26T   72%\",\n\t\"/dev/grid/node-x2-y2     87T   69T    18T   79%\",\n\t\"/dev/grid/node-x2-y3     86T   66T    20T   76%\",\n\t\"/dev/grid/node-x2-y4     94T   68T    26T   72%\",\n\t\"/dev/grid/node-x3-y0     94T   65T    29T   69%\",\n\t\"/dev/grid/node-x3-y1     87T   71T    16T   81%\",\n\t\"/dev/grid/node-x3-y2     91T   0T     91T   0%\",\n\t\"/dev/grid/node-x3-y3     94T   69T    25T   73%\",\n\t\"/dev/grid/node-x3-y4     90T   73T    17T   81%\",\n\t\"/dev/grid/node-x4-y0     86T   69T    17T   80%\",\n\t\"/dev/grid/node-x4-y1     92T   72T    20T   78%\",\n\t\"/dev/grid/node-x4-y2     94T   64T    30T   68%\",\n\t\"/dev/grid/node-x4-y3     85T   64T    21T   75%\",\n\t\"/dev/grid/node-x4-y4     92T   68T    24T   73%\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"24\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"18\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":36,"address":[37108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[64250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[64271,64361,64309,64418,64588,64484],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[37284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[64650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[64671,64818,64884,64988,64709,64761],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-22","input.rs"],"content":"use super::*;\n\nuse model::Pos;\nuse model::Size;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub nodes: Vec \u003cNode\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { nodes, params } = [\n\t\tparams,\n\t\t\"root@ebhq-gridcenter# df -h\\n\",\n\t\t\"Filesystem\", @skip \" \",\n\t\t\"Size\", @skip \" \",\n\t\t\"Used\", @skip \" \",\n\t\t\"Avail\", @skip \" \",\n\t\t\"Use%\\n\",\n\t\t@lines nodes,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Node {\n\tpub pos: Pos,\n\tpub size: Size,\n\tpub used: Size,\n\tpub avail: Size,\n\tpub use_pc: u8,\n}\n\nstruct_parser_display! {\n\tNode { pos: Pos { x, y }, size, used, avail, use_pc } = [\n\t\t\"/dev/grid/node-x\", x, \"-y\", y, @skip \" \",\n\t\tsize, \"T\", @skip \" \",\n\t\tused, \"T\", @skip \" \",\n\t\tavail, \"T\", @skip \" \",\n\t\tuse_pc, \"%\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[57734],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-22","lib.rs"],"content":"//! Advent of Code 2016: Day 22: Grid Computing\n//!\n//! [https://adventofcode.com/2016/day/22](https://adventofcode.com/2016/day/22)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Grid Computing\";\n\tyear = 2016;\n\tday = 22;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Coord = u8;\n\tpub type Size = u16;\n\tpub type Pos = aoc_pos::PosXY \u003cCoord\u003e;\n}\n","traces":[{"line":20,"address":[56760],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-22","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\tOk (\n\t\tinput.nodes.iter ()\n\t\t\t.filter (|node_a| node_a.used \u003e 0)\n\t\t\t.map (|node_a| input.nodes.iter ()\n\t\t\t\t.filter (|node_b| node_a.pos != node_b.pos)\n\t\t\t\t.filter (|node_b| node_a.used \u003c= node_b.avail)\n\t\t\t\t.count ())\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cusize\u003e {\n\n\t// TODO this gets the right answer for the puzzles set, but it's not correct in other cases...\n\t// We can do better, or at the very least return an error if it doesn't meet the criteria.\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tstruct State { data: Pos, empty: Pos }\n\n\ttype Walls = GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e;\n\n\tlet size =\n\t\tinput.nodes.iter ()\n\t\t\t.try_fold (Pos::ZERO, |size, node| Ok::\u003c_, Overflow\u003e (Pos::new (\n\t\t\t\tcmp::max (size.x, chk! (node.pos.x + Coord::ONE) ?),\n\t\t\t\tcmp::max (size.y, chk! (node.pos.y + Coord::ONE) ?)))) ?;\n\n\tif 40 \u003c size.x || 40 \u003c size.y {\n\t\treturn Err (\"Max grid size is 4040\".into ());\n\t}\n\n\tlet empty_start =\n\t\tinput.nodes.iter ()\n\t\t\t.filter (|node| node.used == 0)\n\t\t\t.map (|node| node.pos)\n\t\t\t.exactly_one ()\n\t\t\t.ok ()\n\t\t\t.ok_or (\"Must have exactly one empty node\") ?;\n\n\tlet lowest =\n\t\tinput.nodes.iter ()\n\t\t\t.filter (|node| node.used \u003e 0)\n\t\t\t.map (|node| node.used)\n\t\t\t.min ()\n\t\t\t.ok_or (\"No nodes have used data\") ?;\n\n\tlet data_start = Pos::new (size.x - 1, 0);\n\tlet data_end = Pos::ZERO;\n\n\tlet mut walls = Walls::new_size (size);\n\tfor node in input.nodes.iter () {\n\t\twalls.set (node.pos, node.used \u003e lowest * 2);\n\t}\n\n\tlet state = State { data: data_start, empty: empty_start };\n\n\tlet mut seen: HashSet \u003cState\u003e = HashSet::new ();\n\tseen.insert (state);\n\n\tlet mut todo: VecDeque \u003c(usize, State)\u003e = VecDeque::new ();\n\ttodo.push_back ((0, state));\n\n\twhile let Some ((dist, state)) = todo.pop_front () {\n\t\tif state.data == data_end { return Ok (dist) }\n\t\tfor from_pos in state.empty.adjacent_4 () {\n\t\t\tif walls.get (from_pos).unwrap_or (true) { continue }\n\t\t\tlet new_state = State {\n\t\t\t\tdata: if from_pos == state.data { state.empty } else { state.data },\n\t\t\t\tempty: from_pos,\n\t\t\t};\n\t\t\tif seen.insert (new_state) {\n\t\t\t\ttodo.push_back ((dist + 1, new_state));\n\t\t\t}\n\t\t}\n\t}\n\n\tErr (\"No solution found\".into ())\n\n}\n","traces":[{"line":7,"address":[58944],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":10,"address":[59040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[33842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[41296,41323],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":13,"address":[47744,47388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[61756,59152],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":29,"address":[59201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[41360],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":32,"address":[41375,41623,41398,41600,41591,41568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[48063,48087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[59247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[59395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[59511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[35410,35321],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[35425,35340],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[59842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[32925,33022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[32940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[59852,61483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[59988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[60143,61423,60003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[60304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[60707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[61333],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[60734,60773,61708,60932],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[61062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[61084,61107,61093],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[61125,61165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[61173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[61277],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":24,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"cpy 2 a\",\n\t\"tgl a\",\n\t\"tgl a\",\n\t\"tgl a\",\n\t\"cpy 1 a\",\n\t\"dec a\",\n\t\"dec a\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":16,"address":[28151,27760],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":17,"address":[27770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[28108,27791,27938,28004,27881,27829],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-23","input.rs"],"content":"use super::*;\n\nuse cpu::Instr;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[33115,34196],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-23","lib.rs"],"content":"//! Advent of Code 2016: Day 23: Safe Cracking\n//!\n//! [https://adventofcode.com/2016/day/23](https://adventofcode.com/2016/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2016_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Safe Cracking\";\n\tyear = 2016;\n\tday = 23;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[22424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[22744],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-23","logic.rs"],"content":"use super::*;\n\nuse cpu::Cpu;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tcheck_input (input) ?;\n\tlet mut cpu = Cpu {\n\t\tinstrs: Rc::new (input.instrs.clone ()),\n\t\treg_a: 7,\n\t\tlimit: 1000,\n\t\t.. default ()\n\t};\n\tcpu.exec () ?;\n\tOk (cpu.reg_a)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tcheck_input (input) ?;\n\tlet mut cpu = Cpu {\n\t\tinstrs: Rc::new (input.instrs.clone ()),\n\t\treg_a: 12,\n\t\tlimit: 1000,\n\t\t.. default ()\n\t};\n\tcpu.exec () ?;\n\tOk (cpu.reg_a)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif let Some (instr) = input.instrs.iter ().find (|instr| ! instr.is_v2 ()) {\n\t\treturn Err (format! (\"Invalid instruction: {instr}\").into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[32048,32379],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[32063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[32117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[32244,32295,32265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[32300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[32400,32731],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":19,"address":[32415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[32469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[32596,32617,32647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[32652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[32752],"length":1,"stats":{"Line":1},"fn_name":"check_input"},{"line":31,"address":[21920,21929],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":32,"address":[32833,32920],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-24","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"###########\",\n\t\"#0.1.....2#\",\n\t\"#.#######.#\",\n\t\"#4.......3#\",\n\t\"###########\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"14\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"20\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[83047,82656],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":15,"address":[82666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[82900,82777,82725,83004,82687,82834],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[83056,83447],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":21,"address":[83066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[83177,83300,83404,83234,83087,83125],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-24","input.rs"],"content":"use super::*;\n\nuse model::TilesGrid;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub tiles: TilesGrid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { tiles, params } = [ params, tiles ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-24","lib.rs"],"content":"//! Advent of Code 2016: Day 24: Air Duct Spelunking\n//!\n//! [https://adventofcode.com/2016/day/24](https://adventofcode.com/2016/day/24)\n//!\n//! # Input\n//!\n//! Map with `#` for wall tiles, `.` for open tiles, and digits `0` to `9` for points of interest.\n//! Starting point is always `0`.\n//!\n//! # Part one\n//!\n//! Work out the shortest route starting at `0` and passing through all points of interest.\n//!\n//! # Part two\n//!\n//! Same as part one, while also returning to `0` afterwards.\n//!\n//! # Algorithm\n//!\n//! This works in two steps:\n//!\n//! - Work out the shortest route from every point of interest to every other. This uses a simple\n//!   breadth first path-finding algorithm, starting from each of the points and recording the\n//!   shortest distance to each of the others.\n//!\n//! - Use [`search::PrioritySearch`] to find the shortest path connecting them. As an optimisation,\n//!   we sort the routes used as search nodes, except for the last item, since we don't care about\n//!   the order, only the distance and the point we are setting off from for the next leg.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\nuse aoc_search as search;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Air Duct Spelunking\";\n\tyear = 2016;\n\tday = 24;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-24","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Pos;\nuse model::SeenGrid;\nuse model::Tile;\nuse search::PrioritySearch;\nuse search::PrioritySearchAdder;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, false)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, true)\n}\n\nfn calc_result (input: \u0026 Input, round_trip: bool) -\u003e GenResult \u003cu32\u003e {\n\tlet (nums, dists) = calc_distances (input) ?;\n\tcalc_shortest (\u0026 nums, \u0026 dists, round_trip)\n}\n\n/// Given the distance between each point of interest work out the shortest path between them.\n///\n/// This uses [`PrioritySearch`] to always check the shortest routes first. Along the way, it\n/// tracks only the current position and the set of visited points so far, to allow efficient\n/// short-circuiting.\n///\nfn calc_shortest (\n\tnums: \u0026 [(u8, Pos)],\n\tdists: \u0026 [(u8, u8, u32)],\n\tround_trip: bool,\n) -\u003e GenResult \u003cu32\u003e {\n\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|mut route: ArrayVec \u003cu8, 11\u003e, dist, mut adder: PrioritySearchAdder \u003c_, _, _\u003e| {\n\t\t\tlet here = route.last ().copied ().unwrap ();\n\t\t\troute.sort ();\n\t\t\tfor \u0026 (from, to, next_dist) in dists.iter () {\n\t\t\t\tif from != here { continue }\n\t\t\t\tif route.len () == nums.len () \u0026\u0026 to != 0 { continue }\n\t\t\t\tif route.len () \u003c nums.len () \u0026\u0026 route.contains (\u0026 to) { continue }\n\t\t\t\tif route.len () \u003c nums.len () + usize::from (round_trip) {\n\t\t\t\t\tlet mut new_route = route.clone ();\n\t\t\t\t\tnew_route.push (to);\n\t\t\t\t\tadder.add (new_route.clone (), dist + next_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\t(route, dist)\n\t\t});\n\n\tsearch\n\t\t.push (array_vec! [ 0_u8 ], 0)\n\t\t.filter (|\u0026 (ref route, _)| route.len () ==\n\t\t\tif round_trip { nums.len () + 1 } else { nums.len () })\n\t\t.map (|(_, dist)| dist)\n\t\t.next ()\n\t\t.ok_or_else (|| \"No solution found\".into ())\n\n}\n\n/// Work out the distance between every point of interest.\n///\n/// Points of interests include all of the number locations, ie the start point, all the points\n/// that need to be visited and, in the case of part two, the end point.\n///\nfn calc_distances (\n\tinput: \u0026 Input,\n) -\u003e GenResult \u003c(Vec \u003c(u8, Pos)\u003e, Vec \u003c(u8, u8, u32)\u003e)\u003e {\n\n\t// find list of numbers in grid\n\n\tlet nums: Vec \u003c(u8, Pos)\u003e =\n\t\tinput.tiles.iter ()\n\t\t\t.filter_map (|(pos, tile)| match tile {\n\t\t\t\tTile::Num (num) =\u003e Some ((num, pos)),\n\t\t\t\tTile::Wall | Tile::Open =\u003e None,\n\t\t\t})\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\n\t// check for duplicates\n\n\tif nums.iter ().map (|\u0026 (num, _)| num).sorted ().dedup ().count () != nums.len () {\n\t\treturn Err (\"Duplicated nums\".into ());\n\t}\n\n\t// check start exists\n\n\tif ! nums.iter ().any (|\u0026 (num, _)| num == 0_u8) {\n\t\treturn Err (\"No starting position\".into ());\n\t}\n\n\t// assume we already visited all walls, reusing this makes things quicker\n\n\tlet seen_template = SeenGrid::wrap_range (\n\t\tinput.tiles.values ().map (|tile| matches! (tile, Tile::Wall)).collect (),\n\t\tinput.tiles.start (),\n\t\tinput.tiles.end ()) ?;\n\n\t// work out distances\n\n\tlet mut dists: Vec \u003c(u8, u8, u32)\u003e = Vec::new ();\n\t'OUTER: for (start_idx, \u0026 (start_num, start_pos)) in nums.iter ().enumerate () {\n\n\t\t// track places visited so far\n\n\t\tlet mut seen = seen_template.clone ();\n\t\tseen.set (start_pos, true);\n\n\t\t// track next places to visit\n\n\t\tlet mut todo: VecDeque \u003c(u32, Pos)\u003e = VecDeque::new ();\n\t\ttodo.push_back ((0, start_pos));\n\n\t\t// work out number of distance to find, allows some short-circuiting\n\n\t\tlet mut num_to_find = nums.len () - 1 - start_idx;\n\t\tif num_to_find == 0 { continue }\n\n\t\t// iterate 'todo' places\n\n\t\twhile let Some ((dist, pos)) = todo.pop_front () {\n\n\t\t\t// iterate adjacent positions\n\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\n\t\t\t\t// track seen tiles and short-cirtcuit\n\n\t\t\t\tif seen.get (adj_pos).unwrap_or (true) { continue }\n\t\t\t\tseen.set (adj_pos, true);\n\n\t\t\t\t// add adjacent position to `todo`\n\n\t\t\t\tlet adj_tile = input.tiles.get (adj_pos).unwrap ();\n\t\t\t\ttodo.push_back ((dist + 1, adj_pos));\n\n\t\t\t\t// check if we reached a point-of-interest\n\n\t\t\t\tif let Tile::Num (num) = adj_tile {\n\n\t\t\t\t\t// only record it if it is greater than us, to prevent counting twice and\n\t\t\t\t\t// allow short-circuiting\n\n\t\t\t\t\tif num \u003c start_num { continue }\n\n\t\t\t\t\t// record distance, both ways\n\n\t\t\t\t\tdists.push ((start_num, num, dist + 1));\n\t\t\t\t\tdists.push ((num, start_num, dist + 1));\n\n\t\t\t\t\t// abort path-finding if we found all the points greater than start\n\n\t\t\t\t\tnum_to_find -= 1;\n\t\t\t\t\tif num_to_find == 0 { continue 'OUTER }\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// due to short-circuiting, this loop should never complete if all the points are\n\t\t// connected\n\n\t\treturn Err (\"No solution found1\".into ());\n\n\t}\n\n\t// return\n\n\tOk ((nums, dists))\n\n}\n","traces":[{"line":10,"address":[85856],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":11,"address":[85860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[85872],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":15,"address":[85876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[86178,85904],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":19,"address":[85973,86105,85925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[86052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[86599,86192],"length":1,"stats":{"Line":2},"fn_name":"calc_shortest"},{"line":36,"address":[53200,53966],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":37,"address":[53242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[53305,53344,53366],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[53399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[53419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[53428,53479,53505,53708],"length":1,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[53535,53516,53760],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[53917,53787,53633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[53724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[50976,51143,51212],"length":1,"stats":{"Line":6},"fn_name":null},{"line":55,"address":[51298,51114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[86515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[90215,86608],"length":1,"stats":{"Line":2},"fn_name":"calc_distances"},{"line":73,"address":[86780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[50378],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[50396],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[42626,43072],"length":1,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[87097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[54032],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":91,"address":[87077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[49488],"length":1,"stats":{"Line":0},"fn_name":"call_once\u003c(aoc_2016_day_24::model::Tile), aoc_2016_day_24::logic::calc_distances::{closure_env#3}\u003e"},{"line":104,"address":[87525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[89721,88041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[88060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[88256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[88492,90133,88300,88351],"length":1,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[88606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[88890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[89002],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[89012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[89212],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[89230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[89327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[89525],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":35,"coverable":42},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-24","model.rs"],"content":"use super::*;\n\npub type Coord = u16;\npub type Pos = pos::PosRowCol \u003cu16\u003e;\npub type SeenGrid = GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e;\npub type TilesGrid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tOpen = [ \".\" ],\n\t\tWall = [ \"#\" ],\n\t\tNum (id: u8) = [ id = tile_id_parse ],\n\t}\n}\n\nfn tile_id_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tif ! matches! (parser.peek (), Some ('0' ..= '9')) { return Err (parser.err ()) }\n\tOk (parser.next ().unwrap ().to_digit (10).unwrap ().pan_u8 ())\n}\n","traces":[{"line":9,"address":[47968,41294,47984],"length":1,"stats":{"Line":12},"fn_name":"default"},{"line":18,"address":[47680],"length":1,"stats":{"Line":2},"fn_name":"tile_id_parse"},{"line":19,"address":[47884,47765],"length":1,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[47872,47800,47773],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-25","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"cpy 10 b\",\n\t\"dec a\",\n\t\"dec b\",\n\t\"jnz b -2\",\n\t\"jnz a 4\",\n\t\"out 0\",\n\t\"out 1\",\n\t\"jnz 1 -2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":17,"address":[39584,39588],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":18,"address":[41802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[41970,42036,41823,41913,41861,42140],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-25","input.rs"],"content":"use super::*;\n\nuse cpu::Instr;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t\tpub limit: i32 = (\"LIMIT=\", 500, 1_i32 .. ),\n\t\tpub ops_limit: u32 = (\"OPS_LIMIT=\", 1000, 1 .. ),\n\t}\n}\n","traces":[{"line":12,"address":[29020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[44145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[44148],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-25","lib.rs"],"content":"//! Advent of Code 2016: Day 25: Clock Signal\n//!\n//! [https://adventofcode.com/2016/day/24](https://adventofcode.com/2016/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2016_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Clock Signal\";\n\tyear = 2016;\n\tday = 25;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n","traces":[{"line":19,"address":[49031],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","day-25","logic.rs"],"content":"use super::*;\n\nuse cpu::Cpu;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tfor start in 1_i32 ..= input.params.limit {\n\t\tlet mut cpu = Cpu {\n\t\t\tinstrs: Rc::new (input.instrs.clone ()),\n\t\t\treg_a: start,\n\t\t\tlimit: input.params.ops_limit,\n\t\t\t.. default ()\n\t\t};\n\t\tlet mut expect = 0_i32;\n\t\tlet mut num = 0_u32;\n\t\tlet mut states = HashSet::new ();\n\t\twhile let Some (out) = cpu.exec () ? {\n\t\t\tif out != expect { break }\n\t\t\texpect = i32::from (expect == 0_i32);\n\t\t\tnum += 1;\n\t\t\tlet state = (expect, cpu.next, cpu.reg_a, cpu.reg_b, cpu.reg_c, cpu.reg_d);\n\t\t\tif num \u003e= 2 \u0026\u0026 ! states.insert (state) {\n\t\t\t\treturn Ok (start);\n\t\t\t}\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n","traces":[{"line":6,"address":[40032,40955],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[40054,40697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[40140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[40159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[40429,40455,40400,40735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[40869,40477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[40493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[40488,40526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[40778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[40703],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2016","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2016_day_01 as day_01;\npub use aoc_2016_day_02 as day_02;\npub use aoc_2016_day_03 as day_03;\npub use aoc_2016_day_04 as day_04;\npub use aoc_2016_day_05 as day_05;\npub use aoc_2016_day_06 as day_06;\npub use aoc_2016_day_07 as day_07;\npub use aoc_2016_day_08 as day_08;\npub use aoc_2016_day_09 as day_09;\npub use aoc_2016_day_10 as day_10;\npub use aoc_2016_day_11 as day_11;\npub use aoc_2016_day_12 as day_12;\npub use aoc_2016_day_13 as day_13;\npub use aoc_2016_day_14 as day_14;\npub use aoc_2016_day_15 as day_15;\npub use aoc_2016_day_16 as day_16;\npub use aoc_2016_day_17 as day_17;\npub use aoc_2016_day_18 as day_18;\npub use aoc_2016_day_19 as day_19;\npub use aoc_2016_day_20 as day_20;\npub use aoc_2016_day_21 as day_21;\npub use aoc_2016_day_22 as day_22;\npub use aoc_2016_day_23 as day_23;\npub use aoc_2016_day_24 as day_24;\npub use aoc_2016_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","cpu","cpu.rs"],"content":"use aoc_common::*;\n\npub use logic::Cpu;\npub use logic::CpuError;\npub use model::Instr;\npub use model::SrcArg;\npub use model::DstArg;\npub use model::Reg;\npub use model::Val;\n\n#[ macro_export ]\nmacro_rules! cpu_optimise {\n\n\t(\n\t\t$cpu:expr,\n\t\tregs = [ $( $reg:ident ),* ],\n\t\tinstrs = [ $( $instr:ident ($($instr_arg:tt)*) ),* $(,)? ],\n\t\trun = { $( $run_body:tt )* },\n\t) =\u003e {\n\t\tuse aoc_2017_cpu::{ DstArg, Reg, SrcArg };\n\t\tlet match_len = [ $( stringify! ($instr) ),* ].len ().pan_u64 ();\n\t\tstruct Args {\n\t\t\t$( $reg: Option \u003cReg\u003e, )*\n\t\t}\n\t\tlet mut args = Args {\n\t\t\t$( $reg: None, )*\n\t\t};\n\t\tlet matched = loop {\n\t\t\tif ($cpu).instrs ().len ().pan_u64 () \u003c ($cpu).next () + match_len { break false }\n\t\t\tlet mut match_idx = ($cpu).next ().pan_usize ();\n\t\t\t$(\n\t\t\t\tif let cpu_optimise! (@instr_let_args $instr, $($instr_arg)*) =\n\t\t\t\t\t\t($cpu).instrs () [match_idx] {\n\t\t\t\t\tcpu_optimise! (@instr_check_args args, $($instr_arg)*);\n\t\t\t\t} else {\n\t\t\t\t\tbreak false;\n\t\t\t\t}\n\t\t\t\tmatch_idx += 1;\n\t\t\t)*\n\t\t\tbreak true;\n\t\t};\n\t\tif matched {\n\t\t\t$( let $reg = args.$reg.unwrap (); )*\n\t\t\t$( $run_body )*\n\t\t}\n\t};\n\n\t( @instr_let_args $instr:ident, dst $arg_0:ident, src $arg_1:ident) =\u003e {\n\t\t::aoc_2017_cpu::Instr::$instr (\n\t\t\t::aoc_2017_cpu::DstArg::Reg ($arg_0),\n\t\t\t::aoc_2017_cpu::SrcArg::Reg ($arg_1))\n\t};\n\t( @instr_let_args $instr:ident, dst $arg_0:ident, imm $arg_1:literal) =\u003e {\n\t\t::aoc_2017_cpu::Instr::$instr (\n\t\t\tDstArg::Reg ($arg_0),\n\t\t\tSrcArg::Imm ($arg_1))\n\t};\n\t( @instr_let_args $instr:ident, src $arg_0:ident, imm $arg_1:literal) =\u003e {\n\t\t::aoc_2017_cpu::Instr::$instr (\n\t\t\t::aoc_2017_cpu::SrcArg::Reg ($arg_0),\n\t\t\t::aoc_2017_cpu::SrcArg::Imm ($arg_1))\n\t};\n\n\t( @instr_check_args $args:ident, dst $arg_0:ident, src $arg_1:ident) =\u003e {\n\t\tcpu_optimise! (@instr_check_arg $args, reg $arg_0);\n\t\tcpu_optimise! (@instr_check_arg $args, reg $arg_1);\n\t};\n\t( @instr_check_args $args:ident, dst $arg_0:ident, imm $arg_1:literal) =\u003e {\n\t\tcpu_optimise! (@instr_check_arg $args, reg $arg_0);\n\t};\n\t( @instr_check_args $args:ident, src $arg_0:ident, imm $arg_1:literal) =\u003e {\n\t\tcpu_optimise! (@instr_check_arg $args, reg $arg_0);\n\t};\n\t( @instr_check_arg $args:ident, reg $name:ident) =\u003e {\n\t\tif let Some (prev) = $args.$name {\n\t\t\tif prev != $name { break false }\n\t\t} else {\n\t\t\t$args.$name = Some ($name);\n\t\t}\n\t};\n\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Instr;\n\tuse model::Val;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Cpu {\n\t\tinstrs: Rc \u003c[Instr]\u003e,\n\t\tregs: [Val; 26],\n\t\tnext: u64,\n\t\tlimit: u64,\n\t\tinput: VecDeque \u003cVal\u003e,\n\t}\n\n\timpl Cpu {\n\n\t\t#[ inline ]\n\t\tpub fn new (instrs: impl Into \u003cRc \u003c[Instr]\u003e\u003e) -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tinstrs: instrs.into (),\n\t\t\t\t.. default ()\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn instrs (\u0026 self) -\u003e \u0026 Rc \u003c[Instr]\u003e {\n\t\t\t\u0026 self.instrs\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn next (\u0026 self) -\u003e u64 {\n\t\t\tself.next\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn set_next (\u0026 mut self, next: u64) {\n\t\t\tself.next = next;\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn next_instr (\u0026 self) -\u003e Option \u003cInstr\u003e {\n\t\t\tself.instrs.get (self.next.qck_usize ()).copied ()\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn input (\u0026 self) -\u003e \u0026 VecDeque \u003cVal\u003e {\n\t\t\t\u0026 self.input\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn can_step (\u0026 self) -\u003e bool {\n\t\t\tself.next.qck_usize () \u003c self.instrs.len ()\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn limit (\u0026 self) -\u003e u64 {\n\t\t\tself.limit\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn set_limit (\u0026 mut self, limit: u64) -\u003e \u0026 mut Self {\n\t\t\tself.limit = limit;\n\t\t\tself\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn push_input (\u0026 mut self, input: Val) -\u003e \u0026 mut Self {\n\t\t\tself.input.push_back (input);\n\t\t\tself\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn set_reg (\u0026 mut self, reg_ch: char, val: Val) -\u003e Result \u003c\u0026 mut Self, \u0026 'static str\u003e {\n\t\t\tlet reg = Reg::try_from (reg_ch).ok ().ok_or (\"No such register\") ?;\n\t\t\tself.regs [reg.idx ()] = val;\n\t\t\tOk (self)\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn get_reg (\u0026 mut self, reg_ch: char) -\u003e Result \u003cVal, \u0026 'static str\u003e {\n\t\t\tlet reg = Reg::try_from (reg_ch).ok ().ok_or (\"No such register\") ?;\n\t\t\tOk (self.regs [reg.idx ()])\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn execute (\u0026 mut self) -\u003e CpuResult \u003cOption \u003cVal\u003e\u003e {\n\t\t\twhile self.can_step () {\n\t\t\t\tif let Some (output) = self.step () ? {\n\t\t\t\t\treturn Ok (Some (output));\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (None)\n\t\t}\n\n\t\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t\tpub fn step (\u0026 mut self) -\u003e CpuResult \u003cOption \u003cVal\u003e\u003e {\n\t\t\tif self.limit == 0 { return Err (CpuError::Limit) }\n\t\t\tself.limit -= 1;\n\t\t\tlet instr = self.instrs [self.next.qck_usize ()];\n\t\t\tmatch instr {\n\t\t\t\tInstr::Snd (src) =\u003e {\n\t\t\t\t\tself.next += 1;\n\t\t\t\t\treturn Ok (Some (self.load_src (src)));\n\t\t\t\t},\n\t\t\t\tInstr::Set (dst, src) =\u003e {\n\t\t\t\t\tself.store_dst (dst, self.load_src (src));\n\t\t\t\t},\n\t\t\t\tInstr::Add (dst, src) =\u003e {\n\t\t\t\t\tself.store_dst (dst, Val::add_2 (\n\t\t\t\t\t\tself.load_dst (dst),\n\t\t\t\t\t\tself.load_src (src),\n\t\t\t\t\t).ok ().ok_or (CpuError::Overflow) ?);\n\t\t\t\t},\n\t\t\t\tInstr::Sub (dst, src) =\u003e {\n\t\t\t\t\tself.store_dst (dst, Val::sub_2 (\n\t\t\t\t\t\tself.load_dst (dst),\n\t\t\t\t\t\tself.load_src (src),\n\t\t\t\t\t).ok ().ok_or (CpuError::Overflow) ?);\n\t\t\t\t},\n\t\t\t\tInstr::Mul (dst, src) =\u003e {\n\t\t\t\t\tself.store_dst (dst, Val::mul_2 (\n\t\t\t\t\t\tself.load_dst (dst),\n\t\t\t\t\t\tself.load_src (src),\n\t\t\t\t\t).ok ().ok_or (CpuError::Overflow) ?);\n\t\t\t\t},\n\t\t\t\tInstr::Mod (dst, src) =\u003e {\n\t\t\t\t\tself.store_dst (dst, Val::rem_2 (\n\t\t\t\t\t\tself.load_dst (dst),\n\t\t\t\t\t\tself.load_src (src),\n\t\t\t\t\t).ok ().ok_or (CpuError::Overflow) ?);\n\t\t\t\t},\n\t\t\t\tInstr::Rcv (dst) =\u003e {\n\t\t\t\t\tlet data = self.input.pop_front ().ok_or (CpuError::Receive) ?;\n\t\t\t\t\tself.store_dst (dst, data);\n\t\t\t\t},\n\t\t\t\tInstr::Jgz (cond, offset) =\u003e {\n\t\t\t\t\tif self.load_src (cond) \u003e 0 {\n\t\t\t\t\t\tself.next =\n\t\t\t\t\t\t\tself.next.add_signed (self.load_src (offset))\n\t\t\t\t\t\t\t\t.unwrap_or (u64::MAX);\n\t\t\t\t\t\treturn Ok (None);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstr::Jnz (cnd, off) =\u003e {\n\t\t\t\t\tif self.load_src (cnd) != 0 {\n\t\t\t\t\t\tself.next =\n\t\t\t\t\t\t\tself.next.add_signed (self.load_src (off))\n\t\t\t\t\t\t\t\t.unwrap_or (u64::MAX);\n\t\t\t\t\t\treturn Ok (None);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t\tself.next += 1;\n\t\t\tOk (None)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn load_reg (\u0026 self, reg: Reg) -\u003e Val {\n\t\t\tself.regs [reg.idx ()]\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn store_reg (\u0026 mut self, reg: Reg, val: Val) {\n\t\t\tself.regs [reg.idx ()] = val;\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn load_dst (\u0026 self, dst: DstArg) -\u003e Val {\n\t\t\tmatch dst {\n\t\t\t\tDstArg::Reg (reg) =\u003e self.load_reg (reg),\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn load_src (\u0026 self, src: SrcArg) -\u003e Val {\n\t\t\tmatch src {\n\t\t\t\tSrcArg::Reg (reg) =\u003e self.load_reg (reg),\n\t\t\t\tSrcArg::Imm (val) =\u003e val,\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn store_dst (\u0026 mut self, dst: DstArg, val: Val) {\n\t\t\tmatch dst {\n\t\t\t\tDstArg::Reg (reg) =\u003e self.store_reg (reg, val),\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl Default for Cpu {\n\n\t\t#[ inline ]\n\t\tfn default () -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tinstrs: Rc::from ([]),\n\t\t\t\tregs: [Val::ZERO; 26],\n\t\t\t\tnext: 0_u64,\n\t\t\t\tlimit: u64::MAX,\n\t\t\t\tinput: VecDeque::new (),\n\t\t\t}\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum CpuError {\n\t\tLimit,\n\t\tOverflow,\n\t\tReceive,\n\t}\n\n\tpub type CpuResult \u003cVal\u003e = Result \u003cVal, CpuError\u003e;\n\n\timpl Display for CpuError {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Limit =\u003e write! (formatter, \"Instruction limit reached\") ?,\n\t\t\t\tSelf::Overflow =\u003e write! (formatter, \"Numeric overflow\") ?,\n\t\t\t\tSelf::Receive =\u003e write! (formatter, \"Tried to receive with no input\") ?,\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl Error for CpuError {\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Val = i64;\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Instr {\n\t\tSnd (SrcArg),\n\t\tRcv (DstArg),\n\t\tSet (DstArg, SrcArg),\n\t\tAdd (DstArg, SrcArg),\n\t\tSub (DstArg, SrcArg),\n\t\tMul (DstArg, SrcArg),\n\t\tMod (DstArg, SrcArg),\n\t\tJgz (SrcArg, SrcArg),\n\t\tJnz (SrcArg, SrcArg),\n\t}\n\n\timpl Display for Instr {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Snd (src) =\u003e write! (formatter, \"snd {}\", src),\n\t\t\t\tSelf::Rcv (dst) =\u003e write! (formatter, \"rcv {}\", dst),\n\t\t\t\tSelf::Set (dst, src) =\u003e write! (formatter, \"set {} {}\", dst, src),\n\t\t\t\tSelf::Add (dst, src) =\u003e write! (formatter, \"add {} {}\", dst, src),\n\t\t\t\tSelf::Sub (dst, src) =\u003e write! (formatter, \"sub {} {}\", dst, src),\n\t\t\t\tSelf::Mul (dst, src) =\u003e write! (formatter, \"mul {} {}\", dst, src),\n\t\t\t\tSelf::Mod (dst, src) =\u003e write! (formatter, \"mod {} {}\", dst, src),\n\t\t\t\tSelf::Jgz (cnd, off) =\u003e write! (formatter, \"jgz {} {}\", cnd, off),\n\t\t\t\tSelf::Jnz (cnd, off) =\u003e write! (formatter, \"jnz {} {}\", cnd, off),\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Instr {\n\n\t\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"snd \", @confirm, src);\n\t\t\t\t\tOk (Self::Snd (src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"rcv \", @confirm, dst);\n\t\t\t\t\tOk (Self::Rcv (dst))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"set \", @confirm, dst, \" \", src);\n\t\t\t\t\tOk (Self::Set (dst, src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"add \", @confirm, dst, \" \", src);\n\t\t\t\t\tOk (Self::Add (dst, src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"sub \", @confirm, dst, \" \", src);\n\t\t\t\t\tOk (Self::Sub (dst, src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"mul \", @confirm, dst, \" \", src);\n\t\t\t\t\tOk (Self::Mul (dst, src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"mod \", @confirm, dst, \" \", src);\n\t\t\t\t\tOk (Self::Mod (dst, src))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"jgz \", @confirm, cnd, \" \", off);\n\t\t\t\t\tOk (Self::Jgz (cnd, off))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparse! (parser, \"jnz \", @confirm, cnd, \" \", off);\n\t\t\t\t\tOk (Self::Jnz (cnd, off))\n\t\t\t\t})\n\t\t\t\t.done ()\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum DstArg {\n\t\tReg (Reg),\n\t}\n\n\timpl Display for DstArg {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Reg (reg) =\u003e write! (formatter, \"{}\", reg) ?,\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for DstArg {\n\n\t\t#[ inline ]\n\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet reg = parser.item::\u003cReg\u003e () ?;\n\t\t\t\t\tOk (Self::Reg (reg))\n\t\t\t\t})\n\t\t\t\t.done ()\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum SrcArg {\n\t\tReg (Reg),\n\t\tImm (Val),\n\t}\n\n\timpl Display for SrcArg {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Reg (reg) =\u003e write! (formatter, \"{}\", reg) ?,\n\t\t\t\tSelf::Imm (val) =\u003e write! (formatter, \"{}\", val) ?,\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for SrcArg {\n\n\t\t#[ inline ]\n\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| { parse! (parser, reg); Ok (Self::Reg (reg)) })\n\t\t\t\t.of (|parser| { parse! (parser, val); Ok (Self::Imm (val)) })\n\t\t\t\t.done ()\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub struct Reg (u8);\n\n\timpl Reg {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn idx (self) -\u003e usize {\n\t\t\tself.0.qck_usize ()\n\t\t}\n\n\t\tfn as_char (self) -\u003e char { char::from (self.0 + b'a') }\n\n\t}\n\n\timpl Display for Reg {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tformatter.write_char (self.as_char ())\n\t\t}\n\n\t}\n\n\timpl TryFrom \u003cchar\u003e for Reg {\n\n\t\ttype Error = ();\n\n\t\t#[ inline ]\n\t\tfn try_from (ch: char) -\u003e Result \u003cSelf, ()\u003e {\n\t\t\tif ! ch.is_ascii_lowercase () { return Err (()) }\n\t\t\tOk (Self (ch.qck_u8 () - b'a'))\n\t\t}\n\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Reg {\n\n\t\t#[ inline ]\n\t\tfn from_parser (parser: \u0026 mut Parser) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet ch = parser.expect_next () ?;\n\t\t\t\t\tlet reg = Self::try_from (ch).map_err (|()| parser.err ()) ?;\n\t\t\t\t\tOk (reg)\n\t\t\t\t})\n\t\t\t\t.done ()\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[5008],"length":1,"stats":{"Line":0},"fn_name":"step"},{"line":187,"address":[5019,5187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[5038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[5052,5072,5764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5135,5853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[5259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[5563],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[5592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[5703,5794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[4522,4512],"length":1,"stats":{"Line":0},"fn_name":"as_char"},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":140},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [\"1122\"]));\n\tassert_eq_ok! (\"4\", puzzle.part_one (\u0026 [\"1111\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [\"1234\"]));\n\tassert_eq_ok! (\"9\", puzzle.part_one (\u0026 [\"91212129\"]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_two (\u0026 [\"1212\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [\"1221\"]));\n\tassert_eq_ok! (\"4\", puzzle.part_two (\u0026 [\"123425\"]));\n\tassert_eq_ok! (\"12\", puzzle.part_two (\u0026 [\"123123\"]));\n\tassert_eq_ok! (\"4\", puzzle.part_two (\u0026 [\"12131415\"]));\n}\n","traces":[{"line":6,"address":[24900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[28129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[28245,28150,28659,28722,29317,28192],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[28303,28788,28848,29281,28265,28356],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[28376,28420,28914,28476,28974,29242],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[28540,29097,29203,28496,28596,29037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[24868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[29393],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[30921,29456,30137,29512,30071,29414],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[30883,30205,30266,29572,29534,29631],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[30395,30842,29756,30334,29653,29697],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[30801,29822,29778,30463,30524,29881],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[29903,29947,30650,30589,30006,30760],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-01","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub digits: Vec \u003cu8\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { digits, params } = [ params, @collect digits = digit_parse ]\n}\n\nfn digit_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tif ! matches! (parser.peek (), Some ('0' ..= '9')) { return Err (parser.err ()) }\n\tOk (parser.next ().unwrap ().to_digit (10).unwrap ().pan_u8 ())\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[24362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[43856],"length":1,"stats":{"Line":1},"fn_name":"digit_parse"},{"line":14,"address":[43941,44060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[44048,43949,43976],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-01","lib.rs"],"content":"//! Advent of Code 2017: Day 1: Inverse Captcha\n//!\n//! [https://adventofcode.com/2017/day/1](https://adventofcode.com/2017/day/1)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Inverse Captcha\";\n\tyear = 2017;\n\tday = 1;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[34808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[35128],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-01","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.digits.iter ()\n\t\t\t.circular_tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.filter (|\u0026 (\u0026 digit_0, \u0026 digit_1)| digit_0 == digit_1)\n\t\t\t.map (|(\u0026 digit, _)| digit.pan_u32 ())\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.digits.len () % 2 != 0 {\n\t\treturn Err (\"Must have an even number of digits\".into ());\n\t}\n\tOk (\n\t\tinput.digits.iter ().take (input.digits.len () / 2)\n\t\t\t.zip (input.digits.iter ().skip (input.digits.len () / 2))\n\t\t\t.filter (|\u0026 (\u0026 digit_0, \u0026 digit_1)| digit_0 == digit_1)\n\t\t\t.map (|(\u0026 digit, _)| digit.pan_u32 () * 2)\n\t\t\t.sum ()\n\t)\n}\n","traces":[{"line":5,"address":[27488],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[27505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[23587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[38768],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":15,"address":[27856],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[27876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[28054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[27893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[27941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[23188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[23302,23244],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"5\\t1\\t9\\t5\",\n\t\"7\\t5\\t3\",\n\t\"2\\t4\\t6\\t8\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"5\\t9\\t2\\t8\",\n\t\"9\\t4\\t7\\t3\",\n\t\"3\\t8\\t6\\t5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"18\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"9\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":18,"address":[29975,29584],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":19,"address":[29594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[29932,29705,29615,29762,29653,29828],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[30375,29984],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":25,"address":[29994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[30015,30053,30162,30105,30228,30332],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-02","input.rs"],"content":"use super::*;\n\nuse model::Value;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub rows: Vec \u003cRow\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { rows, params } = [ params, @lines rows ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct Row {\n\t\tpub cells: Vec \u003cValue\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tRow { cells } = [ @delim \"\\t\" cells = (1 .. ) ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[34276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[26900],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-02","lib.rs"],"content":"//! Advent of Code 2017: Day 2: Corruption Checksum\n//!\n//! [https://adventofcode.com/2017/day/2](https://adventofcode.com/2017/day/2)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Corruption Checksum\";\n\tyear = 2017;\n\tday = 2;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Value = u16;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-02","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.rows.iter ()\n\t\t\t.map (|row| {\n\t\t\t\tlet max = row.iter ().max ().copied ().unwrap_or (0).pan_u32 ();\n\t\t\t\tlet min = row.iter ().min ().copied ().unwrap_or (0).pan_u32 ();\n\t\t\t\tmax - min\n\t\t\t})\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tinput.rows.iter ()\n\t\t.map (|row| row.iter ()\n\t\t\t.enumerate ()\n\t\t\t.flat_map (|(idx_0, \u0026 val_0)| row.iter ()\n\t\t\t\t.skip (idx_0 + 1)\n\t\t\t\t.filter_map (move |\u0026 val_1| {\n\t\t\t\t\tlet val_low = cmp::min (val_0, val_1);\n\t\t\t\t\tlet val_high = cmp::max (val_0, val_1);\n\t\t\t\t\t(val_high % val_low == 0).then_some (val_high / val_low)\n\t\t\t\t}))\n\t\t\t.exactly_one ()\n\t\t\t.map_err (|_err| GenError::from (\"No solution found\")))\n\t\t.try_fold (0_u32, |sum, item| {\n\t\t\tlet item = item ?.pan_u32 ();\n\t\t\tOk (chk! (sum + item) ?)\n\t\t})\n}\n","traces":[{"line":5,"address":[28080],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[53392],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":11,"address":[53800,53821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[28272],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[28313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[35526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[32130,31586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[31609,32153],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[52039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[27655],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[30897,30868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[35566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[54064],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":31,"address":[54077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[54196,54320,54230,54336],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":12,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [ \"1\" ]));\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"12\" ]));\n\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [ \"23\" ]));\n\tassert_eq_ok! (\"31\", puzzle.part_one (\u0026 [ \"1024\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_two (\u0026 [ \"1\" ]));\n\tassert_eq_ok! (\"23\", puzzle.part_two (\u0026 [ \"12\" ]));\n\tassert_eq_ok! (\"25\", puzzle.part_two (\u0026 [ \"23\" ]));\n\tassert_eq_ok! (\"1968\", puzzle.part_two (\u0026 [ \"1024\" ]));\n}\n","traces":[{"line":6,"address":[26336,25088],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":7,"address":[25105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[26293,25635,25168,25221,25698,25126],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[25764,25241,25279,25824,26257,25332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[25890,26218,25352,25396,25950,25452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[26013,25472,26073,26179,25572,25516],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[26352,27600],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":16,"address":[26369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[26899,26390,26485,26962,27557,26432],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[27088,27521,26596,26505,26543,27028],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[26660,26616,27154,26716,27482,27214],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[26780,27443,27337,26836,26736,27277],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-03","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub target: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { target, params } = [ params, target ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-03","lib.rs"],"content":"//! Advent of Code 2017: Day 3: Spiral Memory\n//!\n//! [https://adventofcode.com/2017/day/3](https://adventofcode.com/2017/day/3)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Spiral Memory\";\n\tyear = 2017;\n\tday = 3;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Coord = i16;\n\tpub type Pos = aoc_pos::PosRowCol \u003cCoord\u003e;\n\tpub type Dir = aoc_pos::Dir2d;\n\tpub type Turn = aoc_pos::Turn2d;\n}\n","traces":[{"line":18,"address":[36897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[37153],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-03","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Pos;\nuse model::Turn;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet (pos, _) = iter_posns ().zip (1 .. ).find (|\u0026 (_, val)| val == input.target).unwrap ();\n\tOk ((pos.row.unsigned_abs () + pos.col.unsigned_abs ()).pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet mut filled: HashMap \u003cPos, u32\u003e = default ();\n\tfilled.insert (Pos::ZERO, 1);\n\tfor pos in iter_posns ().skip (1) {\n\t\tlet next = pos.adjacent_8 ().iter ()\n\t\t\t.filter_map (|adj_pos| filled.get (adj_pos))\n\t\t\t.sum ();\n\t\tif input.target \u003c next { return Ok (next) }\n\t\tfilled.insert (pos, next);\n\t}\n\tErr (\"No solution found\".into ())\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.target \u003c 1 { return Err (\"Target must be at least one\".into ()) }\n\tif input.target \u003e 1_000_000 { return Err (\"Target must be at most one million\".into ()) }\n\tOk (())\n}\n\nfn iter_posns () -\u003e impl Iterator \u003cItem = Pos\u003e {\n\tlet mut dir = Dir::Down;\n\tlet mut pos = Pos::ZERO;\n\tlet mut rem = 0_u32;\n\tlet mut stride = 0_u32;\n\titer::from_fn (move || {\n\t\tlet next_pos = pos;\n\t\tif rem == 0 {\n\t\t\tdir = dir + Turn::Left;\n\t\t\tif matches! (dir, Dir::Right | Dir::Left) { stride += 1; }\n\t\t\trem = stride;\n\t\t}\n\t\trem -= 1;\n\t\tlet dir_one = (dir, 1);\n\t\tpos = chk! (pos + dir_one).ok () ?;\n\t\tSome (next_pos)\n\t})\n}\n","traces":[{"line":8,"address":[30640],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[30713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[45786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[31189,31091,31145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[31280,31871],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":15,"address":[31359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[31531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[31634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[42433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[31681,31810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[31707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[30657,31300,30685,31331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[31308,30663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[32112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[32119],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[30800,32128],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[32180,32133],"length":1,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[30840,32308,31173,32162],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[32183],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[30864,32188,32281,31018],"length":1,"stats":{"Line":5},"fn_name":null},{"line":48,"address":[24714,24767],"length":1,"stats":{"Line":12},"fn_name":null}],"covered":18,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-04","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input \u003c'inp\u003e {\n\tpub passphrases: Vec \u003cInputLine \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { passphrases, params } = [ params, @lines passphrases ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputLine \u003c'inp\u003e {\n\t\tpub passphrases: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInputLine \u003c'inp\u003e { passphrases } = [\n\t\t@delim \" \" passphrases = passphrase_parse,\n\t]\n}\n\nfn passphrase_parse \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tparser.take_rest_while (|ch| ch.is_ascii_lowercase (), 1 ..= 16)\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[32155,31142],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[32356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-04","lib.rs"],"content":"//! Advent of Code 2017: Day 4: High-Entropy Passphrases\n//!\n//! [https://adventofcode.com/2017/day/4](https://adventofcode.com/2017/day/4)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"High-Entropy Passphrases\";\n\tyear = 2017;\n\tday = 4;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"aa bb cc dd ee\",\n\t\t\"aa bb cc dd aa\",\n\t\t\"aa bb cc dd aaa\",\n\t];\n\n\tconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\t\"abcde fghij\",\n\t\t\"abcde xyz ecdab\",\n\t\t\"a ab abc abd abf abj\",\n\t\t\"iiii oiii ooii oooi oooo\",\n\t\t\"oiii ioii iioi iiio\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_ONE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE_TWO));\n\t}\n\n}\n","traces":[{"line":18,"address":[29624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[38720,39111],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":42,"address":[38730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[38751,38841,38964,38789,38898,39068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[39511,39120],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":48,"address":[39130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[39364,39468,39151,39241,39189,39298],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-04","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.passphrases.iter ()\n\t\t\t.filter (|passphrase| ! passphrase.iter ()\n\t\t\t\t.tuple_combinations::\u003c(_, _)\u003e ()\n\t\t\t\t.any (|(left, right)| left == right))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut buffer_pool: Vec \u003cVec \u003cchar\u003e\u003e = Vec::new ();\n\tlet mut words: Vec \u003cVec \u003cchar\u003e\u003e = Vec::new ();\n\tOk (\n\t\tinput.passphrases.iter ()\n\t\t\t.filter (|passphrase| {\n\t\t\t\twords.extend (\n\t\t\t\t\tpassphrase.iter ()\n\t\t\t\t\t\t.map (|word| {\n\t\t\t\t\t\t\tlet mut buffer = buffer_pool.pop ().unwrap_or_default ();\n\t\t\t\t\t\t\tbuffer.clear ();\n\t\t\t\t\t\t\tbuffer.extend (word.chars ());\n\t\t\t\t\t\t\tbuffer.sort ();\n\t\t\t\t\t\t\tbuffer\n\t\t\t\t\t\t}));\n\t\t\t\tlet result =\n\t\t\t\t\t! words.iter ()\n\t\t\t\t\t\t.tuple_combinations::\u003c(_, _)\u003e ()\n\t\t\t\t\t\t.any (|(left, right)| left == right);\n\t\t\t\tbuffer_pool.append (\u0026 mut words);\n\t\t\t\tresult\n\t\t\t})\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n","traces":[{"line":8,"address":[45017,44795,44784],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":10,"address":[45019,45040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[28336,28725],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[45104],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":22,"address":[45121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[45124],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[45632,45164,45864],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":25,"address":[45649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[45512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[45872,45941],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":9,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-05","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"0\",\n\t\"3\",\n\t\"0\",\n\t\"1\",\n\t\"-3\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[34676,34672],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[35562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[35796,35730,35621,35583,35673,35900],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[34708,34704],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[35962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[36021,36300,36073,35983,36130,36196],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-05","input.rs"],"content":"use super::*;\n\nuse model::Tramp;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub tramps: Vec \u003cTramp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { tramps, params } = [ params, @lines tramps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[21798,22235],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-05","lib.rs"],"content":"//! Advent of Code 2017: Day 5: A Maze of Twisty Trampolines, All Alike\n//!\n//! [https://adventofcode.com/2017/day/5](https://adventofcode.com/2017/day/5)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"A Maze of Twisty Trampolines, All Alike\";\n\tyear = 2017;\n\tday = 5;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Tramp = i16;\n}\n","traces":[{"line":18,"address":[28472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[28792],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-05","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Tramp;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut tramps = input.tramps.clone ();\n\tlet mut offset = Tramp::ZERO;\n\tlet mut count = 0_u32;\n\twhile offset \u003e= Tramp::ZERO \u0026\u0026 offset.pan_usize () \u003c tramps.len () {\n\t\tlet tramp = \u0026 mut tramps [offset.pan_usize ()];\n\t\toffset += * tramp;\n\t\t* tramp += Tramp::ONE;\n\t\tcount += 1_u32;\n\t}\n\tOk (count)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tconst THREE: Tramp = 3;\n\tlet mut tramps = input.tramps.clone ();\n\tlet mut offset = Tramp::ZERO;\n\tlet mut count = 0_u32;\n\twhile offset \u003e= Tramp::ZERO \u0026\u0026 offset.pan_usize () \u003c tramps.len () {\n\t\tlet tramp = \u0026 mut tramps [offset.pan_usize ()];\n\t\toffset += * tramp;\n\t\t* tramp = if * tramp \u003e= THREE { * tramp - Tramp::ONE } else { * tramp + Tramp::ONE };\n\t\tcount += 1_u32;\n\t}\n\tOk (count)\n}\n","traces":[{"line":6,"address":[37776,38136],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[37800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[37885,37992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[37966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[37977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[37987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[38007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[38544,38144],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[38168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[38236,38371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[38320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[38335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[38366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[38385],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-06","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"0\\t2\\t7\\t0\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[26688,27079],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":9,"address":[26698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[27036,26932,26809,26866,26719,26757],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[27479,27088],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":15,"address":[27098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[27157,27436,27209,27119,27266,27332],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-06","input.rs"],"content":"use super::*;\n\nuse model::Banks;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input {\n\tpub banks: Banks,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { banks, params } = [ params, @delim \"\\t\" banks ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[23028],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-06","lib.rs"],"content":"//! Advent of Code 2017: Day 6: Memory Reallocation\n//!\n//! [https://adventofcode.com/2017/day/6](https://adventofcode.com/2017/day/6)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Memory Reallocation\";\n\tyear = 2017;\n\tday = 6;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Banks = Vec \u003cu8\u003e;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-06","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Banks;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet (_, cycle) = calc_result (input);\n\tOk (cycle)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet (cycle_0, cycle_1) = calc_result (input);\n\tOk (cycle_1 - cycle_0)\n}\n\nfn calc_result (input: \u0026 Input) -\u003e (u32, u32) {\n\tlet mut banks = input.banks.clone ();\n\tlet mut seen: HashMap \u003cBanks, u32\u003e = HashMap::new ();\n\tfor cycle in 0 .. {\n\t\tif let Some (prev_cycle) = seen.insert (banks.clone (), cycle) {\n\t\t\treturn (prev_cycle, cycle);\n\t\t}\n\t\tlet (mut idx, \u0026 val) = banks.iter ()\n\t\t\t.enumerate ()\n\t\t\t.max_by_key (|\u0026 (idx, \u0026 val)| (val, cmp::Reverse (idx)))\n\t\t\t.unwrap ();\n\t\tbanks [idx] = 0;\n\t\tfor _ in 0 .. val {\n\t\t\tidx += 1;\n\t\t\tif idx == banks.len () { idx = 0; }\n\t\t\tbanks [idx] += 1;\n\t\t}\n\t}\n\tunreachable! ();\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.banks.len () \u003c 2 {\n\t\treturn Err (\"Must have at least two banks\".into ());\n\t}\n\tif input.banks.iter ().any (|\u0026 val| val \u003e 24) {\n\t\treturn Err (\"Max size of memory in one bank is 24\".into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[44624],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":7,"address":[30195],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[30266],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[30271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[44720],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":13,"address":[30579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[30650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[30655,30861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[44848,45533],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":19,"address":[44873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[45145,45097],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[45154,45238],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[22896,22680],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[45241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[45267,45350],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[45280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[45288],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[45310,45342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[45552],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":40,"address":[45562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[45574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[22912],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":44,"address":[45668],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":19,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-07","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"pbga (66)\",\n\t\"xhth (57)\",\n\t\"ebii (61)\",\n\t\"havc (66)\",\n\t\"ktlj (57)\",\n\t\"fwft (72) -\u003e ktlj, cntj, xhth\",\n\t\"qoyq (66)\",\n\t\"padx (45) -\u003e pbga, havc, qoyq\",\n\t\"tknk (41) -\u003e ugml, padx, fwft\",\n\t\"jptl (61)\",\n\t\"ugml (68) -\u003e gyxo, ebii, jptl\",\n\t\"gyxo (61)\",\n\t\"cntj (57)\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"tknk\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"60\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":22,"address":[34228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[42954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[43013,43122,43065,43188,43292,42975],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[34276],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[43354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[43522,43588,43692,43465,43375,43413],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-07","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Input \u003c'inp\u003e {\n\tpub progs: Vec \u003cProg \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { progs, params } = [ params, @lines progs ]\n}\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Prog \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub weight: u32,\n\tpub holds: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tProg \u003c'inp\u003e { name, weight, holds } = [\n\t\t@str name = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 8), \" \", @confirm,\n\t\t\"(\", weight, \")\",\n\t\tholds {\n\t\t\ttype = Vec \u003c_\u003e;\n\t\t\tholds if (! holds.is_empty ()) = [\n\t\t\t\t\" -\u003e \", @delim \", \" holds { hold = [\n\t\t\t\t\t@str hold = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 8),\n\t\t\t\t] },\n\t\t\t],\n\t\t\tholds = [ @parse holds { Vec::new () } ],\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[33467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[55922],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-07","lib.rs"],"content":"//! Advent of Code 2017: Day 7: Recursive Circus\n//!\n//! [https://adventofcode.com/2017/day/7](https://adventofcode.com/2017/day/7)\n//!\n//! # Input\n//!\n//! A series of \"programs\", one per line, each with a name, a weight in brackets, and an optional\n//! list of \"held\" programs. For example:\n//!\n//! ```text\n//! prog_0 (123)\n//! prog_1 (123) -\u003e prog_2, prog_3\n//! ```\n//!\n//! # Part one\n//!\n//! The programs represent a tree, so there is one program which is not \"held\" by another other,\n//! and which holds all others. Return its name.\n//!\n//! # Part two\n//!\n//! The programs should be balanced, with the total weight of every child tree being equal for\n//! every node. The provided program is not balanced, but it can be made so by modifying the\n//! weight of a single program. Work out the program and return the weight it should have.\n//!\n//! # Algorithm\n//!\n//! To identify the root node, we work out the set of programs which are the children of another,\n//! then iterate over all the program names looking for the single one which does not appear in\n//! this set. We can then use this to build a recursive data structure with a single root where\n//! each node contains a list of its children.\n//!\n//! For part two, we descend the tree, starting from the root, then iteratively descending to the\n//! child which needs to be adjusted. We also track the weight which we expect. Once we find a\n//! node which has balanced children itself, we adjust its weight accordingly, and return the\n//! result.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Recursive Circus\";\n\tyear = 2017;\n\tday = 7;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":52,"address":[39036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[39400],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-07","logic.rs"],"content":"use super::*;\nuse input::Input;\nuse model::ProgInfo;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet root = ProgInfo::build (input) ?;\n\tOk (root.name.to_owned ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet root = ProgInfo::build (input) ?;\n\tlet mut cur = \u0026 root;\n\tlet mut target_weight = root.total_weight;\n\tloop {\n\t\tlet (min_weight, max_weight) =\n\t\t\tcur.holds.iter ()\n\t\t\t\t.map (|held| held.total_weight)\n\t\t\t\t.minmax ()\n\t\t\t\t.into_option ()\n\t\t\t\t.ok_or (\"No solution found\") ?;\n\t\tif min_weight == max_weight {\n\t\t\treturn Ok (u32::sub_2 (\n\t\t\t\tu32::add_2 (cur.prog_weight, target_weight) ?,\n\t\t\t\tcur.total_weight,\n\t\t\t) ?);\n\t\t}\n\t\tlet num_min =\n\t\t\tcur.holds.iter ()\n\t\t\t\t.filter (|held| held.total_weight == min_weight)\n\t\t\t\t.count ();\n\t\tlet num_max =\n\t\t\tcur.holds.iter ()\n\t\t\t\t.filter (|held| held.total_weight == max_weight)\n\t\t\t\t.count ();\n\t\tif num_min + num_max != cur.holds.len () {\n\t\t\treturn Err (\"No solution found\".into ());\n\t\t}\n\t\tlet (wrong_weight, right_weight) =\n\t\t\tmatch (num_min, num_max) {\n\t\t\t\t(1, _) if num_max \u003e 1 =\u003e (min_weight, max_weight),\n\t\t\t\t(_, 1) if num_min \u003e 1 =\u003e (max_weight, min_weight),\n\t\t\t\t_ =\u003e return Err (\"No solution found\".into ()),\n\t\t\t};\n\t\tcur =\n\t\t\tcur.holds.iter ()\n\t\t\t\t.find (|held| held.total_weight == wrong_weight)\n\t\t\t\t.unwrap ();\n\t\ttarget_weight = right_weight;\n\t}\n}\n","traces":[{"line":5,"address":[29120,29385],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":6,"address":[29325,29134,29168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[29408,30590],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":11,"address":[29433,29471,30239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[29717],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[33584],"length":1,"stats":{"Line":3},"fn_name":"call_once\u003c(\u0026aoc_2017_day_07::model::ProgInfo), aoc_2017_day_07::logic::part_two::{closure_env#0}\u003e"},{"line":21,"address":[29735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[30484,30343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[30310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[42481,41024,41872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[26864,29936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[30496,30003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[30377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[30026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[30424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[30182],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-07","model.rs"],"content":"use super::*;\nuse input::Input;\nuse input::Prog;\n\n#[ derive (Debug) ]\npub struct ProgInfo \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub holds: Vec \u003cProgInfo \u003c'inp\u003e\u003e,\n\tpub prog_weight: u32,\n\tpub holds_weight: u32,\n\tpub total_weight: u32,\n}\n\nimpl \u003c'inp\u003e ProgInfo \u003c'inp\u003e {\n\n\t#[ must_use ]\n\tpub fn nested_len (\u0026 self) -\u003e usize {\n\t\tself.holds.iter ().fold (1, |sum, held| sum + held.nested_len ())\n\t}\n\n\tpub fn build (input: \u0026 Input \u003c'inp\u003e) -\u003e GenResult \u003cSelf\u003e {\n\n\t\tif input.progs.is_empty () { return Err (\"Must have at least one program\".into ()) }\n\n\t\tlet mut progs = HashMap::new ();\n\t\tfor prog in input.progs.iter () {\n\t\t\tif progs.contains_key (\u0026 prog.name) {\n\t\t\t\treturn Err (format! (\"Prog name duplicated: {}\", prog.name).into ());\n\t\t\t}\n\t\t\tprogs.insert (prog.name.clone (), prog);\n\t\t}\n\n\t\tlet mut parents: HashMap \u003cInpStr, InpStr\u003e = HashMap::new ();\n\t\tfor prog in input.progs.iter () {\n\t\t\tfor held_name in prog.holds.iter () {\n\t\t\t\tif ! progs.contains_key (held_name) {\n\t\t\t\t\treturn Err (format! (\"Prog {} holds invalid prog {}\", prog.name, held_name).into ());\n\t\t\t\t}\n\t\t\t\tif parents.contains_key (held_name) {\n\t\t\t\t\treturn Err (format! (\"Prog is held multiple times: {}\", held_name).into ());\n\t\t\t\t}\n\t\t\t\tparents.insert (held_name.clone (), prog.name.clone ());\n\t\t\t}\n\t\t}\n\n\t\tlet root = input.progs.iter ()\n\t\t\t.filter (|prog| ! parents.contains_key (\u0026 prog.name))\n\t\t\t.exactly_one ()\n\t\t\t.map_err (|_err| \"More than one prog which is not held by another\") ?;\n\n\t\tOk (Self::build_recursive (\u0026 progs, \u0026 root.name))\n\n\t}\n\n\tfn build_recursive (\n\t\tprogs: \u0026 HashMap \u003cInpStr \u003c'inp\u003e, \u0026 Prog \u003c'inp\u003e\u003e,\n\t\tname: \u0026 InpStr \u003c'inp\u003e,\n\t) -\u003e ProgInfo \u003c'inp\u003e {\n\n\t\tlet prog = progs [name];\n\n\t\tlet holds: Vec \u003cSelf\u003e =\n\t\t\tprog.holds.iter ()\n\t\t\t\t.map (|held_name| Self::build_recursive (progs, held_name))\n\t\t\t\t.collect ();\n\t\tlet holds_weight: u32 =\n\t\t\tholds.iter ()\n\t\t\t\t.map (|held| held.total_weight)\n\t\t\t\t.sum ();\n\n\t\tSelf {\n\t\t\tname: name.clone (),\n\t\t\tholds,\n\t\t\tprog_weight: prog.weight,\n\t\t\tholds_weight,\n\t\t\ttotal_weight: prog.weight + holds_weight,\n\t\t}\n\n\t}\n\n\tpub fn write_input (\u0026 self, dest: \u0026 mut Vec \u003cProg \u003c'inp\u003e\u003e) {\n\n\t\tdest.push (Prog {\n\t\t\tname: self.name.clone (),\n\t\t\tweight: self.prog_weight,\n\t\t\tholds: self.holds.iter ().map (|held| held.name.clone ()).collect (),\n\t\t});\n\n\t\tfor held in self.holds.iter () {\n\t\t\theld.write_input (dest);\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[65088,66897],"length":1,"stats":{"Line":2},"fn_name":"build"},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[65374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[65680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[65790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[65826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[66362,66253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[66502,66409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[66912,67569],"length":1,"stats":{"Line":2},"fn_name":"build_recursive"},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":39},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-08","cpu.rs"],"content":"use super::*;\n\npub type Val = i32;\n\n#[ derive (Clone, Debug) ]\npub struct Cpu \u003c'inp\u003e {\n\tinstrs: Rc \u003c[Instr \u003c'inp\u003e]\u003e,\n\tregs: HashMap \u003cInpStr \u003c'inp\u003e, Val\u003e,\n\tnext: usize,\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum ChkOp {\n\t\tGtrEq = [ \"\u003e=\" ],\n\t\tLsrEq = [ \"\u003c=\" ],\n\t\tEq = [ \"==\" ],\n\t\tNotEq = [ \"!=\" ],\n\t\tGtr = [ \"\u003e\" ],\n\t\tLsr = [ \"\u003c\" ],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum DstOp {\n\t\tInc = [ \"inc\" ],\n\t\tDec = [ \"dec\" ],\n\t}\n}\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Instr \u003c'inp\u003e {\n\tpub dst_reg: InpStr \u003c'inp\u003e,\n\tpub dst_op: DstOp,\n\tpub dst_amt: Val,\n\tpub chk_reg: InpStr \u003c'inp\u003e,\n\tpub chk_op: ChkOp,\n\tpub chk_amt: Val,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInstr \u003c'inp\u003e { dst_reg, dst_op, dst_amt, chk_reg, chk_op, chk_amt } = [\n\t\t@str dst_reg = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 8), \" \",\n\t\tdst_op, \" \",\n\t\tdst_amt, \" \",\n\t\t\"if \",\n\t\t@str chk_reg = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 8), \" \",\n\t\tchk_op, \" \",\n\t\tchk_amt,\n\t]\n}\n\nimpl \u003c'inp\u003e Cpu \u003c'inp\u003e {\n\n\t#[ inline ]\n\tpub fn new (instrs: impl Into \u003cRc \u003c[Instr \u003c'inp\u003e]\u003e\u003e) -\u003e Self {\n\t\tSelf {\n\t\t\tinstrs: instrs.into (),\n\t\t\tregs: default (),\n\t\t\tnext: 0,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn regs (\u0026 self) -\u003e impl Iterator \u003cItem = (\u0026 InpStr \u003c'inp\u003e, \u0026 Val)\u003e {\n\t\tself.regs.iter ()\n\t}\n\n\tpub fn execute (\u0026 mut self) {\n\t\twhile self.next \u003c self.instrs.len () {\n\t\t\tself.step ();\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn is_ready (\u0026 self) -\u003e bool {\n\t\tself.next \u003c self.instrs.len ()\n\t}\n\n\tpub fn step (\u0026 mut self) -\u003e Option \u003c(InpStr \u003c'inp\u003e, Val)\u003e {\n\t\tlet instr = self.instrs [self.next].clone ();\n\t\tself.next += 1;\n\t\tlet chk_val = self.load (\u0026 instr.chk_reg);\n\t\tlet chk_result = match instr.chk_op {\n\t\t\tChkOp::Gtr =\u003e chk_val \u003e instr.chk_amt,\n\t\t\tChkOp::GtrEq =\u003e chk_val \u003e= instr.chk_amt,\n\t\t\tChkOp::Lsr =\u003e chk_val \u003c instr.chk_amt,\n\t\t\tChkOp::LsrEq =\u003e chk_val \u003c= instr.chk_amt,\n\t\t\tChkOp::Eq =\u003e chk_val == instr.chk_amt,\n\t\t\tChkOp::NotEq =\u003e chk_val != instr.chk_amt,\n\t\t};\n\t\tif ! chk_result { return None }\n\t\tlet mut dst_val = self.load (\u0026 instr.dst_reg);\n\t\tmatch instr.dst_op {\t\n\t\t\tDstOp::Inc =\u003e dst_val += instr.dst_amt,\n\t\t\tDstOp::Dec =\u003e dst_val -= instr.dst_amt,\n\t\t}\n\t\tself.store (\u0026 instr.dst_reg, dst_val);\n\t\tSome ((instr.dst_reg.clone (), dst_val))\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn load (\u0026 self, name: \u0026 InpStr \u003c'inp\u003e) -\u003e Val {\n\t\tself.regs.get (name).copied ().unwrap_or (0_i32)\n\t}\n\n\t#[ inline ]\n\tpub fn store (\u0026 mut self, name: \u0026 InpStr \u003c'inp\u003e, val: Val) {\n\t\tself.regs.insert (name.clone (), val);\n\t}\n\n}\n","traces":[{"line":13,"address":[31226,32825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[51726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[33896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[41827,42484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[30912],"length":1,"stats":{"Line":0},"fn_name":"regs"},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[30976],"length":1,"stats":{"Line":0},"fn_name":"execute"},{"line":72,"address":[30985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[31034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[31072],"length":1,"stats":{"Line":0},"fn_name":"is_ready"},{"line":79,"address":[59061,58027],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":21,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-08","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"b inc 5 if a \u003e 1\",\n\t\"a inc 1 if b \u003c 5\",\n\t\"c dec -10 if a \u003e= 1\",\n\t\"c inc -20 if c == 10\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[26356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[59770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[60108,59829,59881,59938,59791,60004],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[26532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[60170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[60191,60508,60229,60338,60404,60281],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-08","input.rs"],"content":"use super::*;\nuse cpu::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub instrs: Vec \u003cInstr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[25819],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-08","lib.rs"],"content":"//! Advent of Code 2017: Day 8: I Heard You Like Registers\n//!\n//! [https://adventofcode.com/2017/day/8](https://adventofcode.com/2017/day/8)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod cpu;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"I Heard You Like Registers\";\n\tyear = 2017;\n\tday = 8;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[52440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[52760],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-08","logic.rs"],"content":"use super::*;\n\nuse cpu::Cpu;\nuse cpu::Val;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (\u0026 * input.instrs);\n\tcpu.execute ();\n\tOk (\n\t\tcpu.regs ()\n\t\t\t.map (|(_, \u0026 val)| val)\n\t\t\t.max ()\n\t\t\t.unwrap_or (Val::ZERO)\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (\u0026 * input.instrs);\n\tOk (\n\t\titer::from_fn (|| cpu.is_ready ().then (|| cpu.step ()))\n\t\t\t.flatten ()\n\t\t\t.map (|(_, val)| val)\n\t\t\t.max ()\n\t\t\t.unwrap_or (Val::ZERO)\n\t)\n}\n","traces":[{"line":7,"address":[41216,41858],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[25904,30784],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003c((\u0026aoc_inpstr::InpStr, \u0026i32)), aoc_2017_day_08::logic::part_one::{closure_env#0}\u003e"},{"line":18,"address":[42453,41872],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[29044,26568,24138,30800,30864,24822,26584,30854,30808,30868,30824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[29913,30880,25877,30884,30893,29190,28872,29430],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-09","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub input: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { input, params } = [ params, input ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-09","lib.rs"],"content":"//! Advent of Code 2017: Day 9: Stream Processing\n//!\n//! [https://adventofcode.com/2017/day/9](https://adventofcode.com/2017/day/9)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Stream Processing\";\n\tyear = 2017;\n\tday = 9;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"{}\" ]));\n\t\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [ \"{{{}}}\" ]));\n\t\tassert_eq_ok! (\"5\", puzzle.part_one (\u0026 [ \"{{},{}}\" ]));\n\t\tassert_eq_ok! (\"16\", puzzle.part_one (\u0026 [ \"{{{},{},{{}}}}\" ]));\n\t\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"{\u003ca\u003e,\u003ca\u003e,\u003ca\u003e,\u003ca\u003e}\" ]));\n\t\tassert_eq_ok! (\"9\", puzzle.part_one (\u0026 [ \"{{\u003cab\u003e},{\u003cab\u003e},{\u003cab\u003e},{\u003cab\u003e}}\" ]));\n\t\tassert_eq_ok! (\"9\", puzzle.part_one (\u0026 [ \"{{\u003c!!\u003e},{\u003c!!\u003e},{\u003c!!\u003e},{\u003c!!\u003e}}\" ]));\n\t\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"{{\u003ca!\u003e},{\u003ca!\u003e},{\u003ca!\u003e},{\u003cab\u003e}}\" ]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [ \"\u003c\u003e\" ]));\n\t\tassert_eq_ok! (\"17\", puzzle.part_two (\u0026 [ \"\u003crandom characters\u003e\" ]));\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [ \"\u003c\u003c\u003c\u003c\u003e\" ]));\n\t\tassert_eq_ok! (\"2\", puzzle.part_two (\u0026 [ \"\u003c{!\u003e}\u003e\" ]));\n\t\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [ \"\u003c!!\u003e\" ]));\n\t\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [ \"\u003c!!!\u003e\u003e\" ]));\n\t\tassert_eq_ok! (\"10\", puzzle.part_two (\u0026 [ \"\u003c{o\\\"i!a,\u003c{i\u003ca\u003e\" ]));\n\t}\n\n}\n","traces":[{"line":27,"address":[30688,30692],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[24897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[24960,25907,24918,27225,25970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[25124,25071,26036,26096,25033,27189],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[26222,25188,26162,25144,25244,27150],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[26288,27111,25264,25364,26348,25308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[25384,26414,27072,26474,25484,25428],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[26540,27033,25548,26600,25604,25504],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[25668,26726,26994,25624,25724,26666],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[25744,26789,26849,25844,26955,25788],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[27280,29458],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":41,"address":[27297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[29415,27318,27416,27360,28225,28291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[28359,29377,27476,28420,27535,27438],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[27660,27601,29336,28549,28488,27557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[27785,28617,27726,28678,29295,27682],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[28807,29254,27807,27851,27910,28746],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[28035,27932,28875,27976,28936,29213],"length":1,"stats":{"Line":3},"fn_name":null},{"line":48,"address":[29001,28101,28160,28057,29062,29172],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-09","logic.rs"],"content":"use super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet (score, _) = calc_result (input) ?;\n\tOk (score)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet (_, garbage) = calc_result (input) ?;\n\tOk (garbage)\n}\n\nfn calc_result (input: \u0026 Input) -\u003e GenResult \u003c(u32, u32)\u003e {\n\t#[ derive (Clone, Copy) ]\n\tenum State { Normal, Garbage, Cancel }\n\tuse State::{ Normal, Garbage, Cancel };\n\tlet mut depth = 0_u32;\n\tlet mut state = Normal;\n\tlet mut score = 0_u32;\n\tlet mut garbage = 0_u32;\n\tfor ch in input.input.chars () {\n\t\tmatch (state, ch) {\n\t\t\t(Normal, '{') =\u003e depth += 1,\n\t\t\t(Normal, '}') =\u003e {\n\t\t\t\tif depth == 0 { return Err (\"Unexpected '}'\".into ()) }\n\t\t\t\tscore += depth;\n\t\t\t\tdepth -= 1;\n\t\t\t},\n\t\t\t(Normal, '\u003c') =\u003e state = Garbage,\n\t\t\t(Normal, _) =\u003e (),\n\t\t\t(Garbage, '\u003e') =\u003e state = Normal,\n\t\t\t(Garbage, '!') =\u003e state = Cancel,\n\t\t\t(Garbage, _) =\u003e garbage += 1,\n\t\t\t(Cancel, _) =\u003e state = Garbage,\n\t\t}\n\t}\n\tmatch state {\n\t\tNormal =\u003e if depth != 0 { return Err (\"Stream ended inside group\".into ()) },\n\t\tGarbage =\u003e return Err (\"Stream ended during garbage\".into ()),\n\t\tCancel =\u003e return Err (\"Stream ended during garbage cancel\".into ()),\n\t}\n\tOk ((score, garbage))\n}\n","traces":[{"line":4,"address":[30000],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":5,"address":[30030,30011,30060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":6,"address":[37959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[30096],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":10,"address":[38338,38306,38286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[38347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[30192],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":22,"address":[30400,30239,30301],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[30410,30448],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[30606,30370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[30576,30463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[30467,30622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[30649,30476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[30590,30432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[30308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[30491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[30330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[30509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[30560],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"3,4,1,5\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"3,4,1,5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4a19451b02fb05416d73aea0ec8c00c0\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":14,"address":[36752,36756],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[51210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[51269,51548,51231,51321,51378,51444],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[36788,36784],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[51610],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[51721,51948,51778,51631,51669,51844],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-10","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub data: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { data, params } = [ params, data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub rounds_one: u32 = (\"ROUNDS_ONE=\", 1, 1 ..= 64),\n\t\tpub rounds_two: u32 = (\"ROUNDS_TWO=\", 64, 1 ..= 64),\n\t}\n}\n","traces":[{"line":17,"address":[44831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[44835],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-10","lib.rs"],"content":"//! Advent of Code 2017: Day 10: Knot Hash\n//!\n//! [https://adventofcode.com/2017/day/10](https://adventofcode.com/2017/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2017_knot as knot;\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Knot Hash\";\n\tyear = 2017;\n\tday = 10;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[42184],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-10","logic.rs"],"content":"use super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet data: Vec \u003cu8\u003e =\n\t\tinput.data\n\t\t\t.split (',')\n\t\t\t.map (str::parse)\n\t\t\t.try_collect () ?;\n\tlet string = knot::calc_sparse (data, input.params.rounds_one);\n\tOk (string [0].pan_u32 () * string [1].pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet hash =\n\t\tknot::calculate_rounds (\n\t\t\tinput.data.as_bytes (),\n\t\t\tinput.params.rounds_two);\n\tlet result =\n\t\thash.iter ()\n\t\t\t.map (|\u0026 byte| format! (\"{:02x}\", byte))\n\t\t\t.collect ();\n\tOk (result)\n}\n","traces":[{"line":4,"address":[36912],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":5,"address":[37182,36960,37387],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[37211],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[37366,37434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[37472],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[37510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[37627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[29734,31256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[37651],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":8,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-11","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"ne,ne,ne\" ]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [ \"ne,ne,sw,sw\" ]));\n\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [ \"ne,ne,s,s\" ]));\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"se,sw,se,sw,sw\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [ \"ne,ne,ne\" ]));\n\tassert_eq_ok! (\"2\", puzzle.part_two (\u0026 [ \"ne,ne,sw,sw\" ]));\n\tassert_eq_ok! (\"2\", puzzle.part_two (\u0026 [ \"ne,ne,s,s\" ]));\n\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [ \"se,sw,se,sw,sw\" ]));\n}\n","traces":[{"line":6,"address":[31300,31296],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":7,"address":[32849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[34037,32912,32965,32870,33379,33442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[33508,34001,33076,33023,32985,33568],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[33962,33096,33196,33694,33634,33140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[33923,33316,33757,33817,33216,33260],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[31328,31332],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":16,"address":[34113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[35301,34229,34176,34643,34134,34706],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[34772,34340,34287,34832,34249,35265],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[34898,34958,35226,34360,34404,34460],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[34580,35187,34524,35021,35081,34480],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-11","input.rs"],"content":"use super::*;\n\nuse model::VHexDir;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cVHexDir\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @delim \",\" steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[26324],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-11","lib.rs"],"content":"//! Advent of Code 2017: Day 11: Hex Ed\n//!\n//! [https://adventofcode.com/2017/day/11](https://adventofcode.com/2017/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Hex Ed\";\n\tyear = 2017;\n\tday = 11;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[42600],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-11","logic.rs"],"content":"use super::*;\nuse input::Input;\nuse model::Pos;\nuse model::VHexDir;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet final_pos =\n\t\tposns_iter (input.steps.iter ().copied ())\n\t\t\t.last ()\n\t\t\t.unwrap_or (Pos::ZERO);\n\tOk (calc_dist (final_pos))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tposns_iter (input.steps.iter ().copied ())\n\t\t\t.map (calc_dist)\n\t\t\t.max ()\n\t\t\t.unwrap_or (0)\n\t)\n}\n\nfn posns_iter (\n\tmut steps_iter: impl Iterator \u003cItem = VHexDir\u003e,\n) -\u003e impl Iterator \u003cItem = Pos\u003e {\n\tuse VHexDir::{ NorthWest, North, NorthEast, SouthWest, South, SouthEast };\n\tlet mut pos = Pos::ZERO;\n\titer::from_fn (move || {\n\t\tlet step = steps_iter.next () ?;\n\t\tpos += match step {\n\t\t\tNorthWest =\u003e Pos { n: 1, e: -1 },\n\t\t\tNorth =\u003e Pos { n: 2, e: 0 },\n\t\t\tNorthEast =\u003e Pos { n: 1, e: 1 },\n\t\t\tSouthWest =\u003e Pos { n: -1, e: -1 },\n\t\t\tSouth =\u003e Pos { n: -2, e: 0 },\n\t\t\tSouthEast =\u003e Pos { n: -1, e: 1 },\n\t\t};\n\t\tSome (pos)\n\t})\n}\n\nfn calc_dist (pos: Pos) -\u003e u32 {\n\tlet horiz_steps = pos.e.abs ();\n\tlet vert_steps = cmp::max (pos.n.abs () - horiz_steps, 0) / 2;\n\thoriz_steps.pan_u32 () + vert_steps.pan_u32 ()\n}\n","traces":[{"line":6,"address":[25360],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[25735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[25824],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":16,"address":[25883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[32576],"length":1,"stats":{"Line":0},"fn_name":"posns_iter\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003caoc_2017_day_11::model::VHexDir\u003e\u003e\u003e"},{"line":28,"address":[32608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[25498,25544,25701,25636,25436],"length":1,"stats":{"Line":10},"fn_name":null},{"line":30,"address":[25646,25561],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[25920],"length":1,"stats":{"Line":1},"fn_name":"calc_dist"},{"line":44,"address":[26129,25951],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[26077,26165],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":8,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-11","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Pos = aoc_pos::PosGeo \u003cCoord\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\n\tpub enum VHexDir {\n\t\tNorthWest = \"nw\",\n\t\tNorthEast = \"ne\",\n\t\tSouthWest = \"sw\",\n\t\tSouthEast = \"se\",\n\t\tNorth = \"n\",\n\t\tSouth = \"s\",\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"0 \u003c-\u003e 2\",\n\t\"1 \u003c-\u003e 1\",\n\t\"2 \u003c-\u003e 0, 3, 4\",\n\t\"3 \u003c-\u003e 2, 4\",\n\t\"4 \u003c-\u003e 2, 3, 6\",\n\t\"5 \u003c-\u003e 6\",\n\t\"6 \u003c-\u003e 4, 5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":16,"address":[60036,60032],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":17,"address":[71082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[71103,71141,71193,71316,71250,71420],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[60064,60068],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":23,"address":[71482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[71503,71593,71716,71820,71541,71650],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-12","input.rs"],"content":"use super::*;\nuse model::Village;\n\npub type InputPipes = Vec \u003cInputPipe\u003e;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub pipes: InputPipes,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { pipes, params } = [ params, @lines pipes ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputPipe {\n\tpub left: Village,\n\tpub right: Vec \u003cVillage\u003e,\n}\n\nstruct_parser_display! {\n\tInputPipe { left, right } = [ left, \" \u003c-\u003e \", @delim \", \" right ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[47412],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[47632],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-12","lib.rs"],"content":"//! Advent of Code 2017: Day 12: Digital Plumber\n//!\n//! [https://adventofcode.com/2017/day/12](https://adventofcode.com/2017/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Digital Plumber\";\n\tyear = 2017;\n\tday = 12;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[56088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[56408],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-12","logic.rs"],"content":"use super::*;\nuse input::Input;\nuse model::Grouper;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grouper = Grouper::build (input);\n\tOk (grouper.group_size (0).pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grouper = Grouper::build (input);\n\tOk (grouper.groups ().count ().pan_u32 ())\n}\n","traces":[{"line":5,"address":[59603,59472],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":6,"address":[59485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[59552,59493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[60018,59616],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":11,"address":[59646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[59919],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-12","model.rs"],"content":"use super::*;\nuse input::Input;\n\npub type Village = u16;\n\n#[ derive (Clone, Debug, Default) ]\npub struct Grouper {\n\tdata: BTreeSet \u003c(Village, Village)\u003e,\n\treverse: HashMap \u003cVillage, Village\u003e,\n}\n\nimpl Grouper {\n\n\t#[ must_use ]\n\tpub fn build (input: \u0026 Input) -\u003e Self {\n\n\t\t#[ derive (Default) ]\n\t\tstruct State {\n\t\t\treverse: HashMap \u003cVillage, Village\u003e,\n\t\t\tvillages: Vec \u003cVillage\u003e,\n\t\t}\n\n\t\timpl State {\n\t\t\tfn resolve (\u0026 mut self, village: Village) -\u003e Village {\n\t\t\t\tlet mut cur = some_or! (self.reverse.get (\u0026 village).copied (), {\n\t\t\t\t\tself.reverse.insert (village, village);\n\t\t\t\t\tself.villages.push (village);\n\t\t\t\t\treturn village;\n\t\t\t\t});\n\t\t\t\tlet group = loop {\n\t\t\t\t\tlet next = self.reverse.get (\u0026 cur).copied ().unwrap ();\n\t\t\t\t\tif next == cur { break cur }\n\t\t\t\t\tcur = next;\n\t\t\t\t};\n\t\t\t\tlet mut cur = village;\n\t\t\t\twhile cur != group {\n\t\t\t\t\tcur = self.reverse.insert (cur, group).unwrap ();\n\t\t\t\t}\n\t\t\t\tgroup\n\t\t\t}\n\t\t}\n\n\t\tlet mut state = State::default ();\n\n\t\tfor (left, right) in input.pipes.iter ()\n\t\t\t.flat_map (|pipe| pipe.right.iter ()\n\t\t\t\t.map (|\u0026 right| (pipe.left, right))) {\n\t\t\tlet left_group = state.resolve (left);\n\t\t\tlet right_group = state.resolve (right);\n\t\t\tlet new_group = cmp::min (left_group, right_group);\n\t\t\tlet old_group = cmp::max (left_group, right_group);\n\t\t\tstate.reverse.insert (old_group, new_group);\n\t\t}\n\n\t\tlet villages = mem::take (\u0026 mut state.villages);\n\t\tlet data: BTreeSet \u003c(Village, Village)\u003e =\n\t\t\tvillages.iter ()\n\t\t\t\t.map (|\u0026 village| (state.resolve (village), village))\n\t\t\t\t.collect ();\n\n\t\tSelf { data, reverse: state.reverse }\n\n\t}\n\n\t#[ must_use ]\n\tpub fn group_size (\u0026 self, group: Village) -\u003e usize {\n\t\tlet \u0026 group = some_or! (self.reverse.get (\u0026 group), return 0);\n\t\tself.data\n\t\t\t.range ((group, Village::MIN) ..= (group, Village::MAX))\n\t\t\t.count ()\n\t}\n\n\tpub fn groups (\u0026 self) -\u003e impl Iterator \u003cItem = Village\u003e + '_ {\n\t\tlet mut bound = Bound::Included ((Village::MIN, Village::ZERO));\n\t\titer::from_fn (move || {\n\t\t\tlet \u0026 (next, _) = self.data.range ((bound, Bound::Unbounded)).next () ?;\n\t\t\tbound = Bound::Excluded ((next, Village::MAX));\n\t\t\tSome (next)\n\t\t})\n\t}\n\n}\n","traces":[{"line":15,"address":[76496,77266],"length":1,"stats":{"Line":1},"fn_name":"build"},{"line":24,"address":[77280],"length":1,"stats":{"Line":1},"fn_name":"resolve"},{"line":25,"address":[77450,77907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[77913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[78059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[78113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[77490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[77496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[77688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[77693,77743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[77735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[76678,76758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[26430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[76790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[76804],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[76816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[76829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[52257,52256],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":61,"address":[77098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[78144],"length":1,"stats":{"Line":1},"fn_name":"group_size"},{"line":67,"address":[78394,78295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[78528],"length":1,"stats":{"Line":0},"fn_name":"groups"},{"line":75,"address":[52288],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":76,"address":[46673,46722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[52436],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":22,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"0: 3\", \"1: 2\", \"4: 4\", \"6: 4\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"24\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[28336,28727],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":9,"address":[28346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[28405,28514,28367,28580,28684,28457],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[28736,29127],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":15,"address":[28746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[28857,28980,29084,28914,28767,28805],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-13","input.rs"],"content":"use super::*;\n\nuse model::LayerDepth;\nuse model::LayerRange;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub layers: Vec \u003cLayer\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { layers, params } = [ params, @lines layers ]\n}\n\n#[ derive (Clone, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Layer {\n\tpub depth: LayerDepth,\n\tpub range: LayerRange,\n}\n\nstruct_parser_display! {\n\tLayer { depth, range } = [ depth, \": \", range ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[29995,29414],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-13","lib.rs"],"content":"//! Advent of Code 2017: Day 13: Packet Scanners\n//!\n//! [https://adventofcode.com/2017/day/13](https://adventofcode.com/2017/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Packet Scanners\";\n\tyear = 2017;\n\tday = 13;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type LayerDepth = u8;\n\tpub type LayerRange = u8;\n}\n","traces":[{"line":18,"address":[53128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[53448],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-13","logic.rs"],"content":"use super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet layers = analyse (input) ?;\n\tOk (\n\t\tlayers.iter ()\n\t\t\t.filter (|layer| layer.offset % layer.period == 0)\n\t\t\t.map (|layer| layer.score)\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tlet layers = analyse (input) ?;\n\n\tlet mut layer_idx = 0_usize;\n\tlet mut repeat: Vec \u003cu32\u003e = vec! [ 0 ];\n\tlet mut period = 1;\n\n\t// iterate over time periods the size of the repeating pattern\n\n\tlet mut base_time = 0_u32;\n\twhile layer_idx \u003c layers.len () {\n\n\t\t// add another layer to the repeating pattern if possible\n\n\t\tlet layer = \u0026 layers [layer_idx];\n\t\tif layer.offset \u003c base_time \u0026\u0026 base_time % layer.period == 0 {\n\n\t\t\t// update the repeating pattern to include this layer\n\n\t\t\tlet mul = layer.period / divisor (period, layer.period);\n\t\t\trepeat = (0 .. )\n\t\t\t\t.step_by (period.pan_usize ())\n\t\t\t\t.take (mul.pan_usize ())\n\t\t\t\t.cartesian_product (repeat)\n\t\t\t\t.map (|(incr, time)| incr + time)\n\t\t\t\t.filter (|time| (time + layer.offset) % layer.period != 0)\n\t\t\t\t.collect ();\n\t\t\tperiod *= mul;\n\t\t\tlayer_idx += 1;\n\n\t\t\tif repeat.len () \u003e 1000 {\n\t\t\t\treturn Err (\"Max 1000 elements in repeating pattern\".into ());\n\t\t\t}\n\n\t\t}\n\n\t\t// check the pattern for times which also match inactive layers\n\n\t\tfor \u0026 offset in repeat.iter () {\n\t\t\tlet time = u32::add_2 (base_time, offset) ?;\n\t\t\tif layers.iter ().skip (layer_idx)\n\t\t\t\t\t.all (|layer| (time + layer.offset) % layer.period != 0) {\n\t\t\t\treturn Ok (time)\n\t\t\t}\n\t\t}\n\n\t\t// advance time period for next application of repeating pattern\n\n\t\tbase_time = u32::add_2 (base_time, period) ?;\n\n\t}\n\n\tErr (\"No solution found\".into ())\n\n}\n\nfn divisor (left: u32, right: u32) -\u003e u32 {\n\t(2 ..= cmp::min (left, right)).rev ()\n\t\t.find (|div| left % div == 0 \u0026\u0026 right % div == 0)\n\t\t.unwrap_or (1)\n}\n\nfn analyse (input: \u0026 Input) -\u003e GenResult \u003cVec \u003cLayerInfo\u003e\u003e {\n\tif input.layers.iter ().any (|layer| layer.range \u003c 2) {\n\t\treturn Err (\"Layer range must be at least two\".into ());\n\t}\n\tlet layers =\n\t\tinput.layers.iter ().cloned ()\n\t\t\t.map (|layer| LayerInfo {\n\t\t\t\toffset: layer.depth.pan_u32 (),\n\t\t\t\tperiod: (layer.range.pan_u32 () - 1) * 2,\n\t\t\t\tscore: layer.depth.pan_u32 () * layer.range.pan_u32 (),\n\t\t\t})\n\t\t\t.sorted_by_key (|layer| layer.offset)\n\t\t\t.collect::\u003cVec \u003cLayerInfo\u003e\u003e ();\n\tOk (layers)\n}\n\n#[ derive (Clone, Copy, Debug) ]\nstruct LayerInfo {\n\toffset: u32,\n\tperiod: u32,\n\tscore: u32,\n}\n","traces":[{"line":4,"address":[63648,63971],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":5,"address":[63693,63670,63868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":8,"address":[32238,31500,32320,31581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[40752],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":14,"address":[65496,63984],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[65147,64009,64035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[64090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[65097,64119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[64206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[64362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[64763,64568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[64540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[48228,47028,48293,47093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[47040,48014,48240,47956,47136,48336,47965],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[64787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[64801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[64810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[65258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[64898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[64932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[65006],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[27047,26966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[65192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[65079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[65108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[64256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[47392,47406,47381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[65504],"length":1,"stats":{"Line":2},"fn_name":"analyse"},{"line":78,"address":[31284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[65696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[65630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[41272,41008],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":85,"address":[41134,41298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[41257,41323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[41360],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":90,"address":[65676],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":31,"coverable":36},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-14","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub key: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { key, params } = [ params, key ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_rounds: u32 = (\"NUM_ROUNDS=\", 64, 1 ..= 64),\n\t\tpub num_rows: u32 = (\"NUM_ROWS=\", 128, 1 ..= 128),\n\t}\n}\n","traces":[{"line":17,"address":[51138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[51142],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-14","lib.rs"],"content":"//! Advent of Code 2017: Day 14: Disk Defragmentation\n//!\n//! [https://adventofcode.com/2017/day/14](https://adventofcode.com/2017/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2017_knot as knot;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Disk Defragmentation\";\n\tyear = 2017;\n\tday = 14;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"8108\", puzzle.part_one (\u0026 [ \"flqrgnkx\" ]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"1242\", puzzle.part_two (\u0026 [ \"flqrgnkx\" ]));\n\t}\n\n}\n","traces":[{"line":20,"address":[74856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[75208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[39552,39943],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":31,"address":[39562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[39900,39730,39583,39673,39621,39796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[39952,40343],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":37,"address":[39962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[40300,40073,40021,40130,39983,40196],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-14","logic.rs"],"content":"use super::*;\nuse input::Input;\n\npub type Pos = pos::PosRowCol \u003cu8\u003e;\npub type Grid = GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tcalc_hashes (input).iter ()\n\t\t\t.map (|hash| hash.iter ().copied ()\n\t\t\t\t.map (u8::count_ones)\n\t\t\t\t.sum::\u003cu32\u003e ())\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\t// calculate hashes and construct a grid\n\n\tlet grid = Grid::wrap_size (\n\t\tcalc_hashes (input).iter ()\n\t\t\t.flat_map (move |\u0026 hash| -\u003e [bool; 128] {\n\t\t\t\tarray::from_fn (|addr| {\n\t\t\t\t\tlet idx = addr \u003e\u003e 3_u32;\n\t\t\t\t\tlet mask = 0x80 \u003e\u003e (addr \u0026 0x7);\n\t\t\t\t\thash [idx] \u0026 mask != 0\n\t\t\t\t})\n\t\t\t})\n\t\t\t.collect (),\n\t\tPos::new (input.params.num_rows.pan_u8 (), 128));\n\n\t// iterate over positions, look for ones, track which we have seen already\n\n\tlet mut seen = Grid::new_size (grid.size ());\n\tlet mut regions = 0;\n\tfor pos in grid.iter ().map (|(pos, _)| pos) {\n\t\tif seen.get (pos).unwrap () { continue }\n\t\tif ! grid.get (pos).unwrap () { continue }\n\t\tseen.set (pos, true);\n\n\t\t// recursively iterate over adjacent unseen positions which are also ones, also mark them\n\t\t// as seen\n\n\t\tlet mut todo = Vec::new ();\n\t\ttodo.push (pos);\n\t\twhile let Some (pos) = todo.pop () {\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\tif seen.get (adj_pos).unwrap_or (true) { continue }\n\t\t\t\tseen.set (adj_pos, true);\n\t\t\t\tif ! grid.get (adj_pos).unwrap_or (false) { continue }\n\t\t\t\ttodo.push (adj_pos);\n\t\t\t}\n\t\t}\n\n\t\tregions += 1;\n\n\t}\n\n\tOk (regions)\n\n}\n\nfn calc_hashes (input: \u0026 Input) -\u003e Vec \u003c[u8; 16]\u003e {\n\t(0_u32 .. input.params.num_rows)\n\t\t.map (|row| knot::calculate_rounds (\n\t\t\tformat! (\"{}-{}\", input.key, row).as_bytes (),\n\t\t\tinput.params.num_rounds))\n\t\t.collect ()\n}\n","traces":[{"line":7,"address":[42832,42965],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[42902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[73520,73532],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":12,"address":[73652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[44667,42976],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":23,"address":[56931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[73952],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":25,"address":[53740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[38289,37742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[49766,49749,49786],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[44544,43302,43132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[43692,43481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[43716,43744],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[43776,43752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[43782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[43955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[44078,43968,44619,43999],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[44084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[44119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[44136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[44228,44381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[44265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[42842,42999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[74016,74344],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":67,"address":[74034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[74172],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":24,"coverable":26},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Generator A starts with 65\",\n\t\"Generator B starts with 8921\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"588\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"309\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[26352,26743],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":12,"address":[26362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[26421,26383,26596,26700,26530,26473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[26752,27143],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":18,"address":[26762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[26930,26996,27100,26783,26821,26873],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-15","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub start_a: u32,\n\tpub start_b: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { start_a, start_b, params } = [\n\t\tparams,\n\t\t\"Generator A starts with \", start_a, \"\\n\",\n\t\t\"Generator B starts with \", start_b,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub reps_one: u32 = (\"REPS_ONE=\", 40_000_000, 0 .. ),\n\t\tpub reps_two: u32 = (\"REPS_TWO=\", 5_000_000, 0 .. ),\n\t}\n}\n","traces":[{"line":21,"address":[37907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[37911],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-15","lib.rs"],"content":"//! Advent of Code 2017: Day 15: Dueling Generators\n//!\n//! [https://adventofcode.com/2017/day/15](https://adventofcode.com/2017/day/15)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Dueling Generators\";\n\tyear = 2017;\n\tday = 15;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-15","logic.rs"],"content":"use super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\t#[ inline ]\n\tfn calc_next (factor: u64, prev: u64) -\u003e u64 {\n\t\tprev.pan_u64 ().wrapping_mul (factor.pan_u64 ()) % 0x_7fff_ffff\n\t}\n\tOk (\n\t\tcalc_result (\n\t\t\tinput,\n\t\t\tinput.params.reps_one,\n\t\t\t|val| calc_next (16807, val),\n\t\t\t|val| calc_next (48271, val))\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\t#[ inline ]\n\tfn calc_next (factor: u64, mask: u64, prev: u64) -\u003e u64 {\n\t\tlet mut cur = prev;\n\t\tloop {\n\t\t\tcur = cur.pan_u64 ().wrapping_mul (factor.pan_u64 ()) % 0x_7fff_ffff;\n\t\t\tif cur \u0026 mask == 0 { return cur }\n\t\t}\n\t}\n\tOk (\n\t\tcalc_result (\n\t\t\tinput,\n\t\t\tinput.params.reps_two,\n\t\t\t|val| calc_next (16807, 0x3, val),\n\t\t\t|val| calc_next (48271, 0x7, val))\n\t)\n}\n\n#[ inline ]\nfn calc_result (\n\tinput: \u0026 Input,\n\tnum_compares: u32,\n\tcalc_a: fn (u64) -\u003e u64,\n\tcalc_b: fn (u64) -\u003e u64,\n) -\u003e u32 {\n\titertools::iterate ((input.start_a.pan_u64 (), input.start_b.pan_u64 ()),\n\t\t\t|\u0026 (a, b)| (calc_a (a), calc_b (b)))\n\t\t.skip (1)\n\t\t.take (num_compares.pan_usize ())\n\t\t.filter (|\u0026 (a, b)| a \u0026 0xffff == b \u0026 0xffff)\n\t\t.count ()\n\t\t.pan_u32 ()\n}\n","traces":[{"line":4,"address":[33440],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[33450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[47838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[41703,41536],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":14,"address":[41895,41728],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":18,"address":[33680],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[33866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[33690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[33687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[41920,42108],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":32,"address":[42316,42128],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":37,"address":[33936],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-16","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"s1,x3/4,pe/b\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"paedcbfghijklmno\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"ghidjklmnopabcef\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[35392,35396],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":11,"address":[47354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[47465,47588,47522,47413,47692,47375],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[35424,35428],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":17,"address":[47754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[47922,47813,48092,47775,47988,47865],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-16","input.rs"],"content":"use super::*;\nuse model::Step;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @delim \",\" steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub reps_two: u64 = (\"REPS_TWO=\", 1_000_000_000, 2_u64 .. ),\n\t}\n}\n","traces":[{"line":11,"address":[30051,30619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[45085],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-16","lib.rs"],"content":"//! Advent of Code 2017: Day 16: Permutation Promenade\n//!\n//! [https://adventofcode.com/2017/day/16](https://adventofcode.com/2017/day/16)\n//!\n//! # Input\n//!\n//! A single line containing a comma-separated list of \"dance steps\", where `X` and `Y` are\n//! positions in the range `0` to `15`, and `A` and `B` are programmes in the range `a` to `p`.\n//!\n//! - `sX` rotates the line left by `X`\n//! - `xX/Y` exchanges positions `X` and `Y`\n//! - `pA/B` swaps programmes `A` and `B`\n//!\n//! # Part one\n//!\n//! Starting with the programme line `abcdefghijklmnop`, apply the steps once.\n//!\n//! # Part two\n//!\n//! Same as part one, but repeat the process one billion times.\n//!\n//! # Algorithm\n//!\n//! We split the process in two, tracking position changes separately from programme swaps, which\n//! we refer to as a transformation. These transformations can then be combined giving an efficient\n//! way to execute many steps in O(n) time. To apply a transformation we first apply the position\n//! changes, then the programme swaps.\n//!\n//! First we combine all of the steps into a single transformation. We then iterate over the bits\n//! in the number of times we want to apply the steps, starting with the lowest, updating the line\n//! if the bit is a one. To work out the transformation for the next bit, we combine the current\n//! transformation with itself.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Permutation Promenade\";\n\tyear = 2017;\n\tday = 16;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":48,"address":[58431],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-16","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Line;\nuse model::Pos;\nuse model::Prog;\nuse model::Step;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet trans = Transform::compile (\u0026 input.steps);\n\tlet progs = trans.apply (Line::default ());\n\tOk (progs.to_string ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tOk (calc_result (input, input.params.reps_two))\n}\n\nfn calc_result (input: \u0026 Input, num_reps: u64) -\u003e String {\n\tlet mut transform = Transform::compile (\u0026 input.steps);\n\tlet mut state = Line::default ();\n\tlet mut remain = num_reps;\n\twhile remain != 0 {\n\t\tif remain \u0026 1 != 0 {\n\t\t\tstate = transform.apply (state);\n\t\t}\n\t\ttransform = transform.combine (transform);\n\t\tremain \u003e\u003e= 1_u32;\n\t}\n\tstate.to_string ()\n}\n\n#[ derive (Clone, Copy) ]\nstruct Transform {\n\tposns: Line \u003cPos\u003e,\n\tswaps: Line \u003cProg\u003e,\n}\n\n/// Efficient abstract to transform [`Line \u003cProg\u003e`]\n///\n/// This tracks changes of positions and swaps between programmes separately. Transformations can\n/// be applied to a [`Line \u003cProg\u003e`], and they can also be combined with another `Transform`. A\n/// transform can be initialised from a list of [`Step`]s.\n///\n/// To implement this, we track position changes separately from swaps of named programmes. When\n/// applied to a programme line, we first apply the position swaps, then the programmes, which\n/// gives the same answer.\n///\nimpl Transform {\n\n\tfn compile (steps: \u0026 [Step]) -\u003e Self {\n\t\tlet mut posns = Line::default ();\n\t\tlet mut swaps = Line::default ();\n\t\tfor step in steps.iter ().copied () {\n\t\t\tmatch step {\n\t\t\t\tStep::Spin (prg) =\u003e {\n\t\t\t\t\tlet size = 16 - prg.idx ();\n\t\t\t\t\tposns = Line::from (\n\t\t\t\t\t\tarray::from_fn (|idx|\n\t\t\t\t\t\t\tposns [(idx + size.pan_usize ()) \u0026 0xf]));\n\t\t\t\t},\n\t\t\t\tStep::Exchange (pos_0, pos_1) =\u003e {\n\t\t\t\t\t(posns [pos_0.idx ()], posns [pos_1.idx ()]) =\n\t\t\t\t\t\t(posns [pos_1.idx ()], posns [pos_0.idx ()]);\n\t\t\t\t},\n\t\t\t\tStep::Partner (prg_0, prg_1) =\u003e {\n\t\t\t\t\tfor prg in swaps.iter_mut () {\n\t\t\t\t\t\tlet cur = * prg;\n\t\t\t\t\t\tif cur == prg_0 { * prg = prg_1; }\n\t\t\t\t\t\tif cur == prg_1 { * prg = prg_0; }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tSelf { posns, swaps }\n\t}\n\n\tfn combine (self, other: Self) -\u003e Self {\n\t\tlet posns = Line::from (self.posns.map (|pos| other.posns [pos.idx ()]));\n\t\tlet swaps = Line::from (self.swaps.map (|prog| other.swaps [prog.idx ()]));\n\t\tSelf { posns, swaps }\n\t}\n\n\tfn apply (self, progs: Line \u003cProg\u003e) -\u003e Line \u003cProg\u003e {\n\t\tLine::from (self.posns.map (|prog|\n\t\t\tself.swaps [progs [prog.idx ()].idx ()]\n\t\t))\n\t}\n\n}\n","traces":[{"line":10,"address":[52496],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[52540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[52548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[52838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[52960],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":17,"address":[58855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[53008],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":21,"address":[53059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[53542,53164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[53200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[53205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[53507,53332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[53536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[53792],"length":1,"stats":{"Line":2},"fn_name":"compile"},{"line":55,"address":[54096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[54156,54777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[41440],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":61,"address":[41506,41447],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[54312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[54502,54575,54822],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[54367,54804,54442],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[54608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[54715,54665,54683],"length":1,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[54659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[54673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[34281,34373,34337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[34161,34197,34105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[52668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[40766,40825,40708,40844],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":27,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-16","model.rs"],"content":"use super::*;\n\npub use line::Line;\npub use line::LineItem;\npub use pos::Pos;\npub use prog::Prog;\npub use step::Step;\n\nmod pos {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Pos { id: u8 }\n\n\timpl Pos {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn idx (self) -\u003e usize {\n\t\t\tself.id.pan_usize ()\n\t\t}\n\n\t}\n\n\timpl Display for Pos {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"{}\", self.id) ?;\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl LineItem for Pos {\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Pos {\n\n\t\t#[ inline ]\n\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tlet id = parser.uint () ?;\n\t\t\tif ! (0 ..= 15).contains (\u0026 id) { return Err (parser.err ()) }\n\t\t\tOk (Self { id })\n\t\t}\n\n\t}\n\n\timpl TryFrom \u003cu8\u003e for Pos {\n\n\t\ttype Error = ();\n\n\t\t#[ inline ]\n\t\tfn try_from (id: u8) -\u003e Result \u003cSelf, ()\u003e {\n\t\t\tif ! (0 .. 16).contains (\u0026 id) { return Err (()) }\n\t\t\tOk (Self { id })\n\t\t}\n\n\t}\n\n}\n\nmod prog {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub struct Prog { id: u8 }\n\n\timpl Prog {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn idx (self) -\u003e usize {\n\t\t\tself.id.pan_usize ()\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn as_char (self) -\u003e char {\n\t\t\tmatch self.id {\n\t\t\t\t0x00 =\u003e 'a', 0x01 =\u003e 'b', 0x02 =\u003e 'c', 0x03 =\u003e 'd',\n\t\t\t\t0x04 =\u003e 'e', 0x05 =\u003e 'f', 0x06 =\u003e 'g', 0x07 =\u003e 'h',\n\t\t\t\t0x08 =\u003e 'i', 0x09 =\u003e 'j', 0x0a =\u003e 'k', 0x0b =\u003e 'l',\n\t\t\t\t0x0c =\u003e 'm', 0x0d =\u003e 'n', 0x0e =\u003e 'o', 0x0f =\u003e 'p',\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl Display for Prog {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tformatter.write_char (self.as_char ()) ?;\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Prog {\n\n\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\tSelf::try_from (parser.expect_next () ?).map_err (|_err| parser.err ())\n\t\t}\n\n\t}\n\n\timpl LineItem for Prog {\n\t}\n\n\timpl TryFrom \u003cchar\u003e for Prog {\n\n\t\ttype Error = ();\n\n\t\t#[ inline ]\n\t\tfn try_from (ch: char) -\u003e Result \u003cSelf, ()\u003e {\n\t\t\tlet id = match ch {\n\t\t\t\t'a' =\u003e 0x00, 'b' =\u003e 0x01, 'c' =\u003e 0x02, 'd' =\u003e 0x03,\n\t\t\t\t'e' =\u003e 0x04, 'f' =\u003e 0x05, 'g' =\u003e 0x06, 'h' =\u003e 0x07,\n\t\t\t\t'i' =\u003e 0x08, 'j' =\u003e 0x09, 'k' =\u003e 0x0a, 'l' =\u003e 0x0b,\n\t\t\t\t'm' =\u003e 0x0c, 'n' =\u003e 0x0d, 'o' =\u003e 0x0e, 'p' =\u003e 0x0f,\n\t\t\t\t_ =\u003e return Err (()),\n\t\t\t};\n\t\t\tOk (Self { id })\n\t\t}\n\n\t}\n\n\timpl TryFrom \u003cu8\u003e for Prog {\n\n\t\ttype Error = ();\n\n\t\t#[ inline ]\n\t\tfn try_from (id: u8) -\u003e Result \u003cSelf, ()\u003e {\n\t\t\tif ! (0 .. 16).contains (\u0026 id) { return Err (()) }\n\t\t\tOk (Self { id })\n\t\t}\n\n\t}\n\n}\n\nmod line {\n\n\tuse super::*;\n\n\tpub trait LineItem: Copy + Display + TryFrom \u003cu8\u003e {\n\t}\n\n\t#[ derive (Copy, Clone, Debug) ]\n\tpub struct Line \u003cItem: LineItem\u003e {\n\t\tprogs: [Item; 16],\n\t}\n\n\timpl \u003cItem: LineItem\u003e Default for Line \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn default () -\u003e Self {\n\t\t\tlet progs = array::from_fn (|idx|\n\t\t\t\tItem::try_from (idx.pan_u8 ()).map_err (|_err| unreachable! ()).unwrap ());\n\t\t\tSelf { progs }\n\t\t}\n\n\t}\n\n\timpl \u003cItem: LineItem\u003e Deref for Line \u003cItem\u003e {\n\n\t\ttype Target = [Item; 16];\n\n\t\t#[ inline ]\n\t\tfn deref (\u0026 self) -\u003e \u0026 [Item; 16] {\n\t\t\t\u0026 self.progs\n\t\t}\n\n\t}\n\n\timpl \u003cItem: LineItem\u003e DerefMut for Line \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn deref_mut (\u0026 mut self) -\u003e \u0026 mut [Item; 16] {\n\t\t\t\u0026 mut self.progs\n\t\t}\n\n\t}\n\n\timpl \u003cItem: LineItem\u003e Display for Line \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfor prog in self.progs {\n\t\t\t\tDisplay::fmt (\u0026 prog, formatter) ?;\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl \u003cItem: LineItem\u003e From \u003c[Item; 16]\u003e for Line \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn from (progs: [Item; 16]) -\u003e Self {\n\t\t\tSelf { progs }\n\t\t}\n\n\t}\n\n}\n\nmod step {\n\n\tuse super::*;\n\n\tenum_decl_parser_display! {\n\t\t#[ derive (Copy, Clone, Debug) ]\n\t\tpub enum Step {\n\t\t\tSpin (pos: Pos) = [ \"s\", pos ],\n\t\t\tExchange (pos_0: Pos, pos_1: Pos) = [ \"x\", pos_0, \"/\", pos_1 ],\n\t\t\tPartner (prg_0: Prog, prg_1: Prog) = [ \"p\", prg_0, \"/\", prg_1 ],\n\t\t}\n\t}\n\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":48},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-17","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"123\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"698\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"29108944\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[21911,21520],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":11,"address":[21530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[21551,21764,21641,21589,21868,21698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[21920,22311],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":17,"address":[21930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[21951,22098,22164,21989,22041,22268],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-17","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub advance: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { advance, params } = [ params, advance ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-17","lib.rs"],"content":"//! Advent of Code 2017: Day 17: Spinlock\n//!\n//! [https://adventofcode.com/2017/day/17](https://adventofcode.com/2017/day/17)\n//!\n//! # Input\n//!\n//! A single line containing a positive number. This is the number of positions to advance in each\n//! iteration.\n//!\n//! # Part one\n//!\n//! Begin with a circular buffer containing only the number `0`. Iterate 2017 times, moving forward\n//! the number of positions specified in the input, plus one, then insert the next number after the\n//! current position. The answer is the number after that in the resulting buffer.\n//!\n//! # Part two\n//!\n//! Same as part one, but iterate fifty million times, and return the number following `0` in the\n//! buffer.\n//!\n//! # Algorithm\n//!\n//! For part one, we use a nave algorithm, creating the circular buffer and inserting the number\n//! each time.\n//!\n//! For part two, we instead only track the number that was last inserted after zero. We model the\n//! circular buffer with only the following information:\n//!\n//! * `size`: total number of items in the buffer\n//! * `pos`: current position, where `0` is at position `0`\n//! * `second`: item at position `1`, ie the answer\n//!\n//! Instead of iterating fifty million times, we alternate between advancing towards the end of the\n//! buffer quickly using division, and advancing past the end of the buffer in a single step. This\n//! allows the process to complete much more quickly.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Spinlock\";\n\tyear = 2017;\n\tday = 17;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":50,"address":[39057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[39313],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-17","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet mut buffer = VecDeque::new ();\n\tbuffer.push_back (0_u32);\n\tfor next in 1 ..= 2017 {\n\t\tbuffer.rotate_left ((input.advance.pan_usize () + 1) % buffer.len ());\n\t\tbuffer.push_front (next);\n\t}\n\tbuffer.rotate_left (1);\n\tOk (buffer.pop_front ().unwrap ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet mut pos = 0_u32;\n\tlet mut size = 1_u32;\n\tlet mut second = 1_u32;\n\tlet mut next = 1_u32;\n\twhile next \u003c= 50_000_000 {\n\n\t\t// advance quickly without wrapping\n\n\t\tif input.advance \u003c size {\n\t\t\tlet mut iters = (size - pos - 1) / input.advance;\n\t\t\tif 50_000_000 \u003c iters + next { iters = 50_000_000 - next; }\n\t\t\tpos += iters * (input.advance + 1);\n\t\t\tsize += iters;\n\t\t\tnext += iters;\n\t\t}\n\n\t\t// advance slowly with wrapping\n\n\t\tpos = (pos + input.advance) % size + 1;\n\t\tif pos == 1 { second = next; }\n\t\tsize += 1;\n\t\tnext += 1;\n\n\t}\n\tOk (second)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif ! (2 .. 1_000).contains (\u0026 input.advance) {\n\t\treturn Err (\"Advance must be at least two and less than one thousand\".into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":6,"address":[25792,26857],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[25854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[26231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[26293,26325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[26684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[26880],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":19,"address":[26930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[27156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[27008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[27013,27272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[27337,27444,27048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[27076,27353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[27104,27401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[27112,27417],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[27188,27120],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[27141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[27148,27234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[27152,27253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[27168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[25824,26900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[25830,26906],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"set a 1\",\n\t\"add a 2\",\n\t\"mul a a\",\n\t\"mod a 5\",\n\t\"snd a\",\n\t\"set a 0\",\n\t\"rcv a\",\n\t\"jgz a -1\",\n\t\"set a 1\",\n\t\"jgz a -2\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"snd 1\",\n\t\"snd 2\",\n\t\"snd p\",\n\t\"rcv a\",\n\t\"rcv b\",\n\t\"rcv c\",\n\t\"rcv d\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":29,"address":[26528,26532],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":30,"address":[38122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[38356,38233,38143,38460,38181,38290],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[26564,26560],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[38522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[38690,38756,38860,38581,38543,38633],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-18","input.rs"],"content":"use super::*;\nuse cpu::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[36619],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-18","lib.rs"],"content":"//! Advent of Code 2017: Day 18: Duet\n//!\n//! [https://adventofcode.com/2017/day/18](https://adventofcode.com/2017/day/18)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2017_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Duet\";\n\tyear = 2017;\n\tday = 18;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[27080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[27400],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-18","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse cpu::Cpu;\nuse cpu::CpuError;\nuse cpu::Instr;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tlet mut cpu = Cpu::new (\u0026 * input.instrs);\n\tcpu.set_limit (10_000);\n\tlet mut last_freq = None;\n\tloop {\n\t\tmatch cpu.execute () {\n\t\t\tOk (Some (freq)) =\u003e last_freq = Some (freq),\n\t\t\tOk (None) =\u003e break,\n\t\t\tErr (CpuError::Receive) if last_freq.is_some () =\u003e return Ok (last_freq.unwrap ()),\n\t\t\tErr (err) =\u003e return Err (err.into ()),\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tuse ProgramState::{ Okay, Waiting, Halted };\n\n\t// set up both programs\n\n\tlet instrs = Rc::from (input.instrs.as_slice ());\n\tlet mut prog_0 = Program::new (\u0026 instrs, 0);\n\tlet mut prog_1 = Program::new (\u0026 instrs, 1);\n\n\t// main loop\n\n\tlet mut num_sends: u32 = 0;\n\twhile prog_0.state == Okay || prog_1.state == Okay {\n\n\t\t// select which program to run, prefering `prog_1`\n\n\t\tlet (prog_a, prog_b) = if prog_1.state == Okay {\n\t\t\t(\u0026 mut prog_1, \u0026 mut prog_0)\n\t\t} else {\n\t\t\t(\u0026 mut prog_0, \u0026 mut prog_1)\n\t\t};\n\n\t\t// run until something interesting happens\n\n\t\tmatch prog_a.cpu.execute () {\n\t\t\tOk (Some (output)) =\u003e {\n\t\t\t\tif prog_b.cpu.input ().len () == 1000 {\n\t\t\t\t\treturn Err (\"Queue full (1000 items)\".into ());\n\t\t\t\t}\n\t\t\t\tprog_b.cpu.push_input (output);\n\t\t\t\tif prog_b.state == Waiting { prog_b.state = Okay; }\n\t\t\t\tif prog_a.id == 1 { num_sends += 1; }\n\t\t\t},\n\t\t\tOk (None) =\u003e {\n\t\t\t\tprog_a.state = Halted;\n\t\t\t\tif prog_a.id == 1 { break }\n\t\t\t},\n\t\t\tErr (CpuError::Receive) =\u003e {\n\t\t\t\tprog_a.state = Waiting;\n\t\t\t},\n\t\t\tErr (err) =\u003e {\n\t\t\t\treturn Err (format! (\"CPU error: {}\", err).into ());\n\t\t\t}\n\t\t}\n\n\t}\n\n\tOk (num_sends)\n\n}\n\n#[ derive (Debug, Default, Eq, PartialEq) ]\nenum ProgramState {\n\t#[ default ]\n\tOkay,\n\tWaiting,\n\tHalted,\n}\n\n#[ derive (Debug) ]\nstruct Program {\n\tid: u32,\n\tcpu: Cpu,\n\tstate: ProgramState,\n}\n\nimpl Program {\n\tfn new (instrs: \u0026 [Instr], id: u32) -\u003e Self {\n\t\tlet mut cpu = Cpu::new (instrs);\n\t\tcpu.set_limit (100_000_u64);\n\t\tcpu.set_reg ('p', id.pan_i64 ()).unwrap ();\n\t\tSelf { id, cpu, state: default () }\n\t}\n}\n","traces":[{"line":9,"address":[29504,29981],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[29549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[29719,29758,29794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[29730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[29865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[29849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[29763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[30000,31092],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":30,"address":[30152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[30174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[30206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[30224,30702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[30287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[30417,30656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[30443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[30468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[30938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[30523,30504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[30535,31001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[30579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[30601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[30672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[30803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[30905,30812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[30731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[31104,31484],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":93,"address":[31127],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[31342],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":28},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-19","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"     |          \",\n\t\"     |  +--+    \",\n\t\"     A  |  C    \",\n\t\" F---|----E|--+ \",\n\t\"     |  |  |  D \",\n\t\"     +B-+  +--+ \",\n\t\"                \",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"ABCDEF\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"38\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-19","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-19","lib.rs"],"content":"//! Advent of Code 2017: Day 19: A Series of Tubes\n//!\n//! [https://adventofcode.com/2017/day/19](https://adventofcode.com/2017/day/19)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"A Series of Tubes\";\n\tyear = 2017;\n\tday = 19;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-19","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Dir;\nuse model::Pos;\nuse model::Tile;\nuse model::Turn;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tOk (\n\t\troute_iter (input) ?\n\t\t\t.take (30_000)\n\t\t\t.filter_map (|(_, tile)|\n\t\t\t\tif let Tile::Letter (asc) = tile { Some (asc.pan_char ()) } else { None })\n\t\t\t.collect ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\troute_iter (input) ?\n\t\t\t.take (30_000)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn route_iter (\n\tinput: \u0026 Input,\n) -\u003e GenResult \u003cimpl Iterator \u003cItem = (Pos, Tile)\u003e + '_\u003e {\n\n\t// find start position\n\n\tlet mut pos =\n\t\tinput.grid.iter ()\n\t\t\t.take_while (|\u0026 (pos, _)| pos.row == 0)\n\t\t\t.filter (|\u0026 (_, tile)| tile == Tile::Vert)\n\t\t\t.map (|(pos, _)| pos)\n\t\t\t.exactly_one ()\n\t\t\t.ok ()\n\t\t\t.ok_or (\"Must have exactly one start position\") ?;\n\n\t// iterate over path\n\n\tlet mut dir = Dir::Down;\n\tOk (iter::from_fn (move || {\n\t\tlet tile = input.grid.get (pos).unwrap_or (Tile::Empty);\n\n\t\t// move straight if on a line or a letter\n\n\t\tif matches! (tile, Tile::Vert | Tile::Horiz | Tile::Letter (_)) {\n\t\t\tlet last_pos = pos;\n\t\t\tlet dir_one = (dir, 1);\n\t\t\tpos = chk! (pos + dir_one).ok () ?;\n\t\t\treturn Some ((last_pos, tile));\n\t\t}\n\n\t\t// turn if on a corner\n\n\t\tfor turn in [ Turn::Left, Turn::Right ].iter ().copied () {\n\t\t\tlet next_dir = dir + turn;\n\t\t\tlet next_dir_one = (next_dir, 1);\n\t\t\tlet next_pos = ok_or! (chk! (pos + next_dir_one), continue);\n\t\t\tif matches! (input.grid.get (next_pos),\n\t\t\t\t\tSome (Tile::Vert | Tile::Horiz | Tile::Letter (_))) {\n\t\t\t\tdir = next_dir;\n\t\t\t\tlet last_pos = pos;\n\t\t\t\tpos = next_pos;\n\t\t\t\treturn Some ((last_pos, tile));\n\t\t\t}\n\t\t}\n\n\t\tNone\n\t}))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-19","model.rs"],"content":"use super::*;\n\npub type Coord = u8;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosRowCol \u003cCoord\u003e;\npub type Turn = pos::Turn2d;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tEmpty = [ \" \" ],\n\t\tHoriz = [ \"-\" ],\n\t\tVert = [ \"|\" ],\n\t\tCorner = [ \"+\" ],\n\t\tLetter (asc: u8) = [ asc = (letter_parse, letter_display) ],\n\t}\n}\n\nfn letter_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tif ! matches! (parser.peek (), Some ('A' ..= 'Z')) { return Err (parser.err ()) }\n\tOk (parser.next ().unwrap ().pan_u8 ())\n}\n\nfn letter_display (letter: \u0026 u8, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\tformatter.write_char (letter.pan_char ())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"p=\u003c3,0,0\u003e, v=\u003c2,0,0\u003e, a=\u003c-1,0,0\u003e\",\n\t\"p=\u003c4,0,0\u003e, v=\u003c0,0,0\u003e, a=\u003c-2,0,0\u003e\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"p=\u003c-6,0,0\u003e, v=\u003c3,0,0\u003e, a=\u003c0,0,0\u003e\",\n\t\"p=\u003c-4,0,0\u003e, v=\u003c2,0,0\u003e, a=\u003c0,0,0\u003e\",\n\t\"p=\u003c-2,0,0\u003e, v=\u003c1,0,0\u003e, a=\u003c0,0,0\u003e\",\n\t\"p=\u003c3,0,0\u003e, v=\u003c-1,0,0\u003e, a=\u003c0,0,0\u003e\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":18,"address":[33024,33415],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":19,"address":[33034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[33202,33055,33093,33145,33268,33372],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[33815,33424],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":25,"address":[33434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[33493,33545,33602,33772,33455,33668],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-20","input.rs"],"content":"use super::*;\nuse model::Particle;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub particles: Vec \u003cParticle\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { particles, params } = [ params, @lines particles ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[33924],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-20","lib.rs"],"content":"//! Advent of Code 2017: Day 20: Particle Swarm\n//!\n//! [https://adventofcode.com/2017/day/20](https://adventofcode.com/2017/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Particle Swarm\";\n\tyear = 2017;\n\tday = 20;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[29688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[30008],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-20","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Aspect;\nuse model::Axis;\nuse model::Coord;\nuse model::Particle;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.particles.is_empty () { return Err (\"No particles provided\".into ()) }\n\tlet (idx, _, _, _) =\n\t\tinput.particles.iter ().copied ()\n\t\t\t.enumerate ()\n\t\t\t.map (|(idx, mut part)| {\n\t\t\t\tfor axis in [ Axis::X, Axis::Y, Axis::Z ] {\n\t\t\t\t\tif [ Aspect::Acc, Aspect::Vel, Aspect::Pos ].iter ().copied ()\n\t\t\t\t\t\t\t.map (|aspect| part [aspect] [axis].signum ())\n\t\t\t\t\t\t\t.find (|\u0026 sign| sign != 0)\n\t\t\t\t\t\t\t.unwrap_or (0) \u003c 0 {\n\t\t\t\t\t\tpart.acc [axis] = - part.acc [axis];\n\t\t\t\t\t\tpart.vel [axis] = - part.vel [axis];\n\t\t\t\t\t\tpart.pos [axis] = - part.pos [axis];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk::\u003c_, nums::Overflow\u003e ((\n\t\t\t\t\tidx,\n\t\t\t\t\tCoord::add_3 (part.acc.x, part.acc.y, part.acc.z) ?,\n\t\t\t\t\tCoord::add_3 (part.vel.x, part.vel.y, part.vel.z) ?,\n\t\t\t\t\tCoord::add_3 (part.pos.x, part.pos.y, part.pos.z) ?,\n\t\t\t\t))\n\t\t\t})\n\t\t\t.fold_ok (None, |min: Option \u003c(usize, Coord, Coord, Coord)\u003e, item| min\n\t\t\t\t.map (|min| {\n\t\t\t\t\tlet min_key = (min.1, min.2, min.3);\n\t\t\t\t\tlet item_key = (item.1, item.2, item.3);\n\t\t\t\t\tif min_key \u003c item_key { min } else { item }\n\t\t\t\t}).or (Some (item))) ?\n\t\t\t.unwrap ();\n\tOk (idx.pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.particles.is_empty () { return Ok (0) }\n\tif input.particles.len () == 1 { return Ok (1) }\n\tstruct PartState { _idx: usize, part: Particle, alive: bool }\n\tlet mut parts: Vec \u003cPartState\u003e =\n\t\tinput.particles.iter ().copied ()\n\t\t\t.enumerate ()\n\t\t\t.map (|(idx, part)| PartState { _idx: idx, part, alive: true })\n\t\t\t.collect ();\n\tlet mut time = 0_u32;\n\twhile ! parts.is_empty () {\n\t\tparts.sort_by_key (|state| state.part.pos);\n\t\t'IDX_0: for idx_0 in 0 .. parts.len () - 1 {\n\t\t\tlet pos_0 = parts [idx_0].part.pos;\n\t\t\tfor idx_1 in idx_0 + 1 .. parts.len () {\n\t\t\t\tif ! parts [idx_1].alive { continue }\n\t\t\t\tlet pos_1 = parts [idx_1].part.pos;\n\t\t\t\tif pos_0 != pos_1 { continue 'IDX_0 }\n\t\t\t\tparts [idx_0].alive = false;\n\t\t\t\tparts [idx_1].alive = false;\n\t\t\t}\n\t\t}\n\t\tif time == 50 { break } // TODO this is hacky (but quite fast)\n\t\tparts.retain (|state| state.alive);\n\t\tfor state in parts.iter_mut () { state.part = next (state.part) ?; }\n\t\ttime += 1;\n\t}\n\tOk (parts.iter ().filter (|\u0026 state| state.alive).count ().pan_u32 ())\n}\n\nfn next (mut part: Particle) -\u003e NumResult \u003cParticle\u003e {\n\tpart.vel.x = Coord::add_2 (part.vel.x, part.acc.x) ?;\n\tpart.vel.y = Coord::add_2 (part.vel.y, part.acc.y) ?;\n\tpart.vel.z = Coord::add_2 (part.vel.z, part.acc.z) ?;\n\tpart.pos.x = Coord::add_2 (part.pos.x, part.vel.x) ?;\n\tpart.pos.y = Coord::add_2 (part.pos.y, part.vel.y) ?;\n\tpart.pos.z = Coord::add_2 (part.pos.z, part.vel.z) ?;\n\tOk (part)\n}\n","traces":[{"line":10,"address":[50976],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[50995,51151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[51076,51066],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[43635,43616,44482],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":16,"address":[43660,43768,44467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[44024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[30916,31734,30877,31756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[44576],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":21,"address":[44099,44062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[44127,44164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[43712,44192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[44385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[44242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[44278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[44315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[44592],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":34,"address":[44752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[44755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[32640,32620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[44736,44798,44675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[51138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[52653,51248],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":44,"address":[51272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[51294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[44800,44803],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":53,"address":[51408,52092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[39335,40542,40754,40008,41168,41424,39193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[51465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[51557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[51685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[51742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[51808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[51844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[51855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[36472,36319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[51967,52058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[29008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[52672],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":74,"address":[52689,52709],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[52759,52739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[52805,52785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[52848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[52886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[52925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[52944],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":38,"coverable":45},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-20","model.rs"],"content":"use super::*;\n\npub type Axis = pos::AxisXYZ;\npub type Coord = i16;\npub type CoordAbs = u16;\npub type Pos = pos::PosXYZ \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Aspect { Pos, Vel, Acc }\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Particle {\n\tpub pos: Pos,\n\tpub vel: Pos,\n\tpub acc: Pos,\n}\n\nstruct_parser_display! {\n\tParticle {\n\t\tpos: Pos { x: pos_x, y: pos_y, z: pos_z },\n\t\tvel: Pos { x: vel_x, y: vel_y, z: vel_z },\n\t\tacc: Pos { x: acc_x, y: acc_y, z: acc_z },\n\t} = [\n\t\t\"p=\u003c\", pos_x, \",\", pos_y, \",\", pos_z, \"\u003e, \",\n\t\t\"v=\u003c\", vel_x, \",\", vel_y, \",\", vel_z, \"\u003e, \",\n\t\t\"a=\u003c\", acc_x, \",\", acc_y, \",\", acc_z, \"\u003e\",\n\t]\n}\n\nimpl Index \u003cAspect\u003e for Particle {\n\ttype Output = Pos;\n\tfn index (\u0026 self, aspect: Aspect) -\u003e \u0026 Pos {\n\t\tmatch aspect {\n\t\t\tAspect::Pos =\u003e \u0026 self.pos,\n\t\t\tAspect::Vel =\u003e \u0026 self.vel,\n\t\t\tAspect::Acc =\u003e \u0026 self.acc,\n\t\t}\n\t}\n}\n","traces":[{"line":32,"address":[44928],"length":1,"stats":{"Line":0},"fn_name":"index"},{"line":33,"address":[31739,30863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[31746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[31752],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-21","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub rules: Vec \u003cInputRule\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { rules, params } = [ params, @lines rules ]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum InputRule {\n\t\tTwoToThree (from: u8, to: u16) = [ from = parse_pixels_2, \" =\u003e \", to = parse_pixels_3 ],\n\t\tThreeToFour (from: u16, to: u16) = [ from = parse_pixels_3, \" =\u003e \", to = parse_pixels_4 ],\n\t}\n}\n\npub fn parse_pixels_2 (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tparse_pixels (parser, 2).map (u64::pan_u8)\n}\n\npub fn parse_pixels_3 (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu16\u003e {\n\tparse_pixels (parser, 3).map (u64::pan_u16)\n}\n\npub fn parse_pixels_4 (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu16\u003e {\n\tparse_pixels (parser, 4).map (u64::pan_u16)\n}\n\npub fn parse_pixels (parser: \u0026 mut Parser, size: usize) -\u003e ParseResult \u003cu64\u003e {\n\tlet mut val = 0_u64;\n\tlet new_bit = (1_u64 \u003c\u003c ((size * size) - 1)).pan_u64 ();\n\tfor row in 0 .. size {\n\t\tif row \u003e 0 { parse! (parser, \"/\"); }\n\t\tfor _col in 0 .. size {\n\t\t\tparse! (parser, bit: InputPixel);\n\t\t\tval \u003e\u003e= 1_u32;\n\t\t\tif bit == InputPixel::On { val |= new_bit; }\n\t\t}\n\t}\n\tOk (val)\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\n\tpub enum InputPixel {\n\t\t#[ default ]\n\t\tOff = [ \".\" ],\n\t\tOn = [ \"#\" ],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub iters_one: u32 = (\"ITERS_ONE=\", 5, 1_u32 ..),\n\t\tpub iters_two: u32 = (\"ITERS_TWO=\", 18, 1_u32 ..),\n\t\tpub check_rules: bool = (\"CHECK_RULES=\", true, false ..= true),\n\t}\n}\n","traces":[{"line":10,"address":[116543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[61072],"length":1,"stats":{"Line":1},"fn_name":"parse_pixels_2"},{"line":22,"address":[61085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[61200],"length":1,"stats":{"Line":0},"fn_name":"parse_pixels_3"},{"line":26,"address":[61213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[61328],"length":1,"stats":{"Line":0},"fn_name":"parse_pixels_4"},{"line":30,"address":[81836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[61456],"length":1,"stats":{"Line":1},"fn_name":"parse_pixels"},{"line":35,"address":[61481,62150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[61585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[61668,62131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[61722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[62056,62022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[62029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[62037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[62099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[62032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[63970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[63974],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-21","lib.rs"],"content":"//! Advent of Code 2017: Day 21: Fractal Art\n//!\n//! [https://adventofcode.com/2017/day/21](https://adventofcode.com/2017/day/21)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Fractal Art\";\n\tyear = 2017;\n\tday = 21;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"ITERS_ONE=2\",\n\t\t\"CHECK_RULES=false\",\n\t\t\"../.# =\u003e ##./#../...\",\n\t\t\".#./..#/### =\u003e #..#/..../..../#..#\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"12\", puzzle.part_one (EXAMPLE));\n\t}\n\n}\n","traces":[{"line":35,"address":[57920,57924],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[74026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[74356,74085,74260,74194,74137,74047],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-21","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse input::InputRule;\nuse model::TwoByTwo;\nuse model::ThreeByThree;\nuse model::FourByFour;\nuse model::SixBySix;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, input.params.iters_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, input.params.iters_two)\n}\n\nfn calc_result (input: \u0026 Input, num_iters: u32) -\u003e GenResult \u003cu64\u003e {\n\tlet enhancer = Enhancer::build (input) ?;\n\tlet mut state = State::default ();\n\tfor _ in 0 .. num_iters {\n\t\tstate = enhancer.next (\u0026 state) ?;\n\t}\n\tOk (state.num_active () ?)\n}\n\n#[ derive (Clone, Debug) ]\nstruct Enhancer {\n\ttwo_to_three: Rc \u003c[ThreeByThree; 16]\u003e,\n\tthree_to_four: Rc \u003c[FourByFour; 512]\u003e,\n}\n\nimpl Enhancer {\n\n\tfn build (input: \u0026 Input) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet mut two_to_three: [ThreeByThree; 16] = default ();\n\t\tlet mut two_to_three_found = [false; 16];\n\t\tlet mut three_to_four: [FourByFour; 512] = array::from_fn (|_| default ());\n\t\tlet mut three_to_four_found = [false; 512];\n\t\tfor rule in input.rules.iter () {\n\t\t\tmatch * rule {\n\t\t\t\tInputRule::TwoToThree (from, to) =\u003e {\n\t\t\t\t\tlet mut from = TwoByTwo::try_from (from).unwrap ();\n\t\t\t\t\tlet to = ThreeByThree::try_from (to).unwrap ();\n\t\t\t\t\tif input.params.check_rules \u0026\u0026 two_to_three_found [from.idx ()] {\n\t\t\t\t\t\treturn Err (format! (\"Duplicated rule: {from}\").into ());\n\t\t\t\t\t}\n\t\t\t\t\tloop {\n\t\t\t\t\t\ttwo_to_three [from.idx ()] = to;\n\t\t\t\t\t\ttwo_to_three_found [from.idx ()] = true;\n\t\t\t\t\t\tfrom = from.rotate ();\n\t\t\t\t\t\tif two_to_three_found [from.idx ()] { break }\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInputRule::ThreeToFour (from, to) =\u003e {\n\t\t\t\t\tlet mut from = ThreeByThree::try_from (from).unwrap ();\n\t\t\t\t\tlet to = FourByFour::try_from (to).unwrap ();\n\t\t\t\t\tif input.params.check_rules \u0026\u0026 three_to_four_found [from.idx ()] {\n\t\t\t\t\t\treturn Err (format! (\"Duplicated rule: {from}\").into ());\n\t\t\t\t\t}\n\t\t\t\t\tloop {\n\t\t\t\t\t\tthree_to_four [from.idx ()] = to;\n\t\t\t\t\t\tthree_to_four_found [from.idx ()] = true;\n\t\t\t\t\t\tfrom = from.rotate ();\n\t\t\t\t\t\tif three_to_four_found [from.idx ()] {\n\t\t\t\t\t\t\tfrom = from.flip ();\n\t\t\t\t\t\t\tif three_to_four_found [from.idx ()] { break }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tif input.params.check_rules {\n\t\t\tif let Some (rule) = two_to_three_found.iter ().position (|found| ! found) {\n\t\t\t\treturn Err (format! (\"Missing rule: 0x{rule:01x}\").into ());\n\t\t\t}\n\t\t\tif let Some (rule) = three_to_four_found.iter ().position (|found| ! found) {\n\t\t\t\treturn Err (format! (\"Missing rule: 0x{rule:03x}\").into ());\n\t\t\t}\n\t\t}\n\t\tlet two_to_three = Rc::new (two_to_three);\n\t\tlet three_to_four = Rc::new (three_to_four);\n\t\tOk (Self { two_to_three, three_to_four })\n\t}\n\n\tfn next (\u0026 self, prev: \u0026 State) -\u003e NumResult \u003cState\u003e {\n\t\tOk (match * prev {\n\n\t\t\tState::ThreeByThree (ref counts) =\u003e\n\t\t\t\tState::FourByFour (merge_counts (\n\t\t\t\t\tcounts.iter ().map (|\u0026 (square, count)|\n\t\t\t\t\t\t(self.three_to_four [square.idx ()], count))) ?),\n\n\t\t\tState::FourByFour (ref counts) =\u003e\n\t\t\t\tState::SixBySix (merge_counts (\n\t\t\t\t\tcounts.iter ().map (|\u0026 (square, count)| (\n\t\t\t\t\t\tSixBySix::join (square.split ().map (|square|\n\t\t\t\t\t\t\tself.two_to_three [square.idx ()])),\n\t\t\t\t\t\tcount))) ?),\n\n\t\t\tState::SixBySix (ref counts) =\u003e\n\t\t\t\tState::ThreeByThree (merge_counts (\n\t\t\t\t\tcounts.iter ().flat_map (|\u0026 (square, count)| square.split ().map (|square|\n\t\t\t\t\t\t(self.two_to_three [square.idx ()], count)))) ?),\n\n\t\t})\n\t}\n\n}\n\nfn merge_counts \u003cSquare: Copy + Ord\u003e (\n\tcounts: impl Iterator \u003cItem = (Square, u64)\u003e,\n) -\u003e NumResult \u003cVec \u003c(Square, u64)\u003e\u003e {\n\tcounts.into_iter ()\n\t\t.sorted ()\n\t\t.map (Ok)\n\t\t.coalesce (|left, right| {\n\t\t\tlet left = ok_or_else! (left, |err| return Ok (Err (err)));\n\t\t\tlet right = ok_or_else! (right, |err| return Ok (Err (err)));\n\t\t\tif left.0 == right.0 {\n\t\t\t\tOk (Ok::\u003c_, Overflow\u003e ((\n\t\t\t\t\tleft.0,\n\t\t\t\t\tok_or_else! (chk! (left.1 + right.1), |err| return Ok (Err (err))),\n\t\t\t\t)))\n\t\t\t} else {\n\t\t\t\tErr ((Ok (left), Ok (right)))\n\t\t\t}\n\t\t})\n\t\t.try_collect ()\n}\n\n#[ derive (Debug) ]\nenum State {\n\tThreeByThree (Vec \u003c(ThreeByThree, u64)\u003e),\n\tFourByFour (Vec \u003c(FourByFour, u64)\u003e),\n\tSixBySix (Vec \u003c(SixBySix, u64)\u003e),\n}\n\nimpl State {\n\n\tfn default () -\u003e Self {\n\t\tSelf::ThreeByThree (vec! [\n\t\t\t(ThreeByThree::try_from (0x1e2).unwrap (), 1),\n\t\t])\n\t}\n\n\tfn num_active (\u0026 self) -\u003e NumResult \u003cu64\u003e {\n\t\tmatch * self {\n\t\t\tSelf::ThreeByThree (ref counts) =\u003e\n\t\t\t\tcounts.iter ()\n\t\t\t\t\t.map (|\u0026 (square, count)| chk! (square.num_active () * count))\n\t\t\t\t\t.try_fold (0, |sum, item| { let item = item ?; chk! (sum + item) }),\n\t\t\tSelf::FourByFour (ref counts) =\u003e\n\t\t\t\tcounts.iter ()\n\t\t\t\t\t.map (|\u0026 (square, count)| chk! (square.num_active () * count))\n\t\t\t\t\t.try_fold (0, |sum, item| { let item = item ?; chk! (sum + item) }),\n\t\t\tSelf::SixBySix (ref counts) =\u003e\n\t\t\t\tcounts.iter ()\n\t\t\t\t\t.map (|\u0026 (square, count)| chk! (square.num_active () * count))\n\t\t\t\t\t.try_fold (0, |sum, item| { let item = item ?; chk! (sum + item) }),\n\t\t}\n\t}\n\n}\n","traces":[{"line":12,"address":[57260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[57660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[51088,51550],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":20,"address":[51112,51127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[51176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[51183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[51295,51274,51490,51216],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[51329,51426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[51568,54326],"length":1,"stats":{"Line":1},"fn_name":"build"},{"line":38,"address":[51612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[100880],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":40,"address":[51733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[53206,51784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[51864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[52704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[52775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[54107,52835,52885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[53877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[54017,52952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[53004,54034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[53110,53019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[53156,54051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[51874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[51950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[52014,52064,54095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[53835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[52130,53803,52184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[52238,53812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[52399,52258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[52438,53821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[52467,52613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[52661,53849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[53235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[53655,53346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[53673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[100918,100912],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":79,"address":[53742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[53542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[53631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[54368],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":88,"address":[55279,54391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[55014,55106],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[83029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[83085,83152,83033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[54873,55054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[98036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[98172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[59574,59630,59739],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[55262,55321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[98892,98659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[58811,58867,59050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[101152,100928,101392],"length":1,"stats":{"Line":0},"fn_name":"merge_counts\u003caoc_2017_day_21::model::Square\u003cu64, 6\u003e, core::iter::adapters::map::Map\u003ccore::slice::iter::Iter\u003c(aoc_2017_day_21::model::Square\u003cu16, 4\u003e, u64)\u003e, aoc_2017_day_21::logic::{impl#0}::next::{closure_env#1}\u003e\u003e"},{"line":115,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[55360],"length":1,"stats":{"Line":1},"fn_name":"default"},{"line":143,"address":[55566,55456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[55584],"length":1,"stats":{"Line":1},"fn_name":"num_active"},{"line":149,"address":[55601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[55812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[101808,96744,101840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[101872,101904,96869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[55651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[101968,97368,101936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[102000,102032,97493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[55972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[83645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[83799],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":48,"coverable":75},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-21","model.rs"],"content":"use super::*;\n\npub type TwoByTwo = Square \u003cu8, 2\u003e;\npub type ThreeByThree = Square \u003cu16, 3\u003e;\npub type FourByFour = Square \u003cu16, 4\u003e;\npub type SixBySix = Square \u003cu64, 6\u003e;\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Square \u003cVal: Int, const SIZE: u32\u003e {\n\tval: Val,\n}\n\nimpl \u003cVal: Int, const SIZE: u32\u003e Square \u003cVal, SIZE\u003e {\n\n\t#[ inline ]\n\tpub fn idx (self) -\u003e usize {\n\t\tself.val.pan_usize ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn num_active (self) -\u003e u64 {\n\t\tself.val.gen_count_ones ().pan_u64 ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn rotate (self) -\u003e Self where Val: From \u003cbool\u003e {\n\t\tlet mut val = Val::ZERO;\n\t\tfor col in 0 .. SIZE {\n\t\t\tfor row in (0 .. SIZE).rev () {\n\t\t\t\tval = (val \u003c\u003c 1) | Val::from (self.val.check_bit (row * SIZE + col));\n\t\t\t}\n\t\t}\n\t\tassert! (val.pan_u32 () \u003c 1 \u003c\u003c (SIZE * SIZE));\n\t\tSelf { val }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn flip (self) -\u003e Self where Val: From \u003cbool\u003e {\n\t\tlet mut val = Val::ZERO;\n\t\tfor row in (0 .. SIZE).rev () {\n\t\t\tfor col in 0 .. SIZE {\n\t\t\t\tval = (val \u003c\u003c 1) | Val::from (self.val.check_bit (row * SIZE + col));\n\t\t\t}\n\t\t}\n\t\tassert! (val.pan_u32 () \u003c 1 \u003c\u003c (SIZE * SIZE));\n\t\tSelf { val }\n\t}\n\n}\n\nimpl Square \u003cu16, 4\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn split (self) -\u003e [TwoByTwo; 4] {\n\t\t[ [0_u32, 1, 4, 5], [2, 3, 6, 7], [8, 9, 12, 13], [10, 11, 14, 15] ].map (|bits| {\n\t\t\tlet mut val = 0;\n\t\t\tfor bit in bits.iter ().copied () {\n\t\t\t\tval \u003e\u003e= 1_u32;\n\t\t\t\tif self.val \u0026 (1 \u003c\u003c bit) != 0 { val |= 0x8; }\n\t\t\t}\n\t\t\tTwoByTwo::try_from (val).unwrap ()\n\t\t})\n\t}\n\n}\n\nimpl Square \u003cu64, 6\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn split (self) -\u003e [TwoByTwo; 9] {\n\t\t[\n\t\t\t[0_u32, 1, 6, 7], [2, 3, 8, 9], [4, 5, 10, 11],\n\t\t\t[12, 13, 18, 19], [14, 15, 20, 21], [16, 17, 22, 23],\n\t\t\t[24, 25, 30, 31], [26, 27, 32, 33], [28, 29, 34, 35],\n\t\t].map (|bits| {\n\t\t\tlet mut val = 0;\n\t\t\tfor bit in bits.iter ().copied () {\n\t\t\t\tval \u003e\u003e= 1_u32;\n\t\t\t\tif self.val \u0026 (1 \u003c\u003c bit) != 0 { val |= 0x8; }\n\t\t\t}\n\t\t\tTwoByTwo::try_from (val).unwrap ()\n\t\t})\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn join (squares: [ThreeByThree; 4]) -\u003e Self {\n\t\tlet mut val = 0;\n\t\tfor (square_idx, bit) in [\n\t\t\t(0, 0_u32), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2),\n\t\t\t(0, 3), (0, 4), (0, 5), (1, 3), (1, 4), (1, 5),\n\t\t\t(0, 6), (0, 7), (0, 8), (1, 6), (1, 7), (1, 8),\n\t\t\t(2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2),\n\t\t\t(2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5),\n\t\t\t(2, 6), (2, 7), (2, 8), (3, 6), (3, 7), (3, 8),\n\t\t].iter ().copied () {\n\t\t\tval \u003e\u003e= 1_u32;\n\t\t\tif squares [square_idx].val \u0026 (1 \u003c\u003c bit) != 0 { val |= 0x8_0000_0000; }\n\t\t}\n\t\tSelf { val }\n\t}\n\n}\n\nimpl \u003cVal: Int, const SIZE: u32\u003e Display for Square \u003cVal, SIZE\u003e {\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"{}\", self.val)\n\t}\n}\n\nimpl \u003cconst SIZE: u32\u003e TryFrom \u003cu8\u003e for Square \u003cu8, SIZE\u003e {\n\ttype Error = ();\n\t#[ inline ]\n\tfn try_from (val: u8) -\u003e Result \u003cSelf, ()\u003e {\n\t\tif 1 \u003c\u003c (SIZE * SIZE) \u003c= val.pan_u32 () { return Err (()) }\n\t\tOk (Self { val })\n\t}\n}\n\nimpl \u003cconst SIZE: u32\u003e TryFrom \u003cu16\u003e for Square \u003cu16, SIZE\u003e {\n\ttype Error = ();\n\t#[ inline ]\n\tfn try_from (val: u16) -\u003e Result \u003cSelf, ()\u003e {\n\t\tif 1 \u003c\u003c (SIZE * SIZE) \u003c= val.pan_u32 () { return Err (()) }\n\t\tOk (Self { val })\n\t}\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[65664,65792],"length":1,"stats":{"Line":0},"fn_name":"rotate\u003cu8, 2\u003e"},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[65968],"length":1,"stats":{"Line":0},"fn_name":"flip\u003cu16, 3\u003e"},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":53},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"..#\",\n\t\"#..\",\n\t\"...\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5587\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2511944\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[52996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[59914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[59935,60252,59973,60148,60025,60082],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[52948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[60314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[60652,60548,60335,60373,60425,60482],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-22","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub nodes: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { nodes, params } = [ params, nodes ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub iters_one: u32 = (\"ITERS_ONE=\", 10_000, 1_u32 .. ),\n\t\tpub iters_two: u32 = (\"ITERS_TWO=\", 10_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":18,"address":[77411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[77415],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-22","lib.rs"],"content":"//! Advent of Code 2017: Day 22: Sporifica Virus\n//!\n//! [https://adventofcode.com/2017/day/22](https://adventofcode.com/2017/day/22)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Sporifica Virus\";\n\tyear = 2017;\n\tday = 22;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-22","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Grid;\nuse model::Node;\nuse model::Pos;\nuse model::Turn;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (\n\t\tinput,\n\t\tinput.params.iters_one,\n\t\t|state| match state {\n\t\t\tNode::Clean | Node::Weakened =\u003e (Turn::Left, Node::Infected, true),\n\t\t\tNode::Infected | Node::Flagged =\u003e (Turn::Right, Node::Clean, false),\n\t\t},\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (\n\t\tinput,\n\t\tinput.params.iters_two,\n\t\t|state| match state {\n\t\t\tNode::Clean =\u003e (Turn::Left, Node::Weakened, false),\n\t\t\tNode::Weakened =\u003e (Turn::None, Node::Infected, true),\n\t\t\tNode::Infected =\u003e (Turn::Right, Node::Flagged, false),\n\t\t\tNode::Flagged =\u003e (Turn::Around, Node::Clean, false),\n\t\t},\n\t)\n}\n\nfn calc_result (\n\tinput: \u0026 Input,\n\tnum_bursts: u32,\n\tstate_fn: impl Fn (Node) -\u003e (Turn, Node, bool),\n) -\u003e GenResult \u003cu64\u003e {\n\tlet mut nodes = input.nodes.translate (\n\t\tPos::new (\n\t\t\t- input.nodes.size ().row / 2,\n\t\t\t- input.nodes.size ().col / 2)) ?;\n\tlet mut pos = Pos::ZERO;\n\tlet mut dir = Dir::Up;\n\tlet mut num_infected = 0;\n\tfor _ in 0 .. num_bursts {\n\t\tlet cur_state = nodes.get (pos).unwrap_or_else (|| {\n\t\t\texpand (\u0026 mut nodes);\n\t\t\tnodes.get (pos).unwrap ()\n\t\t});\n\t\tlet (turn, next_state, count) = state_fn (cur_state);\n\t\tdir = dir + turn;\n\t\tnodes.set (pos, next_state);\n\t\tif count { num_infected += 1; }\n\t\tlet dir_one = (dir, 1);\n\t\tpos = chk! (pos + dir_one) ?;\n\t}\n\tOk (num_infected)\n}\n\nfn expand (nodes: \u0026 mut Grid) {\n\tlet incr_amt = cmp::min (nodes.size ().row, nodes.size ().col) / 20 * 5 + 5;\n\t* nodes = nodes.extend_in_place ([(incr_amt, incr_amt); 2]).unwrap ();\n}\n","traces":[{"line":12,"address":[36576],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":15,"address":[36580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[69772,69744,69734,69798,69760,69710],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[36608],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":26,"address":[36612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[68825,68760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[68272,69168,70133,69184],"length":1,"stats":{"Line":2},"fn_name":"calc_result\u003caoc_2017_day_22::logic::part_two::{closure_env#0}\u003e"},{"line":41,"address":[68411,68369,68921,69282,69324,69886],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[68330,68296,69061,69209,70026,69243],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[70042,69260,68312,68347,69077,69225],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[68454,69876,69368,68911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[70224,70144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[69648,70154,70234,68724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[68734,70159,70239,69658],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[69781,68808],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[69999,68836,69034,69802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[65599,65546,65898,65471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[69932,68967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[36640],"length":1,"stats":{"Line":1},"fn_name":"expand"},{"line":64,"address":[36648,36793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[36687,36754,36857],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-22","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Dir = aoc_pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cNode\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosRowCol \u003cCoord\u003e;\npub type Turn = aoc_pos::Turn2d;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, PartialEq) ]\n\tpub enum Node {\n\t\t#[ default ]\n\t\tClean = [ \".\" ],\n\t\tWeakened = [ \"W\" ],\n\t\tInfected = [ \"#\" ],\n\t\tFlagged = [ \"F\" ],\n\t}\n}\n","traces":[{"line":10,"address":[40053],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"add a 10\",\n\t\"set h 1\",\n\t\"mul h a\",\n\t\"sub a 1\",\n\t\"jnz a -2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"39916800\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[39888,39892],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[58746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[58980,59084,58857,58767,58805,58914],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[39920,39924],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[59146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[59205,59380,59257,59167,59314,59484],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-23","input.rs"],"content":"use super::*;\nuse cpu::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[30292],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-23","lib.rs"],"content":"//! Advent of Code 2017: Day 23: Coprocessor Conflagration\n//!\n//! [https://adventofcode.com/2017/day/23](https://adventofcode.com/2017/day/23)\n//!\n//! # Input\n//!\n//! Each line is a valid instruction for [`aoc_2017_cpu`].\n//!\n//! # Part one\n//!\n//! Execute the program to completion. Return the number of times a `mul` instruction was executed.\n//!\n//! # Part two\n//!\n//! Set register `a` to `1` and execute the program to completion. Return the value from register\n//! `h`.\n//!\n//! # Algorithm\n//!\n//! For part one, we simply step through the program and count the `mul`s.\n//!\n//! Part two is much too slow to do this, so instead we optimise one part of the program. This part\n//! basically checks whether the value in a register is prime, and sets another register to zero\n//! if so. When we recognise this block of instructions we use our own algorithm to do the same and\n//! skip past it.\n//!\n//! To quickly identify prime numbers, we try to divide by a list of known primes less then 1000,\n//! then iterate over odd numbers over that up to the square root of the target.\n//!\n//! I think the output in `h` is the count of primes in some range, or perhaps not primes, but I\n//! haven't bothered to properly analyse what it does apart from the block I optimised.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2017_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Coprocessor Conflagration\";\n\tyear = 2017;\n\tday = 23;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":47,"address":[41544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[41864],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-23","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse cpu::Cpu;\nuse cpu::Instr;\nuse cpu::Val;\nuse cpu::cpu_optimise;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut cpu = Cpu::new (input.instrs.as_slice ());\n\tcpu.set_limit (100_000);\n\tlet mut num_muls = 0;\n\twhile cpu.can_step () {\n\t\tif matches! (cpu.next_instr (), Some (Instr::Mul (_, _))) { num_muls += 1; }\n\t\tcpu.step () ?;\n\t}\n\tOk (num_muls)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tlet mut cpu = Cpu::new (input.instrs.as_slice ());\n\tcpu.set_limit (10_000);\n\tcpu.set_reg ('a', 1) ?;\n\texec_optimised (\u0026 mut cpu, false) ?;\n\tOk (cpu.get_reg ('h') ?)\n}\n\n#[ allow (clippy::print_stdout) ]\nfn exec_optimised (cpu: \u0026 mut Cpu, verbose: bool) -\u003e GenResult \u003cOption \u003cVal\u003e\u003e {\n\twhile cpu.can_step () {\n\t\tif verbose {\n\t\t\tprintln! (\n\t\t\t\t\"{:4}  {:8} {:8} {:8} {:8} {:8} {:8} {:8} {:8}  {}\",\n\t\t\t\tcpu.next () + 1,\n\t\t\t\tcpu.get_reg ('a') ?,\n\t\t\t\tcpu.get_reg ('b') ?,\n\t\t\t\tcpu.get_reg ('c') ?,\n\t\t\t\tcpu.get_reg ('d') ?,\n\t\t\t\tcpu.get_reg ('e') ?,\n\t\t\t\tcpu.get_reg ('f') ?,\n\t\t\t\tcpu.get_reg ('g') ?,\n\t\t\t\tcpu.get_reg ('h') ?,\n\t\t\t\tcpu.next_instr ().unwrap ());\n\t\t}\n\t\tcpu_optimise! {\n\t\t\tcpu,\n\t\t\tregs = [ target, out, temp, outer, inner ],\n\t\t\tinstrs = [\n\t\t\t\tSet (dst outer, imm 2),\n\t\t\t\tSet (dst inner, imm 2),\n\t\t\t\tSet (dst temp, src outer),\n\t\t\t\tMul (dst temp, src inner),\n\t\t\t\tSub (dst temp, src target),\n\t\t\t\tJnz (src temp, imm 2),\n\t\t\t\tSet (dst out, imm 0),\n\t\t\t\tSub (dst inner, imm -1),\n\t\t\t\tSet (dst temp, src inner),\n\t\t\t\tSub (dst temp, src target),\n\t\t\t\tJnz (src temp, imm -8),\n\t\t\t\tSub (dst outer, imm -1),\n\t\t\t\tSet (dst temp, src outer),\n\t\t\t\tSub (dst temp, src target),\n\t\t\t\tJnz (src temp, imm -13),\n\t\t\t],\n\t\t\trun = {\n\t\t\t\tlet target_val = cpu.load_reg (target);\n\t\t\t\tcpu.store_reg (temp, 0);\n\t\t\t\tcpu.store_reg (outer, cpu.load_reg (target));\n\t\t\t\tcpu.store_reg (inner, cpu.load_reg (target));\n\t\t\t\tlet prime = some_or! (is_prime (target_val), break);\n\t\t\t\tif ! prime { cpu.store_reg (out, 0); }\n\t\t\t\tcpu.set_next (cpu.next () + 15);\n\t\t\t\tcpu.set_limit (cpu.limit ().saturating_sub (1));\n\t\t\t\tif verbose {\n\t\t\t\t\tprintln! (\"Optimised check prime (target={target_val}, prime={prime})\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t},\n\t\t};\n\t\tif let Some (val) = cpu.step () ? { return Ok (Some (val)) }\n\t}\n\tOk (None)\n}\n\nfn is_prime (val: Val) -\u003e Option \u003cbool\u003e {\n\tif val \u003c 2 { return None }\n\tfor div in PRIMES {\n\t\tif val \u003c= div * div { break }\n\t\tif val % div == 0 { return Some (false) }\n\t}\n\tfor div in (1001 ..= val / 1000).step_by (2) {\n\t\tif val \u003c= div * div { break }\n\t\tif val % div == 0 { return Some (false) }\n\t}\n\tSome (true)\n}\n\nconst PRIMES: [Val; 168] = [\n\t2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n\t101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193,\n\t197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,\n\t311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421,\n\t431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\n\t557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n\t661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\n\t809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929,\n\t937, 941, 947, 953, 967, 971, 977, 983, 991, 997,\n];\n","traces":[{"line":11,"address":[50037,49648],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[49694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[49732,49859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[49803,49966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[49818,49878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[49866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[50570,50048],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":23,"address":[50087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[50246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[50281,50294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[50488,50501],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[50592],"length":1,"stats":{"Line":1},"fn_name":"exec_optimised"},{"line":32,"address":[50672,50637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[50674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[51247,50705,51064,51817,52658,51626,51435,52297,52208,50883,52008,52551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[50688,55482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[50869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[51050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[51233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[51421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[51612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[51803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[51994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[52185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[53566,53824,54420,53940,54802,52796,53651,54684,52887,54973,55127,54701,54403,52875,54071,54549,55110,54262,53812,54054,53923,54566,54819,54956,54245,53668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[53159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[53231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[53253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[53295,55507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[53339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[53469,53353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[55326,53496,55400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[50639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[55616,56275],"length":1,"stats":{"Line":0},"fn_name":"is_prime"},{"line":88,"address":[55635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[56260,55769,55648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[55771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[55789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[55836,56066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[56169,56070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[56084,56196],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":17,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-24","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"0/2\", \"2/2\", \"2/3\", \"3/4\", \"3/5\", \"0/1\", \"10/1\", \"9/10\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"31\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"19\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[48464,48468],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":9,"address":[51274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[51442,51295,51333,51612,51508,51385],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[48500,48496],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[51674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[51695,51785,51842,51908,51733,52012],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-24","input.rs"],"content":"use super::*;\n\nuse model::Port;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub comps: Vec \u003cComponent\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { comps, params } = [ params, @lines comps ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Component {\n\tpub port_0: Port,\n\tpub port_1: Port,\n}\n\nstruct_parser_display! {\n\tComponent { port_0, port_1 } = [ port_0, \"/\", port_1 ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[26486,27067],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-24","lib.rs"],"content":"//! Advent of Code 2017: Day 24: Electromagnetic Moat\n//!\n//! [https://adventofcode.com/2017/day/24](https://adventofcode.com/2017/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Electromagnetic Moat\";\n\tyear = 2017;\n\tday = 24;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Components = u64;\n\tpub type Port = u16;\n}\n","traces":[{"line":18,"address":[36440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[36760],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-24","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Components;\nuse model::Port;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\tbridges_iter (input)\n\t\t\t.map (|comps| strength (input, comps))\n\t\t\t.max ()\n\t\t\t.unwrap ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet longest =\n\t\tbridges_iter (input)\n\t\t\t.map (Components::count_ones)\n\t\t\t.max ()\n\t\t\t.unwrap ();\n\tOk (\n\t\tbridges_iter (input)\n\t\t\t.filter (|comps| comps.count_ones () == longest)\n\t\t\t.map (|comps| strength (input, comps))\n\t\t\t.max ()\n\t\t\t.unwrap ()\n\t)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tlet mut comps = input.comps.clone ();\n\tif comps.len () \u003e Components::BITS.pan_usize () {\n\t\treturn Err (\"Too many components\".into ());\n\t}\n\tcomps.sort ();\n\tif comps.iter ()\n\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t.any (|(left, right)| left == right\n\t\t\t|| (left.port_0 == right.port_1 \u0026\u0026 left.port_1 == right.port_0)) {\n\t\treturn Err (\"Duplicated components\".into ());\n\t}\n\tOk (())\n}\n\nfn bridges_iter (input: \u0026 Input) -\u003e impl Iterator \u003cItem = Components\u003e + '_ {\n\tlet mut todo: Vec \u003c(Components, Port)\u003e = Vec::new ();\n\ttodo.push ((0, 0));\n\tlet mut seen = HashSet::new ();\n\titer::from_fn (move || {\n\t\tlet (comps, port) = some_or! (todo.pop (), return None);\n\t\tfor (next_idx, \u0026 next) in input.comps.iter ().enumerate () {\n\t\t\tif port != next.port_0 \u0026\u0026 port != next.port_1 { continue }\n\t\t\tlet next_mask = 1 \u003c\u003c next_idx;\n\t\t\tif comps \u0026 next_mask != 0 { continue }\n\t\t\tlet new_comps = comps | next_mask;\n\t\t\tlet new_port = if port == next.port_0 { next.port_1 } else { next.port_0 };\n\t\t\tif seen.insert ((new_comps, new_port)) {\n\t\t\t\ttodo.push ((new_comps, new_port));\n\t\t\t}\n\t\t}\n\t\tSome (comps)\n\t})\n}\n\nfn strength (input: \u0026 Input, comps: Components) -\u003e u32 {\n\tlet mut total = 0;\n\tfor (comp_idx, \u0026 comp) in input.comps.iter ().enumerate () {\n\t\tlet comp_mask = 1 \u003c\u003c comp_idx;\n\t\tif comps \u0026 comp_mask == 0 { continue }\n\t\ttotal += comp.port_0.pan_u32 () + comp.port_1.pan_u32 ();\n\t}\n\ttotal\n}\n","traces":[{"line":9,"address":[46848],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[46863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[46914,46930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[48816,49232],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003c(u64), aoc_2017_day_24::logic::part_one::{closure_env#0}\u003e"},{"line":19,"address":[46992],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[47009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[47060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[47112,47138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[48707,49248,48799,49340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[34971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[47758,47200],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":36,"address":[47222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[47289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[47660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[49376,49393],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":44,"address":[57040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[47776,48055],"length":1,"stats":{"Line":2},"fn_name":"bridges_iter"},{"line":54,"address":[47969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[49500,49800],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[49600,49511,49661],"length":1,"stats":{"Line":6},"fn_name":null},{"line":57,"address":[49680,49726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[49855,49692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[49714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[49721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[49730],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[49750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[48064],"length":1,"stats":{"Line":1},"fn_name":"strength"},{"line":72,"address":[48181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[48368,48190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[48206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[48422,48324],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":31,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-25","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Begin in state A.\",\n\t\"Perform a diagnostic checksum after 6 steps.\",\n\t\"\",\n\t\"In state A:\",\n\t\"  If the current value is 0:\",\n\t\"    - Write the value 1.\",\n\t\"    - Move one slot to the right.\",\n\t\"    - Continue with state B.\",\n\t\"  If the current value is 1:\",\n\t\"    - Write the value 0.\",\n\t\"    - Move one slot to the left.\",\n\t\"    - Continue with state B.\",\n\t\"\",\n\t\"In state B:\",\n\t\"  If the current value is 0:\",\n\t\"    - Write the value 1.\",\n\t\"    - Move one slot to the left.\",\n\t\"    - Continue with state A.\",\n\t\"  If the current value is 1:\",\n\t\"    - Write the value 1.\",\n\t\"    - Move one slot to the right.\",\n\t\"    - Continue with state A.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":31,"address":[32388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[46730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[46898,47068,46789,46964,46841,46751],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-25","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub begin_state: char,\n\tpub num_steps: u32,\n\tpub states: Vec \u003cState\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { begin_state, num_steps, states, params } = [\n\t\tparams,\n\t\t\"Begin in state \", begin_state = 'A' ..= 'Z', \".\\n\",\n\t\t\"Perform a diagnostic checksum after \", num_steps, \" steps.\\n\",\n\t\t\"\\n\",\n\t\t@delim \"\\n\\n\" states,\n\t]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Dir {\n\t\tLeft = [ \"left\" ],\n\t\tRight = [ \"right\" ],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Slot {\n\t\tZero = [ \"0\" ],\n\t\tOne = [ \"1\" ],\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct State {\n\tpub id: char,\n\tpub false_write: Slot,\n\tpub false_dir: Dir,\n\tpub false_state: char,\n\tpub true_write: Slot,\n\tpub true_dir: Dir,\n\tpub true_state: char,\n}\n\nstruct_parser_display! {\n\tState { id, false_write, false_dir, false_state, true_write, true_dir, true_state } = [\n\t\t\"In state \", id, \":\\n\",\n\t\t\"  If the current value is 0:\\n\",\n\t\t\"    - Write the value \", false_write, \".\\n\",\n\t\t\"    - Move one slot to the \", false_dir, \".\\n\",\n\t\t\"    - Continue with state \", false_state = 'A' ..= 'Z', \".\\n\",\n\t\t\"  If the current value is 1:\\n\",\n\t\t\"    - Write the value \", true_write, \".\\n\",\n\t\t\"    - Move one slot to the \", true_dir, \".\\n\",\n\t\t\"    - Continue with state \", true_state = 'A' ..= 'Z', \".\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[35967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[36208],"length":1,"stats":{"Line":0},"fn_name":"eq"}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-25","lib.rs"],"content":"//! Advent of Code 2017: Day 25: The Halting Problem\n//!\n//! [https://adventofcode.com/2017/day/25](https://adventofcode.com/2017/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"The Halting Problem\";\n\tyear = 2017;\n\tday = 25;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n","traces":[{"line":18,"address":[44581],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","day-25","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Dir;\nuse input::Input;\nuse input::Slot;\nuse input::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet states = get_states (input) ?;\n\tlet mut left = Vec::new ();\n\tlet mut right = Vec::new ();\n\tlet mut cur = Slot::Zero;\n\tlet mut state_id = input.begin_state;\n\tfor _ in 0 .. input.num_steps {\n\t\tlet state = \u0026 states [\u0026 state_id];\n\t\tlet (write, dir, new_state_id) = match cur {\n\t\t\tSlot::Zero =\u003e (state.false_write, state.false_dir, state.false_state),\n\t\t\tSlot::One =\u003e (state.true_write, state.true_dir, state.true_state),\n\t\t};\n\t\tmatch dir {\n\t\t\tDir::Left =\u003e { right.push (write); cur = left.pop ().unwrap_or (Slot::Zero); },\n\t\t\tDir::Right =\u003e { left.push (write); cur = right.pop ().unwrap_or (Slot::Zero); },\n\t\t}\n\t\tstate_id = new_state_id;\n\t}\n\tOk (\n\t\titer::empty ()\n\t\t\t.chain (left.iter ())\n\t\t\t.chain (iter::once (\u0026 cur))\n\t\t\t.chain (right.iter ())\n\t\t\t.filter (|\u0026\u0026 val| val == Slot::One)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\nfn get_states (input: \u0026 Input) -\u003e GenResult \u003cHashMap \u003cchar, State\u003e\u003e {\n\tlet states: HashMap \u003cchar, State\u003e =\n\t\tinput.states.iter ().copied ()\n\t\t\t.map (|state| (state.id, state))\n\t\t\t.collect ();\n\tif ! states.contains_key (\u0026 input.begin_state) {\n\t\treturn Err (format! (\"Start state {} does not exist\", input.begin_state).into ());\n\t}\n\tif let Some ((src_id, dst_id)) =\n\t\tinput.states.iter ()\n\t\t\t.flat_map (|state| [ (state.id, state.true_state), (state.id, state.false_state) ])\n\t\t\t.find (|\u0026 (_, dst_id)| ! states.contains_key (\u0026 dst_id)) {\n\t\treturn Err (format! (\"State {src_id} points to nonexistent state {dst_id}\").into ());\n\t}\n\tOk (states)\n}\n","traces":[{"line":10,"address":[23389,22304],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[22332,23265,22399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[22510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[22515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[22529,22522,22577],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[22854,22763,22950],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[22810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[22566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[51913,51904],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":39,"address":[23408,24197],"length":1,"stats":{"Line":1},"fn_name":"get_states"},{"line":42,"address":[51920,51923],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":44,"address":[23467,23592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[23863,23759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[23698,23988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[41054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[41204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[24001,24114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[23709],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":15,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","knot","knot.rs"],"content":"use aoc_common::*;\n\n#[ inline ]\n#[ must_use ]\npub fn calculate (input: \u0026 [u8]) -\u003e [u8; 16] {\n\tcalculate_rounds (input, 64)\n}\n\n#[ inline ]\n#[ must_use ]\npub fn calculate_rounds (input: \u0026 [u8], num_rounds: u32) -\u003e [u8; 16] {\n\tlet input_iter = input.iter ().copied ().chain ([ 17, 31, 73, 47, 23 ]);\n\tlet sparse = calc_sparse (input_iter, num_rounds);\n\tcalc_checksum (\u0026 sparse)\n}\n\n#[ inline ]\n#[ must_use ]\npub fn calc_sparse (\n\tinput_iter: impl IntoIterator \u003cItem = u8\u003e + Clone,\n\tnum_rounds: u32,\n) -\u003e [u8; 256] {\n\n\t// initialise the mutable string data with ascending values\n\n\tlet mut string: VecDeque \u003cu8\u003e = (u8::MIN ..= u8::MAX).collect ();\n\n\t// iterate over lengths, repeated `num_rounds` times\n\n\tlet mut string_temp = Vec::new ();\n\tlet mut skip_size = 0_usize;\n\tlet mut moves = 0_usize;\n\n\tfor length in\n\t\titer::repeat (input_iter)\n\t\t\t.take (num_rounds.qck_usize ())\n\t\t\t.flatten () {\n\n\t\t// take `length` items from the front, them add them to the back in reverse order\n\n\t\tfor _ in 0 .. length { string_temp.push (string.pop_front ().unwrap ()); }\n\t\twhile let Some (mark) = string_temp.pop () { string.push_back (mark); }\n\t\tmoves += length.qck_usize ();\n\n\t\t// advance by `skip_size`\n\n\t\tstring.rotate_left (skip_size);\n\t\tmoves += skip_size;\n\n\t\t// increase `skip_size` by 1\n\n\t\tskip_size += 1;\n\t\tif skip_size == string.len () { skip_size = 0; }\n\n\t}\n\n\t// return to start position and convert to array\n\n\tstring.rotate_right (moves % string.len ());\n\n\tstring.into_iter ().collect::\u003cVec \u003cu8\u003e\u003e ().try_into ().unwrap ()\n\n}\n\n#[ inline ]\n#[ must_use ]\npub fn calc_checksum (input: \u0026 [u8; 256]) -\u003e [u8; 16] {\n\tarray::from_fn (|out_idx| {\n\t\tlet in_idx = out_idx \u003c\u003c 4_u32;\n\t\tinput [in_idx .. in_idx + 16].iter ().copied ().fold (0, |sum, item| sum ^ item)\n\t})\n}\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[35760],"length":1,"stats":{"Line":0},"fn_name":"calculate_rounds"},{"line":12,"address":[37514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[37563],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[38176,38968],"length":1,"stats":{"Line":1},"fn_name":"calc_sparse\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":26,"address":[38205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[38239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[38505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[38535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":28},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2017","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2017_day_01 as day_01;\npub use aoc_2017_day_02 as day_02;\npub use aoc_2017_day_03 as day_03;\npub use aoc_2017_day_04 as day_04;\npub use aoc_2017_day_05 as day_05;\npub use aoc_2017_day_06 as day_06;\npub use aoc_2017_day_07 as day_07;\npub use aoc_2017_day_08 as day_08;\npub use aoc_2017_day_09 as day_09;\npub use aoc_2017_day_10 as day_10;\npub use aoc_2017_day_11 as day_11;\npub use aoc_2017_day_12 as day_12;\npub use aoc_2017_day_13 as day_13;\npub use aoc_2017_day_14 as day_14;\npub use aoc_2017_day_15 as day_15;\npub use aoc_2017_day_16 as day_16;\npub use aoc_2017_day_17 as day_17;\npub use aoc_2017_day_18 as day_18;\npub use aoc_2017_day_19 as day_19;\npub use aoc_2017_day_20 as day_20;\npub use aoc_2017_day_21 as day_21;\npub use aoc_2017_day_22 as day_22;\npub use aoc_2017_day_23 as day_23;\npub use aoc_2017_day_24 as day_24;\npub use aoc_2017_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","cpu","cpu.rs"],"content":"use aoc_common::*;\n\npub type CpuResult \u003cItem\u003e = Result \u003cItem, CpuError\u003e;\n\npub use instr::Instr;\n\nparse_display_enum! {\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Opcode {\n\t\tAddr = \"addr\", Addi = \"addi\",\n\t\tMulr = \"mulr\", Muli = \"muli\",\n\t\tBanr = \"banr\", Bani = \"bani\",\n\t\tBorr = \"borr\", Bori = \"bori\",\n\t\tSetr = \"setr\", Seti = \"seti\",\n\t\tGtir = \"gtir\", Gtri = \"gtri\", Gtrr = \"gtrr\",\n\t\tEqir = \"eqir\", Eqri = \"eqri\", Eqrr = \"eqrr\",\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Op {\n\t\tAdd = \"add\",\n\t\tMul = \"mul\",\n\t\tBan = \"ban\",\n\t\tBor = \"bor\",\n\t\tSet = \"set\",\n\t\tGt = \"gt\",\n\t\tEq = \"eq\",\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum ArgType { Reg = \"r\", Imm = \"i\", Ignore = \"x\" }\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum CpuError {\n\t\tHalt = \"Halt\",\n\t\tOverflow = \"Overflow\",\n\t\tRegister = \"Register\",\n\t\tInternal = \"Internal\",\n\t}\n\n}\n\nimpl Error for CpuError {}\n\nimpl Opcode {\n\n\t#[ inline ]\n\tpub fn apply \u003cVal: Int, const NUM: usize\u003e (\n\t\t\u0026 self,\n\t\targ_a: Val,\n\t\targ_b: Val,\n\t\targ_c: Val,\n\t\tmut regs: Regs \u003cVal, NUM\u003e,\n\t) -\u003e CpuResult \u003cRegs \u003cVal, NUM\u003e\u003e {\n\n\t\tuse CpuError::{ Internal as ErrInt, Register as ErrReg };\n\n\t\tlet val_a = match self.arg_a () {\n\t\t\tArgType::Reg =\u003e regs.get (arg_a).ok_or (ErrReg),\n\t\t\tArgType::Imm =\u003e Ok (arg_a),\n\t\t\tArgType::Ignore =\u003e Err (ErrInt),\n\t\t};\n\n\t\tlet val_b = match self.arg_b () {\n\t\t\tArgType::Reg =\u003e regs.get (arg_b).ok_or (ErrReg),\n\t\t\tArgType::Imm =\u003e Ok (arg_b),\n\t\t\tArgType::Ignore =\u003e Err (ErrInt),\n\t\t};\n\n\t\tlet val_c = self.op ().apply (val_a, val_b) ?;\n\n\t\tregs.set (arg_c, val_c).ok_or (ErrReg) ?;\n\n\t\tOk (regs)\n\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn data (self) -\u003e (Op, ArgType, ArgType) {\n\t\tmatch self {\n\t\t\tSelf::Addr =\u003e (Op::Add, ArgType::Reg, ArgType::Reg),\n\t\t\tSelf::Addi =\u003e (Op::Add, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Mulr =\u003e (Op::Mul, ArgType::Reg, ArgType::Reg),\n\t\t\tSelf::Muli =\u003e (Op::Mul, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Banr =\u003e (Op::Ban, ArgType::Reg, ArgType::Reg),\n\t\t\tSelf::Bani =\u003e (Op::Ban, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Borr =\u003e (Op::Bor, ArgType::Reg, ArgType::Reg),\n\t\t\tSelf::Bori =\u003e (Op::Bor, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Setr =\u003e (Op::Set, ArgType::Reg, ArgType::Ignore),\n\t\t\tSelf::Seti =\u003e (Op::Set, ArgType::Imm, ArgType::Ignore),\n\t\t\tSelf::Gtir =\u003e (Op::Gt, ArgType::Imm, ArgType::Reg),\n\t\t\tSelf::Gtri =\u003e (Op::Gt, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Gtrr =\u003e (Op::Gt, ArgType::Reg, ArgType::Reg),\n\t\t\tSelf::Eqir =\u003e (Op::Eq, ArgType::Imm, ArgType::Reg),\n\t\t\tSelf::Eqri =\u003e (Op::Eq, ArgType::Reg, ArgType::Imm),\n\t\t\tSelf::Eqrr =\u003e (Op::Eq, ArgType::Reg, ArgType::Reg),\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn op (self) -\u003e Op { self.data ().0 }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn arg_a (self) -\u003e ArgType { self.data ().1 }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn arg_b (self) -\u003e ArgType { self.data ().2 }\n\n}\n\nimpl Op {\n\n\t#[ inline ]\n\tpub fn apply \u003cVal: Int\u003e (\n\t\t\u0026 self,\n\t\tval_a: CpuResult \u003cVal\u003e,\n\t\tval_b: CpuResult \u003cVal\u003e,\n\t) -\u003e CpuResult \u003cVal\u003e {\n\t\tuse CpuError::Overflow as ErrNum;\n\t\tOk (match * self {\n\t\t\tSelf::Add =\u003e Val::add_2 (val_a ?, val_b ?).ok ().ok_or (ErrNum) ?,\n\t\t\tSelf::Mul =\u003e Val::mul_2 (val_a ?, val_b ?).ok ().ok_or (ErrNum) ?,\n\t\t\tSelf::Ban =\u003e val_a ? \u0026 val_b ?,\n\t\t\tSelf::Bor =\u003e val_a ? | val_b ?,\n\t\t\tSelf::Set =\u003e val_a ?,\n\t\t\tSelf::Gt =\u003e if val_a ? \u003e val_b ? { Val::ONE } else { Val::ZERO },\n\t\t\tSelf::Eq =\u003e if val_a ? == val_b ? { Val::ONE } else { Val::ZERO },\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Regs \u003cVal: Int, const NUM: usize\u003e {\n\tregs: [Val; NUM],\n}\n\nimpl \u003cVal: Int, const NUM: usize\u003e Regs \u003cVal, NUM\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn new (regs: [Val; NUM]) -\u003e Self {\n\t\tSelf { regs }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn get (\u0026 self, idx: Val) -\u003e Option \u003cVal\u003e {\n\t\tself.regs.get (idx.to_usize ().ok () ?).copied ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn set (\u0026 mut self, idx: Val, val: Val) -\u003e Option \u003c()\u003e {\n\t\t* (self.regs.get_mut (idx.to_usize ().ok () ?) ?) = val;\n\t\tSome (())\n\t}\n\n}\n\nimpl \u003cVal: Int, const NUM: usize\u003e Default for Regs \u003cVal, NUM\u003e {\n\n\t#[ inline ]\n\tfn default () -\u003e Self {\n\t\tlet regs = [Val::default (); NUM];\n\t\tSelf { regs }\n\t}\n\n}\n\nimpl \u003cVal: Int, const NUM: usize\u003e Deref for Regs \u003cVal, NUM\u003e {\n\n\ttype Target = [Val];\n\n\t#[ inline ]\n\tfn deref (\u0026 self) -\u003e \u0026 [Val] {\n\t\t\u0026 self.regs\n\t}\n\n}\n\nimpl \u003cVal: Int, const NUM: usize\u003e Display for Regs \u003cVal, NUM\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"[{}]\", self.regs.display_delim (\", \"))\n\t}\n\n}\n\nimpl \u003c'inp, Val: Int + FromParser \u003c'inp\u003e, const NUM: usize\u003e FromParser \u003c'inp\u003e for Regs \u003cVal, NUM\u003e {\n\n\t#[ inline ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tparse! (parser, \"[\", (@delim \", \" regs): Vec \u003cVal\u003e, \"]\");\n\t\tlet regs = regs.try_into ().ok ().ok_or_else (|| parser.err ()) ?;\n\t\tOk (Self { regs })\n\t}\n\n}\n\nmod instr {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Instr \u003cVal: Int\u003e {\n\t\tpub opcode: Opcode,\n\t\tpub arg_a: Val,\n\t\tpub arg_b: Val,\n\t\tpub arg_c: Val,\n\t}\n\n\tstruct_parser_display! (\n\t\tparams = { Val: Int + FromParser \u003c'inp\u003e }\n\t\tInstr \u003cVal\u003e { opcode, arg_a, arg_b, arg_c } = [\n\t\t\topcode, \" \", arg_a, \" \", arg_b, \" \", arg_c,\n\t\t]\n\t);\n\n\timpl \u003cVal: Int\u003e Debug for Instr \u003cVal\u003e {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter,\n\t\t\t\t\"Instr ({opcode:?}, {arg_a}, {arg_b}, {arg_c})\",\n\t\t\t\topcode = self.opcode,\n\t\t\t\targ_a = self.arg_a,\n\t\t\t\targ_b = self.arg_b,\n\t\t\t\targ_c = self.arg_c,\n\t\t\t)\n\t\t}\n\n\t}\n\n\timpl \u003cVal: Int\u003e Instr \u003cVal\u003e {\n\n\t\t#[ inline ]\n\t\tpub fn apply \u003cconst NUM: usize\u003e (\u0026 self, regs: Regs \u003cVal, NUM\u003e) -\u003e CpuResult \u003cRegs \u003cVal, NUM\u003e\u003e {\n\t\t\tself.opcode.apply (self.arg_a, self.arg_b, self.arg_c, regs)\n\t\t}\n\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn instr_parse () {\n\t\t\tassert_eq_ok! (\n\t\t\t\tInstr { opcode: Opcode::Addi, arg_a: 3, arg_b: 16, arg_c: 3 },\n\t\t\t\tInstr::parse_from_str (\"addi 3 16 3\"));\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":9,"address":[22681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[37552],"length":1,"stats":{"Line":1},"fn_name":"apply\u003cu64, 6\u003e"},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[32159,32144],"length":1,"stats":{"Line":0},"fn_name":"op"},{"line":108,"address":[32160,32175],"length":1,"stats":{"Line":0},"fn_name":"arg_a"},{"line":112,"address":[32191,32176],"length":1,"stats":{"Line":0},"fn_name":"arg_b"},{"line":119,"address":[37312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[22544,22548,22885,22576],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":257,"address":[22802,22653,22742],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":14,"coverable":69},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"+1\", \"-2\", \"+3\", \"+1\" ]));\n\tassert_eq_ok! (\"3\", puzzle.part_one (\u0026 [ \"+1\", \"+1\", \"+1\" ]));\n\tassert_eq_ok! (\"0\", puzzle.part_one (\u0026 [ \"+1\", \"+1\", \"-2\" ]));\n\tassert_eq_ok! (\"-6\", puzzle.part_one (\u0026 [ \"-1\", \"-2\", \"-3\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [ \"+1\", \"-1\" ]));\n\tassert_eq_ok! (\"10\", puzzle.part_two (\u0026 [ \"+3\", \"+3\", \"+4\", \"-2\", \"-4\" ]));\n\tassert_eq_ok! (\"5\", puzzle.part_two (\u0026 [ \"-6\", \"+3\", \"+8\", \"+5\", \"-6\" ]));\n\tassert_eq_ok! (\"14\", puzzle.part_two (\u0026 [ \"+7\", \"+7\", \"-2\", \"-7\", \"-4\" ]));\n}\n","traces":[{"line":6,"address":[36496,37744],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":7,"address":[36513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[36629,36576,37043,37106,37701,36534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[36649,36687,37172,37232,37665,36740],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[37298,37358,37626,36804,36860,36760],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[37481,37587,37421,36880,36924,36980],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[39008,37760],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":16,"address":[37777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[38307,38370,38965,37840,37893,37798],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[38496,37913,38004,38436,37951,38929],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[38068,38890,38562,38124,38024,38622],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[38745,38144,38851,38244,38188,38685],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-01","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub deltas: Vec \u003ci32\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { deltas, params } = [ params, @lines deltas ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[31835,31334],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-01","lib.rs"],"content":"//! Advent of Code 2018: Day 1: Chronal Calibration\n//!\n//! [https://adventofcode.com/2018/day/01](https://adventofcode.com/2018/day/01)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Chronal Calibration\";\n\tyear = 2018;\n\tday = 1;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[30696],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-01","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tOk (\n\t\tinput.deltas.iter ()\n\t\t\t.sum::\u003ci32\u003e ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tif input.deltas.is_empty () { return Err (\"No deltas provided\".into ()) }\n\tlet mut total: i32 = 0;\n\tlet mut seen: HashSet \u003ci32\u003e = HashSet::new ();\n\tfor (idx, delta) in iter::repeat (input.deltas.clone ()).flatten ().enumerate () {\n\t\tif ! seen.insert (total) { break }\n\t\tif idx == 200_000 { return Err (\"Giving up after 200k iterations\".into ()) }\n\t\ttotal = i32::add_2 (total, delta) ?;\n\t}\n\tOk (total)\n}\n","traces":[{"line":6,"address":[27488],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":13,"address":[27664,28369],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":14,"address":[27689,28040],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[27975,28344,27879,27845],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[27987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[28157,27991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[28021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[28086],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"abcdef\",\n\t\"bababc\",\n\t\"abbcde\",\n\t\"abcccd\",\n\t\"aabcdd\",\n\t\"abcdee\",\n\t\"ababab\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"abcde\",\n\t\"fghij\",\n\t\"klmno\",\n\t\"pqrst\",\n\t\"fguij\",\n\t\"axcye\",\n\t\"wvxyz\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"12\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"fgij\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":26,"address":[30308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[51946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[52284,52005,51967,52057,52114,52180],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[30340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[52346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[52367,52580,52457,52405,52514,52684],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-02","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub box_ids: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { box_ids, params } = [\n\t\tparams,\n\t\t@lines box_ids { box_id = [\n\t\t\t@str box_id = (|ch| { ch.is_ascii_lowercase () }, 1 ..= 32),\n\t\t] },\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[29947],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-02","lib.rs"],"content":"//! Advent of Code 2018: Day 2: Inventory Management System\n//!\n//! [https://adventofcode.com/2018/day/02](https://adventofcode.com/2018/day/02)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Inventory Management System\";\n\tyear = 2018;\n\tday = 2;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[45976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[46300],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-02","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut num_twos = 0_u32;\n\tlet mut num_threes = 0_u32;\n\tlet mut counts: HashMap \u003cchar, u16\u003e = HashMap::new ();\n\tfor box_id in input.box_ids.iter () {\n\t\tcounts.clear ();\n\t\tfor ch in box_id.chars () {\n\t\t\t* counts.entry (ch).or_insert (0) += 1;\n\t\t}\n\t\tif counts.values ().any (|\u0026 count| count == 2) { num_twos += 1; }\n\t\tif counts.values ().any (|\u0026 count| count == 3) { num_threes += 1; }\n\t}\n\tOk (num_twos * num_threes)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tfor index_0 in 0 .. input.box_ids.len () - 1 {\n\t\tlet line_0 = \u0026 input.box_ids [index_0];\n\t\tlet mut buffer = String::new ();\n\t\tfor index_1 in index_0 + 1 .. input.box_ids.len () {\n\t\t\tlet line_1 = \u0026 input.box_ids [index_1];\n\t\t\tbuffer.clear ();\n\t\t\tbuffer.extend (\n\t\t\t\tIterator::zip (line_0.chars (), line_1.chars ())\n\t\t\t\t\t.filter (|\u0026 (ch_0, ch_1)| ch_0 == ch_1)\n\t\t\t\t\t.map (|(ch, _)| ch));\n\t\t\tif buffer.len () + 1 != line_0.len () { continue }\n\t\t\treturn Ok (buffer);\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n","traces":[{"line":7,"address":[33264,34659],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[33478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[33669,33600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[33938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[51008],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003c\u0026u16, aoc_2018_day_02::logic::part_one::{closure_env#0}\u003e"},{"line":17,"address":[50992],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003c\u0026u16, aoc_2018_day_02::logic::part_one::{closure_env#1}\u003e"},{"line":19,"address":[34466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[34672,35585],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":23,"address":[35526,34701,35323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[34826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[35029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[27772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[45410,45408],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":33,"address":[35285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[35401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[35358],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"#1 @ 1,3: 4x4\",\n\t\"#2 @ 3,1: 4x4\",\n\t\"#3 @ 5,5: 2x2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[32932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[59546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[59657,59567,59605,59714,59884,59780],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[32868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[59946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[60114,60180,60284,59967,60005,60057],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-03","input.rs"],"content":"use super::*;\n\nuse model::Coord;\nuse model::Id;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub claims: Vec \u003cClaim\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { claims, params } = [ params, @lines claims ]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Claim {\n\tpub id: Id,\n\tpub left: Coord,\n\tpub top: Coord,\n\tpub width: Coord,\n\tpub height: Coord,\n}\n\nstruct_parser_display! {\n\tClaim { id, left, top, width, height } = [\n\t\t\"#\", id, \" @ \", left, \",\", top, \": \", width, \"x\", height,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[32283],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-03","lib.rs"],"content":"//! Advent of Code 2018: Day 3: No Matter How You Slice It\n//!\n//! [https://adventofcode.com/2018/day/03](https://adventofcode.com/2018/day/03)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"No Matter How You Slice It\";\n\tyear = 2018;\n\tday = 3;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[31304],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[31624],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-03","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Claim;\nuse model::Square;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet claims = Claim::build_vec (input) ?;\n\tif claims.is_empty () { return Ok (0) }\n\tconst NUM_SPLITS: u32 = 16;\n\tlet calc_split = |low: u16, high: u16, idx: u32|\n\t\t(low.pan_u32 () + (high - low).pan_u32 () * idx.pan_u32 () / NUM_SPLITS).pan_u16 ();\n\tlet bound = claims.iter ().map (|claim| claim.square).reduce (Square::bound).unwrap ();\n\tlet mut num_overlaps = 0;\n\tlet mut squares_x: Vec \u003cSquare\u003e = Vec::new ();\n\tlet mut squares_xy: Vec \u003cSquare\u003e = Vec::new ();\n\tlet mut count_overlaps = CountOverlaps::default ();\n\tfor part_x in 0 .. NUM_SPLITS {\n\t\tlet bound = ok_or! (Square::new (\n\t\t\tcalc_split (bound.left (), bound.right (), part_x),\n\t\t\tbound.top (),\n\t\t\tcalc_split (bound.left (), bound.right (), part_x + 1),\n\t\t\tbound.bottom (),\n\t\t), continue);\n\t\tsquares_x.clear ();\n\t\tsquares_x.extend (claims.iter ()\n\t\t\t.filter_map (|claim| Square::overlap (bound, claim.square)));\n\t\tfor part_y in 0 .. NUM_SPLITS {\n\t\t\tlet bound = ok_or! (Square::new (\n\t\t\t\tbound.left (),\n\t\t\t\tcalc_split (bound.top (), bound.bottom (), part_y),\n\t\t\t\tbound.right (),\n\t\t\t\tcalc_split (bound.top (), bound.bottom (), part_y + 1),\n\t\t\t), continue);\n\t\t\tsquares_xy.clear ();\n\t\t\tsquares_xy.extend (squares_x.iter ()\n\t\t\t\t.filter_map (|\u0026 square| Square::overlap (bound, square)));\n\t\t\tnum_overlaps += count_overlaps.calc (\u0026 squares_xy);\n\t\t}\n\t}\n\tOk (num_overlaps)\t\t\n}\n\n#[ derive (Default) ]\nstruct CountOverlaps {\n\toverlaps: Vec \u003cSquare\u003e,\n\toverlaps_temp: Vec \u003cSquare\u003e,\n}\n\nimpl CountOverlaps {\n\tfn calc (\u0026 mut self, squares: \u0026 [Square]) -\u003e u32 {\n\t\tself.overlaps.clear ();\n\t\tfor (idx_0, square_0) in squares.iter ().copied ().enumerate () {\n\t\t\tfor square_1 in squares.iter ().skip (idx_0 + 1).copied () {\n\t\t\t\tlet new_overlap =\n\t\t\t\t\tsome_or! (Square::overlap (square_0, square_1), continue);\n\t\t\t\tfor old_overlap in self.overlaps.drain ( .. ) {\n\t\t\t\t\tself.overlaps_temp.extend (Square::remove (old_overlap, new_overlap));\n\t\t\t\t}\n\t\t\t\tself.overlaps_temp.push (new_overlap);\n\t\t\t\tmem::swap (\u0026 mut self.overlaps, \u0026 mut self.overlaps_temp);\n\t\t\t}\n\t\t}\n\t\tself.overlaps.iter ()\n\t\t\t.map (|overlap| overlap.area ())\n\t\t\t.sum ()\n\t}\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut included = Claim::build_vec (input) ?;\n\tlet mut included_temp = Vec::new ();\n\tlet mut excluded: Vec \u003cClaim\u003e = Vec::new ();\n\twhile let Some (claim_0) = included.pop () {\n\t\tlet mut collision = false;\n\t\tfor claim_1 in excluded.iter () {\n\t\t\tif Square::overlap (claim_0.square, claim_1.square).is_some () {\n\t\t\t\tcollision = true;\n\t\t\t}\n\t\t}\n\t\tfor claim_1 in included.drain ( .. ) {\n\t\t\tif Square::overlap (claim_0.square, claim_1.square).is_some () {\n\t\t\t\texcluded.push (claim_1);\n\t\t\t\tcollision = true;\n\t\t\t} else {\n\t\t\t\tincluded_temp.push (claim_1);\n\t\t\t}\n\t\t}\n\t\tif ! collision { return Ok (claim_0.id) }\n\t\tmem::swap (\u0026 mut included, \u0026 mut included_temp);\n\t}\n\tErr (\"No solution found\".into ())\n}\n","traces":[{"line":9,"address":[52404,50384],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[50409,50690,50432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[50716,50470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[28192],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":14,"address":[28437,28256,28360],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[65813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[51094,52127,52135],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[51055,51340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[50920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[50945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[51445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[27233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[52102,52110,51903],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[51868,51622,51920],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[51480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[51499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[51511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[52009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[27041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[52054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[52154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[53752,52416],"length":1,"stats":{"Line":1},"fn_name":"calc"},{"line":55,"address":[52609,52641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[53667,52649,53370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[52791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[53737,52925,53053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[53055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[55776,56259,55168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[53760,54967],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":73,"address":[54752,53820,53788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[53948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[54103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[54110,54065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[54463,54279,54922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[54571,54629],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[54701,54831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[54770],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":34,"coverable":37},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-03","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub type Coord = u16;\npub type Id = u32;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Claim {\n\tpub id: Id,\n\tpub square: Square,\n}\n\nimpl Claim {\n\tpub fn build_vec (input: \u0026 Input) -\u003e GenResult \u003cVec \u003cSelf\u003e\u003e {\n\t\tlet mut result = Vec::new ();\n\t\tlet mut ids = HashSet::new ();\n\t\tfor claim in \u0026 input.claims {\n\t\t\tif ! ids.insert (claim.id) {\n\t\t\t\treturn Err (format! (\"Duplicated claim id: {}\", claim.id).into ());\n\t\t\t}\n\t\t\tresult.push (Self {\n\t\t\t\tid: claim.id,\n\t\t\t\tsquare: Square::new_size (claim.left, claim.top, claim.width, claim.height) ?,\n\t\t\t});\n\t\t}\n\t\tOk (result)\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Square {\n\tleft: Coord,\n\ttop: Coord,\n\tright: Coord,\n\tbottom: Coord,\n}\n\nimpl Square {\n\n\t#[ inline ]\n\tpub fn new (left: Coord, top: Coord, right: Coord, bottom: Coord) -\u003e GenResult \u003cSelf\u003e {\n\t\tif right \u003c= left || bottom \u003c= top {\n\t\t\treturn Err (format! (\"Invalid square: left={left} top={top} right={right} \\\n\t\t\t\tbottom={bottom}\").into ());\n\t\t}\n\t\tOk (Self { left, top, right, bottom })\n\t}\n\n\t#[ inline ]\n\tpub fn new_size (left: Coord, top: Coord, width: Coord, height: Coord) -\u003e GenResult \u003cSelf\u003e {\n\t\tif width == 0 || height == 0 {\n\t\t\treturn Err (format! (\"Invalid square: left={left} top={top} width={width} \\\n\t\t\t\theight={height}\").into ());\n\t\t}\n\t\tlet right = chk! (left + width) ?;\n\t\tlet bottom = chk! (top + height) ?;\n\t\tOk (Self { left, top, right, bottom })\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn left (self) -\u003e Coord { self.left }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn top (self) -\u003e Coord { self.top }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn right (self) -\u003e Coord { self.right }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn bottom (self) -\u003e Coord { self.bottom }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn width (self) -\u003e Coord { self.right - self.left }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn height (self) -\u003e Coord { self.bottom - self.top }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn area (self) -\u003e u32 { self.width ().pan_u32 () * self.height ().pan_u32 () }\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn overlap (self, other: Self) -\u003e Option \u003cSelf\u003e {\n\t\tlet left = cmp::max (self.left, other.left);\n\t\tlet right = cmp::min (self.right, other.right);\n\t\tif right \u003c= left { return None }\n\t\tlet top = cmp::max (self.top, other.top);\n\t\tlet bottom = cmp::min (self.bottom, other.bottom);\n\t\tif bottom \u003c= top { return None }\n\t\tSome (Self { left, top, right, bottom })\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn remove (self, other: Self) -\u003e ArrayVec \u003cSelf, 4\u003e {\n\t\tif Self::overlap (self, other).is_none () {\n\t\t\treturn array_vec! [ self ];\n\t\t}\n\t\tlet mut result = ArrayVec::new ();\n\t\tif self.left \u003c other.left {\n\t\t\tresult.push (Self {\n\t\t\t\tleft: self.left,\n\t\t\t\ttop: self.top,\n\t\t\t\tright: other.left,\n\t\t\t\tbottom: self.bottom,\n\t\t\t});\n\t\t}\n\t\tif self.top \u003c other.top {\n\t\t\tresult.push (Self {\n\t\t\t\tleft: cmp::max (self.left, other.left),\n\t\t\t\ttop: self.top,\n\t\t\t\tright: cmp::min (self.right, other.right),\n\t\t\t\tbottom: other.top,\n\t\t\t});\n\t\t}\n\t\tif other.bottom \u003c self.bottom {\n\t\t\tresult.push (Self {\n\t\t\t\tleft: cmp::max (self.left, other.left),\n\t\t\t\ttop: other.bottom,\n\t\t\t\tright: cmp::min (self.right, other.right),\n\t\t\t\tbottom: self.bottom,\n\t\t\t});\n\t\t}\n\t\tif other.right \u003c self.right {\n\t\t\tresult.push (Self {\n\t\t\t\tleft: other.right,\n\t\t\t\ttop: self.top,\n\t\t\t\tright: self.right,\n\t\t\t\tbottom: self.bottom,\n\t\t\t});\n\t\t}\n\t\tresult\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn bound (self, other: Self) -\u003e Self {\n\t\tSelf {\n\t\t\tleft: cmp::min (self.left, other.left),\n\t\t\tright: cmp::max (self.right, other.right),\n\t\t\ttop: cmp::min (self.top, other.top),\n\t\t\tbottom: cmp::max (self.bottom, other.bottom),\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn square_remove () {\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 15, top: 10, right: 20, bottom: 15 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 10, top: 10, right: 20, bottom: 15 },\n\t\t\t\tSquare { left: 5, top: 5, right: 15, bottom: 20 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 10 },\n\t\t\t\tSquare { left: 10, top: 15, right: 15, bottom: 20 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 20 },\n\t\t\t\tSquare { left: 5, top: 10, right: 20, bottom: 15 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 5, top: 10, right: 10, bottom: 15 },\n\t\t\t\tSquare { left: 15, top: 10, right: 20, bottom: 15 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 5, top: 10, right: 20, bottom: 15 },\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 20 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 5, top: 10, right: 10, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 15, right: 15, bottom: 20 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 5, top: 10, right: 15, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 5, right: 20, bottom: 15 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 5, top: 5, right: 10, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 10 },\n\t\t\t\tSquare { left: 10, top: 15, right: 15, bottom: 20 },\n\t\t\t\tSquare { left: 15, top: 5, right: 20, bottom: 20 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 5, top: 5, right: 20, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 10, right: 15, bottom: 15 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 10 },\n\t\t\t\tSquare { left: 15, top: 5, right: 20, bottom: 15 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 10, top: 5, right: 20, bottom: 15 },\n\t\t\t\tSquare { left: 5, top: 10, right: 15, bottom: 20 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 10, top: 15, right: 15, bottom: 20 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 10, top: 10, right: 15, bottom: 20 },\n\t\t\t\tSquare { left: 5, top: 5, right: 20, bottom: 15 }));\n\t\tassert_eq! (\n\t\t\tarray_vec! [\n\t\t\t\tSquare { left: 5, top: 10, right: 10, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 15, right: 15, bottom: 20 },\n\t\t\t\tSquare { left: 15, top: 10, right: 20, bottom: 20 } ],\n\t\t\tSquare::remove (\n\t\t\t\tSquare { left: 5, top: 10, right: 20, bottom: 20 },\n\t\t\t\tSquare { left: 10, top: 5, right: 15, bottom: 15 }));\n\t}\n\n}\n","traces":[{"line":16,"address":[63318,62528],"length":1,"stats":{"Line":2},"fn_name":"build_vec"},{"line":19,"address":[62775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[62790,62805],"length":1,"stats":{"Line":4},"fn_name":null},{"line":21,"address":[63122,63033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[62813],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[62854,62816],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[62937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[64080,64083],"length":1,"stats":{"Line":0},"fn_name":"left"},{"line":68,"address":[64103,64096],"length":1,"stats":{"Line":0},"fn_name":"top"},{"line":72,"address":[64112,64119],"length":1,"stats":{"Line":0},"fn_name":"right"},{"line":76,"address":[64128,64135],"length":1,"stats":{"Line":0},"fn_name":"bottom"},{"line":80,"address":[64154,64282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[64298,64216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[64314,64144,64269],"length":1,"stats":{"Line":2},"fn_name":"area"},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[28544,28548],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":164,"address":[44855,43500,44312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[43450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[43487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[44353,43616,44832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[43561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[43603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[44394,43722,44809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[43657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[43709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[44786,43828,44435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[43773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[43815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[43952,44763,44476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[43879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[43939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[44055,44514,44740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[43993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[44042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[44552,44714,44146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[44096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[44133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[44590,44254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[44187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[44241],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":70,"coverable":93},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-04","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"[1518-11-01 00:00] Guard #10 begins shift\",\n\t\"[1518-11-01 00:05] falls asleep\",\n\t\"[1518-11-01 00:25] wakes up\",\n\t\"[1518-11-01 00:30] falls asleep\",\n\t\"[1518-11-01 00:55] wakes up\",\n\t\"[1518-11-01 23:58] Guard #99 begins shift\",\n\t\"[1518-11-02 00:40] falls asleep\",\n\t\"[1518-11-02 00:50] wakes up\",\n\t\"[1518-11-03 00:05] Guard #10 begins shift\",\n\t\"[1518-11-03 00:24] falls asleep\",\n\t\"[1518-11-03 00:29] wakes up\",\n\t\"[1518-11-04 00:02] Guard #99 begins shift\",\n\t\"[1518-11-04 00:36] falls asleep\",\n\t\"[1518-11-04 00:46] wakes up\",\n\t\"[1518-11-05 00:03] Guard #99 begins shift\",\n\t\"[1518-11-05 00:45] falls asleep\",\n\t\"[1518-11-05 00:55] wakes up\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"240\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4455\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":26,"address":[40260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[50442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[50553,50463,50610,50676,50501,50780],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[40196],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[50842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[51180,50901,51076,50953,50863,51010],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-04","input.rs"],"content":"use super::*;\n\nuse model::Date;\nuse model::HourMinute;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub entries: Vec \u003cEntry\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { entries, params } = [ params, @lines entries ]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Entry {\n\tpub date: Date,\n\tpub time: HourMinute,\n\tpub event: Event,\n}\n\nstruct_parser_display! {\n\tEntry { date, time, event } = [ \"[\", date, \" \", time, \"] \", event ]\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum Event {\n\t\tBeginsShift (id: u32) = [ \"Guard #\", id, \" begins shift\" ],\n\t\tFallsAsleep = [ \"falls asleep\" ],\n\t\tWakesUp = [ \"wakes up\" ],\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[39707],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-04","lib.rs"],"content":"//! Advent of Code 2018: Day 4: Repose Record\n//!\n//! [https://adventofcode.com/2018/day/04](https://adventofcode.com/2018/day/04)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Repose Record\";\n\tyear = 2018;\n\tday = 4;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[71048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[71368],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-04","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Event;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet guard_min_sleep = analyse (input) ?;\n\tlet mut guard_sleep: HashMap \u003cu32, u32\u003e = HashMap::new ();\n\tfor (\u0026 (guard, _), \u0026 mins) in guard_min_sleep.iter () {\n\t\t* guard_sleep.entry (guard).or_insert (0) += mins;\n\t}\n\tlet sleepiest_guard =\n\t\tguard_sleep.iter ()\n\t\t\t.max_by_key (|\u0026 (_, mins)| mins)\n\t\t\t.map (|(\u0026 guard, _)| guard)\n\t\t\t.ok_or (\"No solution found\") ?;\n\tlet sleepiest_min =\n\t\tguard_min_sleep.iter ()\n\t\t\t.filter (|\u0026 (\u0026 (guard, _), _)| guard == sleepiest_guard)\n\t\t\t.max_by_key (|\u0026 (_, \u0026 mins)| mins)\n\t\t\t.map (|(\u0026 (_, min), _)| min)\n\t\t\t.unwrap ();\n\tOk (sleepiest_guard * sleepiest_min)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet guard_min_sleep = analyse (input) ?;\n\tlet (guard, min) =\n\t\tguard_min_sleep.iter ()\n\t\t\t.max_by_key (|\u0026 (_, \u0026 mins)| mins)\n\t\t\t.map (|(\u0026 (guard, min), _)| (guard, min))\n\t\t\t.ok_or (\"No solution found\") ?;\n\tOk (guard * min)\n}\n\nfn analyse (input: \u0026 Input) -\u003e GenResult \u003cHashMap \u003c(u32, u32), u32\u003e\u003e {\n\tlet mut entries = input.entries.clone ();\n\tentries.sort_by_key (|entry| (entry.date, entry.time));\n\tif entries.iter ()\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.any (|(left, right)| (left.date, left.time) == (right.date, right.time)) {\n\t\treturn Err (\"Two entries share the same time\".into ());\n\t}\n\tlet mut guard_id = None;\n\tlet mut fell_asleep_at = None;\n\tlet mut result: HashMap \u003c(u32, u32), u32\u003e = HashMap::new ();\n\tfor entry in entries.iter () {\n\t\tmatch entry.event {\n\t\t\tEvent::BeginsShift (id) =\u003e {\n\t\t\t\tif fell_asleep_at.is_some () {\n\t\t\t\t\treturn Err (\"Begin shift while previous guard is asleep\".into ());\n\t\t\t\t}\n\t\t\t\tguard_id = Some (id);\n\t\t\t},\n\t\t\tEvent::FallsAsleep =\u003e {\n\t\t\t\tif guard_id.is_none () {\n\t\t\t\t\treturn Err (\"Falls asleep while no guard on duty\".into ());\n\t\t\t\t}\n\t\t\t\tif fell_asleep_at.is_some () {\n\t\t\t\t\treturn Err (\"Falls asleep while already asleep\".into ());\n\t\t\t\t}\n\t\t\t\tif entry.time.hour () != 0 {\n\t\t\t\t\treturn Err (\"Falls asleep after 01:00\".into ());\n\t\t\t\t}\n\t\t\t\tfell_asleep_at = Some ((entry.date, entry.time));\n\t\t\t},\n\t\t\tEvent::WakesUp =\u003e {\n\t\t\t\tif guard_id.is_none () {\n\t\t\t\t\treturn Err (\"Falls asleep while no guard on duty\".into ());\n\t\t\t\t}\n\t\t\t\tlet guard_id = guard_id.unwrap ();\n\t\t\t\tif fell_asleep_at.is_none () {\n\t\t\t\t\treturn Err (\"Wakes up while not asleep\".into ());\n\t\t\t\t}\n\t\t\t\tif entry.time.hour () != 0 {\n\t\t\t\t\treturn Err (\"Wakes up after 01:00\".into ());\n\t\t\t\t}\n\t\t\t\tlet (fell_asleep_date, fell_asleep_time) = fell_asleep_at.take ().unwrap ();\n\t\t\t\tif fell_asleep_date != entry.date {\n\t\t\t\t\treturn Err (\"Falls asleep and wakes up on different days\".into ());\n\t\t\t\t}\n\t\t\t\tfor min in fell_asleep_time.minute () .. entry.time.minute () {\n\t\t\t\t\t* result.entry ((guard_id, min)).or_insert (0) += 1;\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\tOk (result)\n}\n","traces":[{"line":8,"address":[29696,31427],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[29721,29793,30763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[30149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[30459],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[30838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[31440],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":17,"address":[60645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[31181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[29619,31472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[31488,30951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[31504,31164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[31194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[31969,31520],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":29,"address":[31761,31538,31609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[31809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[57259,57387,58155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[32000],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":35,"address":[31818,31919],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[32016,33962],"length":1,"stats":{"Line":2},"fn_name":"analyse"},{"line":39,"address":[32043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[33984],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":41,"address":[32477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[32346,34016,34075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[32481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[32755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[32779,32832],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[32798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[32792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[32842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[32853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[32905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[32913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[32956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[32962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[32988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[33040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[33080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[33088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[33614,33211],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[33589,33889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[33639],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-04","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Date {\n\tyear: u16,\n\tmonth: u8,\n\tday: u8,\n}\n\nstruct_parser_display! {\n\tDate { year, month, day } = [\n\t\tyear = 1 ..= 9999, \"-\", month = 1 ..= 12, \"-\", day = 1 ..= 31,\n\t\t@parse |parser| {\t\n\t\t\tif Date::days_in_month (year, month) \u003c day {\n\t\t\t\treturn Err (parser.err ())\n\t\t\t}\n\t\t}\n\t]\n}\n\nimpl Date {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn next (self) -\u003e Self {\n\t\tif self.day \u003c Self::days_in_month (self.year, self.month) {\n\t\t\tSelf { day: self.day + 1, .. self }\n\t\t} else if self.month \u003c 12 {\n\t\t\tSelf { month: self.month + 1, day: 1, .. self }\n\t\t} else {\n\t\t\tSelf { year: self.year + 1, month: 1, day: 1 }\n\t\t}\n\t}\n\n\tfn days_in_month (year: u16, month: u8) -\u003e u8 {\n\t\tmatch (year, month) {\n\t\t\t(_, 1 | 3 | 5 | 7 | 8 | 10 | 12) =\u003e 31,\n\t\t\t(_, 4 | 6 | 9 | 11) =\u003e 30,\n\t\t\t(year, 2) if year % 400 == 0 =\u003e 29,\n\t\t\t(year, 2) if year % 100 == 0 =\u003e 28,\n\t\t\t(year, 2) if year % 4 == 0 =\u003e 29,\n\t\t\t(_, 2) =\u003e 28,\n\t\t\t_ =\u003e unreachable! (),\n\t\t}\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct HourMinute {\n\thour: u8,\n\tminute: u8,\n}\n\nstruct_parser_display! {\n\tHourMinute { hour, minute } = [ hour = 0 ..= 23, \":\", minute = 0 ..= 59 ]\n}\n\nimpl HourMinute {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn hour (\u0026 self) -\u003e u32 {\n\t\tself.hour.pan_u32 ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn minute (\u0026 self) -\u003e u32 {\n\t\tself.minute.pan_u32 ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn as_minutes (\u0026 self) -\u003e u32 {\n\t\tself.hour.pan_u32 () * 60 + self.minute.pan_u32 ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn as_seconds (\u0026 self) -\u003e u32 {\n\t\tself.hour.pan_u32 () * 3600 + self.minute.pan_u32 () * 60\n\t}\n\n}\n","traces":[{"line":14,"address":[54850],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[54858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[53680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[53680,54812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[53721,54904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[54925,53741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[54946,53761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-05","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"dabAcCaCBAcCcaDA\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[32068,32064],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":9,"address":[37418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[37529,37652,37477,37586,37756,37439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[32096,32100],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[37818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[37877,37986,38052,38156,37839,37929],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-05","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub polymer: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { polymer, params } = [\n\t\tparams,\n\t\t@str polymer = (|ch| { ch.is_ascii_alphabetic () }, 1 .. ),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-05","lib.rs"],"content":"//! Advent of Code 2018: Day 5: Alchemical Reduction\n//!\n//! [https://adventofcode.com/2018/day/05](https://adventofcode.com/2018/day/05)\n//!\n//! # Input\n//!\n//! A single line containing a string of mixed case ASCII letters.\n//!\n//! # Part one\n//!\n//! The string represents a \"polymer\" where each letter is a \"unit\". A lowercase letter and its\n//! uppercase equivalent represent the same unit \"type\" with different polarity. Whenever these\n//! are adjacent, they \"react\" and are removed from the string. Apply these rules until there are\n//! no adjacent units which can react, and return the number of remaining units.\n//!\n//! # Part two\n//!\n//! Remove all units of exactly one type, regardless of polarity, to produce the shortest possible\n//! resulting polymer, and return its length.\n//!\n//! # Algorithm\n//!\n//! We build up the result string one character at a time, always comparing the last char in the\n//! result to the next one in the input. Whenever these form a pair, we skip the next char from\n//! the input and remove the last one from the output. In this way, we can produce the result in a\n//! single pass.\n//!\n//! For part two, we first reduce the polymer the same as part one. We then try every letter from\n//! `a` to `z`, seeing how much we can further reduce the polymer. This works because the\n//! reduction process works the same in whatever order. By first reducing the initial input as\n//! much as possible we reduce the amount of work that has to be done for each letter in the\n//! second part of the process.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Alchemical Reduction\";\n\tyear = 2018;\n\tday = 5;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":47,"address":[34590],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[34910],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-05","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (reduce (input.polymer.chars ()).len ().pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet polymer = reduce (input.polymer.chars ());\n\tOk (\n\t\t('a' ..= 'z')\n\t\t\t.map (|remove_ch| (remove_ch, remove_ch.to_ascii_uppercase ()))\n\t\t\t.map (|(remove_ch_lower, remove_ch_upper)| polymer.iter ().copied ()\n\t\t\t\t.filter (move |\u0026 ch| ch != remove_ch_lower \u0026\u0026 ch != remove_ch_upper))\n\t\t\t.map (|polymer_chars| reduce (polymer_chars))\n\t\t\t.map (|polymer| polymer.len ().pan_u32 ())\n\t\t\t.min ()\n\t\t\t.unwrap ()\n\t)\n}\n\npub fn reduce (polymer: impl IntoIterator \u003cItem = char\u003e) -\u003e Vec \u003cchar\u003e {\n\tlet mut result: Vec \u003cchar\u003e = Vec::new ();\n\tfor next_ch in polymer {\n\t\tif let Some (last_ch) = result.last () {\n\t\t\tif last_ch.pan_u32 ().abs_diff (next_ch.pan_u32 ()) == 'a'.pan_u32 () - 'A'.pan_u32 () {\n\t\t\t\tresult.pop ();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tresult.push (next_ch);\n\t}\n\tresult\n}\n","traces":[{"line":7,"address":[39696,39851],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[39738,39797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[39872,40039],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":12,"address":[39916],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[39957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[40065,40048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[30093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[23454,23443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[29930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[33652,33622],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[40304,40768,40747,41307],"length":1,"stats":{"Line":3},"fn_name":"reduce\u003ccore::str::iter::Chars\u003e"},{"line":27,"address":[40801,40888,40335,40408],"length":1,"stats":{"Line":6},"fn_name":null},{"line":28,"address":[40948,40419,40936,40431],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[40446,41252,40694,40963,41107,40574],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":13,"coverable":14},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-06","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"DIST_TWO=31\",\n\t\"1, 1\",\n\t\"1, 6\",\n\t\"8, 3\",\n\t\"3, 4\",\n\t\"5, 5\",\n\t\"8, 9\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"17\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"16\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":16,"address":[39872,39876],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":17,"address":[42154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[42265,42175,42388,42322,42492,42213],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[39908,39904],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":23,"address":[42554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[42575,42665,42613,42722,42892,42788],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-06","input.rs"],"content":"use super::*;\n\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub posns: Vec \u003cPos\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { posns, params } = [\n\t\tparams,\n\t\t@lines posns { Pos { y, x } = [ x = 0 ..= 399, \", \", y = 0 ..= 399 ] },\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub dist_two: u32 = (\"DIST_TWO=\", 10_000, 1 ..= 100_000),\n\t}\n}\n","traces":[{"line":12,"address":[32795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[33109],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-06","lib.rs"],"content":"//! Advent of Code 2018: Day 6: Chronal Coordinates\n//!\n//! [https://adventofcode.com/2018/day/06](https://adventofcode.com/2018/day/06)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Chronal Coordinates\";\n\tyear = 2018;\n\tday = 6;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tpub type Coord = i16;\n\tpub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\n}\n","traces":[{"line":18,"address":[47303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[47655],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-06","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tcheck_input (input) ?;\n\n\t// work out size\n\n\tlet (start, end) = input.posns.iter ()\n\t\t.fold (None, |state: Option \u003c(Pos, Pos)\u003e, \u0026 pos| state\n\t\t\t.map (|(start, end)| (\n\t\t\t\tPos::new (cmp::min (start.y, pos.y), cmp::min (start.x, pos.x)),\n\t\t\t\tPos::new (cmp::max (end.y, pos.y), cmp::max (end.x, pos.x)),\n\t\t\t))\n\t\t\t.or (Some ((pos, pos))))\n\t\t.unwrap ();\n\n\t// work out area sizes, excluding any which touch the sides\n\n\tlet mut areas = vec! [0_u32; input.posns.len ()];\n\tfor y in start.y ..= end.y {\n\t\tfor x in start.x ..= end.x {\n\t\t\tlet pos = Pos::new (y, x);\n\t\t\tlet (_, close_idx) = input.posns.iter ().enumerate ()\n\t\t\t\t.fold ((u16::MAX, usize::MAX), |(close_dist, close_idx), (inp_idx, inp_pos)| {\n\t\t\t\t\tlet dist = inp_pos.y.abs_diff (pos.y) + inp_pos.x.abs_diff (pos.x);\n\t\t\t\t\t#[ allow (clippy::comparison_chain) ] // this is significantly quicker\n\t\t\t\t\tif dist \u003c close_dist { (dist, inp_idx) }\n\t\t\t\t\telse if close_dist == dist { (close_dist, usize::MAX) }\n\t\t\t\t\telse { (close_dist, close_idx) }\n\t\t\t\t});\n\t\t\tif close_idx == usize::MAX { continue }\n\t\t\tif areas [close_idx] == u32::MAX { continue }\n\t\t\tif y == start.y || y == end.y || x == start.x || x == end.x {\n\t\t\t\tareas [close_idx] = u32::MAX;\n\t\t\t} else {\n\t\t\t\tareas [close_idx] += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// find largest area\n\n\tOk (\n\t\tareas.into_iter ()\n\t\t\t.filter (|\u0026 area| area != u32::MAX)\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tcheck_input (input) ?;\n\n\t// work out size\n\n\tlet height = input.posns.iter ().map (|\u0026 pos| pos.y + Coord::ONE).max ().unwrap ();\n\tlet width = input.posns.iter ().map (|\u0026 pos| pos.x + Coord::ONE).max ().unwrap ();\n\n\t// work out horizontal/vertical distances separately\n\n\tlet dists_x = calc_axis_dists (\n\t\tinput.posns.iter ().map (|pos| pos.x.pan_i32 ()),\n\t\twidth.pan_i32 ());\n\tlet dists_y = calc_axis_dists (\n\t\tinput.posns.iter ().map (|pos| pos.y.pan_i32 ()),\n\t\theight.pan_i32 ());\n\n\t// sum separate distances to get totals and count how many are in range\n\n\tlet mut area = 0_u32;\n\tfor \u0026 dist_x in dists_x.iter () {\n\t\tif dist_x \u003e input.params.dist_two { continue }\n\t\tfor \u0026 dist_y in dists_y.iter () {\n\t\t\tif dist_x + dist_y \u003e input.params.dist_two { continue }\n\t\t\tarea += 1;\n\t\t}\n\t}\n\n\tOk (area)\n\n}\n\nfn calc_axis_dists (posns_iter: impl Iterator \u003cItem = i32\u003e, size: i32) -\u003e Vec \u003cu32\u003e {\n\tlet posns: Vec \u003ci32\u003e = posns_iter.sorted ().collect ();\n\tlet dists_fwd = calc_one_way (posns.iter ().copied (), 0_i32 .. size);\n\tlet dists_rev = calc_one_way (posns.iter ().rev ().copied (), (0_i32 .. size).rev ());\n\tdists_fwd.iter ().zip (dists_rev.iter ().rev ())\n\t\t.map (|(\u0026 fwd, \u0026 rev)| fwd + rev)\n\t\t.collect ()\n}\n\nfn calc_one_way (\n\tposns_iter: impl Iterator \u003cItem = i32\u003e,\n\trange: impl Iterator \u003cItem = i32\u003e,\n) -\u003e Vec \u003cu32\u003e {\n\tlet mut num_points = 0;\n\tlet mut cur_dist = 0;\n\tlet mut posns_iter = posns_iter.peekable ();\n\tlet mut dists: Vec \u003cu32\u003e = Vec::new ();\n\tfor pos in range {\n\t\tcur_dist += num_points;\n\t\tdists.push (cur_dist);\n\t\twhile posns_iter.peek () == Some (\u0026 pos) {\n\t\t\tposns_iter.next ().unwrap ();\n\t\t\tnum_points += 1;\n\t\t}\n\t}\n\tdists\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.posns.is_empty () { return Err (\"Must have at least one position\".into ()) }\n\tif input.posns.len () \u003e 50 { return Err (\"Refusing to handle more than 50 points\".into ()) }\n\tOk (())\n}\n","traces":[{"line":9,"address":[38749,37440],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[37520],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[37593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[49515,49472,49489],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":17,"address":[49728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[49763,49540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[49575,49802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[49695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[37760,38007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[38063,38150],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[49888],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":32,"address":[40944,41121,41229,41183,41076,40989],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[38309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[38347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[38402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[38422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[38502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[38089,38626,38464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[37762,37848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[48562,50016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[38768,39855],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":61,"address":[38845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[26268,26343],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[48145,50081,50080,48156],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[50128],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":74,"address":[50192],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":80,"address":[39534,39561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[39567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[39641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[39650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[39667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[39700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[50975,50624,50256,50607],"length":1,"stats":{"Line":2},"fn_name":"calc_axis_dists\u003ccore::iter::adapters::map::Map\u003ccore::slice::iter::Iter\u003caoc_pos::dim_2::yx::PosYX\u003ci16\u003e\u003e, aoc_2018_day_06::logic::part_two::{closure_env#2}\u003e\u003e"},{"line":93,"address":[50647,50279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[50346,50714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[51041,51040,48702,48748,50993,50992,48988,48942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[51088,51959,51536,51519],"length":1,"stats":{"Line":2},"fn_name":"calc_one_way\u003ccore::iter::adapters::copied::Copied\u003ccore::iter::adapters::rev::Rev\u003ccore::slice::iter::Iter\u003ci32\u003e\u003e\u003e, core::iter::adapters::rev::Rev\u003ccore::ops::range::Range\u003ci32\u003e\u003e\u003e"},{"line":109,"address":[51206,51582,51651,51128],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[51212,51661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[51827,51390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[51842,51398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[51861,51417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[38817,37470,38795,37492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[37472,38797],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":39,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-07","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_WORKERS=2\",\n\t\"EXTRA_TIME=0\",\n\t\"Step C must be finished before step A can begin.\",\n\t\"Step C must be finished before step F can begin.\",\n\t\"Step A must be finished before step B can begin.\",\n\t\"Step A must be finished before step D can begin.\",\n\t\"Step B must be finished before step E can begin.\",\n\t\"Step D must be finished before step E can begin.\",\n\t\"Step F must be finished before step E can begin.\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"CABDFE\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"15\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":18,"address":[34800,34804],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":19,"address":[35946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[36114,35967,36005,36284,36057,36180],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[34832,34836],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":25,"address":[36346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[36367,36514,36580,36405,36457,36684],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-07","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub deps: Vec \u003c(char, char)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { deps, params } = [\n\t\tparams,\n\t\t@lines deps { type = (char, char); (before, after) = [\n\t\t\t\"Step \", before = 'A' ..= 'Z', \" must be finished before \",\n\t\t\t\"step \", after = 'A' ..= 'Z', \" can begin.\",\n\t\t] },\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_workers: u32 = (\"NUM_WORKERS=\", 5, 1_u32 ..= 10),\n\t\tpub extra_time: u32 = (\"EXTRA_TIME=\", 60, 0_u32 ..= 60),\n\t}\n}\n","traces":[{"line":10,"address":[39308],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[69947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[69951],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-07","lib.rs"],"content":"//! Advent of Code 2018: Day 7: The Sum of Its Parts\n//!\n//! [https://adventofcode.com/2018/day/07](https://adventofcode.com/2018/day/07)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"The Sum of Its Parts\";\n\tyear = 2018;\n\tday = 7;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[47551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[47959],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-07","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\n\tlet deps = get_deps (input);\n\n\tlet mut remaining: HashSet \u003cchar\u003e = deps.keys ().copied ().collect ();\n\tlet mut completed: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut order = String::new ();\n\twhile ! remaining.is_empty () {\n\t\tlet next_step = remaining.iter ()\n\t\t\t.filter (|step| deps [step].iter ().all (|dep| completed.contains (dep)))\n\t\t\t.copied ()\n\t\t\t.min ()\n\t\t\t.ok_or (\"No solution found\") ?;\n\t\tremaining.remove (\u0026 next_step);\n\t\tcompleted.insert (next_step);\n\t\torder.push (next_step);\n\t}\n\n\tOk (order)\n\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tlet deps = get_deps (input);\n\n\tlet mut remaining: HashSet \u003cchar\u003e = deps.keys ().copied ().collect ();\n\tlet mut completed: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut queue: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut workers: Vec \u003cOption \u003c(char, u32)\u003e\u003e =\n\t\tvec! [None; input.params.num_workers.pan_usize ()];\n\tlet mut elapsed: u32 = 0;\n\tlet mut newly_completed = true;\n\n\twhile ! remaining.is_empty ()\n\t\t\t|| ! queue.is_empty ()\n\t\t\t|| workers.iter ().any (Option::is_some) {\n\n\t\tif newly_completed {\n\t\t\tfor \u0026 next_step in remaining.iter ()\n\t\t\t\t\t.filter (|step| deps [step].iter ().all (|dep| completed.contains (dep))) {\n\t\t\t\tqueue.insert (next_step);\n\t\t\t}\n\t\t\tnewly_completed = false;\n\t\t}\n\n\t\tfor worker in workers.iter_mut ().filter (|worker| worker.is_none ()) {\n\t\t\tif queue.is_empty () { break }\n\t\t\tlet next_step = queue.iter ().min ().copied ().unwrap ();\n\t\t\tlet step_time = 1 + next_step.pan_u32 () - 'A'.pan_u32 () + input.params.extra_time;\n\t\t\t* worker = Some ((next_step, step_time));\n\t\t\tremaining.remove (\u0026 next_step);\n\t\t\tqueue.remove (\u0026 next_step);\n\t\t}\n\n\t\tif workers.iter ().all (Option::is_none) {\n\t\t\treturn Err (\"No solution found\".into ());\n\t\t}\n\n\t\telapsed += 1;\n\t\tfor worker_opt in workers.iter_mut ().filter (|worker| worker.is_some ()) {\n\t\t\tlet worker = worker_opt.as_mut ().unwrap ();\n\t\t\tworker.1 -= 1;\n\t\t\tif worker.1 \u003e 0 { continue }\n\t\t\tcompleted.insert (worker.0);\n\t\t\t* worker_opt = None;\n\t\t\tnewly_completed = true;\n\t\t}\n\n\t}\n\n\tOk (elapsed)\n\n}\n\nfn get_deps (input: \u0026 Input) -\u003e HashMap \u003cchar, Vec \u003cchar\u003e\u003e {\n\tlet mut deps: HashMap \u003cchar, Vec \u003cchar\u003e\u003e = HashMap::new ();\n\tfor \u0026 (before, after) in input.deps.iter () {\n\t\tdeps.entry (before).or_insert_with (Vec::new);\n\t\tdeps.entry (after).or_insert_with (Vec::new).push (before);\n\t}\n\tdeps\n}\n","traces":[{"line":6,"address":[60496,61972],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[60526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[60971,61030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[61345,61398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[33269,31985,32136,33423,34549,34544,32154,33441,34664],"length":1,"stats":{"Line":6},"fn_name":null},{"line":20,"address":[61488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[61500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[61555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[64902,61984],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":30,"address":[62022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[62587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[62707,62800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[62808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[62859,62871,63009],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[34677,34792,32568,34672,32586,32417],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[31856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[63234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[63458,63478],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[63522,63566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[63584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[63984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[64241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[63996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[31872],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[64171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[64189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[64191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[64206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[64440],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[64912,65858],"length":1,"stats":{"Line":2},"fn_name":"get_deps"},{"line":83,"address":[65123,65181],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":30,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-08","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"138\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"66\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[27044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[30922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[31156,31090,31260,30943,31033,30981],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[26884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[31322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[31381,31433,31490,31556,31660,31343],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-08","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cu8\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \" \" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[26619],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-08","lib.rs"],"content":"//! Advent of Code 2018: Day 8: Memory Maneuver\n//!\n//! [https://adventofcode.com/2018/day/08](https://adventofcode.com/2018/day/08)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Memory Maneuver\";\n\tyear = 2018;\n\tday = 8;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[40776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[41096],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-08","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tstruct Frame {\n\t\tnum_children: u8,\n\t\tnum_metadata: u8,\n\t}\n\n\tlet mut stack: Vec \u003cFrame\u003e = vec! [\n\t\tFrame {\n\t\t\tnum_children: 1,\n\t\t\tnum_metadata: 0,\n\t\t},\n\t];\n\n\tlet mut data_iter = input.data.iter ().copied ();\n\tlet mut metadata_sum: u32 = 0;\n\n\twhile ! stack.is_empty () {\n\t\tlet frame = stack.last_mut ().unwrap ();\n\t\tif frame.num_children \u003e 0 {\n\t\t\tframe.num_children -= 1;\n\t\t\tstack.push (Frame {\n\t\t\t\tnum_children: data_iter.next ().ok_or (\"Invalid data\") ?,\n\t\t\t\tnum_metadata: data_iter.next ().ok_or (\"Invalid data\") ?,\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tmetadata_sum += data_iter.by_ref ()\n\t\t\t.take (frame.num_metadata.pan_usize ())\n\t\t\t.map (u8::pan_u32)\n\t\t\t.sum::\u003cu32\u003e ();\n\t\tstack.pop ();\n\t}\n\n\tif data_iter.next ().is_some () {\n\t\treturn Err (\"Invalid data\".into ());\n\t}\n\n\tOk (metadata_sum)\n\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tstruct Frame {\n\t\tnum_children: u8,\n\t\tnum_metadata: u8,\n\t\tchild_values: Vec \u003cu32\u003e,\n\t}\n\n\tlet mut stack: Vec \u003cFrame\u003e = vec! [\n\t\tFrame {\n\t\t\tnum_children: 1,\n\t\t\tnum_metadata: 1,\n\t\t\tchild_values: Vec::new (),\n\t\t},\n\t];\n\n\tlet mut data = input.data.clone ();\n\tdata.push (1);\n\n\tlet mut data_iter = data.iter ().copied ();\n\n\tlet value = loop {\n\t\tlet frame = stack.last_mut ().unwrap ();\n\t\tif frame.num_children \u003e 0 {\n\t\t\tframe.num_children -= 1;\n\t\t\tstack.push (Frame {\n\t\t\t\tnum_children: data_iter.next ().ok_or (\"Invalid data\") ?,\n\t\t\t\tnum_metadata: data_iter.next ().ok_or (\"Invalid data\") ?,\n\t\t\t\tchild_values: Vec::new (),\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tlet value = if frame.child_values.is_empty () {\n\t\t\tdata_iter.by_ref ()\n\t\t\t\t.take (frame.num_metadata.pan_usize ())\n\t\t\t\t.map (u8::pan_u32)\n\t\t\t\t.sum::\u003cu32\u003e ()\n\t\t} else {\n\t\t\tdata_iter.by_ref ()\n\t\t\t\t.take (frame.num_metadata.pan_usize ())\n\t\t\t\t.map (|idx| {\n\t\t\t\t\tlet idx = chk! (idx.pan_usize () - 1) ?;\n\t\t\t\t\tOk::\u003c_, Overflow\u003e (frame.child_values.get (idx).copied ())\n\t\t\t\t})\n\t\t\t\t.flatten_ok ()\n\t\t\t\t.try_fold (0, |sum, item| { let item = item ?; chk! (sum + item) }) ?\n\t\t};\n\t\tstack.pop ();\n\t\tif let Some (frame) = stack.last_mut () {\n\t\t\tframe.child_values.push (value);\n\t\t} else {\n\t\t\tbreak value;\n\t\t}\n\t};\n\n\tif data_iter.next ().is_some () {\n\t\treturn Err (\"Invalid data\".into ());\n\t}\n\n\tOk (value)\n\n}\n","traces":[{"line":7,"address":[39049,38256],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":14,"address":[38310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[38338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[38387,38637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[38461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[38472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[38511,38476,38522],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[38574,38563,38528],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[38769,38948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[38870,38878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[38880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[38908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[40206,39072],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":57,"address":[39129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[39177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[39191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[39207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[39312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[39324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[39400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[39353,39343,39329],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[39359,39383,39373],"length":1,"stats":{"Line":3},"fn_name":null},{"line":81,"address":[39509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[39597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[44272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[44480,44352,44512,43664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[43691,44379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[30767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[39812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[39865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[39964,39977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[39979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[40071],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":33},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-09","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"9 players; last marble is worth 25 points\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"32\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"22563\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[27252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[38570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[38738,38629,38804,38908,38681,38591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[27220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[38970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[39029,38991,39204,39081,39138,39308],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-09","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub num_players: u32,\n\tpub last_marble: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { num_players, last_marble, params } = [\n\t\tparams,\n\t\tnum_players, \" players; \",\n\t\t\"last marble is worth \", last_marble, \" points\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-09","lib.rs"],"content":"//! Advent of Code 2018: Day 9: Marble Mania\n//!\n//! [https://adventofcode.com/2018/day/09](https://adventofcode.com/2018/day/09)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Marble Mania\";\n\tyear = 2018;\n\tday = 9;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-09","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (play (input) ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet input = Input { last_marble: input.last_marble * 100, .. * input };\n\tOk (play (\u0026 input) ?)\n}\n\nfn play (input: \u0026 Input) -\u003e NumResult \u003cu32\u003e {\n\tlet mut scores: Vec \u003cu32\u003e = vec! [0; input.num_players.pan_usize ()];\n\tlet mut circle: VecDeque \u003cu32\u003e = vec! [0].into ();\n\tfor (player, marble) in Iterator::zip (\n\t\titer::repeat (0 .. input.num_players).flatten (),\n\t\t1 ..= input.last_marble,\n\t) {\n\t\tif marble % 23 == 0 {\n\t\t\tlet score = \u0026 mut scores [player.pan_usize ()];\n\t\t\t* score = chk! (* score + marble) ?;\n\t\t\tcircle.rotate_right (7);\n\t\t\t* score = chk! (* score + circle.pop_front ().unwrap ()) ?;\n\t\t} else {\n\t\t\tcircle.rotate_left (2 % circle.len ());\n\t\t\tcircle.push_front (marble);\n\t\t}\n\t}\n\tOk (scores.into_iter ().max ().unwrap ())\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn play () {\n\t\tfor (expected, input) in [\n\t\t\t(8317, Input { num_players: 10, last_marble: 1618, params: default () }),\n\t\t\t(146373, Input { num_players: 13, last_marble: 7999, params: default () }),\n\t\t\t(2764, Input { num_players: 17, last_marble: 1104, params: default () }),\n\t\t\t(54718, Input { num_players: 21, last_marble: 6111, params: default () }),\n\t\t\t(37305, Input { num_players: 30, last_marble: 5807, params: default () }),\n\t\t] {\n\t\t\tassert_eq_ok! (expected, logic::play (\u0026 input));\n\t\t}\n\t}\n\n}\n","traces":[{"line":7,"address":[44752],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[36030,35988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[44816],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":12,"address":[36314,36564],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[36380,36335],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[46757,44944],"length":1,"stats":{"Line":1},"fn_name":"play"},{"line":17,"address":[44964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[45167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[45463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[45223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[45481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[39376,39360],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[39392,39437,39472],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":29,"address":[45534,46583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[46476,46226],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[28832,27188],"length":1,"stats":{"Line":2},"fn_name":"play"},{"line":43,"address":[29246,28849,29021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[29150,29216,29038,29058],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"position=\u003c 9,  1\u003e velocity=\u003c 0,  2\u003e\",\n\t\"position=\u003c 7,  0\u003e velocity=\u003c-1,  0\u003e\",\n\t\"position=\u003c 3, -2\u003e velocity=\u003c-1,  1\u003e\",\n\t\"position=\u003c 6, 10\u003e velocity=\u003c-2, -1\u003e\",\n\t\"position=\u003c 2, -4\u003e velocity=\u003c 2,  2\u003e\",\n\t\"position=\u003c-6, 10\u003e velocity=\u003c 2, -2\u003e\",\n\t\"position=\u003c 1,  8\u003e velocity=\u003c 1, -1\u003e\",\n\t\"position=\u003c 1,  7\u003e velocity=\u003c 1,  0\u003e\",\n\t\"position=\u003c-3, 11\u003e velocity=\u003c 1, -2\u003e\",\n\t\"position=\u003c 7,  6\u003e velocity=\u003c-1, -1\u003e\",\n\t\"position=\u003c-2,  3\u003e velocity=\u003c 1,  0\u003e\",\n\t\"position=\u003c-4,  3\u003e velocity=\u003c 2,  0\u003e\",\n\t\"position=\u003c10, -3\u003e velocity=\u003c-1,  1\u003e\",\n\t\"position=\u003c 5, 11\u003e velocity=\u003c 1, -2\u003e\",\n\t\"position=\u003c 4,  7\u003e velocity=\u003c 0, -1\u003e\",\n\t\"position=\u003c 8, -2\u003e velocity=\u003c 0,  1\u003e\",\n\t\"position=\u003c15,  0\u003e velocity=\u003c-2,  0\u003e\",\n\t\"position=\u003c 1,  6\u003e velocity=\u003c 1,  0\u003e\",\n\t\"position=\u003c 8,  9\u003e velocity=\u003c 0, -1\u003e\",\n\t\"position=\u003c 3,  3\u003e velocity=\u003c-1,  1\u003e\",\n\t\"position=\u003c 0,  5\u003e velocity=\u003c 0, -1\u003e\",\n\t\"position=\u003c-2,  2\u003e velocity=\u003c 2,  0\u003e\",\n\t\"position=\u003c 5, -2\u003e velocity=\u003c 1,  2\u003e\",\n\t\"position=\u003c 1,  4\u003e velocity=\u003c 2,  1\u003e\",\n\t\"position=\u003c-2,  7\u003e velocity=\u003c 2, -2\u003e\",\n\t\"position=\u003c 3,  6\u003e velocity=\u003c-1, -1\u003e\",\n\t\"position=\u003c 5,  0\u003e velocity=\u003c 1,  0\u003e\",\n\t\"position=\u003c-6,  0\u003e velocity=\u003c 2,  0\u003e\",\n\t\"position=\u003c 5,  9\u003e velocity=\u003c 1, -2\u003e\",\n\t\"position=\u003c14,  7\u003e velocity=\u003c-2,  0\u003e\",\n\t\"position=\u003c-3,  6\u003e velocity=\u003c 2, -1\u003e\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"HI\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":40,"address":[43172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[58458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[58569,58796,58517,58479,58692,58626],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[43140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[58890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[58949,58911,59001,59058,59124,59228],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-10","input.rs"],"content":"use super::*;\nuse model::Point;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub points: Vec \u003cPoint\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { points, params } = [ params, @lines points ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[37732],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-10","lib.rs"],"content":"//! Advent of Code 2018: Day 10: The Stars Align\n//!\n//! [https://adventofcode.com/2018/day/10](https://adventofcode.com/2018/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_ocr as ocr;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"The Stars Align\";\n\tyear = 2018;\n\tday = 10;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-10","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Coord;\nuse model::Point;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet (message, _) = calc_result (input) ?;\n\tOk (message)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet (_, num_iters) = calc_result (input) ?;\n\tOk (num_iters)\n}\n\nfn calc_result (input: \u0026 Input) -\u003e GenResult \u003c(String, u32)\u003e {\n\tfn calc_range (points: \u0026 [Point]) -\u003e NumResult \u003c(Coord, Coord, Coord, Coord)\u003e {\n\t\tpoints.iter ().copied ().fold (\n\t\t\tOk ((Coord::MAX, Coord::MIN, Coord::MAX, Coord::MIN)),\n\t\t\t|state, point| state.and_then (|(min_y, max_y, min_x, max_x)| Ok ((\n\t\t\t\tcmp::min (min_y, point.pos.y),\n\t\t\t\tcmp::max (max_y, Coord::add_2 (point.pos.y, Coord::ONE) ?),\n\t\t\t\tcmp::min (min_x, point.pos.x),\n\t\t\t\tcmp::max (max_x, Coord::add_2 (point.pos.x, Coord::ONE) ?),\n\t\t\t))))\n\t}\n\tfn calc_size (points: \u0026 [Point]) -\u003e NumResult \u003c(Coord, Coord)\u003e {\n\t\tlet (min_y, max_y, min_x, max_x) = calc_range (points) ?;\n\t\tOk ((Coord::sub_2 (max_y, min_y) ?, Coord::sub_2 (max_x, min_x) ?))\n\t}\n\tlet mut points = input.points.clone ();\n\tlet mut points_temp = Vec::new ();\n\tlet (mut size_y, mut size_x) = calc_size (\u0026 points) ?;\n\tlet mut num_iters = 0_u32;\n\tlet mut step = 0x10000_u32;\n\tloop {\n\t\tpoints_temp.clear ();\n\t\tfor new_point in points.iter ().map (|\u0026 point| point.offset (step.pan_i32 ())) {\n\t\t\tpoints_temp.push (new_point ?);\n\t\t}\n\t\tlet (next_y, next_x) = calc_size (\u0026 points_temp) ?;\n\t\tif size_y \u003c next_y \u0026\u0026 size_x \u003c next_x {\n\t\t\tif step == 1 { break }\n\t\t\tif num_iters \u003e= step {\n\t\t\t\tpoints_temp.clear ();\n\t\t\t\tfor new_point in points.iter ()\n\t\t\t\t\t\t.map (|\u0026 point| point.offset (- step.pan_i32 ())) {\n\t\t\t\t\tpoints_temp.push (new_point ?);\n\t\t\t\t}\n\t\t\t\tmem::swap (\u0026 mut points, \u0026 mut points_temp);\n\t\t\t\t(size_y, size_x) = calc_size (\u0026 points) ?;\n\t\t\t\tnum_iters -= step;\n\t\t\t}\n\t\t\tstep \u003e\u003e= 1_u32;\n\t\t\tcontinue;\n\t\t}\n\t\tmem::swap (\u0026 mut points, \u0026 mut points_temp);\n\t\t(size_y, size_x) = (next_y, next_x);\n\t\tnum_iters = u32::add_2 (num_iters, step) ?;\n\t}\n\tlet message = ocr::read_dots (points.iter ()\n\t\t.map (|\u0026 point| (point.pos.y, point.pos.x))) ?;\n\tOk ((message, num_iters))\n}\n","traces":[{"line":8,"address":[59392],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":9,"address":[41587,41609,41648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[59472],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":14,"address":[42012,42042,42126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[59553],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[59616,60953],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":22,"address":[51264,51286,51200,51221,51433],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":23,"address":[51299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[56930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[51375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[51407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[60976],"length":1,"stats":{"Line":2},"fn_name":"calc_size"},{"line":30,"address":[61266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[61343,61288],"length":1,"stats":{"Line":4},"fn_name":null},{"line":33,"address":[59641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[59689,59702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[59729],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[35711,35639],"length":1,"stats":{"Line":8},"fn_name":null},{"line":43,"address":[60059,60101],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[60111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[60244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[60257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[60418,60436,60321,60507],"length":1,"stats":{"Line":8},"fn_name":null},{"line":49,"address":[49201,49112,49170],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[60574,60616],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[60623,60880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[60263,60660],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[60194],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[60779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[32274],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[60845],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":29,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-10","model.rs"],"content":"use super::*;\n\npub type Coord = i32;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Point {\n\tpub pos: Pos,\n\tpub vel: Pos,\n}\n\nstruct_parser_display! {\n\tPoint { pos: Pos { y: pos_y, x: pos_x }, vel: Pos { y: vel_y, x: vel_x } } = [\n\t\t\"position=\u003c\", @skip \"\", pos_x, \",\", @skip \" \", pos_y, \"\u003e \",\n\t\t\"velocity=\u003c\", @skip \"\", vel_x, \",\", @skip \" \", vel_y, \"\u003e\",\n\t]\n}\n\nimpl Point {\n\n\t#[ inline ]\n\tpub fn offset (self, offset: Coord) -\u003e NumResult \u003cSelf\u003e {\n\t\tOk (Self {\n\t\t\tpos: Pos {\n\t\t\t\ty: chk! (self.pos.y + self.vel.y * offset) ?,\n\t\t\t\tx: chk! (self.pos.x + self.vel.x * offset) ?,\n\t\t\t},\n\t\t\t.. self\n\t\t})\n\t}\n\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-11","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"33,45\", puzzle.part_one (\u0026 [ \"18\" ]));\n\tassert_eq_ok! (\"21,61\", puzzle.part_one (\u0026 [ \"42\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"90,269,16\", puzzle.part_two (\u0026 [ \"18\" ]));\n\tassert_eq_ok! (\"232,251,12\", puzzle.part_two (\u0026 [ \"42\" ]));\n}\n","traces":[{"line":6,"address":[40004],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[58689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[59039,58804,58976,58751,58710,59298],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[59102,59262,58914,59162,58824,58861],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[39636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[59377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[59398,59492,59664,59727,59986,59439],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[59950,59850,59512,59790,59602,59549],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-11","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub serial: i32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { serial, params } = [ params, serial ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub grid_size: i16 = (\"GRID_SIZE=\", 300, 2 .. ),\n\t}\n}\n","traces":[{"line":16,"address":[48284],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-11","lib.rs"],"content":"//! Advent of Code 2018: Day 11: Chronal Charge\n//!\n//! [https://adventofcode.com/2018/day/11](https://adventofcode.com/2018/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Chronal Charge\";\n\tyear = 2018;\n\tday = 11;\n\tparse = |input_lines| input::Input::parse_from_lines (input_lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n\npub mod model {\n\tuse super::*;\n\tpub type Coord = i16;\n\tpub type Grid = GridBuf \u003cVec \u003cPower\u003e, Pos, 2\u003e;\n\tpub type Power = i32;\n\tpub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\n}\n","traces":[{"line":19,"address":[82518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[82870],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-11","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Grid;\nuse model::Pos;\nuse model::Power;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet grid = gen_grid (input) ?;\n\tlet grid_ref = \u0026 grid;\n\tlet (pos, _) = (1 ..= input.params.grid_size - 2)\n\t\t.flat_map (|y_0| (1 ..= input.params.grid_size - 2)\n\t\t\t.map (move |x_0| {\n\t\t\t\tlet pos_0 = Pos { y: y_0, x: x_0 };\n\t\t\t\tlet mut power = 0_i32;\n\t\t\t\tfor y_1 in y_0 .. y_0 + 3 {\n\t\t\t\t\tfor x_1 in x_0 .. x_0 + 3 {\n\t\t\t\t\t\tlet pos_1 = Pos { y: y_1, x: x_1 };\n\t\t\t\t\t\tpower += grid_ref.get (pos_1).unwrap ();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(pos_0, power)\n\t\t\t}))\n\t\t.max_by_key (|\u0026 (_, power)| power)\n\t\t.unwrap ();\n\tOk (format! (\"{},{}\", pos.x, pos.y))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet base_grid = gen_grid (input) ?;\n\tlet base_grid_ref = \u0026 base_grid;\n\tlet mut horiz_grid = base_grid.clone ();\n\tlet mut vert_grid = base_grid.clone ();\n\tlet mut small_grid = base_grid.clone ();\n\tlet mut size = 1;\n\tlet mut best = None;\n\tloop {\n\t\tfor (pos, power) in small_grid.iter () {\n\t\t\tif let Some ((_, _, best_power)) = best {\n\t\t\t\tif best_power \u003c power {\n\t\t\t\t\tbest = Some ((pos, size, power));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbest = Some ((pos, size, power));\n\t\t\t}\n\t\t}\n\t\tif size == input.params.grid_size { break }\n\t\tsize += 1;\n\t\tlet grid_size = input.params.grid_size + 1 - size;\n\t\tlet horiz_grid_ref = \u0026 horiz_grid;\n\t\thoriz_grid = Grid::wrap_range (\n\t\t\t(size ..= input.params.grid_size)\n\t\t\t\t.flat_map (|y| (1 ..= grid_size)\n\t\t\t\t\t.map (move |x| horiz_grid_ref.get (Pos { y, x }).unwrap ()\n\t\t\t\t\t\t+ base_grid_ref.get (Pos { y, x: x + size - 1 }).unwrap ()))\n\t\t\t\t.collect (),\n\t\t\tPos::new (size, 1),\n\t\t\tPos::new (input.params.grid_size + 1, grid_size + 1)) ?;\n\t\tlet vert_grid_ref = \u0026 vert_grid;\n\t\tvert_grid = Grid::wrap_range (\n\t\t\t(1 ..= grid_size)\n\t\t\t\t.flat_map (|y| (size ..= input.params.grid_size)\n\t\t\t\t\t.map (move |x| vert_grid_ref.get (Pos { y, x }).unwrap ()\n\t\t\t\t\t\t+ base_grid_ref.get (Pos { y: y + size - 1, x }).unwrap ()))\n\t\t\t\t.collect (),\n\t\t\tPos::new (1, size),\n\t\t\tPos::new (grid_size + 1, input.params.grid_size + 1)) ?;\n\t\tlet horiz_grid_ref = \u0026 horiz_grid;\n\t\tlet vert_grid_ref = \u0026 vert_grid;\n\t\tlet small_grid_ref = \u0026 small_grid;\n\t\tsmall_grid = Grid::wrap_range (\n\t\t\t(1 ..= grid_size)\n\t\t\t\t.flat_map (|y| (1 ..= grid_size)\n\t\t\t\t\t.map (move |x| small_grid_ref.get (Pos { y, x }).unwrap ()\n\t\t\t\t\t\t+ horiz_grid_ref.get (Pos { y: y + size - 1, x }).unwrap ()\n\t\t\t\t\t\t+ vert_grid_ref.get (Pos { y, x: x + size - 1 }).unwrap ()))\n\t\t\t\t.collect (),\n\t\t\tPos::new (1, 1),\n\t\t\tPos::new (grid_size + 1, grid_size + 1)) ?;\n\t}\n\tif let Some ((pos, size, _)) = best {\n\t\tOk (format! (\"{},{},{}\", pos.x, pos.y, size))\n\t} else { Err (\"No solution found\".into ()) }\n}\n\nfn gen_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tif input.params.grid_size \u003c 3 { return Err (\"Grid must be at least 33\".into ()) }\n\tlet mut grid = Grid::new_range (\n\t\tPos::new (1, 1),\n\t\tPos::new (input.params.grid_size + 1, input.params.grid_size + 1)) ?;\n\tfor y in 1 ..= input.params.grid_size {\n\t\tfor x in 1 ..= input.params.grid_size {\n\t\t\tlet pos = Pos { y, x };\n\t\t\tgrid.set (pos, calc_power (input, pos).ok_or (\"Overflow\") ?);\n\t\t}\n\t}\n\tOk (grid)\n}\n\nfn calc_power (input: \u0026 Input, pos: Pos) -\u003e Option \u003cPower\u003e {\n\tif pos.x \u003c 1 || pos.x \u003e input.params.grid_size\n\t\t\t|| pos.y \u003c 1 || pos.y \u003e input.params.grid_size {\n\t\treturn None;\n\t}\n\tlet rack_id = pos.x.pan_i32 () + 10_i32;\n\tlet power_level = Power::mul_2 (\n\t\tPower::add_2 (\n\t\t\tPower::mul_2 (rack_id, pos.y.pan_i32 ()).ok () ?,\n\t\t\tinput.serial,\n\t\t).ok () ?,\n\t\track_id,\n\t).ok () ?;\n\tSome ((power_level % 1000_i32) / 100_i32 - 5_i32)\n}\n","traces":[{"line":9,"address":[41584,42339],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[42164,41607,41646],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[41700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[41708,41928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[31850,32061],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[31879],"length":1,"stats":{"Line":4},"fn_name":null},{"line":15,"address":[51886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[51923,52159,52030,51890],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[52045,52175,51939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[52132,52054],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[52192],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":27,"address":[41936,42031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[46678,42352],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":31,"address":[44819,42439,42385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[42496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[42738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[43060,42843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[43078],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[43168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[43191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[43210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[43243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[46506,43691,43496,43425],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[50403,50410],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[30984],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[52264,52313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[46597,43389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[43724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[43906,43977,44171,46467],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[43740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[31434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[31459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[52503,52453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[43865,46573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[44204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[44220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[44236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[46434,42768,44409,44488],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[44249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[50330,50323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[30491],"length":1,"stats":{"Line":5},"fn_name":null},{"line":76,"address":[52783,52643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[52815,52705,52755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[46549,46054,44390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[45140],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[45197,45361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[45381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[46688,47474],"length":1,"stats":{"Line":2},"fn_name":"gen_grid"},{"line":88,"address":[46713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[47399,46767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[46880,47134],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[46967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[46978,47023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[47140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[47488],"length":1,"stats":{"Line":2},"fn_name":"calc_power"},{"line":102,"address":[47498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[47591,47789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[47685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[47664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[47724],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":56,"coverable":60},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"CHECK_RULES=false\",\n\t\"initial state: #..#.#..##......###...###\",\n\t\"\",\n\t\"...## =\u003e #\",\n\t\"..#.. =\u003e #\",\n\t\".#... =\u003e #\",\n\t\".#.#. =\u003e #\",\n\t\".#.## =\u003e #\",\n\t\".##.. =\u003e #\",\n\t\".#### =\u003e #\",\n\t\"#.#.# =\u003e #\",\n\t\"#.### =\u003e #\",\n\t\"##.#. =\u003e #\",\n\t\"##.## =\u003e #\",\n\t\"###.. =\u003e #\",\n\t\"###.# =\u003e #\",\n\t\"####. =\u003e #\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"325\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"999999999374\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":26,"address":[42224,42228],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[65274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[65333,65508,65612,65385,65295,65442],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[42256,42260],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":33,"address":[65674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[66012,65842,65785,65733,65908,65695],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-12","input.rs"],"content":"use super::*;\nuse model::Pot;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub start: Vec \u003cPot\u003e,\n\tpub rules: Vec \u003cInputRule\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { start, rules, params } = [\n\t\tparams,\n\t\t\"initial state: \", @collect start, \"\\n\",\n\t\t\"\\n\",\n\t\t@lines rules,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct InputRule {\n\tpub from: [Pot; 5],\n\tpub to: Pot,\n}\n\nstruct_parser_display! {\n\tInputRule { from: [ from_0, from_1, from_2, from_3, from_4 ], to } = [\n\t\tfrom_0, from_1, from_2, from_3, from_4, \" =\u003e \", to,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub check_rules: bool = (\"CHECK_RULES=\", true, .. ),\n\t}\n}\n","traces":[{"line":12,"address":[75857],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-12","lib.rs"],"content":"//! Advent of Code 2018: Day 12: Subterranean Sustainability\n//!\n//! [https://adventofcode.com/2018/day/12](https://adventofcode.com/2018/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Subterranean Sustainability\";\n\tyear = 2018;\n\tday = 12;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-12","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Generator;\nuse model::Pot;\nuse model::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcalc_result (input, 20_u64)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcalc_result (input, 50_000_000_000_u64)\n}\n\nfn calc_result (input: \u0026 Input, num_iters: u64) -\u003e GenResult \u003ci64\u003e {\n\n\t// set up various things\n\n\tlet generator = Generator::build (input) ?;\n\tlet mut state = State::from (input.start.as_slice ());\n\tlet mut cache: HashMap \u003cVec \u003cu8\u003e, (u64, i64)\u003e = HashMap::new ();\n\n\t// loop for the specified number of iterations\n\n\tlet mut cur_iters = 0_u64;\n\twhile cur_iters \u003c num_iters {\n\t\tstate = generator.next (\u0026 state) ?;\n\t\tcur_iters += 1;\n\n\t\t// if we revisit the same state, even in a different position, take a short cut using some\n\t\t// simple maths\n\n\t\tif let Some (\u0026 (prev_iters, prev_start)) = cache.get (\u0026 state.data) {\n\t\t\tlet loop_iters = u64::sub_2 (cur_iters, prev_iters) ?;\n\t\t\tlet rem_iters = u64::sub_2 (num_iters, cur_iters) ?;\n\t\t\tif loop_iters \u003c= rem_iters {\n\t\t\t\tlet reps = u64::div_2 (rem_iters, loop_iters) ?;\n\t\t\t\tstate.start = i64::add_2 (state.start, Int::mul_2 (\n\t\t\t\t\tInt::sub_2 (state.start, prev_start) ?,\n\t\t\t\t\treps.pan_i64 (),\n\t\t\t\t) ?) ?;\n\t\t\t\tcur_iters = Int::add_2 (cur_iters, Int::mul_2 (reps, loop_iters) ?) ?;\n\t\t\t}\n\t\t}\n\n\t\t// update cache, abort if things are taking too long\n\n\t\tcache.entry (state.data.clone ()).or_insert ((cur_iters, state.start));\n\t\tif cache.len () == 200 { return Err (\"Giving up after 200 distinct states\".into ()) }\n\n\t}\n\n\t// calculate the answer from the final state and return\n\n\tOk (\n\t\tstate.iter ()\n\t\t\t.map (|(pos, pot)| {\n\t\t\t\tOk (match pot {\n\t\t\t\t\tPot::Empty =\u003e 0,\n\t\t\t\t\tPot::Plant =\u003e pos.to_i64 () ?,\n\t\t\t\t})\n\t\t\t})\n\t\t\t.fold (Ok (0), |sum, item| Int::add_2 (sum ?, item ?)) ?\n\t)\n\n}\n","traces":[{"line":9,"address":[53168],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":10,"address":[74755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[53200],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":14,"address":[75197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[55264,53232],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":21,"address":[53394,53273,53302],"length":1,"stats":{"Line":4},"fn_name":null},{"line":28,"address":[53820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[53932,53831,53893,55199],"length":1,"stats":{"Line":6},"fn_name":null},{"line":30,"address":[55141,53951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[54160,54181],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[54210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[54254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[54275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[54315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[54339,54496,54457],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[54362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[54582,54543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[54720,54609],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[54834,53802],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[55049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[59440],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[59441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[59475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[59520,59534],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"}],"covered":21,"coverable":24},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-12","model.rs"],"content":"//! Data representation and algorithms used to solve the puzzle\n\nuse super::*;\nuse input::Input;\n\nenum_decl_parser_display! {\n\t/// Simple enum to represent the state of a pot\n\t///\n\t/// This represents a plant pot, and determines whether it contains a [`Plant`] or is [`Empty`].\n\t///\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum Pot { Empty = [ \".\" ], Plant = [ \"#\" ] }\n}\n\nimpl Pot {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn as_usize (self) -\u003e usize {\n\t\tself.as_u8 ().pan_usize ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tconst fn as_u8 (self) -\u003e u8 {\n\t\tmatch self {\n\t\t\tSelf::Empty =\u003e 0,\n\t\t\tSelf::Plant =\u003e 1,\n\t\t}\n\t}\n\n}\n\n/// Efficiently apply rules to a [`State`]\n///\n/// This builds up a table to apply rules to eight pots at a time. It uses a table with `4096`\n/// entries. This is enough to check `12` bits at the same time, which is sufficient to determine\n/// the output of eight output bits at the same time. That includes the eight output bits\n/// themselves, plus two bits to either side.\n///\n/// The main methods are [`build`](Generator::build) to create a new `Generator` from the puzzle\n/// input, and `next` to apply the rules to a [`State`].\n///\n#[ derive (Clone, Debug) ]\npub struct Generator {\n\tbit_rules: [u8; 4096],\n}\n\nimpl Generator {\n\n\t/// Build a [`Generator`] from an [`Input`]\n\t///\n\t/// This analyses the rules and creates a generator which can apply them quickly to a\n\t/// [`State`].\n\t///\n\t/// This returns an error if there are duplicate rules, or if any rules are missing. The check\n\t/// for missing rules is skipped in the input parameter `check_rules` is set to `false`, in\n\t/// which case any missing rules are assumed to result in no plant. This is used for testing,\n\t/// where the example given only includes rules which result in a plant.\n\t///\n\tpub fn build (input: \u0026 Input) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet mut rules = [None; 32];\n\t\tfor input_rule in input.rules.iter () {\n\t\t\tlet rule_idx = input_rule.from.iter ()\n\t\t\t\t.fold (0, |state, \u0026 item| (state \u003c\u003c 1_u32) | item.as_usize ());\n\t\t\tlet rule = \u0026 mut rules [rule_idx];\n\t\t\tif rule.is_some () { return Err (\"Duplicated rule\".into ()) }\n\t\t\t* rule = Some (input_rule.to);\n\t\t}\n\t\tif input.params.check_rules \u0026\u0026 rules.iter ().any (Option::is_none) {\n\t\t\treturn Err (\"Missing rule\".into ());\n\t\t}\n\t\tlet rules = rules.map (|rule| rule.unwrap_or (Pot::Empty));\n\t\tlet bit_rules = array::from_fn (|mut idx| {\n\t\t\tlet mut val = 0_u8;\n\t\t\tfor _ in 0 .. 8_u32 {\n\t\t\t\tlet from = (idx \u0026 0xf80) \u003e\u003e 7_u32;\n\t\t\t\tidx \u003c\u003c= 1_u32;\n\t\t\t\tval = (val \u003c\u003c 1_u32) | rules [from].as_u8 ();\n\t\t\t}\n\t\t\tval\n\t\t});\n\t\tOk (Self { bit_rules })\n\t}\n\n\tpub fn next (\u0026 self, state: \u0026 State) -\u003e NumResult \u003cState\u003e {\n\t\tlet mut start = state.start - 2;\n\t\tlet mut data = Vec::new ();\n\t\tlet mut prev = 0_u8;\n\t\tfor \u0026 byte in state.data.iter ().chain (iter::once (\u0026 0)) {\n\t\t\tlet idx = (prev.pan_usize () \u0026 0x0f) \u003c\u003c 8_u32 | byte.pan_usize ();\n\t\t\tassert! (idx \u003c 4096);\n\t\t\tlet next = self.bit_rules [idx];\n\t\t\tif next == 0 \u0026\u0026 data.is_empty () {\n\t\t\t\tstart = Int::add_2 (start, 8) ?;\n\t\t\t} else {\n\t\t\t\tdata.push (next);\n\t\t\t}\n\t\t\tprev = byte;\n\t\t}\n\t\twhile data.last ().copied () == Some (0) { data.pop ().unwrap (); }\n\t\tOk (State { start, data })\n\t}\n\n}\n\n/// Represents all occupied plant pots at a specific point in time\n///\n/// This uses an array of bytes, with each bit representing a single plant pot. We only cover the\n/// range of occupied plant pots, so the first and last entries should never be `0`. The number of\n/// plant represented by the first bit in the first byte is also stored.\n///\n#[ derive (Default) ]\npub struct State {\n\tpub start: i64,\n\tpub data: Vec \u003cu8\u003e,\n}\n\nimpl State {\n\n\t/// Return an iterator over the numbers of all occupied pots, in order\n\t///\n\tpub fn iter (\u0026 self) -\u003e impl Iterator \u003cItem = (i64, Pot)\u003e + '_ {\n\t\tself.data.iter ().enumerate ()\n\t\t\t.flat_map (|(byte_idx, byte)| {\n\t\t\t\tlet start = self.start + (byte_idx.pan_i64 ()) * 8;\n\t\t\t\t[\n\t\t\t\t\t(start, if byte \u0026 0x80 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 1, if byte \u0026 0x40 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 2, if byte \u0026 0x20 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 3, if byte \u0026 0x10 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 4, if byte \u0026 0x08 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 5, if byte \u0026 0x04 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 6, if byte \u0026 0x02 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t\t(start + 7, if byte \u0026 0x01 != 0 { Pot::Plant } else { Pot::Empty }),\n\t\t\t\t]\n\t\t\t})\n\t}\n\n}\n\nimpl From \u003c\u0026 [Pot]\u003e for State {\n\n\t#[ inline ]\n\tfn from (pots: \u0026 [Pot]) -\u003e Self {\n\t\tlet data =\n\t\t\tpots.iter ().copied ()\n\t\t\t\t.chain (iter::repeat (Pot::Empty).take (7))\n\t\t\t\t.tuples::\u003c(_, _, _, _, _, _, _, _)\u003e ()\n\t\t\t\t.map (|(a, b, c, d, e, f, g, h)|\n\t\t\t\t\ta.as_u8 () \u003c\u003c 7_u32 | b.as_u8 () \u003c\u003c 6_u32 |\n\t\t\t\t\tc.as_u8 () \u003c\u003c 5_u32 | d.as_u8 () \u003c\u003c 4_u32 |\n\t\t\t\t\te.as_u8 () \u003c\u003c 3_u32 | f.as_u8 () \u003c\u003c 2_u32 |\n\t\t\t\t\tg.as_u8 () \u003c\u003c 1_u32 | h.as_u8 ())\n\t\t\t\t.collect ();\n\t\tSelf { start: 0, data }\n\t}\n\n}\n","traces":[{"line":11,"address":[33472],"length":1,"stats":{"Line":0},"fn_name":"clone"},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[31632],"length":1,"stats":{"Line":2},"fn_name":"build"},{"line":62,"address":[31663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[31972,31719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[46393,46336],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[32366,31910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[31926,32297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[31937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[32078,32008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[32311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[61216],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":76,"address":[47712,48704,47409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[48678,47382,47686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[68578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[31328,31340],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[32292,32277],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[33245,32448],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":87,"address":[32467,33161],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[32498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[32504,32842,32650],"length":1,"stats":{"Line":6},"fn_name":null},{"line":91,"address":[32745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[32756,33188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[32773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[32777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[32901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[32592],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[33007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[33112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[33264],"length":1,"stats":{"Line":0},"fn_name":"iter"},{"line":124,"address":[33274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[61280],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":126,"address":[61300,61361,61639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[61548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[61682,61380,61537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[61392,61698,61526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[61405,61518,61714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[61506,61730,61418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[61746,61431,61490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[61444,61762,61480],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[61457,61778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null}],"covered":40,"coverable":55},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\tr\"/-\u003e-\\        \",\n\tr\"|   |  /----\\\",\n\tr\"| /-+--+-\\  |\",\n\tr\"| | |  | v  |\",\n\tr\"\\-+-/  \\-+--/\",\n\tr\"  \\------/   \",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\tr\"/\u003e-\u003c\\  \",\n\tr\"|   |  \",\n\tr\"| /\u003c+-\\\",\n\tr\"| | | v\",\n\tr\"\\\u003e+\u003c/ |\",\n\tr\"  |   ^\",\n\tr\"  \\\u003c-\u003e/\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"7,3\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6,4\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":25,"address":[37536,37540],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[42906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[43244,42965,43017,43074,42927,43140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[37572,37568],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":32,"address":[43306],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[43327,43474,43417,43644,43540,43365],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-13","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-13","lib.rs"],"content":"//! Advent of Code 2018: Day 13: Mine Cart Madness\n//!\n//! [https://adventofcode.com/2018/day/13](https://adventofcode.com/2018/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Mine Cart Madness\";\n\tyear = 2018;\n\tday = 13;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":21,"address":[80442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[80858],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-13","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\nuse model::Tile;\nuse model::Turn;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut state = State::new (input);\n\tfor _ in 0_u32 .. 200 {\n\t\tstate.tick () ?;\n\t\tif let Some (\u0026 (pos, _, _, _, _)) =\n\t\t\tstate.carts.iter ()\n\t\t\t\t.find (|\u0026\u0026 (_, _, _, _, crashed)| crashed) {\n\t\t\treturn Ok (format! (\"{},{}\", pos.x, pos.y));\n\t\t}\n\t}\n\tErr (\"Giving up after 200 iters\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut state = State::new (input);\n\tfor _ in 0_u32 .. 20_000 {\n\t\tstate.tick () ?;\n\t\tlet mut carts_iter =\n\t\t\tstate.carts.iter ()\n\t\t\t\t.filter (|\u0026\u0026 (_, _, _, _, crashed)| ! crashed);\n\t\tif let Some (\u0026 (pos, _, _, _, _)) = carts_iter.next () {\n\t\t\tif carts_iter.next ().is_none () {\n\t\t\t\treturn Ok (format! (\"{},{}\", pos.x, pos.y));\n\t\t\t}\n\t\t} else { return Err (\"No solution found\".into ()) }\n\t}\n\tErr (\"Giving up after 20k iters\".into ())\n}\n\nstruct State {\n\tgrid: Grid,\n\tcarts: Vec \u003c(Pos, Dir, Turn, Tile, bool)\u003e,\n}\n\nimpl State {\n\tfn new (input: \u0026 Input) -\u003e Self {\n\t\tlet grid = input.grid.clone ();\n\t\tlet carts = grid.iter ()\n\t\t\t.filter_map (|(pos, item)|\n\t\t\t\tSome (match item {\n\t\t\t\t\tTile::CartUp =\u003e (pos, Dir::Up, Turn::Left, Tile::Vert, false),\n\t\t\t\t\tTile::CartDown =\u003e (pos, Dir::Down, Turn::Left, Tile::Vert, false),\n\t\t\t\t\tTile::CartLeft =\u003e (pos, Dir::Left, Turn::Left, Tile::Horiz, false),\n\t\t\t\t\tTile::CartRight =\u003e (pos, Dir::Right, Turn::Left, Tile::Horiz, false),\n\t\t\t\t\tTile::Empty | Tile::Vert | Tile::Horiz | Tile::Crossing | Tile::CornerFwd |\n\t\t\t\t\t\tTile::CornerBck =\u003e return None,\n\t\t\t\t})\n\t\t\t)\n\t\t\t.collect ();\n\t\tSelf { grid, carts }\n\t}\n\tfn tick (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.carts.sort_by_key (|\u0026 (pos, _, _, _, _)| pos);\n\t\tfor idx in 0 .. self.carts.len () {\n\t\t\tlet (prev_pos, prev_dir, prev_turn, prev_tile, prev_crashed) = self.carts [idx];\n\t\t\tif prev_crashed { continue }\n\t\t\tlet next_pos = prev_pos.try_add ((prev_dir, 1)) ?;\n\t\t\tlet next_tile = self.grid.get (next_pos).ok_or (\"Cart left grid\") ?;\n\t\t\tlet (next_dir, next_turn, next_crashed) = match (prev_dir, prev_turn, next_tile) {\n\t\t\t\t(Dir::Up, turn, Tile::Vert) =\u003e (Dir::Up, turn, false),\n\t\t\t\t(Dir::Down, turn, Tile::Vert) =\u003e (Dir::Down, turn, false),\n\t\t\t\t(Dir::Left, turn, Tile::Horiz) =\u003e (Dir::Left, turn, false),\n\t\t\t\t(Dir::Right, turn, Tile::Horiz) =\u003e (Dir::Right, turn, false),\n\t\t\t\t(Dir::Up, turn, Tile::CornerBck) =\u003e (Dir::Left, turn, false),\n\t\t\t\t(Dir::Up, turn, Tile::CornerFwd) =\u003e (Dir::Right, turn, false),\n\t\t\t\t(Dir::Down, turn, Tile::CornerBck) =\u003e (Dir::Right, turn, false),\n\t\t\t\t(Dir::Down, turn, Tile::CornerFwd) =\u003e (Dir::Left, turn, false),\n\t\t\t\t(Dir::Left, turn, Tile::CornerBck) =\u003e (Dir::Up, turn, false),\n\t\t\t\t(Dir::Left, turn, Tile::CornerFwd) =\u003e (Dir::Down, turn, false),\n\t\t\t\t(Dir::Right, turn, Tile::CornerBck) =\u003e (Dir::Down, turn, false),\n\t\t\t\t(Dir::Right, turn, Tile::CornerFwd) =\u003e (Dir::Up, turn, false),\n\t\t\t\t(dir, Turn::Left, Tile::Crossing) =\u003e (dir + Turn::Left, Turn::None, false),\n\t\t\t\t(dir, Turn::None, Tile::Crossing) =\u003e (dir + Turn::None, Turn::Right, false),\n\t\t\t\t(dir, Turn::Right, Tile::Crossing) =\u003e (dir + Turn::Right, Turn::Left, false),\n\t\t\t\t(dir, turn, tile) if tile.is_cart () =\u003e (dir, turn, true),\n\t\t\t\t_ =\u003e return Err (format! (\n\t\t\t\t\t\"Unable to tick: {prev_dir:?} {prev_turn:?} {next_tile:?}\").into ()),\n\t\t\t};\n\t\t\tself.carts [idx] = (next_pos, next_dir, next_turn, next_tile, next_crashed);\n\t\t\tself.grid.set (prev_pos, prev_tile);\n\t\t\tif next_crashed {\n\t\t\t\tlet \u0026 mut (_, _, _, other_tile, ref mut other_crashed) =\n\t\t\t\t\tself.carts.iter_mut ()\n\t\t\t\t\t\t.find (|\u0026\u0026 mut (other_pos, _, _, _, other_crashed)|\n\t\t\t\t\t\t\tother_pos == next_pos \u0026\u0026 ! other_crashed)\n\t\t\t\t\t\t.unwrap ();\n\t\t\t\t* other_crashed = true;\n\t\t\t\tself.grid.set (next_pos, other_tile);\n\t\t\t} else {\n\t\t\t\tself.grid.set (next_pos, match next_dir {\n\t\t\t\t\tDir::Up =\u003e Tile::CartUp,\n\t\t\t\t\tDir::Down =\u003e Tile::CartDown,\n\t\t\t\t\tDir::Left =\u003e Tile::CartLeft,\n\t\t\t\t\tDir::Right =\u003e Tile::CartRight,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n}\n","traces":[{"line":11,"address":[37936,38431],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[37963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[38028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[38030,38202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[38000,38228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[38135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[38346,38238],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[38149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[38448,39013],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":25,"address":[38475],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[38713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[38496,38744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[38614,38680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[38626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[38692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[38935,38817],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[38773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[38719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[39024,39285],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":50,"address":[42118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[32326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[42154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[42168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[42182],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[39296],"length":1,"stats":{"Line":2},"fn_name":"tick"},{"line":63,"address":[42832],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":64,"address":[39354,39453],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[39500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[39538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[39546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[39662,39603],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[40209,39682,39673],"length":1,"stats":{"Line":5},"fn_name":null},{"line":85,"address":[40255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[40409,40266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[39961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[40003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[40024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[40191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[42866,42848],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":95,"address":[40168],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[40195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[39414],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":36,"coverable":42},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-13","model.rs"],"content":"//! Data representation and algorithms used to solve the puzzle\n\nuse super::*;\n\npub type Coord = u16;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\npub type Turn = pos::Turn2d;\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Default) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tEmpty = [ \" \" ],\n\t\tVert = [ \"|\" ],\n\t\tHoriz = [ \"-\" ],\n\t\tCrossing = [ \"+\" ],\n\t\tCornerFwd = [ \"/\" ],\n\t\tCornerBck = [ \"\\\\\" ],\n\t\tCartUp = [ \"^\" ],\n\t\tCartDown = [ \"v\" ],\n\t\tCartLeft = [ \"\u003c\" ],\n\t\tCartRight = [ \"\u003e\" ],\n\t}\n\n}\n\nimpl Tile {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_cart (self) -\u003e bool {\n\t\tmatches! (self, Self::CartUp | Self::CartDown | Self::CartLeft | Self::CartRight)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_crossing (self) -\u003e bool {\n\t\tmatches! (self, Self::Crossing)\n\t}\n\n}\n","traces":[{"line":13,"address":[36906,35807,32264],"length":1,"stats":{"Line":8},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5158916779\", puzzle.part_one (\u0026 [\"9\"]));\n\tassert_eq_ok! (\"0124515891\", puzzle.part_one (\u0026 [\"5\"]));\n\tassert_eq_ok! (\"9251071085\", puzzle.part_one (\u0026 [\"18\"]));\n\tassert_eq_ok! (\"5941429882\", puzzle.part_one (\u0026 [\"2018\"]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"9\", puzzle.part_two (\u0026 [\"51589\"]));\n\tassert_eq_ok! (\"5\", puzzle.part_two (\u0026 [\"01245\"]));\n\tassert_eq_ok! (\"18\", puzzle.part_two (\u0026 [\"92510\"]));\n\tassert_eq_ok! (\"2018\", puzzle.part_two (\u0026 [\"59414\"]));\n}\n","traces":[{"line":6,"address":[30752,30756],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":7,"address":[33761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[33782,34291,33824,34949,33877,34354],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[33935,34480,34420,33897,34913,33988],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[34052,34546,34108,34606,34874,34008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[34128,34172,34228,34669,34729,34835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[30784,30788],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":16,"address":[35025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[35046,35088,35555,35141,35618,36213],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[36177,35684,35161,35744,35252,35199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[35316,35272,35372,35810,35870,36138],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[35933,35392,35436,35492,35993,36099],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-14","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub value: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { value, params } = [\n\t\tparams,\n\t\t@str value = (|ch| { ch.is_ascii_digit () }, 1 ..= 6),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_recipes: u32 = (\"MAX_RECIPES=\", 50_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":20,"address":[45693],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-14","lib.rs"],"content":"//! Advent of Code 2018: Day 14: Chocolate Charts\n//!\n//! [https://adventofcode.com/2018/day/14](https://adventofcode.com/2018/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Chocolate Charts\";\n\tyear = 2018;\n\tday = 14;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[42256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[42680],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-14","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet num_recipes: u32 = input.value.parse ().unwrap ();\n\tlet mut recipes: Vec \u003cu8\u003e = vec! [ 3, 7 ];\n\tlet mut idx_0 = 0_usize;\n\tlet mut idx_1 = 1_usize;\n\twhile recipes.len () \u003c num_recipes.pan_usize () + 10 {\n\t\tlet recipe_0 = recipes [idx_0];\n\t\tlet recipe_1 = recipes [idx_1];\n\t\tlet sum = recipe_0 + recipe_1;\n\t\tif sum \u003e= 10 {\n\t\t\trecipes.push (1);\n\t\t\trecipes.push (sum - 10);\n\t\t} else {\n\t\t\trecipes.push (sum);\n\t\t}\n\t\tidx_0 += recipe_0.pan_usize () + 1;\n\t\twhile recipes.len () \u003c= idx_0 { idx_0 -= recipes.len (); }\n\t\tidx_1 += recipe_1.pan_usize () + 1;\n\t\twhile recipes.len () \u003c= idx_1 { idx_1 -= recipes.len (); }\n\t}\n\tOk (\n\t\trecipes.iter ()\n\t\t\t.skip (num_recipes.pan_usize ())\n\t\t\t.take (10)\n\t\t\t.map (|\u0026 recipe| char::from_digit (recipe.pan_u32 (), 10).unwrap ())\n\t\t\t.collect ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet search: Vec \u003cu8\u003e =\n\t\tinput.value.chars ()\n\t\t\t.map (|ch| ch.to_digit (10).unwrap ().pan_u8 ())\n\t\t\t.collect ();\n\tlet mut recipes: Vec \u003cu8\u003e = vec! [ 3, 7 ];\n\tlet mut idx_0 = 0_usize;\n\tlet mut idx_1 = 1_usize;\n\tlet mut search_idx = 0;\n\tloop {\n\t\tlet recipe_0 = recipes [idx_0];\n\t\tlet recipe_1 = recipes [idx_1];\n\t\tlet sum = recipe_0 + recipe_1;\n\t\tif sum \u003e= 10 {\n\t\t\trecipes.push (1);\n\t\t\trecipes.push (sum - 10);\n\t\t} else {\n\t\t\trecipes.push (sum);\n\t\t}\n\t\tidx_0 += recipe_0.pan_usize () + 1;\n\t\twhile recipes.len () \u003c= idx_0 { idx_0 -= recipes.len (); }\n\t\tidx_1 += recipe_1.pan_usize () + 1;\n\t\twhile recipes.len () \u003c= idx_1 { idx_1 -= recipes.len (); }\n\t\twhile search_idx + search.len () \u003c= recipes.len () {\n\t\t\tif \u0026 recipes [search_idx .. search_idx + search.len ()] == search.as_slice () {\n\t\t\t\treturn Ok (search_idx.pan_u32 ());\n\t\t\t}\n\t\t\tif search_idx == input.params.max_recipes.pan_usize () {\n\t\t\t\treturn Err (\"Giving up after reaching recipe limit\".into ());\n\t\t\t}\n\t\t\tsearch_idx += 1;\n\t\t}\n\t}\n}\n","traces":[{"line":7,"address":[46608,47653],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[46647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[46715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[46831,46768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[46850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[46873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[46895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[46911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[46917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[46931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[47004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[47024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[47107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[47136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[47184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[48812,47664],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":39,"address":[32418,32149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[47759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[47827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[47836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[47858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[47870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[47875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[47889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[47960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[47984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[48082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[48112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[48341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[48160,48254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[48460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[48319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[48472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[48328],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":33,"coverable":34},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#.G...#\",\n\t\"#...EG#\",\n\t\"#.#.#G#\",\n\t\"#..G#E#\",\n\t\"#.....#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#G..#E#\",\n\t\"#E#E.E#\",\n\t\"#G.##.#\",\n\t\"#...#E#\",\n\t\"#...E.#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#E..EG#\",\n\t\"#.#G.E#\",\n\t\"#E.##E#\",\n\t\"#G..#.#\",\n\t\"#..E#.#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_3: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#E.G#.#\",\n\t\"#.#G..#\",\n\t\"#G.#.G#\",\n\t\"#G..#.#\",\n\t\"#...E.#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_4: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#.E...#\",\n\t\"#.#..G#\",\n\t\"#.###.#\",\n\t\"#E#G#G#\",\n\t\"#...#G#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_5: \u0026 [\u0026 str] = \u0026 [\n\t\"#########\",\n\t\"#G......#\",\n\t\"#.E.#...#\",\n\t\"#..##..G#\",\n\t\"#...##..#\",\n\t\"#...#...#\",\n\t\"#.G...G.#\",\n\t\"#.....G.#\",\n\t\"#########\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"27730\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"36334\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"39514\", puzzle.part_one (EXAMPLE_2));\n\tassert_eq_ok! (\"27755\", puzzle.part_one (EXAMPLE_3));\n\tassert_eq_ok! (\"28944\", puzzle.part_one (EXAMPLE_4));\n\tassert_eq_ok! (\"18740\", puzzle.part_one (EXAMPLE_5));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4988\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"29064\", puzzle.part_two (EXAMPLE_1));\n\tassert_eq_ok! (\"31284\", puzzle.part_two (EXAMPLE_2));\n\tassert_eq_ok! (\"3478\", puzzle.part_two (EXAMPLE_3));\n\tassert_eq_ok! (\"6474\", puzzle.part_two (EXAMPLE_4));\n\tassert_eq_ok! (\"1140\", puzzle.part_two (EXAMPLE_5));\n}\n","traces":[{"line":68,"address":[41460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[85057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[85890,86815,85078,85827,85173,85120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[85193,85956,85284,85231,86016,86779],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[86740,86142,85348,86082,85404,85304],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[85524,86268,86701,85424,85468,86208],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[86334,86394,86662,85644,85588,85544],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[86517,86457,86623,85708,85764,85664],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[41492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[86897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[87667,88655,87013,86960,86918,87730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[87033,87124,88619,87796,87856,87071],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[87244,87144,87188,87922,88580,87982],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[88048,87308,88108,88541,87264,87364],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[87484,87384,87428,88234,88174,88502],"length":1,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[87548,87504,88297,88357,87604,88463],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","lib.rs"],"content":"//! Advent of Code 2018: Day 15: Beverage Bandits\n//!\n//! [https://adventofcode.com/2018/day/15](https://adventofcode.com/2018/day/15)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod state;\n\npuzzle_info! {\n\tname = \"Beverage Bandits\";\n\tyear = 2018;\n\tday = 15;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":22,"address":[78791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[79143],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Tile;\nuse state::State;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet state = State::build (input.grid.clone (), 3, 3) ?;\n\tlet state = calc_result (state) ?;\n\tif state.winner ().is_none () { return Err (\"Stalemate\".into ()) }\n\tOk (state.score ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet num_elves = input.grid.values ().filter (|\u0026 tile| tile == Tile::Elf).count ();\n\tlet mut lose = 0;\n\tlet mut win = 200;\n\tlet mut win_score = None;\n\twhile win - lose \u003e 1 {\n\t\tlet elf_attack = if 40 \u003c win - lose { lose + 20 } else { (lose + win) / 2 };\n\t\tlet state = State::build (input.grid.clone (), 3, elf_attack) ?;\n\t\tlet state = calc_result (state) ?;\n\t\tlet winner = some_or! (state.winner (), return Err (\"Stalemate\".into ()));\n\t\tif winner == Tile::Elf \u0026\u0026 state.units ().len () == num_elves {\n\t\t\twin_score = Some (state.score ());\n\t\t\twin = elf_attack;\n\t\t} else {\n\t\t\tlose = elf_attack;\n\t\t}\n\t}\n\tOk (win_score.ok_or (\"No solution found\") ?)\n}\n\nfn calc_result (mut state: State) -\u003e GenResult \u003cState\u003e {\n\twhile ! state.tick () {\n\t\tif state.num_rounds () == 200 {\n\t\t\treturn Err (\"Giving up after 200 rounds\".into ());\n\t\t}\n\t}\n\tOk (state)\n}\n","traces":[{"line":9,"address":[50054,48768],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[49011,48831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[49651,49169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[49855,49848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[49934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[51743,50064],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[51760,51766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[51602,50254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[50274,51629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[50539,51439,50370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[51456,50677,51149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[51277,50224,51504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[51308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[51420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[50020,51712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[50816,49312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[49324,50828],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[50841,49337],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[50880,49378],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","model.rs"],"content":"use super::*;\n\npub type Coord = u8;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type SeenGrid = GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tOpen = [ \".\" ],\n\t\tCavern = [ \"#\" ],\n\t\tGoblin = [ \"G\" ],\n\t\tElf = [ \"E\" ],\n\t}\n\n}\n\nimpl Tile {\n\n\t#[ must_use ]\n\tpub fn enemy (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::Goblin =\u003e Self::Elf,\n\t\t\tSelf::Elf =\u003e Self::Goblin,\n\t\t\tSelf::Open | Self::Cavern =\u003e panic! (),\n\t\t}\n\t}\n\n}\n","traces":[{"line":11,"address":[46638,50164,40503,47241,41566,50156,51760,47250],"length":1,"stats":{"Line":20},"fn_name":null},{"line":25,"address":[103072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[46543,45312],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[45322,46566],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-15","state.rs"],"content":"use super::*;\n\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\nuse model::SeenGrid;\nuse model::Tile;\n\npub struct State {\n\tgrid: Grid,\n\tgoblin_attack: u16,\n\telf_attack: u16,\n\tunits: Vec \u003c(Pos, u16)\u003e,\n\tnum_rounds: u32,\n\tfrozen: bool,\n\twalk_queue: VecDeque \u003c(u32, Pos, Pos)\u003e,\n\tseen: SeenGrid,\n}\n\nimpl State {\n\n\tpub fn build (grid: Grid, goblin_attack: u16, elf_attack: u16) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet units: Vec \u003c(Pos, u16)\u003e = grid.iter ()\n\t\t\t.filter_map (|(pos, tile)| matches! (tile, Tile::Goblin | Tile::Elf)\n\t\t\t\t.then_some ((pos, 200)))\n\t\t\t.collect ();\n\t\tif units.is_empty () { return Err (\"No combatants found\".into ()) }\n\t\tif units.len () \u003e 50 { return Err (\"More than 50 combatants\".into ()) }\n\t\tlet seen = SeenGrid::new_range (grid.start (), grid.end ()) ?;\n\t\tOk (Self {\n\t\t\tgrid,\n\t\t\tgoblin_attack,\n\t\t\telf_attack,\n\t\t\tunits,\n\t\t\tnum_rounds: 0,\n\t\t\tfrozen: false,\n\t\t\twalk_queue: VecDeque::new (),\n\t\t\tseen,\n\t\t})\n\t}\n\n\tpub fn tick (\u0026 mut self) -\u003e bool {\n\t\tlet mut unit_idx = 0;\n\t\tlet mut moved = false;\n\t\tlet mut attacked = false;\n\t\tlet num_before = self.units.len ();\n\t\twhile unit_idx \u003c self.units.len () {\n\t\t\tif self.units.iter ()\n\t\t\t\t\t.map (|\u0026 (unit_pos, _)| self.grid.get (unit_pos).unwrap ())\n\t\t\t\t\t.all_equal () {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ! self.frozen \u0026\u0026 self.unit_move (unit_idx) { moved = true; }\n\t\t\tif self.unit_attack (\u0026 mut unit_idx) { attacked = true; }\n\t\t\tif num_before != self.units.len () { self.frozen = false; }\n\t\t\tunit_idx += 1;\n\t\t}\n\t\tif ! self.frozen \u0026\u0026 ! moved \u0026\u0026 num_before == self.units.len () { self.frozen = true; }\n\t\tself.units.sort_by_key (|\u0026 (unit_pos, _)| unit_pos);\n\t\tself.num_rounds += 1;\n\t\t! (moved || attacked)\n\t}\n\n\tfn unit_move (\u0026 mut self, unit_idx: usize) -\u003e bool {\n\n\t\tlet (unit_pos, unit_hp) = self.units [unit_idx];\n\t\tlet unit_tile = self.grid.get (unit_pos).unwrap ();\n\n\t\t// don't move if we are already next to an enemy\n\n\t\tif unit_pos.adjacent_4 ().iter ().copied ()\n\t\t\t\t.any (|adj_pos| self.grid.get (adj_pos) == Some (unit_tile.enemy ())) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// start path finding, breadth first\n\n\t\tself.walk_queue.clear ();\n\t\tfor step_dir in [ Dir::Up, Dir::Left, Dir::Right, Dir::Down ].iter ().copied () {\n\t\t\tlet step_pos = ok_or! (unit_pos.try_add ((step_dir, 1)), continue);\n\t\t\tif self.grid.get (step_pos) != Some (Tile::Open) { continue }\n\t\t\tself.walk_queue.push_back ((1, step_pos, step_pos));\n\t\t}\n\t\tself.seen.reset ();\n\t\tlet mut found: Option \u003c(u32, Pos, Pos)\u003e = None;\n\t\twhile let Some ((dist, walk_pos, step_pos)) = self.walk_queue.pop_front () {\n\n\t\t\t// abort if we found a route with a shorter distance already\n\n\t\t\tif found.map_or (false, |(found_dist, _, _)| found_dist \u003c dist) { break }\n\n\t\t\t// abort if this path crossing another\n\n\t\t\tif self.seen.get (walk_pos).unwrap_or (true) { continue }\n\t\t\tself.seen.set (walk_pos, true);\n\n\t\t\t// iterate next steps\n\n\t\t\tfor adj_pos in walk_pos.adjacent_4 ().iter ().copied () {\n\t\t\t\tlet adj_tile = some_or! (self.grid.get (adj_pos), continue);\n\n\t\t\t\t// if there is an enemy and this route is better then record it\n\n\t\t\t\tif adj_tile == unit_tile.enemy ()\n\t\t\t\t\t\t\u0026\u0026 found.map_or (true, |found| (dist, walk_pos, step_pos) \u003c found) {\n\t\t\t\t\tfound = Some ((dist, walk_pos, step_pos));\n\t\t\t\t}\n\n\t\t\t\t// if we can step then iterate paths with a step in that direction\n\n\t\t\t\tif adj_tile == Tile::Open {\n\t\t\t\t\tself.walk_queue.push_back ((dist + 1, adj_pos, step_pos));\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet (_, _, step_pos) = some_or! (found, return false);\n\n\t\t// move the unit\n\n\t\tself.grid.set (unit_pos, Tile::Open);\n\t\tself.grid.set (step_pos, unit_tile);\n\t\tself.units [unit_idx] = (step_pos, unit_hp);\n\n\t\ttrue\n\n\t}\n\n\tfn unit_attack (\u0026 mut self, unit_idx: \u0026 mut usize) -\u003e bool{\n\t\tlet (unit_pos, _) = self.units [* unit_idx];\n\t\tlet unit_tile = self.grid.get (unit_pos).unwrap ();\n\t\tlet mut found: Option \u003c(Pos, u16)\u003e = None;\n\t\tfor enemy_dir in [ Dir::Up, Dir::Left, Dir::Right, Dir::Down ].iter ().copied () {\n\t\t\tlet enemy_pos = ok_or! (unit_pos.try_add ((enemy_dir, 1)), continue);\n\t\t\tlet enemy_tile = some_or! (self.grid.get (enemy_pos), continue);\n\t\t\tif enemy_tile != unit_tile.enemy () { continue }\n\t\t\tlet enemy_hp = self.units.iter ().copied ()\n\t\t\t\t.find (|\u0026 (other_pos, _)| other_pos == enemy_pos)\n\t\t\t\t.map (|(_, other_hp)| other_hp)\n\t\t\t\t.unwrap ();\n\t\t\tif found.map_or (true, |(_, found_hp)| enemy_hp \u003c found_hp) {\n\t\t\t\tfound = Some ((enemy_pos, enemy_hp));\n\t\t\t}\n\t\t}\n\t\tlet (enemy_pos, _) = some_or! (found, return false);\n\t\tlet enemy_idx =\n\t\t\tself.units.iter ()\n\t\t\t\t.position (|\u0026 (other_pos, _)| other_pos == enemy_pos)\n\t\t\t\t.unwrap ();\n\t\tlet \u0026 mut (_, ref mut enemy_hp) = \u0026 mut self.units [enemy_idx];\n\t\tlet attack = match unit_tile {\n\t\t\tTile::Goblin =\u003e self.goblin_attack,\n\t\t\tTile::Elf =\u003e self.elf_attack,\n\t\t\tTile::Open | Tile::Cavern =\u003e unreachable! (),\n\t\t};\n\t\t* enemy_hp = cmp::max (* enemy_hp, attack) - attack;\n\t\tif * enemy_hp == 0 {\n\t\t\tself.grid.set (enemy_pos, Tile::Open);\n\t\t\tself.units.remove (enemy_idx);\n\t\t\tif enemy_idx \u003c * unit_idx { * unit_idx -= 1; }\n\t\t}\n\t\ttrue\n\t}\n\n\t#[ must_use ]\n\tpub fn score (\u0026 self) -\u003e u32 {\n\t\tlet remain_hp = self.units.iter ()\n\t\t\t.map (|\u0026 (_, unit_hp)| unit_hp.pan_u32 ())\n\t\t\t.sum::\u003cu32\u003e ();\n\t\tself.num_rounds * remain_hp\n\t}\n\n\t#[ must_use ]\n\tpub fn winner (\u0026 self) -\u003e Option \u003cTile\u003e {\n\t\tlet unit_tile = self.grid.get (self.units [0].0).unwrap ();\n\t\tself.units.iter ().copied ()\n\t\t\t.map (|(unit_pos, _)| self.grid.get (unit_pos).unwrap ())\n\t\t\t.all (|other_tile| other_tile == unit_tile)\n\t\t\t.then_some (unit_tile)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn units (\u0026 self) -\u003e \u0026 [(Pos, u16)] {\n\t\t\u0026 self.units\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn num_rounds (\u0026 self) -\u003e u32 {\n\t\tself.num_rounds\n\t}\n\n}\n","traces":[{"line":22,"address":[68704,69644],"length":1,"stats":{"Line":1},"fn_name":"build"},{"line":24,"address":[54080],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}\u003c(aoc_pos::dim_2::yx::PosYX\u003cu8\u003e, aoc_2018_day_15::model::Tile), (aoc_pos::dim_2::yx::PosYX\u003cu8\u003e, u16), \u0026mut aoc_2018_day_15::state::{impl#0}::build::{closure_env#0}\u003e"},{"line":27,"address":[68927,68899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[68901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[69003,69188,69070],"length":1,"stats":{"Line":4},"fn_name":null},{"line":30,"address":[69357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[69109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[69130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[69329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[69664],"length":1,"stats":{"Line":2},"fn_name":"tick"},{"line":43,"address":[69681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[69903,69694],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[69763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[56439,54232,56564],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[69781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[69834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[69863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[70058,69879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[69912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[40112,38345,39486,39632,39519,38276,39671,38455,40133,38375,38244,38425,39967,39936],"length":1,"stats":{"Line":8},"fn_name":null},{"line":60,"address":[70013,70085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[70112,71833],"length":1,"stats":{"Line":2},"fn_name":"unit_move"},{"line":66,"address":[70172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[70163,70199,70215],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[70294,70251,70229],"length":1,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[71801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[70491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[70522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[70571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[70591],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[70672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[70881,70937],"length":1,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[70919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[70800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[70961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[70985,71118,71818],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[71126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[71160,71294,71479,71185,71285],"length":1,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[103377,103296,103397,103373],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":106,"address":[71298],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[71346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[71352,71693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[71528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[71548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[71567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[71617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[71856],"length":1,"stats":{"Line":2},"fn_name":"unit_attack"},{"line":132,"address":[71876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[71912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[72032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[72058],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[72114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[71999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[72290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[46674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[103440,103445],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":143,"address":[72315],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[72329],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[72358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[72543],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[103482,103492,103472],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":153,"address":[72595],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[72617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[72611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[72855,72621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[72653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[72655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[72750,72882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[73008],"length":1,"stats":{"Line":0},"fn_name":"score"},{"line":170,"address":[103504],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":172,"address":[49976,49925,51661,51354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[73104],"length":1,"stats":{"Line":2},"fn_name":"winner"},{"line":177,"address":[73165,73144],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[46623,40491],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[46635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":68,"coverable":79},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-16","input.rs"],"content":"use super::*;\nuse model::Instr;\nuse model::Sample;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub samples: Vec \u003cSample\u003e,\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { samples, instrs, params } = [\n\t\tparams,\n\t\t@delim \"\\n\\n\" samples,\n\t\t\"\\n\\n\\n\\n\",\n\t\t@lines instrs,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-16","lib.rs"],"content":"//! Advent of Code 2018: Day 16: Chronal Classification\n//!\n//! [https://adventofcode.com/2018/day/16](https://adventofcode.com/2018/day/16)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2018_cpu as cpu;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Chronal Classification\";\n\tyear = 2018;\n\tday = 16;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-16","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Opcode;\nuse model::Regs;\nuse model::Sample;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut count = 0_u32;\n\tfor sample in input.samples.iter () {\n\t\tlet mut num_matches = 0_u32;\n\t\tfor opcode in Opcode::VARIANTS.iter ().copied () {\n\t\t\tif ! test_sample (opcode, sample) { continue }\n\t\t\tnum_matches += 1;\n\t\t}\n\t\tif num_matches \u003e= 3 { count += 1; }\n\t}\n\tOk (count)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tfor sample in input.samples.iter () {\n\t\tif ! (0 .. 16).contains (\u0026 sample.instr.op) {\n\t\t\treturn Err (format! (\"Opcode number out of range: {}\", sample.instr.op).into ());\n\t\t}\n\t}\n\tfor instr in input.instrs.iter () {\n\t\tif ! (0 .. 16).contains (\u0026 instr.op) {\n\t\t\treturn Err (format! (\"Opcode number out of range: {}\", instr.op).into ());\n\t\t}\n\t}\n\n\t// gather data from the samples\n\n\tlet mut opcode_to_num_arr = [[true; 16]; 16];\n\tlet mut num_to_opcode_arr = [[true; 16]; 16];\n\tfor sample in input.samples.iter () {\n\t\tfor opcode in Opcode::VARIANTS.iter ().copied () {\n\t\t\tif ! test_sample (opcode, sample) {\n\t\t\t\topcode_to_num_arr [opcode.idx ()] [sample.instr.op.pan_usize ()] = false;\n\t\t\t\tnum_to_opcode_arr [sample.instr.op.pan_usize ()] [opcode.idx ()] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the data to get mapping from num to opcode\n\n\tlet mut num_to_opcode = [None; 16];\n\tloop {\n\t\tlet mut progress = false;\n\t\tfor match_opcode in Opcode::VARIANTS.iter ().copied () {\n\t\t\tif let Ok (match_num) =\n\t\t\t\topcode_to_num_arr [match_opcode.idx ()]\n\t\t\t\t\t.iter ().copied ()\n\t\t\t\t\t.enumerate ()\n\t\t\t\t\t.filter (|\u0026 (_, val)| val)\n\t\t\t\t\t.map (|(idx, _)| idx)\n\t\t\t\t\t.exactly_one () {\n\t\t\t\tfor opcode in Opcode::VARIANTS.iter ().copied () {\n\t\t\t\t\t#[ allow (clippy::needless_range_loop) ]\n\t\t\t\t\tfor num in 0_usize .. 16 {\n\t\t\t\t\t\tif opcode == match_opcode || num == match_num {\n\t\t\t\t\t\t\topcode_to_num_arr [opcode.idx ()] [num] = false;\n\t\t\t\t\t\t\tnum_to_opcode_arr [num] [opcode.idx ()] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnum_to_opcode [match_num] = Some (match_opcode);\n\t\t\t\tprogress = true;\n\t\t\t}\n\t\t}\n\t\tif ! progress { break }\n\t}\n\tif num_to_opcode.iter ().any (Option::is_none) {\n\t\treturn Err (\"Failed to decode all instructions\".into ());\n\t}\n\tlet num_to_opcode = num_to_opcode.map (Option::unwrap);\n\n\t// run the specified program\n\n\tlet mut regs = Regs::default ();\n\tfor instr in input.instrs.iter () {\n\t\tlet opcode = num_to_opcode [instr.op.pan_usize ()];\n\t\tregs = opcode.apply (instr.arg_a, instr.arg_b, instr.arg_c, regs) ?;\n\t}\n\n\t// return the value from register zero\n\n\tOk (regs [0].pan_u32 ())\n\n}\n\nfn test_sample (opcode: Opcode, sample: \u0026 Sample) -\u003e bool {\n\tlet instr = sample.instr;\n\tlet result = ok_or! (\n\t\topcode.apply (instr.arg_a, instr.arg_b, instr.arg_c, sample.before),\n\t\treturn false);\n\tresult == sample.after\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-16","model.rs"],"content":"use super::*;\n\npub type Regs = cpu::Regs \u003cVal, 4\u003e;\npub type Val = u16;\n\npub use cpu::ArgType;\npub use cpu::Op;\npub use cpu::Opcode;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Instr {\n\tpub op: Val,\n\tpub arg_a: Val,\n\tpub arg_b: Val,\n\tpub arg_c: Val,\n}\n\nstruct_parser_display! (Instr { op, arg_a, arg_b, arg_c } = [\n\top, \" \", arg_a, \" \", arg_b, \" \", arg_c,\n]);\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Sample {\n\tpub before: Regs,\n\tpub instr: Instr,\n\tpub after: Regs,\n}\n\nstruct_parser_display! (Sample { before, instr, after } = [\n\t\"Before: \", before, \"\\n\", instr, \"\\nAfter:  \", after,\n]);\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-17","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"x=495, y=2..7\",\n\t\"y=7, x=495..501\",\n\t\"x=501, y=3..7\",\n\t\"x=498, y=2..4\",\n\t\"x=506, y=1..2\",\n\t\"x=498, y=10..13\",\n\t\"x=504, y=10..13\",\n\t\"y=13, x=498..504\",\n];\n\n#[ test ]\nfn test_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"57\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn test_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"29\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":17,"address":[43648,40884,44039],"length":1,"stats":{"Line":2},"fn_name":"test_one"},{"line":18,"address":[43658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[43996,43892,43769,43717,43826,43679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[40852,44048,44439],"length":1,"stats":{"Line":2},"fn_name":"test_two"},{"line":24,"address":[44058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[44117,44079,44226,44292,44169,44396],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-17","input.rs"],"content":"use super::*;\n\nuse model::ClayRange;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub clay_ranges: Vec \u003cClayRange\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { clay_ranges, params } = [ params, @lines clay_ranges ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[39739],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-17","lib.rs"],"content":"//! Advent of Code 2018: Day 17: Reservoir Research\n//!\n//! [https://adventofcode.com/2018/day/17](https://adventofcode.com/2018/day/17)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Reservoir Research\";\n\tyear = 2018;\n\tday = 17;\n\tparse = |input_lines| input::Input::parse_from_lines (input_lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":21,"address":[61176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[61496],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-17","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::ClayRange;\nuse model::Coord;\nuse model::Grid;\nuse model::Pos;\nuse model::Tile::{ self, DrySand, WetSand, Clay, Water };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = calc_grid (input) ?;\n\tOk (count_tiles (\u0026 grid, |tile| matches! (tile, WetSand | Water)))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = calc_grid (input) ?;\n\tOk (count_tiles (\u0026 grid, |tile| matches! (tile, Water)))\n}\n\nfn count_tiles (grid: \u0026 Grid, pred_fn: fn (Tile) -\u003e bool) -\u003e u32 {\n\tlet mut num = 0_u32;\n\tfor y in grid.first_key ().y ..= grid.last_key ().y {\n\t\tif num == 0 \u0026\u0026 ! (grid.first_key ().x ..= grid.last_key ().x)\n\t\t\t\t.any (|x| grid.get (Pos { y, x }).unwrap () == Clay) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor x in grid.first_key ().x ..= grid.last_key ().x {\n\t\t\tlet pos = Pos { y, x };\n\t\t\tif pred_fn (grid.get (pos).unwrap ()) { num += 1; }\n\t\t}\n\t}\n\tnum\n}\n\nfn calc_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\n\tif input.clay_ranges.is_empty () {\n\t\treturn Err (\"No clay ranges specified\".into ());\n\t}\n\n\tif ! input.clay_ranges.iter ().copied ().all (ClayRange::valid) {\n\t\treturn Err (\"Invalid ranges specified\".into ());\n\t}\n\n\tif input.clay_ranges.iter ().any (|clay_range|\n\t\t! (1 ..= 2000).contains (clay_range.y ().start ())\n\t\t\t|| ! (1 ..= 2000).contains (clay_range.y ().end ())\n\t\t\t|| ! (1 ..= 1000).contains (clay_range.x ().start ())\n\t\t\t|| ! (1 ..= 1000).contains (clay_range.x ().end ())) {\n\t\treturn Err (\"Clay ranges must be in range 1 to 1000 for x, 1 to 2000 for y\".into ());\n\t}\n\n\t// create empty grid\n\n\ttype Ranges = (RangeInclusive \u003cCoord\u003e, RangeInclusive \u003cCoord\u003e);\n\n\tlet merge_ranges = |(left_y, left_x): Ranges, (right_y, right_x): Ranges| {\n\t\tlet y_start = cmp::min (* left_y.start (), * right_y.start ());\n\t\tlet y_end = cmp::max (* left_y.end (), * right_y.end ());\n\t\tlet x_start = cmp::min (* left_x.start (), * right_x.start ());\n\t\tlet x_end = cmp::max (* left_x.end (), * right_x.end ());\n\t\t(y_start ..= y_end, x_start ..= x_end)\n\t};\n\n\tlet (clay_range_y, clay_range_x) =\n\t\tinput.clay_ranges.iter ().copied ()\n\t\t\t.map (ClayRange::ranges)\n\t\t\t.reduce (merge_ranges)\n\t\t\t.unwrap ();\n\n\tlet (grid_range_y, grid_range_x) =\n\t\tmerge_ranges (\n\t\t\t(clay_range_y, clay_range_x.start () - 1 ..= clay_range_x.end () + 1),\n\t\t\t(0 ..= 0, 500 ..= 500));\n\n\tlet mut grid = Grid::new_range (\n\t\tPos::new (* grid_range_y.start (), * grid_range_x.start ()),\n\t\tPos::new (* grid_range_y.end (), * grid_range_x.end ()) + Pos::new (1, 1)) ?;\n\n\t// place clay\n\n\tfor range in input.clay_ranges.iter () {\n\t\tfor y in range.y () {\n\t\t\tfor x in range.x () {\n\t\t\t\tlet pos = Pos { y, x };\n\t\t\t\tgrid.set (pos, Clay);\n\t\t\t}\n\t\t}\n\t}\n\n\t// iterate over points where water is flowing\n\n\tlet mut queue = Vec::with_capacity (grid_range_y.len () * 2);\n\tqueue.push (Pos { y: 0, x: 500 });\n\twhile let Some (pos) = queue.pop () {\n\t\tlet tile_here = grid.get (pos).unwrap ();\n\t\tlet tile_down = grid.get (pos.down (1) ?);\n\t\tmatch (tile_here, tile_down) {\n\n\t\t\t// retracing areas which are already handled\n\n\t\t\t(Water, Some (Water)) =\u003e (),\n\t\t\t(WetSand, Some (WetSand)) =\u003e (),\n\n\t\t\t// flowing down through dry sand\n\n\t\t\t(DrySand, Some (DrySand)) =\u003e {\n\t\t\t\tgrid.set (pos, Tile::WetSand);\n\t\t\t\tqueue.push (pos);\n\t\t\t\tqueue.push (pos.down (1) ?);\n\t\t\t},\n\n\t\t\t// flowing down into an existing flow\n\n\t\t\t(DrySand, None | Some (WetSand)) =\u003e {\n\t\t\t\tgrid.set (pos, Tile::WetSand);\n\t\t\t},\n\n\t\t\t// hitting a surface\n\n\t\t\t(DrySand | WetSand, Some (Clay | Water)) =\u003e {\n\n\t\t\t\t// check if we are enclosed or can flow off on each side\n\n\t\t\t\tfn check_dir (grid: \u0026 Grid, mut pos: Pos, next_fn: fn (Pos) -\u003e Pos) -\u003e (bool, Coord) {\n\t\t\t\t\tlet bounded = loop {\n\t\t\t\t\t\tlet next = next_fn (pos);\n\t\t\t\t\t\tmatch (grid.get (next).unwrap (), grid.get (next.down (1).unwrap ()).unwrap_or (DrySand)) {\n\t\t\t\t\t\t\t(DrySand | WetSand, Clay | Water) =\u003e pos = next,\n\t\t\t\t\t\t\t(Clay, _) =\u003e break true,\n\t\t\t\t\t\t\t(DrySand | WetSand, DrySand | WetSand) =\u003e break false,\n\t\t\t\t\t\t\t(Water, _) =\u003e unreachable! (),\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t(bounded, pos.x)\n\t\t\t\t}\n\n\t\t\t\tlet (left_bounded, left) = check_dir (\u0026 grid, pos, |pos| pos.left (1).unwrap ());\n\t\t\t\tlet (right_bounded, right) = check_dir (\u0026 grid, pos, |pos| pos.right (1).unwrap ());\n\n\t\t\t\tif left_bounded \u0026\u0026 right_bounded {\n\n\t\t\t\t\t// fully enclosed, fill with water\n\n\t\t\t\t\tfor x in left ..= right {\n\t\t\t\t\t\tgrid.set (Pos { x, .. pos }, Water);\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// flowing off one or both sides, continue with those flows\n\n\t\t\t\t\tfor x in left ..= right {\n\t\t\t\t\t\tgrid.set (Pos { x, .. pos }, WetSand);\n\t\t\t\t\t}\n\t\t\t\t\tif ! left_bounded { queue.push (Pos { x: left, .. pos }.left (1).unwrap ()); }\n\t\t\t\t\tif ! right_bounded { queue.push (Pos { x: right, .. pos }.right (1).unwrap ()); }\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t(WetSand, None | Some (DrySand)) | (Clay | Water, _) =\u003e unreachable! (\"{tile_here:?} {tile_down:?}\"),\n\n\t\t}\n\t}\n\n\tOk (grid)\n\n}\n","traces":[{"line":12,"address":[32239,32064],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":13,"address":[32188,32077,32112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[32141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[32256,32431],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[32304,32269,32380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[32333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[32448],"length":1,"stats":{"Line":2},"fn_name":"count_tiles"},{"line":24,"address":[32597,32735,32981],"length":1,"stats":{"Line":6},"fn_name":null},{"line":25,"address":[32761,32879,32928],"length":1,"stats":{"Line":6},"fn_name":null},{"line":26,"address":[53438,53411,53408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":29,"address":[33202,33117],"length":1,"stats":{"Line":4},"fn_name":null},{"line":31,"address":[33212,33229],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[33376,38724],"length":1,"stats":{"Line":2},"fn_name":"calc_grid"},{"line":39,"address":[33403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[33520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[33560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[33794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[33848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[33743,33669,33774,33701],"length":1,"stats":{"Line":8},"fn_name":null},{"line":51,"address":[53602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[33901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[34122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[34127],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[34138],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[34153],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[34170],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[53762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[34435,34413],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[34588,34450,34495],"length":1,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[34597,34643],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[34673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[34852,37907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[35168],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[35423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[35463,35707],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[35712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[37509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[37625],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[35074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[37296,37109,37404,36446],"length":1,"stats":{"Line":8},"fn_name":null},{"line":131,"address":[37095,36427],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[53808,53847],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":141,"address":[53943,53904],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":143,"address":[37129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[37154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[37190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[37234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[37262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[37301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[37408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[37776],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":42,"coverable":51},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-17","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tDrySand = [ \".\" ],\n\t\tWetSand = [ \"|\" ],\n\t\tWater = [ \"~\" ],\n\t\tClay = [ \"#\" ],\n\t}\n\n}\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum ClayRange {\n\t\tHoriz { y: Coord, x_start: Coord, x_end: Coord } = [\n\t\t\t\"y=\", y, \", x=\", x_start, \"..\", x_end,\n\t\t],\n\t\tVert { x: Coord, y_start: Coord, y_end: Coord } = [\n\t\t\t\"x=\", x, \", y=\", y_start, \"..\", y_end,\n\t\t],\n\t}\n\n}\n\nimpl ClayRange {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn ranges (self) -\u003e (RangeInclusive \u003cCoord\u003e, RangeInclusive \u003cCoord\u003e) {\n\t\tmatch self {\n\t\t\tSelf::Horiz { y, x_start, x_end } =\u003e (y ..= y, x_start ..= x_end),\n\t\t\tSelf::Vert { x, y_start, y_end } =\u003e (y_start ..= y_end, x ..= x),\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn y (self) -\u003e RangeInclusive \u003cCoord\u003e {\n\t\tself.ranges ().0\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn x (self) -\u003e RangeInclusive \u003cCoord\u003e {\n\t\tself.ranges ().1\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn valid (self) -\u003e bool {\n\t\t! (self.y ().is_empty () || self.x ().is_empty ())\n\t}\n\n}\n","traces":[{"line":9,"address":[36777,35397,36399,37064,36121,35692],"length":1,"stats":{"Line":22},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[33943,33745,33776,33710,34453,33672,34600],"length":1,"stats":{"Line":20},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":6,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\".#.#...|#.\",\n\t\".....#|##|\",\n\t\".|..|...#.\",\n\t\"..|#.....#\",\n\t\"#.#|||#|#|\",\n\t\"...#.||...\",\n\t\".|....|...\",\n\t\"||...#|.#|\",\n\t\"|.||||..|.\",\n\t\"...#.|..|.\",\n];\n\n#[ test ]\nfn test_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1147\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn test_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"0\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[33824,33828],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[51674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[51842,51908,51785,52012,51695,51733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[33860,33856],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[52074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[52133,52185,52095,52242,52308,52412],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-18","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-18","lib.rs"],"content":"//! Advent of Code 2018: Day 18: Settlers of The North Pole\n//!\n//! [https://adventofcode.com/2018/day/18](https://adventofcode.com/2018/day/18)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Settlers of The North Pole\";\n\tyear = 2018;\n\tday = 18;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-18","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Grid;\nuse model::Tile::{ Open, Tree, Yard };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, 10)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, 1_000_000_000)\n}\n\nfn calc_result (input: \u0026 Input, num_reps: u32) -\u003e GenResult \u003cu32\u003e {\n\n\tif [ input.grid.last_key ().x, input.grid.last_key ().y ].contains (\u0026 Coord::MAX) {\n\t\treturn Err (\"Refusing to handle large grid\".into ());\n\t}\n\n\t// iterate the specified number of times\n\n\tlet mut grid = input.grid.clone ();\n\tlet mut cache: HashMap \u003cGrid, u32\u003e = HashMap::new ();\n\tcache.insert (grid.clone (), 0);\n\tlet mut cur_rep = 0_u32;\n\twhile cur_rep \u003c num_reps {\n\n\t\t// calculate the next state\n\n\t\tgrid = Grid::wrap_range (\n\t\t\tgrid.iter ()\n\t\t\t\t.map (|(pos, val)|\n\t\t\t\t\tOk::\u003c_, Overflow\u003e ((pos, val, [\n\t\t\t\t\t\tgrid.get (pos.up (1) ?.left (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.up (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.up (1) ?.right (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.left (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.right (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.down (1) ?.left (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.down (1) ?).unwrap_or (Open),\n\t\t\t\t\t\tgrid.get (pos.down (1) ?.right (1) ?).unwrap_or (Open),\n\t\t\t\t\t])))\n\t\t\t\t.map_ok (|(_, here, around)| {\n\t\t\t\t\tlet num_trees = around.iter ().filter (|\u0026\u0026 tile| tile == Tree).count ();\n\t\t\t\t\tlet num_yards = around.iter ().filter (|\u0026\u0026 tile| tile == Yard).count ();\n\t\t\t\t\tmatch (here, num_trees, num_yards) {\n\t\t\t\t\t\t(Open, 3 .. , _) =\u003e Tree,\n\t\t\t\t\t\t(Open, _, _) =\u003e Open,\n\t\t\t\t\t\t(Tree, _, 3 .. ) =\u003e Yard,\n\t\t\t\t\t\t(Tree, _, _) =\u003e Tree,\n\t\t\t\t\t\t(Yard, 1 .. , 1 .. ) =\u003e Yard,\n\t\t\t\t\t\t(Yard, _, _) =\u003e Open,\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.try_collect () ?,\n\t\t\tgrid.start (),\n\t\t\tgrid.end (),\n\t\t) ?;\n\t\tcur_rep += 1;\n\n\t\t// detect loops and fast forward, otherwise add new state to cache\n\n\t\tif let Some (prev_rep) = cache.get (\u0026 grid) {\n\t\t\tlet loop_reps = cur_rep - prev_rep;\n\t\t\tif num_reps \u003c cur_rep + loop_reps { continue }\n\t\t\tlet num_loops = (num_reps - cur_rep) / loop_reps;\n\t\t\tcur_rep += num_loops * loop_reps;\n\t\t} else {\n\t\t\tcache.insert (grid.clone (), cur_rep);\n\t\t}\n\n\t}\n\n\t// count trees and yards, and return their product\n\n\tlet num_trees = grid.values ().filter (|\u0026 tile| tile == Tree).count ().pan_u32 ();\n\tlet num_yards = grid.values ().filter (|\u0026 tile| tile == Yard).count ().pan_u32 ();\n\n\tOk (num_trees * num_yards)\n\n}\n","traces":[{"line":10,"address":[76864],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":11,"address":[76868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[76896],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":15,"address":[45915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[79042,76928],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":20,"address":[77190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[77192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[77505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[78969,77900,77814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[77762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[56096],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":37,"address":[56834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[56115,56157,56218],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[56281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[56351,56395],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[56471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[56510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[56574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[56671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[56735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[56990,56976],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":48,"address":[57264,57273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[57289,57280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[39087,40106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[34915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[34905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[34924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[77977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[78138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[78151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[78170],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[78193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[57296,57302],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":81,"address":[57318,57312],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":83,"address":[78606],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-18","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tOpen = [ \".\" ],\n\t\tTree = [ \"|\" ],\n\t\tYard = [ \"#\" ],\n\t}\n\n}\n\n","traces":[{"line":9,"address":[41070,36224],"length":1,"stats":{"Line":17},"fn_name":"next\u003caoc_2018_day_18::model::Tile\u003e"}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-19","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"#ip 0\",\n\t\"seti 5 0 1\",\n\t\"seti 6 0 2\",\n\t\"addi 0 1 0\",\n\t\"addr 1 2 3\",\n\t\"setr 1 0 0\",\n\t\"seti 8 0 4\",\n\t\"seti 9 0 5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"7\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":17,"address":[22272,22276],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":18,"address":[31754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[31813,32092,31922,31775,31988,31865],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-19","input.rs"],"content":"use super::*;\nuse model::Instr;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub ip: Val,\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { ip, instrs, params } = [ params, \"#ip \", ip, \"\\n\", @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[22583],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-19","lib.rs"],"content":"//! Advent of Code 2018: Day 19: Go With The Flow\n//!\n//! [https://adventofcode.com/2018/day/19](https://adventofcode.com/2018/day/19)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2018_cpu as cpu;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Go With The Flow\";\n\tyear = 2018;\n\tday = 19;\n\tparse = |input_lines| input::Input::parse_from_lines (input_lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":21,"address":[43710],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-19","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Instr;\nuse model::Opcode;\nuse model::Regs;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet regs: Regs= Regs::default ();\n\tcalc_result (input, regs)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut regs: Regs = Regs::default ();\n\tregs.set (0, 1).unwrap ();\n\tcalc_result (input, regs)\n}\n\n#[ allow (clippy::unneeded_field_pattern) ]\nfn calc_result (input: \u0026 Input, mut regs: Regs) -\u003e GenResult \u003cu64\u003e {\n\tlet is_sum_of_factors = if input.instrs.len () == 36 {\n\t\tmatches! (\u003c[Instr; 16]\u003e::try_from (\u0026 input.instrs [1 .. 17]).unwrap (), [\n\t\t\tInstr { opcode: Opcode::Seti, arg_a: 1, arg_b: _, arg_c: 2 },\n\t\t\tInstr { opcode: Opcode::Seti, arg_a: 1, arg_b: _, arg_c: 4 },\n\t\t\tInstr { opcode: Opcode::Mulr, arg_a: 2, arg_b: 4, arg_c: 1 },\n\t\t\tInstr { opcode: Opcode::Eqrr, arg_a: 1, arg_b: 5, arg_c: 1 },\n\t\t\tInstr { opcode: Opcode::Addr, arg_a: 1, arg_b: 3, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Addi, arg_a: 3, arg_b: 1, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Addr, arg_a: 2, arg_b: 0, arg_c: 0 },\n\t\t\tInstr { opcode: Opcode::Addi, arg_a: 4, arg_b: 1, arg_c: 4 },\n\t\t\tInstr { opcode: Opcode::Gtrr, arg_a: 4, arg_b: 5, arg_c: 1 },\n\t\t\tInstr { opcode: Opcode::Addr, arg_a: 3, arg_b: 1, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Seti, arg_a: 2, arg_b: _, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Addi, arg_a: 2, arg_b: 1, arg_c: 2 },\n\t\t\tInstr { opcode: Opcode::Gtrr, arg_a: 2, arg_b: 5, arg_c: 1 },\n\t\t\tInstr { opcode: Opcode::Addr, arg_a: 1, arg_b: 3, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Seti, arg_a: 1, arg_b: _, arg_c: 3 },\n\t\t\tInstr { opcode: Opcode::Mulr, arg_a: 3, arg_b: 3, arg_c: 3 },\n\t\t])\n\t} else { false };\n\tlet mut limit = 10_000_u32;\n\t#[ allow (clippy::while_let_loop) ]\n\tloop {\n\t\tlet instr_val = some_or! (regs.get (input.ip), break);\n\t\tlet instr_idx = ok_or! (instr_val.to_usize (), break);\n\t\tif input.instrs.len () \u003c= instr_idx { break }\n\t\tif is_sum_of_factors \u0026\u0026 instr_idx == 1 {\n\t\t\tlet target = regs.get (5).unwrap ();\n\t\t\treturn Ok (calc_sum_of_factors (target));\n\t\t}\n\t\tlet instr = input.instrs [instr_idx];\n\t\tregs = instr.apply (regs) ?;\n\t\tlet new_ip = regs.get (input.ip).unwrap () + 1;\n\t\tregs.set (input.ip, new_ip).unwrap ();\n\t\tlimit -= 1;\n\t\tif limit == 0 { return Err (\"Giving up after 10k instrs\".into ()) }\n\t}\n\tOk (regs.get (0).unwrap ())\n}\n\nconst fn calc_sum_of_factors (target: u64) -\u003e u64 {\n\tlet mut result = target + 1;\n\tlet mut div_0 = 2_u64;\n\tloop {\n\t\tlet div_1 = target / div_0;\n\t\tlet product = div_0 * div_1;\n\t\tif product == target {\n\t\t\tif div_0 == div_1 {\n\t\t\t\tresult += div_0;\n\t\t\t} else {\n\t\t\t\tresult += div_0 + div_1;\n\t\t\t}\n\t\t}\n\t\tif target \u003c= product { break }\n\t\tdiv_0 += 1;\n\t}\n\tresult\n}\n","traces":[{"line":10,"address":[32624],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":12,"address":[43339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[32672],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[32771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[32864],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":23,"address":[32890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[32933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[34311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[33778,33818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[33853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[33876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[34624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[34637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[33908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[34076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[34205,34678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[34300,34565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[34409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[34800],"length":1,"stats":{"Line":0},"fn_name":"calc_sum_of_factors"},{"line":64,"address":[34801,34964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[34832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[34847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[34852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[34857,34905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[34864,34921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[34874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[34879],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-19","model.rs"],"content":"use super::*;\n\npub type Instr = cpu::Instr \u003cVal\u003e;\npub type Regs = cpu::Regs \u003cVal, 6\u003e;\npub type Val = u64;\n\npub use cpu::ArgType;\npub use cpu::CpuError;\npub use cpu::Op;\npub use cpu::Opcode;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLES: \u0026 [\u0026 str] = \u0026 [\n\t\"^ENNWSWW(NEWS|)SSSEEN(WNSE|)EE(SWEN|)NNN$\",\n\t\"^ESSWWN(E|NNENN(EESS(WNSE|)SSS|WWWSSSSE(SW|NNNE)))$\",\n\t\"^WSSEESWWWNW(S|NENNEEEENN(ESSSSW(NWSW|SSEN)|WSWWN(E|WWS(E|SS))))$\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"18\", puzzle.part_one (\u0026 [ EXAMPLES [0] ]));\n\tassert_eq_ok! (\"23\", puzzle.part_one (\u0026 [ EXAMPLES [1] ]));\n\tassert_eq_ok! (\"31\", puzzle.part_one (\u0026 [ EXAMPLES [2] ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"13\", puzzle.part_two (\u0026 [ \"DIST_TWO=10\", EXAMPLES [0] ]));\n\tassert_eq_ok! (\"25\", puzzle.part_two (\u0026 [ \"DIST_TWO=10\", EXAMPLES [1] ]));\n\tassert_eq_ok! (\"39\", puzzle.part_two (\u0026 [ \"DIST_TWO=10\", EXAMPLES [2] ]));\n}\n","traces":[{"line":12,"address":[50796,49744],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":13,"address":[49761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[49843,50246,49782,50312,50753,49899],"length":1,"stats":{"Line":3},"fn_name":null},{"line":15,"address":[50380,50441,49921,49978,50715,50037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[50122,50506,50674,50567,50181,50059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[51942,50816],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":21,"address":[50833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[51439,51891,50854,50939,51373,50995],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[51845,51568,51017,51507,51150,51091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[51172,51804,51249,51308,51694,51633],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-20","input.rs"],"content":"use super::*;\n\nuse model::RouteRegex;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub regex: RouteRegex,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { regex, params } = [ params, regex ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub dist_two: u32 = (\"DIST_TWO=\", 1000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":18,"address":[93037],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-20","lib.rs"],"content":"//! Advent of Code 2018: Day 20: A Regular Map\n//!\n//! [https://adventofcode.com/2018/day/20](https://adventofcode.com/2018/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"A Regular Map\";\n\tyear = 2018;\n\tday = 20;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[93944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[94264],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-20","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Grid;\nuse model::Pos;\nuse model::RouteDir;\nuse model::RouteRegexItem;\nuse model::RouteRegexString;\n\nconst STACK_SIZE: usize = 320;\nconst GRID_EXPAND: Coord = 24;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = gen_grid (input) ?;\n\tlet mut todo: Vec \u003c(Pos, u32)\u003e = Vec::new ();\n\ttodo.push ((Pos::ZERO, 0));\n\tlet mut seen: HashSet \u003cPos\u003e = HashSet::new ();\n\tseen.insert (Pos::ZERO);\n\tlet mut furthest = 0;\n\twhile let Some ((pos, dist)) = todo.pop () {\n\t\tfurthest = cmp::max (dist, furthest);\n\t\tfor dir in grid.get (pos).unwrap ().doors () {\n\t\t\tlet adj_pos = (pos + (dir, 1)).unwrap ();\n\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\ttodo.push ((adj_pos, u32::add_2 (dist, 1) ?));\n\t\t}\n\t}\n\tOk (furthest)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = gen_grid (input) ?;\n\tlet mut todo: Vec \u003c(Pos, u32)\u003e = Vec::new ();\n\ttodo.push ((Pos::ZERO, 0));\n\tlet mut seen: HashSet \u003cPos\u003e = HashSet::new ();\n\tseen.insert (Pos::ZERO);\n\tlet mut num_far_rooms = 0;\n\twhile let Some ((pos, dist)) = todo.pop () {\n\t\tif input.params.dist_two \u003c= dist { num_far_rooms += 1; }\n\t\tfor dir in grid.get (pos).unwrap ().doors () {\n\t\t\tlet adj_pos = (pos + (dir, 1)).unwrap ();\n\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\ttodo.push ((adj_pos, u32::add_2 (dist, 1) ?));\n\t\t}\n\t}\n\tOk (num_far_rooms)\n}\n\nfn gen_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tuse RouteRegexItem::{ Branch, Span };\n\ttype Frame = (RouteRegexString, Pos, u8, u8);\n\ttype Stack = ArrayVec \u003cFrame, STACK_SIZE\u003e;\n\tlet mut grid = Grid::new_range (\n\t\tPos::new (- GRID_EXPAND, - GRID_EXPAND),\n\t\tPos::new (GRID_EXPAND + 1, GRID_EXPAND + 1)) ?;\n\tlet mut todo: Vec \u003c(Pos, Stack)\u003e = Vec::new ();\n\ttodo.push ((Pos::ZERO, array_vec! [ (input.regex.deref ().clone (), Pos::ZERO, 0, 0) ]));\n\tlet mut seen: HashSet \u003c(Pos, ArrayVec \u003c(u8, u8), STACK_SIZE\u003e)\u003e = HashSet::new ();\n\tseen.insert ((Pos::ZERO, array_vec! [ (0, 0) ]));\n\tfn make_seen_indexes (stack: \u0026 Stack) -\u003e ArrayVec \u003c(u8, u8), STACK_SIZE\u003e {\n\t\tstack.iter ()\n\t\t\t.map (|\u0026 (_, _, branch_idx, string_idx)| (branch_idx, string_idx))\n\t\t\t.collect ()\n\t}\n\twhile let Some ((mut pos, mut stack)) = todo.pop () {\n\t\tlet (string, start_pos, branch_idx, string_idx) = stack.pop ().unwrap ();\n\t\tif string.len () \u003c= string_idx.to_usize () ? {\n\t\t\tif ! stack.is_empty () {\n\t\t\t\ttodo.push ((pos, stack));\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tmatch string [string_idx.to_usize () ?] {\n\t\t\tBranch (ref branches) =\u003e {\n\t\t\t\tfor (sub_branch_idx, sub_branch) in branches.iter ().enumerate () {\n\t\t\t\t\tlet sub_branch_idx = sub_branch_idx.to_u8 () ?;\n\t\t\t\t\tlet mut stack = stack.clone ();\n\t\t\t\t\tstack.push ((string.clone (), start_pos, branch_idx, u8::add_2 (string_idx, 1) ?));\n\t\t\t\t\tstack.push ((sub_branch.clone (), pos, sub_branch_idx, 0));\n\t\t\t\t\tif seen.insert ((pos, make_seen_indexes (\u0026 stack))) {\n\t\t\t\t\t\ttodo.push ((pos, stack));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tSpan (ref span_dirs) =\u003e {\n\t\t\t\tfor dir in span_dirs.iter ().copied () {\n\t\t\t\t\t* grid.get_mut (pos).unwrap () |= dir;\n\t\t\t\t\tpos = (pos + (* dir, 1)) ?;\n\t\t\t\t\tif grid.get (pos).is_none () { grid_resize (\u0026 mut grid, dir) ?; }\n\t\t\t\t\t* grid.get_mut (pos).unwrap () |= dir.rev ();\n\t\t\t\t}\n\t\t\t\tstack.push ((string, start_pos, branch_idx, u8::add_2 (string_idx, 1) ?));\n\t\t\t\tif seen.insert ((pos, make_seen_indexes (\u0026 stack))) {\n\t\t\t\t\ttodo.push ((pos, stack));\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\tOk (grid)\n}\n\nfn grid_resize (grid: \u0026 mut Grid, dir: RouteDir) -\u003e GenResult \u003c()\u003e {\n\tmatch dir {\n\t\tRouteDir::North =\u003e {\n\t\t\tif 240 \u003c grid.size ().n { return Err (\"Max grid size is 240\".into ()) }\n\t\t\t* grid = grid.extend_in_place ([(0, GRID_EXPAND), (0, 0)]) ?;\n\t\t},\n\t\tRouteDir::South =\u003e {\n\t\t\tif 240 \u003c grid.size ().n { return Err (\"Max grid size is 240\".into ()) }\n\t\t\t* grid = grid.extend_in_place ([(GRID_EXPAND, 0), (0, 0)]) ?;\n\t\t},\n\t\tRouteDir::East =\u003e {\n\t\t\tif 240 \u003c grid.size ().e { return Err (\"Max grid size is 240\".into ()) }\n\t\t\t* grid = grid.extend_in_place ([(0, 0), (0, GRID_EXPAND)]) ?;\n\t\t},\n\t\tRouteDir::West =\u003e {\n\t\t\tif 240 \u003c grid.size ().e { return Err (\"Max grid size is 240\".into ()) }\n\t\t\t* grid = grid.extend_in_place ([(0, 0), (GRID_EXPAND, 0)]) ?;\n\t\t},\n\t}\n\tOk (())\n}\n","traces":[{"line":16,"address":[65876,64304],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":17,"address":[64334,64385,65446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[64651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[64755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[64780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[65110,65825,65030],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[65119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[65176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[65212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[65507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[67524,65888],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":35,"address":[67071,65970,65919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[66243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[66331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[67259,66351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[66614,67473,66694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[66703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[66760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[66796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[67122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[74248,67536],"length":1,"stats":{"Line":2},"fn_name":"gen_grid"},{"line":60,"address":[67901,73610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[38960,41287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[68395],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[68572],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[68639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[68843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[68849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[72164,68712,72793,74127,72011,71782],"length":1,"stats":{"Line":8},"fn_name":null},{"line":78,"address":[70616],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[70668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[70837,70795,73953],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[71241,71318],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[71424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[69032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[69523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[69832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[71626,73481,71571],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[72002,71914],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[72031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[72272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[74256],"length":1,"stats":{"Line":0},"fn_name":"grid_resize"},{"line":106,"address":[74266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[74290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[74629,74306,74352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[74370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[74432,74647,74386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[74450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[74665,74472,74513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[74531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[74582,74619,74683],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":41,"coverable":51},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-20","model.rs"],"content":"use super::*;\n\npub use dir::RouteDir;\npub use room::Room;\n\npub type Coord = i16;\npub type Dir = aoc_pos::DirGeo;\npub type Grid = GridBuf \u003cVec \u003cRoom\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosGeo \u003cCoord\u003e;\n\nmod room {\n\n\tuse super::*;\n\n\tenum_decl_parser_display! {\n\t\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub enum Room {\n\t\t\t#[ default ]\n\t\t\tNone = [ \"  \" ],\n\t\t\tNorth = [ \" \" ],\n\t\t\tSouth = [ \" \" ],\n\t\t\tNorthSouth = [ \" \" ],\n\t\t\tEast = [ \"\" ],\n\t\t\tNorthEast = [ \"\" ],\n\t\t\tSouthEast = [ \"\" ],\n\t\t\tNorthSouthEast = [ \"\" ],\n\t\t\tWest = [ \" \" ],\n\t\t\tNorthWest = [ \" \" ],\n\t\t\tSouthWest = [ \" \" ],\n\t\t\tNorthSouthWest = [ \" \" ],\n\t\t\tEastWest = [ \"\" ],\n\t\t\tNorthEastWest = [ \"\" ],\n\t\t\tSouthEastWest = [ \"\" ],\n\t\t\tNorthSouthEastWest = [ \"\" ],\n\t\t}\n\t}\n\n\timpl Room {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn north (self) -\u003e bool {\n\t\t\tmatches! (self,\n\t\t\t\tSelf::North | Self::NorthSouth | Self::NorthEast | Self::NorthSouthEast |\n\t\t\t\tSelf::NorthWest | Self::NorthSouthWest | Self::NorthEastWest |\n\t\t\t\tSelf::NorthSouthEastWest)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn south (self) -\u003e bool {\n\t\t\tmatches! (self,\n\t\t\t\tSelf::South | Self::NorthSouth | Self::SouthEast | Self::NorthSouthEast |\n\t\t\t\tSelf::SouthWest | Self::NorthSouthWest | Self::SouthEastWest |\n\t\t\t\tSelf::NorthSouthEastWest)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn east (self) -\u003e bool {\n\t\t\tmatches! (self,\n\t\t\t\tSelf::East | Self::NorthEast | Self::SouthEast | Self::NorthSouthEast |\n\t\t\t\tSelf::EastWest | Self::NorthEastWest | Self::SouthEastWest | Self::NorthSouthEastWest)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn west (self) -\u003e bool {\n\t\t\tmatches! (self,\n\t\t\t\tSelf::West | Self::NorthWest | Self::SouthWest | Self::NorthSouthWest |\n\t\t\t\tSelf::EastWest | Self::NorthEastWest | Self::SouthEastWest | Self::NorthSouthEastWest)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn doors (self) -\u003e ArrayVec \u003cDir, 4\u003e {\n\t\t\tlet mut result = ArrayVec::new ();\n\t\t\tif self.north () { result.push (Dir::North); }\n\t\t\tif self.south () { result.push (Dir::South); }\n\t\t\tif self.east () { result.push (Dir::East); }\n\t\t\tif self.west () { result.push (Dir::West); }\n\t\t\tresult\n\t\t}\n\n\t}\n\n\timpl BitOrAssign \u003cRouteDir\u003e for Room {\n\t\tfn bitor_assign (\u0026 mut self, dir: RouteDir) {\n\t\t\t* self = match (\n\t\t\t\tself.north () || matches! (dir, RouteDir::North),\n\t\t\t\tself.south () || matches! (dir, RouteDir::South),\n\t\t\t\tself.east () || matches! (dir, RouteDir::East),\n\t\t\t\tself.west () || matches! (dir, RouteDir::West),\n\t\t\t) {\n\t\t\t\t(false, false, false, false) =\u003e Self::None,\n\t\t\t\t(true, false, false, false) =\u003e Self::North,\n\t\t\t\t(false, true, false, false) =\u003e Self::South,\n\t\t\t\t(true, true, false, false) =\u003e Self::NorthSouth,\n\t\t\t\t(false, false, true, false) =\u003e Self::East,\n\t\t\t\t(true, false, true, false) =\u003e Self::NorthEast,\n\t\t\t\t(false, true, true, false) =\u003e Self::SouthEast,\n\t\t\t\t(true, true, true, false) =\u003e Self::NorthSouthEast,\n\t\t\t\t(false, false, false, true) =\u003e Self::West,\n\t\t\t\t(true, false, false, true) =\u003e Self::NorthWest,\n\t\t\t\t(false, true, false, true) =\u003e Self::SouthWest,\n\t\t\t\t(true, true, false, true) =\u003e Self::NorthSouthWest,\n\t\t\t\t(false, false, true, true) =\u003e Self::EastWest,\n\t\t\t\t(true, false, true, true) =\u003e Self::NorthEastWest,\n\t\t\t\t(false, true, true, true) =\u003e Self::SouthEastWest,\n\t\t\t\t(true, true, true, true) =\u003e Self::NorthSouthEastWest,\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nmod dir {\n\n\tuse super::*;\n\n\tenum_decl_parser_display! {\n\n\t\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub enum RouteDir {\n\t\t\tNorth = [ \"N\" ],\n\t\t\tSouth = [ \"S\" ],\n\t\t\tEast = [ \"E\" ],\n\t\t\tWest = [ \"W\" ],\n\t\t}\n\n\t}\n\n\timpl RouteDir {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn rev (self) -\u003e Self {\n\t\t\tmatch self {\n\t\t\t\tSelf::North =\u003e Self::South,\n\t\t\t\tSelf::South =\u003e Self::North,\n\t\t\t\tSelf::East =\u003e Self::West,\n\t\t\t\tSelf::West =\u003e Self::East,\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl Deref for RouteDir {\n\n\t\ttype Target = Dir;\n\n\t\t#[ inline ]\n\t\tfn deref (\u0026 self) -\u003e \u0026 Dir {\n\t\t\tmatch * self {\n\t\t\t\tSelf::North =\u003e \u0026 Dir::North,\n\t\t\t\tSelf::South =\u003e \u0026 Dir::South,\n\t\t\t\tSelf::East =\u003e \u0026 Dir::East,\n\t\t\t\tSelf::West =\u003e \u0026 Dir::West,\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct RouteRegex (RouteRegexString);\n\nstruct_parser_display! {\n\tRouteRegex (string) = [ \"^\", string, \"$\" ]\n}\n\nimpl Deref for RouteRegex {\n\ttype Target = RouteRegexString;\n\tfn deref (\u0026 self) -\u003e \u0026 RouteRegexString {\n\t\t\u0026 self.0\n\t}\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct RouteRegexString (Rc \u003c[RouteRegexItem]\u003e);\n\nimpl Deref for RouteRegexString {\n\ttype Target = [RouteRegexItem];\n\tfn deref (\u0026 self) -\u003e \u0026 [RouteRegexItem] {\n\t\t\u0026 self.0\n\t}\n}\n\nstruct_parser_display! {\n\tRouteRegexString (items) = [ @collect items ]\n}\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum RouteRegexItem {\n\t\tBranch (branches: Rc \u003c[RouteRegexString]\u003e) = [\n\t\t\t\"(\", @confirm, @delim \"|\" branches, \")\",\n\t\t],\n\t\tSpan (dirs: Rc \u003c[RouteDir]\u003e) = [\n\t\t\t@confirm, @collect_some dirs,\n\t\t],\n\t}\n\n}\n","traces":[{"line":16,"address":[85297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[46246,46456],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[46416],"length":1,"stats":{"Line":0},"fn_name":"bitor_assign"},{"line":89,"address":[46510,46570,46562,46526,46538,46554,46477],"length":1,"stats":{"Line":6},"fn_name":null},{"line":90,"address":[46416],"length":1,"stats":{"Line":4},"fn_name":"bitor_assign"},{"line":91,"address":[46427],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[46446],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[69373,70219],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[59888],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":185,"address":[59904],"length":1,"stats":{"Line":0},"fn_name":"deref"}],"covered":18,"coverable":46},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","analyser.rs"],"content":"use super::*;\n\nuse std::fs::File;\nuse std::io::Write as _;\nuse std::path::PathBuf;\n\nuse input::Input;\nuse model::ArgType;\nuse model::CpuError;\nuse model::Instr;\nuse model::Op;\nuse model::Opcode;\nuse model::Val;\n\ntype MultiReg = MultiVal \u003c8\u003e;\n\n#[ derive (clap::Parser) ]\npub struct Args {\n\n\t#[ clap (from_global, value_parser) ]\n\tinput: PathBuf,\n\n}\n\npub fn run (args: Args) -\u003e GenResult \u003c()\u003e {\n\n\tlet input_string = fs::read_to_string (args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim_end ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\n\tlet reg_multis: [MultiReg; 6] =\n\t\tarray::from_fn (|idx| match idx {\n\t\t\t0 =\u003e MultiReg::unlimited (),\n\t\t\t_ =\u003e MultiReg::single (0),\n\t\t});\n\n\tlet instrs = get_instr_infos (input.ip.pan_u16 (), \u0026 input.instrs, \u0026 reg_multis);\n\tlet blocks = get_blocks (\u0026 instrs);\n\tlet super_blocks = get_super_blocks (\u0026 blocks);\n\n\tdot::write (\u0026 blocks, \u0026 super_blocks) ?;\n\n\tOk (())\n\n}\n\nmod dot {\n\n\tuse super::*;\n\n\tstruct Styles {\n\t\tbackground_colour: \u0026 'static str,\n\t\tblock_fill: \u0026 'static str,\n\t\tbranch_fill: \u0026 'static str,\n\t\tbranch_text_colour: \u0026 'static str,\n\t\tbranch_text_font: \u0026 'static str,\n\t\tcode_fill: \u0026 'static str,\n\t\tcode_text_colour: \u0026 'static str,\n\t\tcode_text_font: \u0026 'static str,\n\t\tedge_colour: \u0026 'static str,\n\t\tend_fill: \u0026 'static str,\n\t\tend_text_colour: \u0026 'static str,\n\t\tend_text_font: \u0026 'static str,\n\t\tstart_fill: \u0026 'static str,\n\t\tstart_text_colour: \u0026 'static str,\n\t\tstart_text_font: \u0026 'static str,\n\t}\n\n\timpl Default for Styles {\n\t\tfn default () -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tbackground_colour: \"black\",\n\t\t\t\tblock_fill: \"dodgerblue4\",\n\t\t\t\tbranch_fill: \"goldenrod1\",\n\t\t\t\tbranch_text_colour: \"black\",\n\t\t\t\tbranch_text_font: \"LiberationSansMono\",\n\t\t\t\tcode_fill: \"white\",\n\t\t\t\tcode_text_colour: \"black\",\n\t\t\t\tcode_text_font: \"LiberationSansMono\",\n\t\t\t\tedge_colour: \"white\",\n\t\t\t\tend_fill: \"red2\",\n\t\t\t\tend_text_colour: \"white\",\n\t\t\t\tend_text_font: \"LiberationSans-Bold\",\n\t\t\t\tstart_fill: \"forestgreen\",\n\t\t\t\tstart_text_font: \"LiberationSans-Bold\",\n\t\t\t\tstart_text_colour: \"white\",\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn write (\n\t\tblocks: \u0026 HashMap \u003cVal, Rc \u003cBlock\u003e\u003e,\n\t\tsuper_blocks: \u0026 HashMap \u003cVal, Rc \u003cSuperBlock\u003e\u003e,\n\t) -\u003e GenResult \u003c()\u003e {\n\n\t\tlet styles = Styles::default ();\n\n\t\tlet mut file = File::create (\"target/graph.dot\") ?;\n\t\twrite! (file, \"digraph analysis {{\\n\") ?;\n\t\twrite! (file, \"  bgcolor = \\\"{}\\\"\\n\", styles.background_colour) ?;\n\t\twrite! (file, \"  edge [\\n\") ?;\n\t\twrite! (file, \"    color = \\\"{}\\\"\\n\", styles.edge_colour) ?;\n\t\twrite! (file, \"    len=2\\n\") ?;\n\t\twrite! (file, \"   ]\\n\") ?;\n\t\twrite! (file, \"  start [\\n\") ?;\n\t\twrite! (file, \"    fillcolor = \\\"{}\\\"\\n\", styles.start_fill) ?;\n\t\twrite! (file, \"    fontcolor = \\\"{}\\\"\\n\", styles.start_text_colour) ?;\n\t\twrite! (file, \"    fontname = \\\"{}\\\"\\n\", styles.start_text_font) ?;\n\t\twrite! (file, \"    style = \\\"filled\\\"\\n\") ?;\n\t\twrite! (file, \"  ]\\n\") ?;\n\t\twrite! (file, \"  end [\\n\") ?;\n\t\twrite! (file, \"    fillcolor = \\\"{}\\\"\\n\", styles.end_fill) ?;\n\t\twrite! (file, \"    fontcolor = \\\"{}\\\"\\n\", styles.end_text_colour) ?;\n\t\twrite! (file, \"    fontname = \\\"{}\\\"\\n\", styles.end_text_font) ?;\n\t\twrite! (file, \"    style = \\\"filled\\\"\\n\") ?;\n\t\twrite! (file, \"  ]\\n\") ?;\n\t\twrite_super_blocks (\u0026 mut file, \u0026 styles, blocks, super_blocks) ?;\n\t\tfor block in blocks.values () {\n\t\t\tif block.prev.values ().contains (\u0026 Val::MAX) {\n\t\t\t\twrite! (file, \"  start -\u003e block_{}_code:start\", block.idx) ?;\n\t\t\t}\n\t\t}\n\t\tfor block in blocks.values () {\n\t\t\tlet block_idx = block.idx;\n\t\t\tmatch block.block_next {\n\t\t\t\tBlockNext::Simple (next_idx) =\u003e {\n\t\t\t\t\tif next_idx == Val::MAX {\n\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end -\u003e end\\n\") ?;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet next = \u0026 blocks [\u0026 next_idx];\n\t\t\t\t\t\tif next.super_idx == block.super_idx { continue }\n\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end -\u003e block_{next_idx}_code:start\\n\") ?;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tBlockNext::Condition { ref options, .. } =\u003e {\n\t\t\t\t\tfor \u0026 (val, next_idx) in options {\n\t\t\t\t\t\tif next_idx == Val::MAX {\n\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end_{val} -\u003e end\\n\") ?;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet next = \u0026 blocks [\u0026 next_idx];\n\t\t\t\t\t\t\tif next.super_idx == block.super_idx { continue }\n\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end_{val} -\u003e block_{next_idx}_code:start [\\n\") ?;\n\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\twrite! (file, \"}}\\n\") ?;\n\n\t\tOk (())\n\n\t}\n\n\tfn write_super_blocks (\n\t\tfile: \u0026 mut File,\n\t\tstyles: \u0026 Styles,\n\t\tblocks: \u0026 HashMap \u003cVal, Rc \u003cBlock\u003e\u003e,\n\t\tsuper_blocks: \u0026 HashMap \u003cVal, Rc \u003cSuperBlock\u003e\u003e,\n\t) -\u003e GenResult \u003c()\u003e {\n\t\tfor super_block in super_blocks.values () {\n\t\t\tlet super_block_idx = super_block.idx;\n\t\t\twrite! (file, \"  subgraph cluster_super_{super_block_idx} {{\\n\") ?;\n\t\t\twrite! (file, \"    style = \\\"filled\\\"\\n\") ?;\n\t\t\twrite! (file, \"    fillcolor = \\\"{}\\\"\\n\", styles.block_fill) ?;\n\t\t\tfor block in \u0026 super_block.blocks {\n\t\t\t\tlet block_idx = block.idx;\n\t\t\t\tlet mut label = String::new ();\n\t\t\t\tfor instr in \u0026 block.instrs {\n\t\t\t\t\tif label.is_empty () {\n\t\t\t\t\t\twrite! (label, \"\u003cstart\u003e\") ?;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twrite! (label, \"|\") ?;\n\t\t\t\t\t}\n\t\t\t\t\twrite! (label, \"{}\", InstrDisplay { instr, idx: true, orig: false }) ?;\n\t\t\t\t}\n\t\t\t\twrite! (file, \"    block_{block_idx}_code [\\n\") ?;\n\t\t\t\twrite! (file, \"      fillcolor = \\\"{}\\\"\\n\", styles.code_fill) ?;\n\t\t\t\twrite! (file, \"      fontcolor = \\\"{}\\\"\\n\", styles.code_text_colour) ?;\n\t\t\t\twrite! (file, \"      fontname = \\\"{}\\\"\\n\", styles.code_text_font) ?;\n\t\t\t\twrite! (file, \"      label = \\\"{{{label}}}\\\"\\n\") ?;\n\t\t\t\twrite! (file, \"      shape = \\\"record\\\"\\n\") ?;\n\t\t\t\twrite! (file, \"      style = \\\"filled\\\"\\n\") ?;\n\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\tmatch block.block_next {\n\t\t\t\t\tBlockNext::Simple (next_idx) =\u003e {\n\t\t\t\t\t\tif next_idx == Val::MAX {\n\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_code:s -\u003e block_{block_idx}_end:n\\n\") ?;\n\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end [\\n\") ?;\n\t\t\t\t\t\t\twrite! (file, \"      fillcolor = \\\"{}\\\"\\n\", styles.branch_fill) ?;\n\t\t\t\t\t\t\twrite! (file, \"      label = \\\"else\\\"\\n\") ?;\n\t\t\t\t\t\t\twrite! (file, \"      style = \\\"filled\\\"\\n\") ?;\n\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet next = \u0026 blocks [\u0026 next_idx];\n\t\t\t\t\t\t\tif block.super_idx == next.super_idx {\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_code:s -\u003e block_{next_idx}_code:start\\n\") ?;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_code:s -\u003e block_{block_idx}_end\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end [\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      label=\\\"goto {next_idx}\\\"\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tBlockNext::Condition { arg, ref options } =\u003e {\n\t\t\t\t\t\tfor \u0026 (val, next_idx) in options {\n\t\t\t\t\t\t\tif next_idx == Val::MAX {\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end_{val} [\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      fillcolor = \\\"{}\\\"\\n\", styles.branch_fill) ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      label = \\\"halt\\\"\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      style = \\\"filled\\\"\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_code:s -\u003e block_{block_idx}_end_{val} [\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      len=0.1\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlet next = \u0026 blocks [\u0026 next_idx];\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end_{val} [\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      fillcolor = \\\"{}\\\"\\n\", styles.branch_fill) ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      fontcolor = \\\"{}\\\"\\n\", styles.branch_text_colour) ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      fontname = \\\"{}\\\"\\n\", styles.branch_text_font) ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      label = \\\"{arg} = {val}\\\"\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"      style = \\\"filled\\\"\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_code:s -\u003e block_{block_idx}_end_{val}\\n\") ?;\n\t\t\t\t\t\t\t\tif block.super_idx == next.super_idx {\n\t\t\t\t\t\t\t\t\twrite! (file, \"    block_{block_idx}_end_{val} -\u003e block_{next_idx}_code:start [\\n\") ?;\n\t\t\t\t\t\t\t\t\twrite! (file, \"      constraint=false\\n\") ?;\n\t\t\t\t\t\t\t\t\twrite! (file, \"    ]\\n\") ?;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite! (file, \"  }}\\n\") ?;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\nfn get_super_blocks (\n\tblocks: \u0026 HashMap \u003cVal, Rc \u003cBlock\u003e\u003e,\n) -\u003e HashMap \u003cVal, Rc \u003cSuperBlock\u003e\u003e {\n\n\tlet mut super_blocks: HashMap \u003cVal, SuperBlock\u003e = HashMap::new ();\n\n\tfor block in blocks.values () {\n\t\tlet mut final_block = block;\n\t\twhile let BlockNext::Simple (next_idx) = final_block.block_next {\n\t\t\tif next_idx == Val::MAX { break }\n\t\t\tfinal_block = \u0026 blocks [\u0026 next_idx];\n\t\t}\n\t\tlet super_block =\n\t\t\tsuper_blocks.entry (final_block.idx)\n\t\t\t\t.or_insert (SuperBlock { idx: final_block.idx, blocks: Vec::new () });\n\t\tsuper_block.blocks.push (Rc::clone (block));\n\t}\n\n\t// TODO this fails with nightly for some reason, should be .into_iter ()\n\tsuper_blocks.iter ()\n\t\t.map (|(key, val)| (* key, Rc::new (val.clone ())))\n\t\t.collect ()\n\n}\n\n#[ derive (Clone, Debug) ]\npub struct SuperBlock {\n\tidx: Val,\n\tblocks: Vec \u003cRc \u003cBlock\u003e\u003e,\n}\n\nfn get_instr_infos (\n\tip: u16,\n\tinstrs: \u0026 [Instr],\n\treg_multis: \u0026 [MultiReg; 6],\n) -\u003e Vec \u003cRc \u003cInstrInfo\u003e\u003e {\n\n\tlet mut instrs: Vec \u003cInstrInfo\u003e =\n\t\tinstrs.iter ().copied ()\n\t\t\t.enumerate ()\n\t\t\t.map (|(instr_idx, instr)| {\n\t\t\t\tlet instr_idx = Val::from_usize (instr_idx).unwrap ();\n\t\t\t\tInstrInfo::new (ip, instr_idx, instr)\n\t\t\t})\n\t\t\t.collect ();\n\tlet instrs_len = instrs.len ();\n\n\tlet mut todo: Vec \u003c(Val, Val, [MultiReg; 6])\u003e = Vec::new ();\n\tlet mut seen: HashSet \u003c(Val, [MultiReg; 6])\u003e = HashSet::new ();\n\tmatch reg_multis [ip.pan_usize ()] {\n\t\tMultiVal::Limited (ref vals) =\u003e {\n\t\t\tfor val in vals.iter ().copied () {\n\t\t\t\tlet mut reg_multis = reg_multis.clone ();\n\t\t\t\treg_multis [ip.pan_usize ()] = MultiReg::single (val);\n\t\t\t\tif seen.insert ((val, reg_multis.clone ())) {\n\t\t\t\t\ttodo.push ((Val::MAX, val, reg_multis));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tMultiReg::Unlimited =\u003e panic! (),\n\t}\n\n\twhile let Some ((prev_idx, instr_idx, reg_multis)) = todo.pop () {\n\t\tlet instr = \u0026 mut instrs [instr_idx.pan_usize ()];\n\t\tinstr.prev.push (prev_idx);\n\t\tfor (reg_vals, reg_vals_new) in instr.before.iter_mut ().zip (reg_multis.iter ()) {\n\t\t\treg_vals.update (reg_vals_new);\n\t\t}\n\t\tlet arg_a = match instr.opcode.arg_a () {\n\t\t\tArgType::Reg =\u003e Some (instr.before [instr.arg_a.as_reg_idx ()].clone ()),\n\t\t\tArgType::Imm =\u003e Some (MultiReg::single (instr.arg_a.as_imm_val ())),\n\t\t\tArgType::Ignore =\u003e None,\n\t\t};\n\t\tlet arg_b = match instr.opcode.arg_b () {\n\t\t\tArgType::Reg =\u003e Some (instr.before [instr.arg_b.as_reg_idx ()].clone ()),\n\t\t\tArgType::Imm =\u003e Some (MultiReg::single (instr.arg_b.as_imm_val ())),\n\t\t\tArgType::Ignore =\u003e None,\n\t\t};\n\t\tlet args: Option \u003cVec \u003c(Option \u003cVal\u003e, Option \u003cVal\u003e)\u003e\u003e = match (arg_a, arg_b) {\n\t\t\t(Some (arg_a), Some (arg_b)) =\u003e\n\t\t\t\t(arg_a.is_limited () \u0026\u0026 arg_b.is_limited ())\n\t\t\t\t\t.then (|| arg_a.values ().iter ()\n\t\t\t\t\t\t.flat_map (|\u0026 val_a| arg_b.values ().iter ()\n\t\t\t\t\t\t\t.map (move |\u0026 val_b| (Some (val_a), Some (val_b))))\n\t\t\t\t\t\t.collect ()),\n\t\t\t(Some (arg_a), None) =\u003e\n\t\t\t\targ_a.is_limited ()\n\t\t\t\t\t.then (|| arg_a.values ().iter ()\n\t\t\t\t\t\t.map (|\u0026 val_a| (Some (val_a), None))\n\t\t\t\t\t\t.collect ()),\n\t\t\t(None, Some (arg_b)) =\u003e\n\t\t\t\targ_b.is_limited ()\n\t\t\t\t\t.then (|| arg_b.values ().iter ()\n\t\t\t\t\t\t.map (|\u0026 val_b| (None, Some (val_b)))\n\t\t\t\t\t\t.collect ()),\n\t\t\t(None, None) =\u003e unreachable! (),\n\t\t};\n\t\tif let Some (args) = args {\n\t\t\tfor (arg_a, arg_b) in args {\n\t\t\t\tlet arg_c = instr.opcode.op ().apply (\n\t\t\t\t\t\targ_a.ok_or (CpuError::Internal),\n\t\t\t\t\t\targ_b.ok_or (CpuError::Internal))\n\t\t\t\t\t.unwrap ();\n\t\t\t\tlet next_idx = if instr.arg_c.is_ip () { arg_c + 1 } else { instr_idx + 1 };\n\t\t\t\tlet mut reg_multis = instr.before.clone ();\n\t\t\t\treg_multis [instr.arg_c.as_reg_idx ()] = MultiReg::single (arg_c);\n\t\t\t\treg_multis [ip.pan_usize ()] = MultiReg::single (next_idx);\n\t\t\t\tif next_idx.pan_usize () \u003c instrs_len {\n\t\t\t\t\tinstr.next.push (next_idx);\n\t\t\t\t\tif seen.insert ((next_idx, reg_multis.clone ())) {\n\t\t\t\t\t\ttodo.push ((instr_idx, next_idx, reg_multis));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinstr.next.push (Val::MAX);\n\t\t\t\t\tinstr.halts.push (reg_multis);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if instr.arg_c.is_ip () {\n\t\t\tpanic! (\"{instr_idx} {args:?} {:?}\", instr.before);\n\t\t} else {\n\t\t\tlet mut reg_multis = instr.before.clone ();\n\t\t\treg_multis [instr.arg_c.as_reg_idx ()] =\n\t\t\t\tmatch instr.opcode.op () {\n\t\t\t\t\tOp::Add | Op::Mul | Op::Ban | Op::Bor | Op::Set =\u003e MultiVal::unlimited (),\n\t\t\t\t\tOp::Gt | Op::Eq =\u003e MultiReg::double (0, 1),\n\t\t\t\t};\n\t\t\treg_multis [ip.pan_usize ()] = MultiReg::single (instr_idx + 1);\n\t\t\tinstr.next.push (instr_idx + 1);\n\t\t\tif seen.insert ((instr_idx + 1, reg_multis.clone ())) {\n\t\t\t\ttodo.push ((instr_idx, instr_idx + 1, reg_multis));\n\t\t\t}\n\t\t}\n\t}\n\n\tfill_instr_prov (ip, \u0026 mut instrs);\n\n\tinstrs.into_iter ()\n\t\t.filter (|instr| ! instr.prev.is_empty ())\n\t\t.map (Rc::new)\n\t\t.collect ()\n\n}\n\nfn fill_instr_prov (ip: u16, instrs: \u0026 mut [InstrInfo]) {\n\n\t// track each start register from each starting point\n\n\tfor reg in 0 .. 6 {\n\t\tif reg == ip { continue }\n\t\tfor instr_idx in 0 .. Val::from_usize (instrs.len ()).unwrap () {\n\t\t\tlet instr = \u0026 instrs [instr_idx.pan_usize ()];\n\t\t\tif ! instr.prev.contains (Val::MAX) { continue }\n\t\t\tfill_instr_prov_from (instrs, instr_idx, reg, ValProv::InReg (reg));\n\t\t}\n\t}\n\n\t// track each output register from each instruction\n\n\tfor instr_idx in 0 .. Val::from_usize (instrs.len ()).unwrap () {\n\t\tlet instr = \u0026 instrs [instr_idx.pan_usize ()];\n\t\tif instr.arg_c.is_ip () { continue }\n\t\tlet reg_num = instr.arg_c.as_reg_num ();\n\t\tfor instr_next_idx in 0 .. instr.next.len () {\n\t\t\tlet next_idx = instrs [instr_idx.pan_usize ()].next.values () [instr_next_idx.pan_usize ()];\n\t\t\tif next_idx == Val::MAX {\n\t\t\t\tunimplemented! ();\n\t\t\t} else {\n\t\t\t\tfill_instr_prov_from (instrs, next_idx, reg_num, ValProv::Instr (instr_idx));\n\t\t\t}\n\t\t}\n\t}\n\n\t// assign temporary ids where possible\n\n\t// TODO match start regs\n\tlet mut temps: HashMap \u003cValProv, u16\u003e = HashMap::new ();\n\tfor orig_instr_idx in 0 .. Val::from_usize (instrs.len ()).unwrap () {\n\t\tlet orig_instr = \u0026 instrs [orig_instr_idx.pan_usize ()];\n\t\tif orig_instr.arg_c.is_ip () { continue }\n\t\tlet mut aliases: HashSet \u003cValProv\u003e = HashSet::new ();\n\t\tif temps.contains_key (\u0026 ValProv::Instr (orig_instr_idx)) { continue }\n\t\taliases.insert (ValProv::Instr (orig_instr_idx));\n\t\tloop {\n\t\t\tlet mut progress = false;\n\t\t\tfor instr in \u0026 * instrs {\n\t\t\t\tif instr.arg_a_prov.iter ().any (|\u0026 arg_prov| aliases.contains (\u0026 arg_prov)) {\n\t\t\t\t\tfor \u0026 arg_prov in \u0026 instr.arg_a_prov {\n\t\t\t\t\t\tif aliases.insert (arg_prov) {\n\t\t\t\t\t\t\tprogress = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif instr.arg_b_prov.iter ().any (|\u0026 arg_prov| aliases.contains (\u0026 arg_prov)) {\n\t\t\t\t\tfor \u0026 arg_prov in \u0026 instr.arg_b_prov {\n\t\t\t\t\t\tif aliases.insert (arg_prov) {\n\t\t\t\t\t\t\tprogress = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ! progress { break }\n\t\t}\n\t\tlet temp_idx = temps.len ().pan_u16 ();\n\t\tfor \u0026 alias in aliases.iter () { temps.insert (alias, temp_idx); }\n\t}\n\n\t// replace references to registers with temporaries\n\n\tfor instr in \u0026 mut * instrs {\n\t\tfor \u0026 arg_a_prov in \u0026 instr.arg_a_prov {\n\t\t\tif let Some (\u0026 temp_idx) = temps.get (\u0026 arg_a_prov) {\n\t\t\t\tinstr.arg_a.temp_assign (temp_idx);\n\t\t\t}\n\t\t}\n\t\tfor \u0026 arg_b_prov in \u0026 instr.arg_b_prov {\n\t\t\tif let Some (\u0026 temp_idx) = temps.get (\u0026 arg_b_prov) {\n\t\t\t\tinstr.arg_b.temp_assign (temp_idx);\n\t\t\t}\n\t\t}\n\t\tif let Some (\u0026 temp_idx) = temps.get (\u0026 ValProv::Instr (instr.idx)) {\n\t\t\tinstr.arg_c.temp_assign (temp_idx);\n\t\t}\n\t}\n\n}\n\nfn fill_instr_prov_from (instrs: \u0026 mut [InstrInfo], start_idx: Val, reg: u16, prov: ValProv) {\n\tlet mut todo: Vec \u003cVal\u003e = Vec::new ();\n\ttodo.push (start_idx);\n\tlet mut seen: HashSet \u003cVal\u003e = HashSet::new ();\n\twhile let Some (instr_idx) = todo.pop () {\n\t\tlet instr = \u0026 mut instrs [instr_idx.pan_usize ()];\n\t\tif instr.arg_a.is_reg () \u0026\u0026 instr.arg_a.as_reg_num () == reg\n\t\t\t\t\u0026\u0026 ! instr.arg_a_prov.contains (\u0026 prov) {\n\t\t\tinstr.arg_a_prov.push (prov);\n\t\t\tinstr.arg_a_prov.sort ();\n\t\t}\n\t\tif instr.arg_b.is_reg () \u0026\u0026 instr.arg_b.as_reg_num () == reg\n\t\t\t\t\u0026\u0026 ! instr.arg_b_prov.contains (\u0026 prov) {\n\t\t\tinstr.arg_b_prov.push (prov);\n\t\t\tinstr.arg_b_prov.sort ();\n\t\t}\n\t\tif instr.arg_c.is_reg () \u0026\u0026 instr.arg_c.as_reg_num () == reg { continue }\n\t\tif ! seen.insert (instr_idx) { continue }\n\t\tfor \u0026 next_idx in instr.next.values () {\n\t\t\tif next_idx == Val::MAX {\n\t\t\t\t// TODO\n\t\t\t} else {\n\t\t\t\ttodo.push (next_idx);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfn get_blocks (instrs: \u0026 [Rc \u003cInstrInfo\u003e]) -\u003e HashMap \u003cVal, Rc \u003cBlock\u003e\u003e {\n\tlet all_instrs: HashMap \u003cVal, Rc \u003cInstrInfo\u003e\u003e =\n\t\tinstrs.iter ()\n\t\t\t.map (|instr| (instr.idx, Rc::clone (instr)))\n\t\t\t.collect ();\n\tlet mut blocks_temp: HashMap \u003cVal, Block\u003e = HashMap::new ();\n\tlet mut instr_blocks: HashMap \u003cVal, Val\u003e = HashMap::new ();\n\tfor mut instr in instrs {\n\t\tlet first = instr;\n\t\tlet mut block_instrs = Vec::new ();\n\t\tif instr.prev.len () == 1 \u0026\u0026 ! instr.prev.contains (Val::MAX) {\n\t\t\tlet prev = \u0026 all_instrs [\u0026 instr.prev.values () [0]];\n\t\t\tif prev.next.len () == 1 { continue }\n\t\t}\n\t\tloop {\n\t\t\tinstr_blocks.insert (instr.idx, first.idx);\n\t\t\tif ! instr.arg_c.is_ip () {\n\t\t\t\tblock_instrs.push (Rc::clone (instr));\n\t\t\t}\n\t\t\tif instr.next.len () \u003e 1 { break }\n\t\t\tlet next = \u0026 all_instrs [\u0026 instr.next.values () [0]];\n\t\t\tif next.prev.len () \u003e 1 { break }\n\t\t\tinstr = next;\n\t\t}\n\t\tlet last = instr;\n\t\tlet block_next = if last.next.len () == 1 {\n\t\t\tBlockNext::Simple (last.next.values () [0])\n\t\t} else {\n\t\t\tlet arg = match (last.arg_a.is_ip (), last.arg_b.is_ip ()) {\n\t\t\t\t(false, true) =\u003e last.arg_a,\n\t\t\t\t(true, false) =\u003e last.arg_b,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t};\n\t\t\tlet mut options = Vec::new ();\n\t\t\tfor \u0026 next_idx in last.next.values () {\n\t\t\t\tlet val = next_idx - last.idx - 1;\n\t\t\t\toptions.push ((val, next_idx));\n\t\t\t}\n\t\t\tBlockNext::Condition { arg, options }\n\t\t};\n\t\tblocks_temp.insert (first.idx, Block {\n\t\t\tidx: first.idx,\n\t\t\tsuper_idx: Val::MAX,\n\t\t\tinstrs: block_instrs,\n\t\t\thalts: last.halts.clone (),\n\t\t\tprev: first.prev.clone (),\n\t\t\tnext: last.next.clone (),\n\t\t\tblock_next,\n\t\t});\n\t}\n\tblocks_temp.values ()\n\t\t.map (|block| {\n\t\t\tlet mut final_block = block;\n\t\t\twhile let BlockNext::Simple (next_idx) = final_block.block_next {\n\t\t\t\tif next_idx == Val::MAX { break }\n\t\t\t\tfinal_block = \u0026 blocks_temp [\u0026 next_idx];\n\t\t\t}\n\t\t\t( block.idx, Rc::new (Block {\n\t\t\t\tsuper_idx: final_block.idx,\n\t\t\t\tprev: {\n\t\t\t\t\tlet mut prev = MultiVal::empty ();\n\t\t\t\t\tfor \u0026 prev_idx in block.prev.values () {\n\t\t\t\t\t\tif prev_idx == Val::MAX {\n\t\t\t\t\t\t\tprev.push (Val::MAX);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprev.push (instr_blocks [\u0026 prev_idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprev\n\t\t\t\t},\n\t\t\t\t.. block.clone ()\n\t\t\t}))\n\t\t})\n\t\t.collect ()\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Block {\n\tidx: Val,\n\tsuper_idx: Val,\n\tinstrs: Vec \u003cRc \u003cInstrInfo\u003e\u003e,\n\thalts: Vec \u003c[MultiReg; 6]\u003e,\n\tprev: MultiVal \u003c{ usize::MAX }\u003e,\n\tnext: MultiVal \u003c{ usize::MAX }\u003e,\n\tblock_next: BlockNext,\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum BlockNext {\n\tSimple (Val),\n\tCondition { arg: ArgInfo, options: Vec \u003c(Val, Val)\u003e },\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct InstrInfo {\n\tidx: Val,\n\tbefore: [MultiReg; 6],\n\tafter: [MultiReg; 6],\n\thalts: Vec \u003c[MultiReg; 6]\u003e,\n\tprev: MultiVal \u003c{ usize::MAX }\u003e,\n\tnext: MultiVal \u003c{ usize::MAX }\u003e,\n\topcode: Opcode,\n\targ_a: ArgInfo,\n\targ_b: ArgInfo,\n\targ_c: ArgInfo,\n\targ_a_prov: Vec \u003cValProv\u003e,\n\targ_b_prov: Vec \u003cValProv\u003e,\n}\n\nimpl InstrInfo {\n\tfn new (ip: u16, instr_idx: Val, instr: Instr) -\u003e Self {\n\t\tSelf {\n\t\t\tidx: instr_idx,\n\t\t\tbefore: array::from_fn (|_| MultiReg::empty ()),\n\t\t\tafter: array::from_fn (|_| MultiReg::empty ()),\n\t\t\thalts: Vec::new (),\n\t\t\tprev: MultiVal::empty (),\n\t\t\tnext: MultiVal::empty (),\n\t\t\topcode: instr.opcode,\n\t\t\targ_a: ArgInfo::auto (ip, instr.opcode.arg_a (), instr.arg_a),\n\t\t\targ_b: ArgInfo::auto (ip, instr.opcode.arg_b (), instr.arg_b),\n\t\t\targ_c: ArgInfo::auto (ip, ArgType::Reg, instr.arg_c),\n\t\t\targ_a_prov: Vec::new (),\n\t\t\targ_b_prov: Vec::new (),\n\t\t}\n\t}\n}\n\nstruct InstrDisplay \u003c'ins\u003e {\n\tinstr: \u0026 'ins InstrInfo,\n\tidx: bool,\n\torig: bool,\n}\n\nimpl \u003c'ins\u003e Display for InstrDisplay \u003c'ins\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tif self.idx { write! (formatter, \"[{}]: \", self.instr.idx) ?; }\n\t\twrite! (formatter, \"{}\", self.instr.arg_a.display (self.orig)) ?;\n\t\tif self.instr.opcode.arg_b () != ArgType::Ignore {\n\t\t\tmatch self.instr.opcode.op () {\n\t\t\t\tOp::Add =\u003e write! (formatter, \" + \") ?,\n\t\t\t\tOp::Mul =\u003e write! (formatter, \"  \") ?,\n\t\t\t\tOp::Ban =\u003e write! (formatter, \" and \") ?,\n\t\t\t\tOp::Bor =\u003e write! (formatter, \" or \") ?,\n\t\t\t\tOp::Set =\u003e unreachable! (),\n\t\t\t\tOp::Gt =\u003e write! (formatter, \" \u0026gt; \") ?,\n\t\t\t\tOp::Eq =\u003e write! (formatter, \" = \") ?,\n\t\t\t}\n\t\t\twrite! (formatter, \"{}\", self.instr.arg_b.display (self.orig)) ?;\n\t\t}\n\t\twrite! (formatter, \"  {}\", self.instr.arg_c.display (self.orig)) ?;\n\t\tOk (())\n\t}\n}\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum ArgInfo {\n\tImmediate (Val),\n\t#[ allow (unused) ] InReg (u16),\n\t#[ allow (unused) ] OutReg (u16),\n\tInOutReg (u16),\n\tTemp (u16, u16),\n\tInstrPtr (u16),\n\tUnused (u16),\n}\n\nimpl ArgInfo {\n\tfn auto (ip: u16, arg_type: ArgType, arg: Val) -\u003e Self {\n\t\tlet ip_val = Val::try_from (ip).unwrap ();\n\t\tmatch arg_type {\n\t\t\tArgType::Reg if arg == ip_val =\u003e Self::InstrPtr (ip),\n\t\t\tArgType::Reg =\u003e Self::InOutReg (arg.pan_u16 ()),\n\t\t\tArgType::Imm =\u003e Self::Immediate (arg),\n\t\t\tArgType::Ignore =\u003e Self::Unused (arg.pan_u16 ()),\n\t\t}\n\t}\n\tconst fn is_ip (self) -\u003e bool {\n\t\tmatches! (self, Self::InstrPtr (_))\n\t}\n\tconst fn is_reg (self) -\u003e bool {\n\t\tmatches! (self, Self::InReg (_) | Self::OutReg (_) | Self::InOutReg (_) |\n\t\t\tSelf::Temp (_, _) | Self::InstrPtr (_))\n\t}\n\tfn as_imm_val (self) -\u003e Val {\n\t\tmatch self {\n\t\t\tSelf::Immediate (val) =\u003e val,\n\t\t\tSelf::InReg (_) | Self::OutReg (_) | Self::InOutReg (_) | Self::Temp (_, _)\n\t\t\t\t| Self::InstrPtr (_) | Self::Unused (_) =\u003e panic! (),\n\t\t}\n\t}\n\tfn as_reg_num (self) -\u003e u16 {\n\t\tmatch self {\n\t\t\tSelf::InReg (reg) =\u003e reg,\n\t\t\tSelf::OutReg (reg) =\u003e reg,\n\t\t\tSelf::InOutReg (reg) =\u003e reg,\n\t\t\tSelf::Temp (reg, _) =\u003e reg,\n\t\t\tSelf::InstrPtr (reg) =\u003e reg,\n\t\t\tSelf::Immediate (_) | Self::Unused (_) =\u003e panic! (),\n\t\t}\n\t}\n\tfn as_reg_idx (self) -\u003e usize {\n\t\tself.as_reg_num ().pan_usize ()\n\t}\n\tfn temp_assign (\u0026 mut self, temp_idx: u16) {\n\t\t* self = Self::Temp (self.as_reg_num (), temp_idx);\n\t}\n\tconst fn display (\u0026 self, orig: bool) -\u003e ArgInfoDisplay {\n\t\tArgInfoDisplay { arg: self, orig }\n\t}\n}\n\nimpl Debug for ArgInfo {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::InReg (reg) =\u003e write! (formatter, \"InReg ({reg})\"),\n\t\t\tSelf::OutReg (reg) =\u003e write! (formatter, \"OutReg ({reg})\"),\n\t\t\tSelf::InOutReg (reg) =\u003e write! (formatter, \"InOutReg ({reg})\"),\n\t\t\tSelf::Temp (reg, temp) =\u003e write! (formatter, \"Temp ({reg}, {temp})\"),\n\t\t\tSelf::InstrPtr (reg) =\u003e write! (formatter, \"InstrPtr ({reg})\"),\n\t\t\tSelf::Immediate (val) =\u003e write! (formatter, \"Immediate ({val})\"),\n\t\t\tSelf::Unused (val) =\u003e write! (formatter, \"Unused ({val})\"),\n\t\t}\n\t}\n}\n\nimpl Display for ArgInfo {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tDisplay::fmt (\u0026 ArgInfoDisplay { arg: self, orig: false }, formatter)\n\t}\n}\n\nstruct ArgInfoDisplay \u003c'arg\u003e {\n\targ: \u0026 'arg ArgInfo,\n\torig: bool,\n}\n\nimpl \u003c'arg\u003e Display for ArgInfoDisplay \u003c'arg\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch (* self.arg, self.orig) {\n\t\t\t(ArgInfo::Immediate (val), _) =\u003e write! (formatter, \"{}\", val) ?,\n\t\t\t(ArgInfo::InReg (_), _) =\u003e unimplemented! (),\n\t\t\t(ArgInfo::OutReg (_), _) =\u003e unimplemented! (),\n\t\t\t(ArgInfo::InOutReg (reg), _) =\u003e write! (formatter, \"r{}\", reg) ?,\n\t\t\t(ArgInfo::Temp (_, temp), false) =\u003e write! (formatter, \"v{}\", temp) ?,\n\t\t\t(ArgInfo::Temp (reg, _), true) =\u003e write! (formatter, \"r{}\", reg) ?,\n\t\t\t(ArgInfo::InstrPtr (_), false) =\u003e write! (formatter, \"ip\") ?,\n\t\t\t(ArgInfo::InstrPtr (reg), true) =\u003e write! (formatter, \"r{}\", reg) ?,\n\t\t\t(ArgInfo::Unused (_), _) =\u003e unreachable! (),\n\t\t}\n\t\tOk (())\n\t}\n}\n\n#[ derive (Clone, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum MultiVal \u003cconst MAX: usize\u003e {\n\tLimited (Vec \u003cVal\u003e),\n\tUnlimited,\n}\n\nimpl \u003cconst MAX: usize\u003e MultiVal \u003cMAX\u003e {\n\tconst fn empty () -\u003e Self {\n\t\tSelf::Limited (Vec::new ())\n\t}\n\tconst fn unlimited () -\u003e Self {\n\t\tSelf::Unlimited\n\t}\n\tfn single (val: Val) -\u003e Self {\n\t\tSelf::Limited (vec! [ val ])\n\t}\n\tfn double (val_0: Val, val_1: Val) -\u003e Self {\n\t\tSelf::Limited (vec! [ val_0, val_1 ])\n\t}\n\tconst fn is_limited (\u0026 self) -\u003e bool {\n\t\tmatches! (* self, Self::Limited (_))\n\t}\n\tfn contains (\u0026 self, val: Val) -\u003e bool {\n\t\tself.values ().contains (\u0026 val)\n\t}\n\tfn push (\u0026 mut self, val: Val) {\n\t\tif let Self::Limited (ref mut values) = * self {\n\t\t\tif values.len () == MAX {\n\t\t\t\t* self = Self::Unlimited;\n\t\t\t} else if ! values.contains (\u0026 val) {\n\t\t\t\tvalues.push (val);\n\t\t\t\tvalues.sort ();\n\t\t\t}\n\t\t}\n\t}\n\tfn is_empty (\u0026 self) -\u003e bool {\n\t\tself.values ().is_empty ()\n\t}\n\tfn len (\u0026 self) -\u003e usize {\n\t\tself.values ().len ()\n\t}\n\tfn values (\u0026 self) -\u003e \u0026 [Val] {\n\t\tmatch * self {\n\t\t\tSelf::Limited (ref vals) =\u003e vals,\n\t\t\tSelf::Unlimited =\u003e panic! (),\n\t\t}\n\t}\n\tfn update (\u0026 mut self, other: \u0026 Self) {\n\t\tmatch * other {\n\t\t\tSelf::Limited (ref vals) =\u003e {\n\t\t\t\tfor val in vals.iter ().copied () {\n\t\t\t\t\tself.push (val);\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::Unlimited =\u003e * self = Self::Unlimited,\n\t\t}\n\t}\n}\n\nimpl \u003cconst MAX: usize\u003e Debug for MultiVal \u003cMAX\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Limited (ref vals) =\u003e\n\t\t\t\twrite! (formatter, \"MultiVal [{}]\", vals.display_delim (\", \")),\n\t\t\tSelf::Unlimited =\u003e\n\t\t\t\twrite! (formatter, \"MultiVal [ .. ]\"),\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum ValProv {\n\tInReg (u16),\n\tInstr (Val),\n}\n\nimpl Debug for ValProv {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::InReg (reg) =\u003e write! (formatter, \"InReg ({reg})\"),\n\t\t\tSelf::Instr (instr_idx) =\u003e write! (formatter, \"Instr ({instr_idx})\"),\n\t\t}\n\t}\n}\n","traces":[{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":62},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"#ip 5\",\n\t\"seti 9 0 1\",\n\t\"addi 1 1 1\", // incr\n\t\"eqri 1 20 2\",\n\t\"addr 5 2 5\",\n\t\"addi 5 2 5\", // goto check\n\t\"seti 9 0 1\",\n\t\"seti 0 0 5\", // goto incr\n\t\"eqrr 1 0 2\", // check\n\t\"addr 5 2 5\",\n\t\"seti 0 0 5\", // goto incr\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"19\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","input.rs"],"content":"use super::*;\n\nuse model::Instr;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub ip: Val,\n\tpub instrs: Rc \u003c[Instr]\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { ip, instrs, params } = [ params, \"#ip \", ip, \"\\n\", @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_instrs: u64 = (\"MAX_INSTRS=\", 5_000_000_000, 1 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","lib.rs"],"content":"//! Advent of Code 2018: Day 21: Chronal Conversion\n//!\n//! [https://adventofcode.com/2018/day/21](https://adventofcode.com/2018/day/21)\n//!\n//! # Input\n//!\n//! A single line defining the instruction pointer register eg \"#ip 0\", then a series of lines with\n//! an opcode name followed by three integer arguments.\n//!\n//! # Part one\n//!\n//! Work out the starting value for register 0 which makes the program exit as quickly as possible.\n//!\n//! # Part two\n//!\n//! Work out the starting value for register 0 which makes the program exit as slowly as possible.\n//!\n//! # Algorithm\n//!\n//! Run the programme as normal but look out for any instructions which look at register 0. The\n//! only supported opcode is \"eqrr\" and we split our iteration in two, with one branch assuming\n//! equality and the other ineqaulity, taking the equal branch first. The value reg 0 was compared\n//! about is also stored and this is taken when the programme halts.\n//!\n//! There are quite a few shortcuts taken here, but I think it will work for any provided puzzle\n//! input from the official site.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_2018_cpu as cpu;\n\npub mod analyser;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Chronal Conversion\";\n\tyear = 2018;\n\tday = 21;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"analyse\"; method = analyser::run; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::ArgType;\nuse model::Opcode;\nuse model::Regs;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tsanity_check (input) ?;\n\tSolutionsIter::new (input).next ().ok_or (\"No solution found\") ?\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tsanity_check (input) ?;\n\tSolutionsIter::new (input).last ().ok_or (\"No solution found\") ?\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tlet regs = Regs::default ();\n\tregs.get (input.ip).ok_or (\"Instruction pointer register is not valid\") ?;\n\tfor (instr_idx, instr) in input.instrs.iter ().enumerate () {\n\t\tif instr.opcode.arg_a () == ArgType::Reg {\n\t\t\tregs.get (instr.arg_a).ok_or (format! (\n\t\t\t\t\"Instruction {instr_idx} references non-existent register {}\", instr.arg_a)) ?;\n\t\t}\n\t\tif instr.opcode.arg_b () == ArgType::Reg {\n\t\t\tregs.get (instr.arg_b).ok_or (format! (\n\t\t\t\t\"Instruction {instr_idx} references non-existent register {}\", instr.arg_b)) ?;\n\t\t}\n\t\tregs.get (instr.arg_c).ok_or (format! (\n\t\t\t\"Instruction {instr_idx} references non-existent register {}\", instr.arg_c)) ?;\n\t}\n\tOk (())\n}\n\nstruct SolutionsIter \u003c'inp\u003e {\n\tinput: \u0026 'inp Input,\n\ttodo: Vec \u003c(Regs, Option \u003cVal\u003e)\u003e,\n\tseen: HashSet \u003cVal\u003e,\n\tremain: u64,\n}\n\nimpl \u003c'inp\u003e SolutionsIter \u003c'inp\u003e {\n\tfn new (input: \u0026 'inp Input) -\u003e Self {\n\t\tlet mut todo = Vec::new ();\n\t\ttodo.push ((Regs::default (), None));\n\t\tlet seen = HashSet::new ();\n\t\tlet remain = input.params.max_instrs;\n\t\tSolutionsIter { input, todo, seen, remain }\n\t}\n}\n\nimpl \u003c'inp\u003e Iterator for SolutionsIter \u003c'inp\u003e {\n\ttype Item = GenResult \u003cVal\u003e;\n\tfn next (\u0026 mut self) -\u003e Option \u003cGenResult \u003cVal\u003e\u003e {\n\t\twhile let Some ((mut regs, reg_0)) = self.todo.pop () {\n\t\t\tloop {\n\t\t\t\tif self.remain == 0 {\n\t\t\t\t\treturn Some (Err (\"Instruction limit reached\".into ()));\n\t\t\t\t}\n\t\t\t\tself.remain -= 1;\n\t\t\t\tlet instr_idx = regs.get (self.input.ip).unwrap ().pan_usize ();\n\t\t\t\tif self.input.instrs.len () \u003c= instr_idx.pan_usize () {\n\t\t\t\t\treturn reg_0.map_or_else (\n\t\t\t\t\t\t|| Some (Err (\"Halted with indeterminate value in reg 0\".into ())),\n\t\t\t\t\t\t|reg_0| Some (Ok (reg_0)));\n\t\t\t\t}\n\t\t\t\tlet instr = self.input.instrs [instr_idx];\n\t\t\t\tif instr.arg_c == 0 {\n\t\t\t\t\treturn Some (Err (\"Don't know how to handle write to reg 0\".into ()));\n\t\t\t\t}\n\t\t\t\tif (instr.opcode.arg_a () == ArgType::Reg \u0026\u0026 instr.arg_a == 0)\n\t\t\t\t\t\t|| (instr.opcode.arg_b () == ArgType::Reg \u0026\u0026 instr.arg_b == 0) {\n\t\t\t\t\tif instr.opcode != Opcode::Eqrr || (instr.arg_a == 0 \u0026\u0026 instr.arg_b == 0) {\n\t\t\t\t\t\treturn Some (Err (\n\t\t\t\t\t\t\tformat! (\"Don't know how to handle {:?}\", instr).into ()));\n\t\t\t\t\t}\n\t\t\t\t\tif reg_0.is_some () {\n\t\t\t\t\t\treturn Some (Err (\"Reg 0 compared again after matching as equal\".into ()));\n\t\t\t\t\t}\n\t\t\t\t\tlet other_reg = if instr.arg_a == 0 { instr.arg_b } else { instr.arg_a };\n\t\t\t\t\tlet other = regs.get (other_reg).unwrap ();\n\t\t\t\t\tif ! self.seen.insert (other) { break; }\n\t\t\t\t\tregs.set (self.input.ip, regs.get (self.input.ip).unwrap () + 1).unwrap ();\n\t\t\t\t\tregs.set (instr.arg_c, 0).unwrap ();\n\t\t\t\t\tself.todo.push ((regs, None));\n\t\t\t\t\tregs.set (instr.arg_c, 1).unwrap ();\n\t\t\t\t\tself.todo.push ((regs, Some (other)));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tregs = instr.apply (regs).unwrap ();\n\t\t\t\tregs.set (self.input.ip, regs.get (self.input.ip).unwrap () + 1).unwrap ();\n\t\t\t}\n\t\t}\n\t\tNone\n\t}\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":38},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-21","model.rs"],"content":"use super::*;\n\npub use cpu::ArgType;\npub use cpu::CpuError;\npub use cpu::Op;\npub use cpu::Opcode;\n\npub type Instr = cpu::Instr \u003cVal\u003e;\npub type Regs = cpu::Regs \u003cVal, 6\u003e;\npub type Val = u64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"depth: 510\",\n\t\"target: 10,10\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"114\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"45\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[34935,34544],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":12,"address":[34554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[34892,34613,34722,34575,34665,34788],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[34944,35335],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":18,"address":[34954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[34975,35065,35122,35188,35292,35013],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-22","input.rs"],"content":"use super::*;\n\nuse model::Pos;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub depth: Val,\n\tpub target: Pos,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { depth, target: Pos { y: target_y, x: target_x }, params } = [\n\t\tparams, \"depth: \", depth, \"\\ntarget: \", target_x, \",\", target_y,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub modulo: u32 = (\"MODULO=\", 20183, 3 .. ),\n\t\tpub top_factor: u32 = (\"TOP_FACTOR=\", 16_807, 1 .. ),\n\t\tpub left_factor: u32 = (\"LEFT_FACTOR=\", 48_271, 1 .. ),\n\t\tpub max_mins: u32 = (\"MAX_MINS=\", 2000, 1 .. ),\n\t\tpub max_target: i16 = (\"MAX_TARGET=\", 1000, 1 .. ),\n\t}\n}\n","traces":[{"line":22,"address":[52282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[52286],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[52290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[52294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[52298],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":5,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-22","lib.rs"],"content":"//! Advent of Code 2018: Day 22: Mode Maze\n//!\n//! [https://adventofcode.com/2018/day/22](https://adventofcode.com/2018/day/22)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::*;\nuse aoc_search as search;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Mode Maze\";\n\tyear = 2018;\n\tday = 22;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":21,"address":[79609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[79913],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-22","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Equip;\nuse model::Grid;\nuse model::Pos;\nuse model::Region;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet size = input.target + Pos { y: 1, x: 1 };\n\tlet grid = calc_grid (input, size);\n\tlet risk_level = grid.values ()\n\t\t.map (|region| match region {\n\t\t\tRegion::Rocky =\u003e 0,\n\t\t\tRegion::Wet =\u003e 1,\n\t\t\tRegion::Narrow =\u003e 2,\n\t\t})\n\t\t.sum ();\n\tOk (risk_level)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet base_dim = cmp::max (input.target.y, input.target.x) + 1;\n\tlet base_size = Pos { y: base_dim, x: base_dim };\n\t'OUTER: for mul in 2 .. {\n\t\tlet size = base_size * mul;\n\t\tlet grid = calc_grid (input, size);\n\t\tlet mut search = search::PrioritySearch::with_hash_map (|\n\t\t\t(pos, equip): (Pos, Equip),\n\t\t\tdist: u32,\n\t\t\tmut adder: search::PrioritySearchAdder \u003c_, _, _\u003e,\n\t\t| {\n\t\t\tfor next_equip in [ Equip::Torch, Equip::Climbing, Equip::Neither ].iter ().copied () {\n\t\t\t\tif next_equip == equip { continue }\n\t\t\t\tif ! grid.get (pos).unwrap ().can_equip (next_equip) { continue }\n\t\t\t\tadder.add ((pos, next_equip), dist + 7);\n\t\t\t}\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\tif adj_pos.x \u003c 0 || adj_pos.y \u003c 0 { continue }\n\t\t\t\tlet adj_region = some_or! (grid.get (adj_pos), return None);\n\t\t\t\tif ! adj_region.can_equip (equip) { continue }\n\t\t\t\tadder.add ((adj_pos, equip), dist + 1);\n\t\t\t}\n\t\t\tSome ((pos, equip, dist))\n\t\t});\n\t\tsearch.push ((Pos::ZERO, Equip::Torch), 0);\n\t\tfor item in search {\n\t\t\tif let Some ((pos, equip, dist)) = item {\n\t\t\t\tif dist \u003e input.params.max_mins {\n\t\t\t\t\treturn Err (\"Giving up after 2k minutes\".into ());\n\t\t\t\t}\n\t\t\t\tif pos == input.target \u0026\u0026 equip == Equip::Torch { return Ok (dist) }\n\t\t\t} else {\n\t\t\t\tcontinue 'OUTER;\n\t\t\t}\n\t\t}\n\t\treturn Err (\"No solution found\".into ());\n\t}\n\tunreachable! ();\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.target.x \u003c 0 || input.target.y \u003c 0 {\n\t\treturn Err (\"Target must have positive coordinates\".into ());\n\t}\n\tif input.target.y \u003e= input.params.max_target || input.target.x \u003e= input.params.max_target {\n\t\treturn Err (\"Refusing to handle target more than 1000 distant in any axis\".into ());\n\t}\n\tOk (())\n}\n\nfn calc_grid (input: \u0026 Input, size: Pos) -\u003e Grid {\n\tlet mut grid_data = Vec::new ();\n\tlet mut ero_row: Vec \u003cVal\u003e =\n\t\titertools::iterate (input.depth, |prev| (prev + input.params.top_factor) % input.params.modulo)\n\t\t\t.take (size.x.pan_usize ())\n\t\t\t.collect ();\n\tlet mut y: Coord = 0;\n\tloop {\n\t\tgrid_data.extend (ero_row.iter ().map (|\u0026 ero| match ero % 3 {\n\t\t\t0 =\u003e Region::Rocky,\n\t\t\t1 =\u003e Region::Wet,\n\t\t\t2 =\u003e Region::Narrow,\n\t\t\t_ =\u003e unreachable! (),\n\t\t}));\n\t\ty += 1;\n\t\tif y == size.y { break }\n\t\tlet first = (y.pan_u32 () * input.params.left_factor + input.depth) % input.params.modulo;\n\t\tero_row = iter::empty ()\n\t\t\t.chain (iter::once (first))\n\t\t\t.chain (ero_row.iter ().skip (1).copied ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(idx, val)| (Coord::from_usize (idx).unwrap () + 1, val))\n\t\t\t\t.scan (first, |state, (x, up)| {\n\t\t\t\t\tlet left = * state;\n\t\t\t\t\tif (Pos { y, x }) == input.target {\n\t\t\t\t\t\t* state = input.depth % input.params.modulo;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t* state = (left * up + input.depth) % input.params.modulo;\n\t\t\t\t\t}\n\t\t\t\t\tSome (* state)\n\t\t\t\t}))\n\t\t\t.collect ();\n\t}\n\tGrid::wrap_size (grid_data, size)\n}\n","traces":[{"line":13,"address":[75964,75520],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":14,"address":[75614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[75697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[46000],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":24,"address":[75840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[75984,77033],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":28,"address":[76081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[76933,76119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[76300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[46945,46016],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":35,"address":[46052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[46138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[46179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[46181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[46256,46763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[46460,46327,46930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[46499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[46681,46519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[46790,46576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[46639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[76485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[76638,76505,76985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[76621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[76629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[76789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[76826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[76762],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[75540,76007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[75576,76043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[75558,76025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[75590,76057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[77056,77886],"length":1,"stats":{"Line":1},"fn_name":"calc_grid"},{"line":80,"address":[64722,65037,64741,65357],"length":1,"stats":{"Line":7},"fn_name":null},{"line":84,"address":[77206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[33024,32802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[77277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[77296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[77397,77350],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[77511,77815],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[31140,31226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[47072],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":101,"address":[39519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[39548,39522],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[39550,39673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[39567,39603],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":39,"coverable":45},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-22","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cRegion\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Val = u32;\n\nenum_decl_parser_display! {\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Region {\n\t\tRocky = [ \".\" ],\n\t\tWet = [ \"=\" ],\n\t\tNarrow = [ \"|\" ],\n\t}\n\n}\n\nimpl Region {\n\n\t#[ must_use ]\n\tpub const fn can_equip (self, equip: Equip) -\u003e bool {\n\t\t! matches! ((self, equip),\n\t\t\t(Self::Rocky, Equip::Neither) |\n\t\t\t(Self::Wet, Equip::Torch) |\n\t\t\t(Self::Narrow, Equip::Climbing))\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Equip {\n\tTorch,\n\tClimbing,\n\tNeither,\n}\n","traces":[{"line":10,"address":[32377,30777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[46547,46222],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"pos=\u003c0,0,0\u003e, r=4\",\n\t\"pos=\u003c1,0,0\u003e, r=1\",\n\t\"pos=\u003c4,0,0\u003e, r=3\",\n\t\"pos=\u003c0,2,0\u003e, r=1\",\n\t\"pos=\u003c0,5,0\u003e, r=3\",\n\t\"pos=\u003c0,0,3\u003e, r=1\",\n\t\"pos=\u003c1,1,1\u003e, r=1\",\n\t\"pos=\u003c1,1,2\u003e, r=1\",\n\t\"pos=\u003c1,3,1\u003e, r=1\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"pos=\u003c10,12,12\u003e, r=2\",\n\t\"pos=\u003c12,14,12\u003e, r=2\",\n\t\"pos=\u003c16,12,12\u003e, r=4\",\n\t\"pos=\u003c14,14,14\u003e, r=6\",\n\t\"pos=\u003c50,50,50\u003e, r=200\",\n\t\"pos=\u003c10,10,10\u003e, r=5\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"7\", puzzle.part_one (EXAMPLE_0));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"36\", puzzle.part_two (EXAMPLE_1));\n}\n","traces":[{"line":27,"address":[32928,32932],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[42730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[42898,42789,42964,42751,43068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[32964,32960],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":34,"address":[43130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[43151,43241,43298,43189,43468,43364],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-23","input.rs"],"content":"use super::*;\nuse model::Nanobot;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub nanobots: Vec \u003cNanobot\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { nanobots, params } = [ params, @lines nanobots ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters: u32 = (\"MAX_ITERS=\", 5_000, 1 .. ),\n\t}\n}\n","traces":[{"line":11,"address":[36763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[37085],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-23","lib.rs"],"content":"//! Advent of Code 2018: Day 23: Experimental Emergency Teleportation\n//!\n//! [https://adventofcode.com/2018/day/23](https://adventofcode.com/2018/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Experimental Emergency Teleportation\";\n\tyear = 2018;\n\tday = 23;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[37627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[38155],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-23","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Pos;\nuse model::Region;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet strongest =\n\t\tinput.nanobots.iter ()\n\t\t\t.max_by_key (|bot| bot.radius)\n\t\t\t.ok_or (\"No solution found\") ?;\n\tlet num_in_range =\n\t\tinput.nanobots.iter ()\n\t\t\t.map (|bot| get_dist (bot.pos, strongest.pos))\n\t\t\t.filter (|dist| dist.as_ref ().map (|\u0026 dist| dist \u003c= strongest.radius).unwrap_or (true))\n\t\t\t.try_fold (0_u32, |sum, item| { item ?; Ok::\u003c_, Overflow\u003e (sum + 1) }) ?;\n\tOk (num_in_range)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tsanity_check (input) ?;\n\tlet mut bots: Vec \u003cRegion\u003e =\n\t\tinput.nanobots.iter ()\n\t\t\t.map (Region::from_bot)\n\t\t\t.try_collect () ?;\n\tbots.sort_by_key (|bot| bot.dist ());\n\tlet mut todo: Vec \u003c(Region, usize, u32)\u003e = Vec::new ();\n\ttodo.push ((Region::OPEN, 0, 0));\n\tlet mut best_num = 0_u32;\n\tlet mut best_dist = Coord::MAX;\n\tlet mut num_iters = 0;\n\t'OUTER: while let Some ((mut region, bot_idx, mut num)) = todo.pop () {\n\t\tfor bot_idx in bot_idx .. bots.len () {\n\t\t\tif num_iters == input.params.max_iters {\n\t\t\t\treturn Err (format! (\n\t\t\t\t\t\"Giving up after {max_iters} iterations.\",\n\t\t\t\t\tmax_iters = input.params.max_iters,\n\t\t\t\t).into ());\n\t\t\t}\n\t\t\tnum_iters += 1;\n\t\t\tlet num_remain =\n\t\t\t\tbots.iter ()\n\t\t\t\t\t.skip (bot_idx)\n\t\t\t\t\t.filter (|bot| bot.overlap (region).is_some ())\n\t\t\t\t\t.count ()\n\t\t\t\t\t.pan_u32 ();\n\t\t\tif num + num_remain \u003c best_num { continue 'OUTER }\n\t\t\tlet bot = bots [bot_idx];\n\t\t\tif let Some (overlap) = region.overlap (bot) {\n\t\t\t\tif region != overlap {\n\t\t\t\t\ttodo.push ((region, bot_idx + 1, num));\n\t\t\t\t}\n\t\t\t\tregion = overlap;\n\t\t\t\tnum += 1;\n\t\t\t}\n\t\t}\n\t\tif best_num \u003c= num {\n\t\t\tlet dist = region.dist ();\n\t\t\tif best_num \u003c num || region.dist () \u003c best_dist {\n\t\t\t\tbest_num = num;\n\t\t\t\tbest_dist = dist;\n\t\t\t}\n\t\t}\n\t}\n\tif best_dist == Coord::MAX { return Err (\"No solution found\".into ()); }\n\tOk (best_dist)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tfor bot in \u0026 * input.nanobots {\n\t\tif bot.radius \u003c 0_i32 { return Err (\"Radius must not be negative\".into ()) }\n\t}\n\tOk (())\n}\n\nfn get_dist (pos_0: Pos, pos_1: Pos) -\u003e NumResult \u003cCoord\u003e {\n\tchk! (chk! (pos_0.x - pos_1.x) ?.abs (),\n\t\t+ chk! (pos_0.y - pos_1.y) ?.abs (),\n\t\t+ chk! (pos_0.z - pos_1.z) ?.abs ())\n}\n","traces":[{"line":10,"address":[30096],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[30242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[30472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[50019,49971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[30531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[46477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[46548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[50560,50565],"length":1,"stats":{"Line":1},"fn_name":"{closure#3}"},{"line":21,"address":[30600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[32620,30640],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":25,"address":[30773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[30960,32389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[50640,50644],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[31276],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[31324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[31391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[32214,32309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[31400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[50688,50692,50757],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":51,"address":[31568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[31631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[31796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[31824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[32029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[32064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[32084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[32094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[32132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[32441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[32476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[30187,30718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[30209,30740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[32640],"length":1,"stats":{"Line":1},"fn_name":"get_dist"},{"line":81,"address":[32667,32650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[32737,32718],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[32809,32828],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":35,"coverable":36},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-23","model.rs"],"content":"use super::*;\n\npub type Coord = i32;\npub type Pos = pos::PosXYZ \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Nanobot {\n\tpub pos: Pos,\n\tpub radius: Coord,\n}\n\nstruct_parser_display! {\n\tNanobot { pos: Pos { x, y, z }, radius } = [\n\t\t\"pos=\u003c\", x, \",\", y, \",\", z, \"\u003e, \",\n\t\t\"r=\", radius,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Region {\n\tpub ppp: CoordRange,\n\tpub pnn: CoordRange,\n\tpub npn: CoordRange,\n\tpub nnp: CoordRange,\n}\n\nimpl Region {\n\n\tpub fn from_bot (bot: \u0026 Nanobot) -\u003e NumResult \u003cSelf\u003e {\n\t\tOk (Self {\n\t\t\tppp: CoordRange::new (bot.pos, bot.radius, signs::PPP) ?,\n\t\t\tpnn: CoordRange::new (bot.pos, bot.radius, signs::PNN) ?,\n\t\t\tnpn: CoordRange::new (bot.pos, bot.radius, signs::NPN) ?,\n\t\t\tnnp: CoordRange::new (bot.pos, bot.radius, signs::NNP) ?,\n\t\t})\n\t}\n\n\t#[ must_use ]\n\tpub fn overlap (self, other: Self) -\u003e Option \u003cSelf\u003e {\n\t\tSome (Self {\n\t\t\tppp: some_or! (self.ppp.overlap (other.ppp), return None),\n\t\t\tpnn: some_or! (self.pnn.overlap (other.pnn), return None),\n\t\t\tnpn: some_or! (self.npn.overlap (other.npn), return None),\n\t\t\tnnp: some_or! (self.nnp.overlap (other.nnp), return None),\n\t\t})\n\t}\n\n\t#[ must_use ]\n\tpub fn dist (self) -\u003e Coord {\n\t\t[\n\t\t\tself.ppp.dist (),\n\t\t\tself.pnn.dist (),\n\t\t\tself.npn.dist (),\n\t\t\tself.nnp.dist (),\n\t\t].iter ().copied ().max ().unwrap ()\n\t}\n\n\tpub const OPEN: Self = Self {\n\t\tppp: CoordRange::OPEN,\n\t\tpnn: CoordRange::OPEN,\n\t\tnpn: CoordRange::OPEN,\n\t\tnnp: CoordRange::OPEN,\n\t};\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct CoordRange {\n\tpub start: Coord,\n\tpub end: Coord,\n}\n\nimpl CoordRange {\n\n\tpub fn new (pos: Pos, radius: Coord, sign: Pos) -\u003e NumResult \u003cSelf\u003e {\n\t\tlet base = chk! (pos.x * sign.x + pos.y * sign.y + pos.z * sign.z) ?;\n\t\tOk (Self {\n\t\t\tstart: Coord::sub_2 (base, radius) ?,\n\t\t\tend: Coord::add_3 (base, radius, Coord::ONE) ?,\n\t\t})\n\t}\n\n\t#[ must_use ]\n\tpub fn overlap (self, other: Self) -\u003e Option \u003cSelf\u003e {\n\t\t(self.start \u003c other.end \u0026\u0026 other.start \u003c self.end).then (|| Self {\n\t\t\tstart: cmp::max (self.start, other.start),\n\t\t\tend: cmp::min (self.end, other.end),\n\t\t})\n\t}\n\n\t#[ must_use ]\n\tpub const fn dist (self) -\u003e Coord {\n\t\tif self.start \u003e Coord::ZERO {\n\t\t\tself.start\n\t\t} else if self.end \u003c= Coord::ZERO {\n\t\t\tCoord::ONE - self.end\n\t\t} else {\n\t\t\tCoord::ZERO\n\t\t}\n\t}\n\n\tpub const OPEN: Self = Self { start: Coord::MIN, end: Coord::MAX };\n\n}\n\npub mod signs {\n\tuse super::*;\n\tpub const PPP: Pos = Pos { x: Coord::ONE, y: Coord::ONE, z: Coord::ONE };\n\tpub const PNN: Pos = Pos { x: Coord::ONE, y: Coord::NEG_ONE, z: Coord::NEG_ONE };\n\tpub const NPN: Pos = Pos { x: Coord::NEG_ONE, y: Coord::ONE, z: Coord::NEG_ONE };\n\tpub const NNP: Pos = Pos { x: Coord::NEG_ONE, y: Coord::NEG_ONE, z: Coord::ONE };\n}\n","traces":[{"line":29,"address":[43520],"length":1,"stats":{"Line":1},"fn_name":"from_bot"},{"line":30,"address":[43877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[43614,43540],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[43630,43695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[43719,43784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[43808,43867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[43952],"length":1,"stats":{"Line":1},"fn_name":"overlap"},{"line":40,"address":[44257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[43975,44034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[44046,44109],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[44117,44178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[44182,44246],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[44336],"length":1,"stats":{"Line":1},"fn_name":"dist"},{"line":51,"address":[44348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[44376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[44405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[44434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[44640],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":76,"address":[44687,44663,44781,44731],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[44862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[44810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[44832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[44135,44064,43986,44200],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[44221,44153,44007,44082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[44017,44230,44092,44163],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[44379,44408,44350,44437],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[44417,44446,44359,44388],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[44397,44368,44426,44455],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":28,"coverable":28},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-24","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Immune System:\",\n\t\"17 units each with 5390 hit points (weak to radiation, bludgeoning) with an attack that \\\n\tdoes 4507 fire damage at initiative 2\",\n\t\"989 units each with 1274 hit points (immune to fire; weak to bludgeoning, slashing) with \\\n\tan attack that does 25 slashing damage at initiative 3\",\n\t\"\",\n\t\"Infection:\",\n\t\"801 units each with 4706 hit points (weak to radiation) with an attack that does 116 \\\n\tbludgeoning damage at initiative 1\",\n\t\"4485 units each with 2961 hit points (immune to radiation; weak to fire, cold) with an \\\n\tattack that does 12 slashing damage at initiative 4\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5216\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"51\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":20,"address":[36048,36431],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":21,"address":[36058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[36292,36388,36226,36079,36169,36117],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[36448,36831],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":27,"address":[36458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[36788,36479,36569,36626,36517,36692],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-24","input.rs"],"content":"use super::*;\nuse model::Group;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub immune_system: Vec \u003cGroup\u003e,\n\tpub infection: Vec \u003cGroup\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { immune_system, infection, params } = [\n\t\tparams,\n\t\t\"Immune System:\\n\",\n\t\t@lines immune_system, \"\\n\",\n\t\t\"\\n\",\n\t\t\"Infection:\\n\",\n\t\t@lines infection,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_rounds: u32 = (\"MAX_ROUNDS=\", 5_000, 1 .. ),\n\t\tpub max_boost: u32 = (\"MAX_BOOST=\", 2_048, 1 .. ),\n\t}\n}\n","traces":[{"line":12,"address":[75082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[75779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[75783],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-24","lib.rs"],"content":"//! Advent of Code 2018: Day 24: Immune System Simulator 20XX\n//!\n//! [https://adventofcode.com/2018/day/24](https://adventofcode.com/2018/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Immune System Simulator 20XX\";\n\tyear = 2018;\n\tday = 24;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[68691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[69171],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-24","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Group;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tsanity_check (input) ?;\n\tlet (num_0, num_1) = calc_result (input, 0) ?;\n\tOk (num_0 + num_1)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tsanity_check (input) ?;\n\tlet mut boost_min = 0;\n\tlet mut boost_max = input.params.max_boost;\n\tlet mut num_units = 0;\n\twhile boost_min == boost_max || boost_min + 1 \u003c boost_max {\n\t\tlet boost = (boost_min + boost_max) / 2;\n\t\tlet (num_0, num_1) = calc_result (input, boost) ?;\n\t\tif num_0 \u003e 0 \u0026\u0026 num_1 == 0 {\n\t\t\tboost_max = boost;\n\t\t\tnum_units = num_0;\n\t\t} else {\n\t\t\tboost_min = boost;\n\t\t}\n\t}\n\tif num_units == 0 { return Err (\"Max boost exceeded\".into ()) }\n\tOk (num_units)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tfor group in iter::empty ()\n\t\t\t.chain (\u0026 input.immune_system)\n\t\t\t.chain (\u0026 input.infection) {\n\t\tif group.num_units \u003c 1 || group.hit_points \u003c 1 || group.attack_damage \u003c 1 {\n\t\t\treturn Err (\"Each group must have at least one unit, one hit point, and one attack \\\n\t\t\t\tdamage\".into ());\n\t\t}\n\t}\n\tOk (())\n}\n\nfn calc_result (input: \u0026 Input, boost: u32) -\u003e GenResult \u003c(u32, u32)\u003e {\n\tlet mut immune_system = input.immune_system.clone ();\n\tfor group in \u0026 mut immune_system {\n\t\tgroup.attack_damage += boost;\n\t}\n\tlet mut infection = input.infection.clone ();\n\tlet mut num_rounds = 0;\n\tloop {\n\t\tif num_rounds == input.params.max_rounds { return Err (\"Max rounds exceeded\".into ()) }\n\t\tlet progress = one_round (\u0026 mut immune_system, \u0026 mut infection) ?;\n\t\tif ! progress { break }\n\t\tnum_rounds += 1;\n\t}\n\tlet num_0 = immune_system.iter ().map (|group| group.num_units).sum ();\n\tlet num_1 = infection.iter ().map (|group| group.num_units).sum ();\n\tOk ((num_0, num_1))\n}\n\nfn one_round (left: \u0026 mut Vec \u003cGroup\u003e, right: \u0026 mut Vec \u003cGroup\u003e) -\u003e NumResult \u003cbool\u003e {\n\t#[ derive (Clone, Copy, Debug) ]\n\tenum Side { Left, Right }\n\tuse Side::{ Left, Right };\n\tlet attacks: Vec \u003c(Side, usize, usize)\u003e = iter::empty ()\n\t\t.chain (choose_targets (left, right) ?.into_iter ()\n\t\t\t.map (|(att_idx, def_idx)| (Left, att_idx, def_idx)))\n\t\t.chain (choose_targets (right, left) ?.into_iter ()\n\t\t\t.map (|(att_idx, def_idx)| (Right, att_idx, def_idx)))\n\t\t.sorted_by_key (|\u0026 (side, att_idx, _)|\n\t\t\tcmp::Reverse (match side {\n\t\t\t\tLeft =\u003e left [att_idx].initiative,\n\t\t\t\tRight =\u003e right [att_idx].initiative,\n\t\t\t}))\n\t\t.collect ();\n\tlet mut progress = false;\n\tfor (side, att_idx, def_idx) in attacks {\n\t\tlet (att_group, def_group) = match side {\n\t\t\tLeft =\u003e (\u0026 mut left [att_idx], \u0026 mut right [def_idx]),\n\t\t\tRight =\u003e (\u0026 mut right [att_idx], \u0026 mut left [def_idx]),\n\t\t};\n\t\tlet damage = if def_group.has_weakness (att_group.attack_type) {\n\t\t\tatt_group.effective_power () * 2\n\t\t} else {\n\t\t\tatt_group.effective_power ()\n\t\t};\n\t\tlet lost_units = cmp::min (damage / def_group.hit_points, def_group.num_units);\n\t\tif lost_units \u003e 0 { progress = true; }\n\t\tdef_group.num_units -= lost_units;\n\t}\n\tleft.retain (|group| group.num_units \u003e 0);\n\tright.retain (|group| group.num_units \u003e 0);\n\tOk (progress)\n}\n\nfn choose_targets (\n\tatt_groups: \u0026 [Group],\n\tdef_groups: \u0026 [Group],\n) -\u003e NumResult \u003cVec \u003c(usize, usize)\u003e\u003e {\n\tlet mut result = Vec::new ();\n\tlet att_groups: Vec \u003c(usize, \u0026 Group)\u003e =\n\t\tatt_groups.iter ()\n\t\t\t.enumerate ()\n\t\t\t.sorted_by_key (|\u0026 (_, group)|\n\t\t\t\tcmp::Reverse ((group.effective_power (), group.initiative)))\n\t\t\t.collect ();\n\tlet mut def_groups: Vec \u003c(usize, \u0026 Group)\u003e =\n\t\tdef_groups.iter ()\n\t\t\t.enumerate ()\n\t\t\t.collect ();\n\tfor (att_idx, att_group) in att_groups.iter ().copied () {\n\t\tif let Some ((def_idx, _, _)) =\n\t\t\tdef_groups.iter ().copied ()\n\t\t\t\t.filter (|\u0026 (_, def_group)|\n\t\t\t\t\t! def_group.has_immunity (att_group.attack_type))\n\t\t\t\t.map (|(def_idx, def_group)| Ok ((\n\t\t\t\t\tdef_idx,\n\t\t\t\t\tdef_group,\n\t\t\t\t\tif def_group.has_weakness (att_group.attack_type) {\n\t\t\t\t\t\tchk! (att_group.effective_power () * 2) ?\n\t\t\t\t\t} else {\n\t\t\t\t\t\tatt_group.effective_power ()\n\t\t\t\t\t}\n\t\t\t\t)))\n\t\t\t\t.max_ok_by_key (|\u0026 (_, def_group, damage)| (\n\t\t\t\t\tdamage,\n\t\t\t\t\tdef_group.effective_power (),\n\t\t\t\t\tdef_group.initiative,\n\t\t\t\t)) ? {\n\t\t\tresult.push ((att_idx, def_idx));\n\t\t\tdef_groups.retain (|\u0026 (idx, _)| idx != def_idx);\n\t\t}\n\t}\n\tOk (result)\n}\n","traces":[{"line":9,"address":[49040],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[49053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[49162,49098,49123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[49174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[49232],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[49252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[49299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[49315,49448,49565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[49347,49549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[49455,49360,49388,49415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[49420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[49493,49515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[49502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[49600],"length":1,"stats":{"Line":2},"fn_name":"sanity_check"},{"line":35,"address":[49804,49835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[49809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[49842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[49888,50572],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":48,"address":[50024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[50472,50034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[50147,50090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[50128,50141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[50145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[67696],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":60,"address":[67712],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":61,"address":[50419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[50592,51838],"length":1,"stats":{"Line":2},"fn_name":"one_round"},{"line":68,"address":[50928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[50680,50661],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[67728,67731],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":71,"address":[50786,50808],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[51787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[67760,67765],"length":1,"stats":{"Line":8},"fn_name":"{closure#2}"},{"line":74,"address":[67768],"length":1,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[67810],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[67774],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[50983,51040,51234,51139,51823],"length":1,"stats":{"Line":8},"fn_name":null},{"line":85,"address":[51320,51420],"length":1,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[51435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[51464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[51515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[51502,51538],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[60078,60245],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[61198,61365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[51599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[51856,52571],"length":1,"stats":{"Line":2},"fn_name":"choose_targets"},{"line":104,"address":[51936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[67905,67904],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":108,"address":[67917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[52371,52134],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[52245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[66586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[33329],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[66900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[66793,66714],"length":1,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[68112,68096,66824],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[67956,67952,67974],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":131,"address":[67971],"length":1,"stats":{"Line":4},"fn_name":null},{"line":134,"address":[60839,60674],"length":1,"stats":{"Line":3},"fn_name":null},{"line":137,"address":[52380],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":60},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-24","model.rs"],"content":"use super::*;\n\npub type Val = u32;\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Group {\n\tpub num_units: Val,\n\tpub hit_points: Val,\n\tpub weaknesses: Vec \u003cAttackType\u003e,\n\tpub immunities: Vec \u003cAttackType\u003e,\n\tpub attack_damage: Val,\n\tpub attack_type: AttackType,\n\tpub initiative: Val,\n}\n\nstruct_parser_display! {\n\tGroup { num_units, hit_points, weaknesses, immunities, attack_damage, attack_type, initiative } = [\n\t\tnum_units, \" units each with \", hit_points, \" hit points \",\n\t\t(weaknesses, immunities) {\n\t\t\tdisplay_type = (\u0026 [AttackType], \u0026 [AttackType]);\n\t\t\t(weaknesses, immunities) if (! weaknesses.is_empty () \u0026\u0026 ! immunities.is_empty ()) = [\n\t\t\t\t\"(weak to \", @delim \", \" weaknesses, \"; \",\n\t\t\t\t\"immune to \", @delim \", \" immunities, \") \",\n\t\t\t],\n\t\t\t(weaknesses, immunities) if (false) = [\n\t\t\t\t\"(immune to \", @delim \", \" immunities, \"; \",\n\t\t\t\t\"weak to \", @delim \", \" weaknesses, \") \",\n\t\t\t],\n\t\t\t(weaknesses, immunities) if (! weaknesses.is_empty ()) = [\n\t\t\t\t\"(weak to \", @delim \", \" weaknesses, \") \",\n\t\t\t\t@parse immunities { Vec::new () },\n\t\t\t],\n\t\t\t(weaknesses, immunities) if (! immunities.is_empty ()) = [\n\t\t\t\t@parse weaknesses { Vec::new () },\n\t\t\t\t\"(immune to \", @delim \", \" immunities, \") \",\n\t\t\t],\n\t\t\t(weaknesses, immunities) = [\n\t\t\t\t@parse weaknesses { Vec::new () },\n\t\t\t\t@parse immunities { Vec::new () },\n\t\t\t],\n\t\t},\n\t\t\"with an attack that does \", attack_damage, \" \", attack_type, \" damage \",\n\t\t\"at initiative \", initiative,\n\t]\n}\n\nimpl Group {\n\n\t#[ must_use ]\n\tpub const fn effective_power (\u0026 self) -\u003e Val {\n\t\tself.num_units * self.attack_damage\n\t}\n\n\t#[ must_use ]\n\tpub fn has_weakness (\u0026 self, attack_type: AttackType) -\u003e bool {\n\t\tself.weaknesses.contains (\u0026 attack_type)\n\t}\n\n\t#[ must_use ]\n\tpub fn has_immunity (\u0026 self, attack_type: AttackType) -\u003e bool {\n\t\tself.immunities.contains (\u0026 attack_type)\n\t}\n\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum AttackType {\n\t\tBludgeoning = \"bludgeoning\",\n\t\tCold = \"cold\",\n\t\tFire = \"fire\",\n\t\tRadiation = \"radiation\",\n\t\tSlashing = \"slashing\",\n\t}\n}\n","traces":[{"line":17,"address":[53771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[85481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[85993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[86333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[86646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[38842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[52592],"length":1,"stats":{"Line":0},"fn_name":"effective_power"},{"line":51,"address":[74378,73897],"length":1,"stats":{"Line":12},"fn_name":null},{"line":55,"address":[52640],"length":1,"stats":{"Line":0},"fn_name":"has_weakness"},{"line":60,"address":[52752],"length":1,"stats":{"Line":0},"fn_name":"has_immunity"},{"line":67,"address":[33385,33636],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":5,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-25","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"0,0,0,0\",\n\t\"3,0,0,0\",\n\t\"0,3,0,0\",\n\t\"0,0,3,0\",\n\t\"0,0,0,3\",\n\t\"0,0,0,6\",\n\t\"9,0,0,0\",\n\t\"12,0,0,0\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"-1,2,2,0\",\n\t\"0,0,2,-2\",\n\t\"0,0,0,-2\",\n\t\"-1,2,0,0\",\n\t\"-2,-2,-2,2\",\n\t\"3,0,2,-1\",\n\t\"-1,3,2,2\",\n\t\"-1,0,-1,0\",\n\t\"0,2,1,-2\",\n\t\"3,0,0,0\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"1,-1,0,1\",\n\t\"2,0,-1,0\",\n\t\"3,2,-1,0\",\n\t\"0,0,3,1\",\n\t\"0,0,-1,-1\",\n\t\"2,3,-2,0\",\n\t\"-2,2,0,0\",\n\t\"2,-2,0,-1\",\n\t\"1,-1,0,-1\",\n\t\"3,2,0,2\",\n];\n\nconst EXAMPLE_3: \u0026 [\u0026 str] = \u0026 [\n\t\"1,-1,-1,-2\",\n\t\"-2,-2,0,1\",\n\t\"0,2,1,3\",\n\t\"-2,3,-2,1\",\n\t\"0,2,3,-2\",\n\t\"-1,-1,1,-2\",\n\t\"0,-2,-1,0\",\n\t\"-2,2,3,-1\",\n\t\"1,2,2,0\",\n\t\"-1,-2,0,-2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"3\", puzzle.part_one (EXAMPLE_2));\n\tassert_eq_ok! (\"8\", puzzle.part_one (EXAMPLE_3));\n}\n","traces":[{"line":56,"address":[27760,27764],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":57,"address":[46785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[47378,46901,47973,46848,46806,47315],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[47504,47012,47444,47937,46959,46921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[47570,47132,47076,47032,47898,47630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[47152,47693,47859,47196,47753,47252],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-25","input.rs"],"content":"use super::*;\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub coords: Vec \u003cInputCoord\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput {\n\t\tcoords,\n\t\tparams,\n\t} = [\n\t\tparams,\n\t\t@lines coords,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct InputCoord {\n\tpub coord: Pos,\n}\n\nstruct_parser_display! {\n\tInputCoord { coord: Pos { x, y, z, t } } = [ x, \",\", y, \",\", z, \",\", t ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[31044],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-25","lib.rs"],"content":"//! Advent of Code 2018: Day 25: Four-Dimensional Adventure\n//!\n//! [https://adventofcode.com/2018/day/25](https://adventofcode.com/2018/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\npub mod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Four-Dimensional Adventure\";\n\tyear = 2018;\n\tday = 25;\n\tparse = |input_lines| input::Input::parse_from_lines (input_lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n","traces":[{"line":20,"address":[36840],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-25","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Coord;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut remain: Vec \u003cPos\u003e =\n\t\tinput.coords.iter ()\n\t\t\t.map (|line| line.coord)\n\t\t\t.collect ();\n\tlet mut remain_temp = Vec::new ();\n\tlet mut constellations: Vec \u003cVec \u003cPos\u003e\u003e = Vec::new ();\n\twhile let Some (first_pos) = remain.pop () {\n\t\tlet mut todo = Vec::new ();\n\t\ttodo.push (first_pos);\n\t\tlet mut constellation = Vec::new ();\n\t\twhile let Some (pos_0) = todo.pop () {\n\t\t\tconstellation.push (pos_0);\n\t\t\tfor pos_1 in remain.drain ( .. ) {\n\t\t\t\tif get_dist (pos_0, pos_1) ? \u003c= 3 {\n\t\t\t\t\ttodo.push (pos_1);\n\t\t\t\t} else {\n\t\t\t\t\tremain_temp.push (pos_1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmem::swap (\u0026 mut remain, \u0026 mut remain_temp);\n\t\t}\n\t\tconstellations.push (constellation);\n\t}\n\tOk (constellations.len ().pan_u32 ())\n}\n\nfn get_dist (pos_0: Pos, pos_1: Pos) -\u003e NumResult \u003cCoord\u003e {\n\tCoord::add_4 (\n\t\tCoord::sub_2 (pos_0.x, pos_1.x) ?.abs (),\n\t\tCoord::sub_2 (pos_0.y, pos_1.y) ?.abs (),\n\t\tCoord::sub_2 (pos_0.z, pos_1.z) ?.abs (),\n\t\tCoord::sub_2 (pos_0.t, pos_1.t) ?.abs (),\n\t)\n}\n","traces":[{"line":8,"address":[34720,35950],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[25682],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[34881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[35023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[35121,35263,35879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[35269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[35482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[35774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[35968],"length":1,"stats":{"Line":1},"fn_name":"get_dist"},{"line":37,"address":[35999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[36081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[36163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[36234],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":13,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","day-25","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Pos = pos::PosXYZT \u003cCoord\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2018_day_01 as day_01;\npub use aoc_2018_day_02 as day_02;\npub use aoc_2018_day_03 as day_03;\npub use aoc_2018_day_04 as day_04;\npub use aoc_2018_day_05 as day_05;\npub use aoc_2018_day_06 as day_06;\npub use aoc_2018_day_07 as day_07;\npub use aoc_2018_day_08 as day_08;\npub use aoc_2018_day_09 as day_09;\npub use aoc_2018_day_10 as day_10;\npub use aoc_2018_day_11 as day_11;\npub use aoc_2018_day_12 as day_12;\npub use aoc_2018_day_13 as day_13;\npub use aoc_2018_day_14 as day_14;\npub use aoc_2018_day_15 as day_15;\npub use aoc_2018_day_16 as day_16;\npub use aoc_2018_day_17 as day_17;\npub use aoc_2018_day_18 as day_18;\npub use aoc_2018_day_19 as day_19;\npub use aoc_2018_day_20 as day_20;\npub use aoc_2018_day_21 as day_21;\npub use aoc_2018_day_22 as day_22;\npub use aoc_2018_day_23 as day_23;\npub use aoc_2018_day_24 as day_24;\npub use aoc_2018_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"12\",\n\t\"14\",\n\t\"1969\",\n\t\"100756\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"34241\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"51316\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[22180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[33562],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[33730,33621,33673,33583,33796,33900],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[22148],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[33962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[34130,34073,33983,34196,34300,34021],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-01","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub module_masses: Vec \u003cu32\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput {\n\t\tmodule_masses,\n\t\tparams,\n\t} = [\n\t\tparams,\n\t\t@lines module_masses,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[21691],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-01","lib.rs"],"content":"//! Advent of Code 2019: Day 1: The Tyranny of the Rocket Equation\n//!\n//! [https://adventofcode.com/2019/day/01](https://adventofcode.com/2019/day/01)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"The Tyranny of the Rocket Equation\";\n\tyear = 2019;\n\tday = 1;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-01","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.module_masses.iter ().copied ()\n\t\t\t.map (|mass| if 6 \u003c mass { mass / 3 - 2 } else { 0 })\n\t\t\t.try_fold (0, u32::add_2) ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.module_masses.iter ().copied ()\n\t\t\t.map (|mut mass| {\n\t\t\t\tlet mut sum = 0;\n\t\t\t\tloop {\n\t\t\t\t\tmass /= 3;\n\t\t\t\t\tif mass \u003c= 2 { break }\n\t\t\t\t\tmass -= 2;\n\t\t\t\t\tsum += mass;\n\t\t\t\t}\n\t\t\t\tsum\n\t\t\t})\n\t\t\t.try_fold (0, u32::add_2) ?\n\t)\n}\n","traces":[{"line":6,"address":[26080],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[26117,26139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[23512,23614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[26208],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":16,"address":[26245,26267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[42176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":20,"address":[23744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[23736,23763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[23848,23754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[23759,23875],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":7,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-02","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput {\n\t\tdata,\n\t\tparams,\n\t} = [\n\t\tparams,\n\t\t@delim \",\" data,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_ops: u32 = (\"MAX_OPS=\", 100, 1_u32 ..),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-02","lib.rs"],"content":"//! Advent of Code 2019: Day 2: 1202 Program Alarm\n//!\n//! [https://adventofcode.com/2019/day/02](https://adventofcode.com/2019/day/02)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"1202 Program Alarm\";\n\tyear = 2019;\n\tday = 2;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-02","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Cpu;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result (input, 12, 2)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tfor noun in 0_i32 .. 100_i32 {\n\t\tfor verb in 0_i32 .. 100_i32 {\n\t\t\tif calc_result (input, noun, verb) ? != 19_690_720_i32 { continue }\n\t\t\treturn Ok (noun * 100_i32 + verb)\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\nfn calc_result (input: \u0026 Input, noun: Val, verb: Val) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_max_ops (input.params.max_ops);\n\tcpu.mem_set (1_i32, noun).unwrap ();\n\tcpu.mem_set (2_i32, verb).unwrap ();\n\tcpu.run ().halt () ?;\n\tOk (cpu.mem_get (0_i32).unwrap ())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-02","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Mem = intcode::Mem \u003cVal\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i32;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"R8,U5,L5,D3\",\n\t\"U7,R6,D4,L4\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"R75,D30,R83,U83,L12,D49,R71,U7,L72\",\n\t\"U62,R66,U55,R34,D71,R55,D58,R83\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51\",\n\t\"U98,R91,D20,R16,D67,R40,U7,R15,U6,R7\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"159\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"135\", puzzle.part_one (EXAMPLE_2));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"30\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"610\", puzzle.part_two (EXAMPLE_1));\n\tassert_eq_ok! (\"410\", puzzle.part_two (EXAMPLE_2));\n}\n","traces":[{"line":21,"address":[28404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[61041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[61469,61535,61160,61104,61976,61062],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[61603,61664,61182,61938,61220,61279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[61729,61301,61345,61404,61790,61897],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[28436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[62049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[62112,62477,62984,62543,62168,62070],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[62287,62611,62946,62228,62672,62190],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[62905,62309,62353,62798,62737,62412],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-03","input.rs"],"content":"use super::*;\n\nuse model::Step;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub wire_0: Vec \u003cStep\u003e,\n\tpub wire_1: Vec \u003cStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput {\n\t\twire_0,\n\t\twire_1,\n\t\tparams,\n\t} = [\n\t\tparams,\n\t\t@delim \",\" wire_0, \"\\n\",\n\t\t@delim \",\" wire_1,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[63245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[63264],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-03","lib.rs"],"content":"//! Advent of Code 2019: Day 3: Crossed Wires\n//!\n//! [https://adventofcode.com/2019/day/03](https://adventofcode.com/2019/day/03)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Crossed Wires\";\n\tyear = 2019;\n\tday = 3;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[60156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[60556],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-03","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Pos;\nuse model::Step;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tsanity_check (input) ?;\n\tlet map_0 = line_points (\u0026 input.wire_0) ?;\n\tlet map_1 = line_points (\u0026 input.wire_1) ?;\n\tlet set_0: HashSet \u003cPos\u003e = map_0.keys ().copied ().collect ();\n\tlet set_1: HashSet \u003cPos\u003e = map_1.keys ().copied ().collect ();\n\tOk (\n\t\tset_0.intersection (\u0026 set_1)\n\t\t\t.map (|pos| pos.x.abs () + pos.y.abs ())\n\t\t\t.min ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tlet map_0 = line_points (\u0026 input.wire_0) ?;\n\tlet map_1 = line_points (\u0026 input.wire_1) ?;\n\tlet set_0: HashSet \u003cPos\u003e = map_0.keys ().copied ().collect ();\n\tlet set_1: HashSet \u003cPos\u003e = map_1.keys ().copied ().collect ();\n\tOk (\n\t\tset_0.intersection (\u0026 set_1)\n\t\t\t.map (|pos| map_0 [pos] + map_1 [pos])\n\t\t\t.min ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tfor step in iter::empty ()\n\t\t\t.chain (\u0026 input.wire_0)\n\t\t\t.chain (\u0026 input.wire_1) {\n\t\tif step.num \u003c 1 { return Err (\"Step distance must be one or more\".into ()) }\n\t}\n\tOk (())\n}\n\nfn line_points (steps: \u0026 [Step]) -\u003e GenResult \u003cHashMap \u003cPos, u32\u003e\u003e {\n\tlet mut result = HashMap::new ();\n\tlet mut pos = Pos::ZERO;\n\tlet mut dist = 0_u32;\n\tfor step in steps {\n\t\tfor _ in 0 .. step.num {\n\t\t\tpos = pos.try_add ((step.dir, 1)) ?;\n\t\t\tdist += 1;\n\t\t\tresult.entry (pos).or_insert (dist);\n\t\t}\n\t}\n\tOk (result)\n}\n","traces":[{"line":9,"address":[30416,32106],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[30439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[30604,30770,30529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[30797,30707,31476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[31574,31590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[59190,59247,59232,59211],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[32128,33841],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":24,"address":[32151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[32482,32316,32241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[33188,32419,32509],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[33312,33327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[49204,48954,47697,47530,49121,48768,48788,47364,47780],"length":1,"stats":{"Line":7},"fn_name":null},{"line":37,"address":[33856],"length":1,"stats":{"Line":1},"fn_name":"sanity_check"},{"line":38,"address":[34051,34036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[34041,34058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[34112,34817],"length":1,"stats":{"Line":1},"fn_name":"line_points"},{"line":50,"address":[34289,34272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[34323,34380,34332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[34391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[34427,34763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[34622],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":21,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-03","model.rs"],"content":"use super::*;\n\npub type Dir = aoc_pos::Dir2d;\npub type Pos = aoc_pos::PosYX \u003cVal\u003e;\npub type Val = i16;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Step {\n\tpub dir: Dir,\n\tpub num: Val,\n}\n\nimpl Display for Step {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter,\n\t\t\t\"{dir}{num}\",\n\t\t\tdir = match self.dir {\n\t\t\t\tDir::Up =\u003e 'U',\n\t\t\t\tDir::Down =\u003e 'D',\n\t\t\t\tDir::Left =\u003e 'L',\n\t\t\t\tDir::Right =\u003e 'R',\n\t\t\t},\n\t\t\tnum = self.num)\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Step {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tparse! (parser, dir_ch: char);\n\t\tlet dir = match dir_ch {\n\t\t\t'U' =\u003e Dir::Up,\n\t\t\t'D' =\u003e Dir::Down,\n\t\t\t'L' =\u003e Dir::Left,\n\t\t\t'R' =\u003e Dir::Right,\n\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t};\n\t\tparse! (parser, num);\n\t\tOk (Self { dir, num })\n\t}\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-04","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub min: u32,\n\tpub max: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { min, max, params } = [ params, min, \"-\", max ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-04","lib.rs"],"content":"//! Advent of Code 2019: Day 4: Secure Container\n//!\n//! [https://adventofcode.com/2019/day/04](https://adventofcode.com/2019/day/04)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Secure Container\";\n\tyear = 2019;\n\tday = 4;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-04","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tOk (\n\t\titer_passwords (input)\n\t\t\t.filter (is_ascending)\n\t\t\t.filter (has_repeated)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tsanity_check (input) ?;\n\tOk (\n\t\titer_passwords (input)\n\t\t\t.filter (is_ascending)\n\t\t\t.filter (has_repeated_alone)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\nfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tlet range = 100_000 ..= 999_999;\n\tif ! range.contains (\u0026 input.min) || ! range.contains (\u0026 input.max) {\n\t\treturn Err (\"Password must be a six digit number\".into ());\n\t}\n\tOk (())\n}\n\nfn iter_passwords (input: \u0026 Input) -\u003e impl Iterator \u003cItem = [char; 6]\u003e {\n\tlet first_password = num_to_char_array (input.min);\n\tlet last_password = num_to_char_array (input.max);\n\titer::successors (Some (first_password), |\u0026 password| next_password (password))\n\t\t.take_while (move |\u0026 password| password \u003c= last_password)\n}\n\nfn num_to_char_array (num: u32) -\u003e [char; 6] {\n\tnum.to_string ().chars ()\n\t\t.collect::\u003cVec \u003cchar\u003e\u003e ()\n\t\t.try_into ()\n\t\t.unwrap ()\n}\n\nfn next_password (mut password: [char; 6]) -\u003e Option \u003c[char; 6]\u003e {\n\tlet mut idx = 5;\n\tlet mut ch;\n\tloop {\n\t\tch = password [idx];\n\t\tif ch != '9' { break }\n\t\tif idx == 0 { return None }\n\t\tidx -= 1;\n\t}\n\tch = (ch.pan_u32 () + 1).pan_char ();\n\tpassword.iter_mut ().skip (idx).for_each (|password_ch| * password_ch = ch);\n\tSome (password)\n}\n\nfn is_ascending (password: \u0026 [char; 6]) -\u003e bool {\n\tpassword.iter ()\n\t\t.tuple_windows ()\n\t\t.all (|(a, b)| a \u003c= b)\n}\n\nfn has_repeated (password: \u0026 [char; 6]) -\u003e bool {\n\tpassword.iter ()\n\t\t.tuple_windows ()\n\t\t.any (|(a, b)| a == b)\n}\n\nfn has_repeated_alone (password: \u0026 [char; 6]) -\u003e bool {\n\titer::empty ()\n\t\t.chain (iter::once ('X'))\n\t\t.chain (password.iter ().copied ())\n\t\t.chain (iter::once ('X'))\n\t\t.tuple_windows ()\n\t\t.any (|(a, b, c, d)| a != b \u0026\u0026 b == c \u0026\u0026 c != d)\n}\n","traces":[{"line":50,"address":[4448],"length":1,"stats":{"Line":0},"fn_name":"next_password"},{"line":54,"address":[4479,4506,4468,4519,4488,4497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[4510,4522,4474,4501,4483,4492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4608,4894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4833],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-05","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-05","lib.rs"],"content":"//! Advent of Code 2019: Day 5: Sunny with a Chance of Asteroids\n//!\n//! [https://adventofcode.com/2019/day/05](https://adventofcode.com/2019/day/05)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Sunny with a Chance of Asteroids\";\n\tyear = 2019;\n\tday = 5;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-05","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Cpu;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result (input, 1)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result (input, 5)\n}\n\nfn calc_result (input: \u0026 Input, mode: Val) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_max_ops (300);\n\tcpu.input (mode);\n\tlet mut last_output = None;\n\twhile let Some (val) = cpu.run ().output () ? {\n\t\tlast_output = Some (val);\n\t}\n\tOk (last_output.ok_or (\"No diagnostic code received\") ?)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-05","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Mem = intcode::Machine \u003cVal\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i32;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-06","input.rs"],"content":"use super::*;\n\nuse model::Orbit;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub orbits: Vec \u003cOrbit \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { orbits, params } = [ params, @lines orbits ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-06","lib.rs"],"content":"//! Advent of Code 2019: Day 6: Universal Orbit Map\n//!\n//! [https://adventofcode.com/2019/day/06](https://adventofcode.com/2019/day/06)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Universal Orbit Map\";\n\tyear = 2019;\n\tday = 6;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-06","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one \u003c'inp\u003e (input: \u0026 Input \u003c'inp\u003e) -\u003e GenResult \u003cu32\u003e {\n\tlet parent_map: HashMap \u003cInpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e\u003e =\n\t\tinput.orbits.iter ()\n\t\t\t.map (|orbit| (orbit.satl.clone (), orbit.base.clone ()))\n\t\t\t.collect ();\n\tlet com = InpStr::borrow (\"COM\");\n\tlet mut sum: u32 = 0;\n\tfor (start, _) in parent_map.iter () {\n\t\tlet mut current = start.clone ();\n\t\tlet mut seen = HashSet::new ();\n\t\twhile current != com {\n\t\t\tif ! seen.insert (current.clone ()) { return Err (\"Loop detected\".into ()) }\n\t\t\tsum += 1;\n\t\t\tcurrent = parent_map.get (\u0026 current)\n\t\t\t\t.ok_or (format! (\"No parent for {current}\")) ?\n\t\t\t\t.clone ();\n\t\t}\n\t}\n\tOk (sum)\n}\n\npub fn part_two \u003c'inp\u003e (input: \u0026 Input \u003c'inp\u003e) -\u003e GenResult \u003cu32\u003e {\n\n\tlet parent_map: HashMap \u003cInpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e\u003e =\n\t\tinput.orbits.iter ()\n\t\t\t.map (|orbit| (orbit.satl.clone (), orbit.base.clone ()))\n\t\t\t.collect ();\n\n\tlet you = InpStr::borrow (\"YOU\");\n\tlet san = InpStr::borrow (\"SAN\");\n\n\tlet mut you_chain = chain (\u0026 parent_map, you.clone ()) ?;\n\tlet mut san_chain = chain (\u0026 parent_map, san.clone ()) ?;\n\n\tif let Some (pos) = you_chain.iter ().position (|name| name == \u0026 san) {\n\t\treturn Ok (pos.pan_u32 ())\n\t}\n\tif let Some (pos) = san_chain.iter ().position (|name| name == \u0026 you) {\n\t\treturn Ok (pos.pan_u32 ())\n\t}\n\n\tloop {\n\t\tif you_chain.is_empty () || san_chain.is_empty () { break }\n\t\tif you_chain.last ().unwrap () != san_chain.last ().unwrap () { break }\n\t\tyou_chain.pop ().unwrap ();\n\t\tsan_chain.pop ().unwrap ();\n\t}\n\n\tOk ((you_chain.len () + san_chain.len () - 2).pan_u32 ())\n\n}\n\nfn chain \u003c'inp\u003e (\n\tparent_map: \u0026 HashMap \u003cInpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e\u003e,\n\tkey: InpStr \u003c'inp\u003e,\n) -\u003e GenResult \u003cVec \u003cInpStr \u003c'inp\u003e\u003e\u003e {\n\tlet mut result: Vec \u003cInpStr\u003e = Vec::new ();\n\tlet mut current = key;\n\tlet com = InpStr::borrow (\"COM\");\n\twhile current != com {\n\t\tif result.contains (\u0026 current) { return Err (\"Loop detected\".into ()) }\n\t\tresult.push (current.clone ());\n\t\tcurrent = parent_map.get (\u0026 current)\n\t\t\t.ok_or (format! (\"No parent for {current}\")) ?\n\t\t\t.clone ();\n\t}\n\tOk (result)\n}\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-06","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Orbit \u003c'inp\u003e {\n\tpub base: InpStr \u003c'inp\u003e,\n\tpub satl: InpStr \u003c'inp\u003e,\n}\n\nstruct_parser! {\n\tinput_lifetime = 'inp;\n\tOrbit \u003c'inp\u003e { base, satl } = [ base = parse_object, \")\", satl = parse_object ]\n}\n\nstruct_display! {\n\tinput_lifetime = 'inp;\n\tOrbit \u003c'inp\u003e { base, satl } = [ base, \")\", satl ]\n}\n\nfn parse_object \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tparser.take_rest_while (|ch| ch.is_ascii_alphanumeric (), .. )\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-07","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_ops_one: u32 = (\"MAX_OPS_ONE=\", 20, 1_u32 .. ),\n\t\tpub max_ops_two: u32 = (\"MAX_OPS_TWO=\", 100, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-07","lib.rs"],"content":"//! Advent of Code 2019: Day 7: Amplification Circuit\n//!\n//! [https://adventofcode.com/2019/day/07](https://adventofcode.com/2019/day/07)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Amplification Circuit\";\n\tyear = 2019;\n\tday = 7;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-07","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Cpu;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut todo: Vec \u003c(ArrayVec \u003cVal, 5\u003e, Val)\u003e = Vec::new ();\n\ttodo.push ((ArrayVec::new (), Val::ZERO));\n\tlet mut highest = Val::ZERO;\n\twhile let Some ((phases, value)) = todo.pop () {\n\t\tif phases.len () == 5 {\n\t\t\tif value \u003c= highest { continue }\n\t\t\thighest = value;\n\t\t\tcontinue;\n\t\t}\n\t\tfor phase in Val::ZERO .. Val::FIVE {\n\t\t\tif phases.contains (\u0026 phase) { continue }\n\t\t\tlet mut phases = phases.clone ();\n\t\t\tphases.push (phase);\n\t\t\tlet mut cpu = Cpu::new (input.data.clone ());\n\t\t\tcpu.set_max_ops (input.params.max_ops_one);\n\t\t\tcpu.input (phase);\n\t\t\tcpu.input (value);\n\t\t\tlet value = cpu.run ().output () ?.ok_or (\"Program generated no output\") ?;\n\t\t\ttodo.push ((phases, value));\n\t\t}\n\t}\n\tOk (highest)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut highest = Val::ZERO;\n\tlet mut todo: Vec \u003cArrayVec \u003cVal, 5\u003e\u003e = Vec::new ();\n\ttodo.push (ArrayVec::new ());\n\twhile let Some (phases) = todo.pop () {\n\t\tif phases.len () \u003c 5 {\n\t\t\tfor phase in Val::FIVE ..= Val::NINE {\n\t\t\t\tif phases.contains (\u0026 phase) { continue }\n\t\t\t\tlet mut phases = phases.clone ();\n\t\t\t\tphases.push (phase);\n\t\t\t\ttodo.push (phases);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tlet mut cpus: Vec \u003cCpu\u003e =\n\t\t\tphases.iter ().copied ()\n\t\t\t\t.map (|phase| {\n\t\t\t\t\tlet mut cpu = Cpu::new (input.data.clone ());\n\t\t\t\t\tcpu.set_max_ops (input.params.max_ops_two);\n\t\t\t\t\tcpu.input (phase);\n\t\t\t\t\tcpu\n\t\t\t\t})\n\t\t\t\t.collect ();\n\t\tlet mut value = Val::ZERO;\n\t\t'CALC: loop {\n\t\t\tfor cpu in cpus.iter_mut () {\n\t\t\t\tcpu.input (value);\n\t\t\t\tvalue = some_or! (cpu.run ().output () ?, break 'CALC);\n\t\t\t}\n\t\t}\n\t\thighest = cmp::max (highest, value);\n\t}\n\tOk (highest)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-07","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Val = i32;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-08","input.rs"],"content":"use super::*;\nuse model::Pixel;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub pixels: Vec \u003cPixel\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { pixels, params } = [ params, @collect pixels ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-08","lib.rs"],"content":"//! Advent of Code 2019: Day 8: Space Image Format\n//!\n//! [https://adventofcode.com/2019/day/08](https://adventofcode.com/2019/day/08)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_ocr as ocr;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Space Image Format\";\n\tyear = 2019;\n\tday = 8;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-08","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Pixel;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet layers: Vec \u003cVec \u003cPixel\u003e\u003e =\n\t\tinput.pixels.iter ().copied ()\n\t\t\t.chunks (25 * 6)\n\t\t\t.into_iter ()\n\t\t\t.map (Iterator::collect)\n\t\t\t.collect ();\n\tlet most_black_idx =\n\t\tlayers.iter ().enumerate ()\n\t\t\t.map (|(layer_idx, pixels)| (\n\t\t\t\tlayer_idx,\n\t\t\t\tpixels.iter ().copied ()\n\t\t\t\t\t.filter (|\u0026 pixel| pixel == Pixel::Black)\n\t\t\t\t\t.count ()))\n\t\t\t.min_by_key (|\u0026 (_, num_black)| num_black)\n\t\t\t.map (|(idx, _)| idx)\n\t\t\t.ok_or (\"No solution found\") ?;\n\tlet most_black_layer = \u0026 layers [most_black_idx];\n\tlet (num_white, num_transparent) =\n\t\tmost_black_layer.iter ().copied ()\n\t\t\t.fold ((0, 0), |(sum_white, sum_transparent), pixel| match pixel {\n\t\t\t\tPixel::Black =\u003e (sum_white, sum_transparent),\n\t\t\t\tPixel::White =\u003e (sum_white + 1, sum_transparent),\n\t\t\t\tPixel::Transparent =\u003e (sum_white, sum_transparent + 1),\n\t\t\t});\n\tOk (num_white * num_transparent)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet start: Vec \u003cPixel\u003e = iter::repeat (Pixel::Transparent).take (25 * 6).collect ();\n\tlet image: Vec \u003cPixel\u003e =\n\t\tinput.pixels.iter ().copied ()\n\t\t\t.chunks (25 * 6)\n\t\t\t.into_iter ()\n\t\t\t.fold (start, |mut image, layer| {\n\t\t\t\tfor (im_pixel, lr_pixel) in Iterator::zip (image.iter_mut (), layer) {\n\t\t\t\t\tif * im_pixel != Pixel::Transparent { continue }\n\t\t\t\t\t* im_pixel = lr_pixel;\n\t\t\t\t}\n\t\t\t\timage\n\t\t\t});\n\tlet mut result = String::new ();\n\tfor ch_idx in 0 .. 5 {\n\t\tlet ch_str = ocr::read_dots (\n\t\t\timage.iter ().copied ().enumerate ()\n\t\t\t\t.filter_map (|(idx, val)| {\n\t\t\t\t\tlet row = idx / 25;\n\t\t\t\t\tlet col = idx % 25;\n\t\t\t\t\tif col / 5 != ch_idx { return None }\n\t\t\t\t\tmatch val {\n\t\t\t\t\t\tPixel::Black =\u003e None,\n\t\t\t\t\t\tPixel::White =\u003e Some ((row, col)),\n\t\t\t\t\t\tPixel::Transparent =\u003e None,\n\t\t\t\t\t}\n\t\t\t\t})) ?;\n\t\tresult += \u0026 ch_str;\n\t}\n\tOk (result)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-08","model.rs"],"content":"use super::*;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Pixel {\n\t\tBlack = \"0\",\n\t\tWhite = \"1\",\n\t\tTransparent = \"2\",\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-09","input.rs"],"content":"use super::*;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-09","lib.rs"],"content":"//! Advent of Code 2019: Day 9: Sensor Boost\n//!\n//! [https://adventofcode.com/2019/day/09](https://adventofcode.com/2019/day/09)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Sensor Boost\";\n\tyear = 2019;\n\tday = 9;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-09","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Cpu;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result (input, 1, 500)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result (input, 2, 500_000)\n}\n\nfn calc_result (input: \u0026 Input, mode: Val, max_ops: u32) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_max_ops (max_ops);\n\tcpu.input (mode);\n\tOk (cpu.run ().output () ?.ok_or (\"No output from program\") ?)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-09","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Val = i64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"......#.#.\",\n\t\"#..#.#....\",\n\t\"..#######.\",\n\t\".#.#.###..\",\n\t\".#..#.....\",\n\t\"..#....#.#\",\n\t\"#..#....#.\",\n\t\".##.#..###\",\n\t\"##...#..#.\",\n\t\".#....####\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"#.#...#.#.\",\n\t\".###....#.\",\n\t\".#....#...\",\n\t\"##.#.#.#.#\",\n\t\"....#.#.#.\",\n\t\".##..###.#\",\n\t\"..#...##..\",\n\t\"..##....##\",\n\t\"......#...\",\n\t\".####.###.\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\".#..#..###\",\n\t\"####.###.#\",\n\t\"....###.#.\",\n\t\"..###.##.#\",\n\t\"##.##.#.#.\",\n\t\"....###..#\",\n\t\"..#.#..#.#\",\n\t\"#..#.#.###\",\n\t\".##...##.#\",\n\t\".....#.#..\",\n];\n\nconst EXAMPLE_3: \u0026 [\u0026 str] = \u0026 [\n\t\".#..##.###...#######\",\n\t\"##.############..##.\",\n\t\".#.######.########.#\",\n\t\".###.#######.####.#.\",\n\t\"#####.##.#.##.###.##\",\n\t\"..#####..#.#########\",\n\t\"####################\",\n\t\"#.####....###.#.#.##\",\n\t\"##.#################\",\n\t\"#####.##.###..####..\",\n\t\"..######..##.#######\",\n\t\"####.##.####...##..#\",\n\t\".#####..#.######.###\",\n\t\"##...#.##########...\",\n\t\"#.##########.#######\",\n\t\".####.#.###.###.#.##\",\n\t\"....##.##.###..#####\",\n\t\".#.#.###########.###\",\n\t\"#.#.#.#####.####.###\",\n\t\"###.##.####.##.#..##\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"33\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"35\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"41\", puzzle.part_one (EXAMPLE_2));\n\tassert_eq_ok! (\"210\", puzzle.part_one (EXAMPLE_3));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"802\", puzzle.part_two (EXAMPLE_3));\n}\n","traces":[{"line":68,"address":[65044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[74567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[74621,75228,74584,74674,75168,75848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[74694,74796,75294,74740,75354,75809],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[74816,75420,75770,75480,74862,74918],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[74984,75543,75731,75040,75603,74938],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[64932],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[76147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[76201,76442,76257,76561,76164,76382],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":9,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-10","input.rs"],"content":"use super::*;\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-10","lib.rs"],"content":"//! Advent of Code 2019: Day 10: Monitoring Station\n//!\n//! [https://adventofcode.com/2019/day/10](https://adventofcode.com/2019/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Monitoring Station\";\n\tyear = 2019;\n\tday = 10;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[76865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[77233],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-10","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Coord;\nuse model::Dir;\nuse model::DirVec;\nuse model::Pos;\nuse model::Space;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet (_, num) = best_roid (\u0026 get_roids (input)).ok_or (\"No solution found\") ?;\n\tOk (num)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cCoord\u003e {\n\tlet roids = get_roids (input);\n\tlet (base, _) = best_roid (\u0026 roids).ok_or (\"No solution found\") ?;\n\tlet mut roid_dir_vecs: Vec \u003cDirVec\u003e =\n\t\troids.iter ().copied ()\n\t\t\t.filter (|\u0026 roid| roid != base)\n\t\t\t.map (|roid| DirVec::new (roid - base))\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tlet mut roid_dir_vecs_temp = Vec::new ();\n\tlet mut num_roids = 0_u32;\n\tloop {\n\t\tlet mut last_dir = None;\n\t\tfor roid_dir_vec in roid_dir_vecs.drain ( .. ) {\n\t\t\tif Some (roid_dir_vec.dir) == last_dir {\n\t\t\t\troid_dir_vecs_temp.push (roid_dir_vec);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlast_dir = Some (roid_dir_vec.dir);\n\t\t\tnum_roids += 1;\n\t\t\tif num_roids == 200 {\n\t\t\t\tlet roid_pos = base + roid_dir_vec.pos ();\n\t\t\t\treturn Ok (roid_pos.x * 100 + roid_pos.y);\n\t\t\t}\n\t\t}\n\t\tmem::swap (\u0026 mut roid_dir_vecs, \u0026 mut roid_dir_vecs_temp);\n\t\tif roid_dir_vecs.is_empty () {\n\t\t\treturn Err (\"No solution found\".into ())\n\t\t}\n\t}\n}\n\nfn best_roid (roids: \u0026 [Pos]) -\u003e Option \u003c(Pos, u32)\u003e {\n\troids.iter ()\n\t\t.map (|\u0026 roid| (roid, num_visible (roids, roid)))\n\t\t.max_by_key (|\u0026 (_, num)| num)\n}\n\nfn get_roids (input: \u0026 Input) -\u003e Vec \u003cPos\u003e {\n\tinput.grid.iter ()\n\t\t.filter (|\u0026 (_, space)| matches! (space, Space::Asteroid))\n\t\t.map (|(pos, _)| pos)\n\t\t.collect ()\n}\n\nfn num_visible (roids: \u0026 [Pos], base: Pos) -\u003e u32 {\n\troids.iter ().copied ()\n\t\t.filter (|\u0026 other| other != base)\n\t\t.map (|other| DirVec::new (other - base).dir)\n\t\t.collect::\u003cHashSet \u003cDir\u003e\u003e ()\n\t\t.len ()\n\t\t.pan_u32 ()\n}\n","traces":[{"line":11,"address":[40192,40778],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[40642,40697,40655,40730,40763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[40676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[40800,42376],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[42146,41281,41301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[41378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[86979,87258,86992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[88242,88206],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[41626,41526,41657,42325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[41814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[41845],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[41978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[42052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[41937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[41943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[40371,41136,40998,40512],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[89888],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":56,"address":[31952],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}\u003c(aoc_pos::dim_2::yx::PosYX\u003ci16\u003e, aoc_2019_day_10::model::Space), \u0026mut aoc_2019_day_10::logic::get_roids::{closure_env#0}\u003e"},{"line":61,"address":[42777,42384],"length":1,"stats":{"Line":2},"fn_name":"num_visible"},{"line":63,"address":[55976],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[56041,55996],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":17,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-10","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cSpace\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Space {\n\t\tAsteroid = \"#\",\n\t\t#[ default ] Empty = \".\",\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct DirVec {\n\tpub dir: Dir,\n\tpub mul: Coord,\n}\n\nimpl DirVec {\n\t#[ must_use ]\n\tpub fn new (offset: Pos) -\u003e Self {\n\t\tif offset == Pos::ZERO { panic! () }\n\t\tif offset.x == 0 {\n\t\t\tlet sign = offset.y.signum ();\n\t\t\treturn Self { dir: Dir (Pos { y: sign, x: 0 }), mul: offset.y.abs () }\n\t\t}\n\t\tif offset.y == 0 {\n\t\t\tlet sign = offset.x.signum ();\n\t\t\treturn Self { dir: Dir (Pos { y: 0, x: sign }), mul: offset.x.abs () }\n\t\t}\n\t\tlet mul = calc_gcd (offset.y.abs (), offset.x.abs ());\n\t\tlet dir = Dir (Pos { y: offset.y / mul, x: offset.x / mul });\n\t\tSelf { dir, mul }\n\t}\n\t#[ must_use ]\n\tpub fn pos (self) -\u003e Pos {\n\t\tself.dir.0 * self.mul\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub struct Dir (Pos);\n\nimpl Ord for Dir {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tlet pos_0 = self.0;\n\t\tlet pos_1 = other.0;\n\t\tfn get_dir (pos: Pos) -\u003e u8 {\n\t\t\tmatch (pos.y.signum (), pos.x.signum ()) {\n\t\t\t\t(-1, 0) =\u003e 0,\n\t\t\t\t(-1, 1) =\u003e 1,\n\t\t\t\t(0, 1) =\u003e 2,\n\t\t\t\t(1, 1) =\u003e 3,\n\t\t\t\t(1, 0) =\u003e 4,\n\t\t\t\t(1, -1) =\u003e 5,\n\t\t\t\t(0, -1) =\u003e 6,\n\t\t\t\t(-1, -1) =\u003e 7,\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t}\n\t\tlet key_0 = (get_dir (pos_0), pos_0.y * pos_1.x);\n\t\tlet key_1 = (get_dir (pos_1), pos_1.y * pos_0.x);\n\t\tkey_0.cmp (\u0026 key_1)\n\t}\n}\n\nimpl PartialOrd for Dir {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tSome (self.cmp (other))\n\t}\n}\n\nconst fn calc_gcd (mut num_0: Coord, mut num_1: Coord) -\u003e Coord {\n\tloop {\n\t\tlet rem = num_0 % num_1;\n\t\tif rem == 0 { return num_1 }\n\t\tnum_0 = num_1;\n\t\tnum_1 = rem;\n\t}\n}\n","traces":[{"line":8,"address":[88597],"length":1,"stats":{"Line":6},"fn_name":null},{"line":23,"address":[51072],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":24,"address":[51126,51469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[51081],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[51135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[51267,51426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[51504],"length":1,"stats":{"Line":1},"fn_name":"pos"},{"line":47,"address":[51696],"length":1,"stats":{"Line":1},"fn_name":"cmp"},{"line":48,"address":[51697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[51744],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[51755,51907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[52037,51857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[52053,51995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[52282],"length":1,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[51212,51200,51383],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[51207],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-11","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_step_ops: u32 = (\"MAX_STEP_OPS=\", 500, 1_u32 .. ),\n\t\tpub max_steps: u32 = (\"MAX_STEPS=\", 20_000, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-11","lib.rs"],"content":"//! Advent of Code 2019: Day 11: Space Police\n//!\n//! [https://adventofcode.com/2019/day/11](https://adventofcode.com/2019/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_ocr as ocr;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Space Police\";\n\tyear = 2019;\n\tday = 11;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-11","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Colour;\nuse model::Cpu;\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = calc_result (input, Colour::None) ?;\n\tOk (\n\t\tgrid.values ()\n\t\t\t.filter (|\u0026 colour| matches! (colour, Colour::Black | Colour::White))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet grid = calc_result (input, Colour::White) ?;\n\tlet result = ocr::read_dots (\n\t\tgrid.iter ()\n\t\t\t.filter (|\u0026 (_, colour)| matches! (colour, Colour::White))\n\t\t\t.map (|(pos, _)| (pos.y, pos.x))) ?;\n\tOk (result)\n}\n\nfn calc_result (input: \u0026 Input, initial: Colour) -\u003e GenResult \u003cGrid\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tlet mut grid = Grid::new_range (Pos::new (-10, -10), Pos::new (11, 11)) ?;\n\tlet mut pos = Pos::ZERO;\n\tlet mut dir = Dir::Up;\n\tgrid.set (pos, initial);\n\tfor _ in 0 .. input.params.max_steps {\n\t\tcpu.set_max_ops (input.params.max_step_ops);\n\t\tlet old_colour = grid.get (pos).ok_or (()).or_else (|()| {\n\t\t\tgrid = grid.resize (\n\t\t\t\tgrid.start () - Pos::new (10, 10),\n\t\t\t\tgrid.end () + Pos::new (10, 10)) ?;\n\t\t\tOk::\u003c_, Overflow\u003e (grid.get (pos).unwrap ())\n\t\t}) ?;\n\t\tcpu.input (match old_colour {\n\t\t\tColour::None | Colour::Black =\u003e 0,\n\t\t\tColour::White =\u003e 1,\n\t\t});\n\t\tlet new_colour = match cpu.run ().output () ? {\n\t\t\tSome (0) =\u003e Colour::Black,\n\t\t\tSome (1) =\u003e Colour::White,\n\t\t\tSome (other) =\u003e return Err (format! (\"Unexpected output: {other}\").into ()),\n\t\t\tNone =\u003e return Ok (grid),\n\t\t};\n\t\tgrid.set (pos, new_colour);\n\t\tdir = match cpu.run ().output () ? {\n\t\t\tSome (0) =\u003e dir.left (),\n\t\t\tSome (1) =\u003e dir.right (),\n\t\t\tSome (other) =\u003e return Err (format! (\"Unexpected output: {other}\").into ()),\n\t\t\tNone =\u003e return Ok (grid),\n\t\t};\n\t\tpos = pos.try_add ((dir, 1)) ?;\n\t}\n\tErr (\"Max steps exceeded\".into ())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-11","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Dir = aoc_pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cColour\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Val = i64;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Colour {\n\t\t#[ default ]\n\t\tNone = \" \",\n\t\tBlack = \".\",\n\t\tWhite = \"#\",\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_STEPS_ONE=10\",\n\t\"\u003cx=-1, y=0, z=2\u003e\",\n\t\"\u003cx=2, y=-10, z=-7\u003e\",\n\t\"\u003cx=4, y=-8, z=8\u003e\",\n\t\"\u003cx=3, y=5, z=-1\u003e\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"NUM_STEPS_ONE=100\",\n\t\"\u003cx=-8, y=-10, z=0\u003e\",\n\t\"\u003cx=5, y=5, z=10\u003e\",\n\t\"\u003cx=2, y=-7, z=3\u003e\",\n\t\"\u003cx=9, y=-8, z=-3\u003e\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"179\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"1940\", puzzle.part_one (EXAMPLE_1));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2772\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"4686774924\", puzzle.part_two (EXAMPLE_1));\n}\n","traces":[{"line":22,"address":[49828,49824],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":23,"address":[60129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[60191,60416,60479,60244,60738,60150],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[60264,60542,60301,60702,60602,60354],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[49860,49856],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":30,"address":[60817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[61426,60838,60932,60879,61104,61167],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[61042,61230,61290,61390,60952,60989],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-12","input.rs"],"content":"use super::*;\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub moons: Vec \u003cPos\u003e,\n\tpub params: InputParams,\n}\n\nstruct_display! {\n\tInput { moons, params } = [ params, @lines moons = display_moon ]\n}\n\nfn display_moon (moon: \u0026 Pos, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\twrite! (formatter, \"\u003cx={x}, y={y}, z={z}\u003e\", x = moon.x, y = moon.y, z = moon.z)\n}\n\nstruct_parser! {\n\tInput { moons, params } = [ params, @lines moons = parse_moon ]\n}\n\nfn parse_moon (parser: \u0026 mut Parser) -\u003e ParseResult \u003cPos\u003e {\n\tparse! (parser, \"\u003cx=\", x, \", y=\", y, \", z=\", z, \"\u003e\");\n\tOk (Pos { x, y, z })\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_steps_one: u32 = (\"NUM_STEPS_ONE=\", 1000, 1_u32 .. ),\n\t\tpub num_steps_two: u32 = (\"NUM_STEPS_TWO=\", 500_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":19,"address":[32508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[33136],"length":1,"stats":{"Line":2},"fn_name":"parse_moon"},{"line":23,"address":[33156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[33537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[34355],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[34359],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-12","lib.rs"],"content":"//! Advent of Code 2019: Day 12: The N-Body Problem\n//!\n//! [https://adventofcode.com/2019/day/12](https://adventofcode.com/2019/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"The N-Body Problem\";\n\tyear = 2019;\n\tday = 12;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[65815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[66162],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-12","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Axis;\nuse model::Coord;\nuse model::Energy;\nuse model::Moon;\nuse model::MoonAxis;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cEnergy\u003e {\n\tlet mut moons: Vec \u003cMoon\u003e =\n\t\tinput.moons.iter ()\n\t\t\t.map (|\u0026 pos| Moon::new (pos))\n\t\t\t.collect ();\n\tfor _ in 0 .. input.params.num_steps_one {\n\t\ttick (\u0026 mut moons) ?;\n\t}\n\tOk (moons.iter ().map (Moon::total_energy).sum ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet repeat_x = calc_axis_repeat (input, Axis::X) ?;\n\tlet repeat_y = calc_axis_repeat (input, Axis::Y) ?;\n\tlet repeat_z = calc_axis_repeat (input, Axis::Z) ?;\n\tif repeat_x.0 != 0 || repeat_y.0 != 0 || repeat_z.0 != 0 { panic! () }\n\tlet mut result = 1_u64;\n\tresult = calc_lcm (result, repeat_x.1);\n\tresult = calc_lcm (result, repeat_y.1);\n\tresult = calc_lcm (result, repeat_z.1);\n\tOk (result)\n}\n\nfn calc_axis_repeat (input: \u0026 Input, axis: Axis) -\u003e GenResult \u003c(u64, u64)\u003e {\n\tlet mut moons: Vec \u003cMoonAxis\u003e =\n\t\tinput.moons.iter ()\n\t\t\t.map (|moon| MoonAxis { pos: moon [axis], vel: 0 })\n\t\t\t.collect ();\n\tlet mut tick: u64 = 0;\n\tlet mut seen: HashMap \u003cVec \u003cMoonAxis\u003e, u64\u003e = HashMap::new ();\n\tfor _ in 0 .. input.params.num_steps_two {\n\t\tif let Some (prev) = seen.insert (moons.clone (), tick) {\n\t\t\treturn Ok ((prev, tick));\n\t\t}\n\t\tfor idx_0 in 0 .. moons.len () {\n\t\t\tfor idx_1 in 0 .. moons.len () {\n\t\t\t\tif idx_0 == idx_1 { continue }\n\t\t\t\tlet moon_0 = \u0026 moons [idx_0];\n\t\t\t\tlet moon_1 = \u0026 moons [idx_1];\n\t\t\t\tmoons [idx_0].vel = Coord::add_2 (\n\t\t\t\t\tmoon_0.vel,\n\t\t\t\t\tCoord::sub_2 (moon_1.pos, moon_0.pos) ?.signum (),\n\t\t\t\t) ?;\n\t\t\t};\n\t\t}\n\t\tfor moon in moons.iter_mut () {\n\t\t\tmoon.pos = Coord::add_2 (moon.pos, moon.vel) ?;\n\t\t}\n\t\ttick += 1;\n\t}\n\tErr (\"Max steps exceeded\".into ())\n}\n\nfn tick (moons: \u0026 mut Vec \u003cMoon\u003e) -\u003e GenResult \u003c()\u003e {\n\tfor idx_0 in 0 .. moons.len () {\n\t\tfor idx_1 in 0 .. moons.len () {\n\t\t\tif idx_0 == idx_1 { continue }\n\t\t\tlet moon_0 = \u0026 moons [idx_0];\n\t\t\tlet moon_1 = \u0026 moons [idx_1];\n\t\t\tmoons [idx_0].vel = moon_0.vel + Pos {\n\t\t\t\tx: (moon_1.pos.x - moon_0.pos.x).signum (),\n\t\t\t\ty: (moon_1.pos.y - moon_0.pos.y).signum (),\n\t\t\t\tz: (moon_1.pos.z - moon_0.pos.z).signum (),\n\t\t\t};\n\t\t}\n\t}\n\tfor moon in moons.iter_mut () {\n\t\tmoon.pos = moon.pos.try_add (moon.vel) ?;\n\t}\n\tOk (())\n}\n\nfn calc_lcm \u003cVal: Int\u003e (num_0: Val, num_1: Val) -\u003e Val {\n\tlet gcd = calc_gcd (num_0, num_1);\n\tnum_0 * num_1 / gcd\n}\n\nfn calc_gcd \u003cVal: Int\u003e (mut num_0: Val, mut num_1: Val) -\u003e Val {\n\tloop {\n\t\tlet rem = num_0 % num_1;\n\t\tif rem == Val::ZERO { return num_1 }\n\t\tnum_0 = num_1;\n\t\tnum_1 = rem;\n\t}\n}\n","traces":[{"line":12,"address":[39184,39416],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":15,"address":[56316,56288,56291],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":17,"address":[39246,39273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[39275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[39356],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[39424],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":24,"address":[39447,39469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[39501,39529],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[39561,39589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[39615,39877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[39794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[40982,39904],"length":1,"stats":{"Line":1},"fn_name":"calc_axis_repeat"},{"line":38,"address":[56345,56320],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":42,"address":[40131,40137,40741],"length":1,"stats":{"Line":3},"fn_name":null},{"line":43,"address":[40186,40234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[40870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[40249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[40294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[40343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[40501,40549],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[40402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[40408,40430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[40649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[40656,40676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[40747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[40992],"length":1,"stats":{"Line":1},"fn_name":"tick"},{"line":66,"address":[41015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[41108,41209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[41229],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[41186,41414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[41771,41281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[41327,41787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[41342,41803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[41561,41683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[41603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":35,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-12","model.rs"],"content":"use super::*;\n\npub type Axis = pos::AxisXYZ;\npub type Coord = i16;\npub type Energy = i32;\npub type Pos = pos::PosXYZ \u003cCoord\u003e;\n\npub struct Moon {\n\tpub pos: Pos,\n\tpub vel: Pos,\n}\n\nimpl Moon {\n\n\t#[ must_use ]\n\tpub const fn new (pos: Pos) -\u003e Self {\n\t\tSelf { pos, vel: Pos::ZERO }\n\t}\n\n\t#[ must_use ]\n\tpub fn potential_energy (\u0026 self) -\u003e Energy {\n\t\tself.pos.x.pan_i32 ().abs () + self.pos.y.pan_i32 ().abs () + self.pos.z.pan_i32 ().abs ()\n\t}\n\n\t#[ must_use ]\n\tpub fn kinetic_energy (\u0026 self) -\u003e Energy {\n\t\tself.vel.x.pan_i32 ().abs () + self.vel.y.pan_i32 ().abs () + self.vel.z.pan_i32 ().abs ()\n\t}\n\n\t#[ must_use ]\n\tpub fn total_energy (\u0026 self) -\u003e Energy {\n\t\tself.potential_energy () * self.kinetic_energy ()\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct MoonAxis {\n\tpub pos: Coord,\n\tpub vel: Coord,\n}\n","traces":[{"line":16,"address":[59472],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":21,"address":[59504],"length":1,"stats":{"Line":1},"fn_name":"potential_energy"},{"line":22,"address":[59640,59706,59720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[59776],"length":1,"stats":{"Line":1},"fn_name":"kinetic_energy"},{"line":27,"address":[59913,59979,59993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[60048],"length":1,"stats":{"Line":0},"fn_name":"total_energy"},{"line":32,"address":[51814,51844],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":5,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-13","input.rs"],"content":"use super::*;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub step_max_ops: u32 = (\"STEP_MAX_OPS=\", 200, 1_u32 .. ),\n\t\tpub core_max_steps: u32 = (\"CORE_MAX_STEPS=\", 15_000, 1_u32 .. ),\n\t\tpub game_max_steps: u32 = (\"GAME_MAX_STEPS=\", 15_000, 1_u32 .. ),\n\t\tpub size_max_steps: u32 = (\"SIZE_MAX_STEPS=\", 1_000, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-13","lib.rs"],"content":"//! Advent of Code 2019: Day 13: Care Package\n//!\n//! [https://adventofcode.com/2019/day/13](https://adventofcode.com/2019/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\npub mod input;\npub mod logic;\npub mod model;\npub mod run;\n\npuzzle_info! {\n\tname = \"Care Package\";\n\tyear = 2019;\n\tday = 13;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = run::run; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-13","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Coord;\nuse model::Core;\nuse model::CoreNext;\nuse model::Game;\nuse model::GameNext;\nuse model::Pos;\nuse model::Tile;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet size = get_size (input) ?;\n\tlet mut game = Game::new (input, false, size) ?;\n\tgame.next () ?;\n\tOk (\n\t\tgame.grid ().values ()\n\t\t\t.filter (|\u0026 tile| tile == Tile::Block)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tlet size = get_size (input) ?;\n\tlet mut game = Game::new (input, true, size) ?;\n\tfor _ in 0 .. input.params.game_max_steps {\n\t\tmatch game.next () ? {\n\t\t\tGameNext::Input =\u003e game.input ((game.ball_pos ().x - game.paddle_pos ().x).signum ()),\n\t\t\tGameNext::Halt =\u003e return Ok (game.score ()),\n\t\t}\n\t}\n\tErr (\"Max steps exceeded\".into ())\n}\n\npub fn get_size (input: \u0026 Input) -\u003e GenResult \u003cPos\u003e {\n\tlet mut core = Core::new (input, false);\n\tlet mut size = Pos::ZERO;\n\tfor _ in 0 .. input.params.size_max_steps {\n\t\tmatch core.next () ? {\n\t\t\tCoreNext::Input =\u003e break,\n\t\t\tCoreNext::Output (pos, _) =\u003e {\n\t\t\t\tif pos.x \u003c Coord::ZERO || pos.y \u003c Coord::ZERO {\n\t\t\t\t\treturn Err (\"Coordinates must not be negative\".into ());\n\t\t\t\t}\n\t\t\t\tif pos.x \u003e 1024_i32 || pos.y \u003e 1024_i32 {\n\t\t\t\t\treturn Err (\"Max size is 1024 in each axis\".into ());\n\t\t\t\t}\n\t\t\t\tsize.x = cmp::max (size.x, pos.x + Coord::ONE);\n\t\t\t\tsize.y = cmp::max (size.y, pos.y + Coord::ONE);\n\t\t\t},\n\t\t\tCoreNext::Halt =\u003e break,\n\t\t}\n\t}\n\tif size.x \u003c Coord::ONE || size.y \u003c Coord::ONE {\n\t\treturn Err (\"Output must not be empty\".into ());\n\t}\n\tOk (size)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-13","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub use self::core::{ Core, CoreNext };\npub use self::game::{ Game, GameNext };\n\npub type Coord = i32;\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i32;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tEmpty = \"  \",\n\t\tWall = \"##\",\n\t\tBlock = \"[]\",\n\t\tPaddle = \"==\",\n\t\tBall = \"()\",\n\t}\n}\n\nmod core {\n\n\tuse super::*;\n\n\tpub struct Core {\n\t\tcpu: Cpu,\n\t\tstep_max_ops: u32,\n\t}\n\n\timpl Core {\n\n\t\t#[ must_use ]\n\t\tpub fn new (input: \u0026 Input, insert_coin: bool) -\u003e Self {\n\t\t\tlet mut cpu = Cpu::new (input.data.clone ());\n\t\t\tif insert_coin { cpu.mem_set (0_i32, 2_i32).unwrap (); }\n\t\t\tSelf { cpu, step_max_ops: input.params.step_max_ops }\n\t\t}\n\n\t\tpub fn input (\u0026 mut self, val: Val) {\n\t\t\tself.cpu.input (val);\n\t\t}\n\n\t\t#[ allow (clippy::should_implement_trait) ]\n\t\tpub fn next (\u0026 mut self) -\u003e GenResult \u003cCoreNext\u003e {\n\t\t\tlet mut output_buf: ArrayVec \u003cVal, 3\u003e = array_vec! [];\n\t\t\tself.cpu.set_max_ops (self.step_max_ops);\n\t\t\tloop {\n\t\t\t\t#[ allow (clippy::wildcard_enum_match_arm) ]\n\t\t\t\tmatch self.cpu.run () {\n\t\t\t\t\tRunResult::Halt =\u003e return Ok (CoreNext::Halt),\n\t\t\t\t\tRunResult::Input =\u003e return Ok (CoreNext::Input),\n\t\t\t\t\tRunResult::Output (val) =\u003e output_buf.push (val),\n\t\t\t\t\tother =\u003e return Err (other.into ()),\n\t\t\t\t}\n\t\t\t\tif ! output_buf.is_full () { continue }\n\t\t\t\tlet x = output_buf [0];\n\t\t\t\tlet y = output_buf [1];\n\t\t\t\tlet val = output_buf [2];\n\t\t\t\tlet pos = Pos { y, x };\n\t\t\t\treturn Ok (CoreNext::Output (pos, val));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpub enum CoreNext {\n\t\tInput,\n\t\tOutput (Pos, Val),\n\t\tHalt,\n\t}\n\n}\n\nmod game {\n\n\tuse super::*;\n\n\tpub struct Game {\n\t\tcore: Core,\n\t\tsize: Pos,\n\t\tscore: Val,\n\t\tgrid: Grid,\n\t\tpaddle_pos: Pos,\n\t\tball_pos: Pos,\n\t\tmax_steps: u32,\n\t}\n\n\timpl Game {\n\n\t\tpub fn new (input: \u0026 Input, insert_coin: bool, size: Pos) -\u003e GenResult \u003cSelf\u003e {\n\t\t\tlet grid = Grid::new_size (size);\n\t\t\tOk (Self {\n\t\t\t\tcore: Core::new (input, insert_coin),\n\t\t\t\tsize,\n\t\t\t\tscore: 0,\n\t\t\t\tgrid,\n\t\t\t\tpaddle_pos: Pos::ZERO,\n\t\t\t\tball_pos: Pos::ZERO,\n\t\t\t\tmax_steps: input.params.game_max_steps,\n\t\t\t})\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn grid (\u0026 self) -\u003e \u0026 Grid { \u0026 self.grid }\n\n\t\t#[ must_use ]\n\t\tpub const fn score (\u0026 self) -\u003e Val { self.score }\n\n\t\t#[ must_use ]\n\t\tpub const fn paddle_pos (\u0026 self) -\u003e Pos { self.paddle_pos }\n\n\t\t#[ must_use ]\n\t\tpub const fn ball_pos (\u0026 self) -\u003e Pos { self.ball_pos } \n\n\t\tpub fn input (\u0026 mut self, val: Val) {\n\t\t\tself.core.input (val);\n\t\t}\n\n\t\t#[ allow (clippy::should_implement_trait) ]\n\t\tpub fn next (\u0026 mut self) -\u003e GenResult \u003cGameNext\u003e {\n\t\t\tfor _ in 0 .. self.max_steps {\n\t\t\t\tmatch self.core.next () ? {\n\t\t\t\t\tCoreNext::Input =\u003e return Ok (GameNext::Input),\n\t\t\t\t\tCoreNext::Output (pos, val) =\u003e {\n\t\t\t\t\t\tif pos == (Pos { y: Coord::ZERO, x: Coord::NEG_ONE }) { self.score = val; continue }\n\t\t\t\t\t\tif pos.x \u003c Coord::ZERO || pos.y \u003c Coord::ZERO || self.size.x \u003c= pos.x || self.size.y \u003c= pos.y {\n\t\t\t\t\t\t\treturn Err (format! (\"Invalid position: {pos:?}\").into ());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet tile = match val {\n\t\t\t\t\t\t\t0_i32 =\u003e Tile::Empty,\n\t\t\t\t\t\t\t1_i32 =\u003e Tile::Wall,\n\t\t\t\t\t\t\t2_i32 =\u003e Tile::Block,\n\t\t\t\t\t\t\t3_i32 =\u003e Tile::Paddle,\n\t\t\t\t\t\t\t4_i32 =\u003e Tile::Ball,\n\t\t\t\t\t\t\t_ =\u003e return Err (format! (\"Invalid tile id: {val}\").into ()),\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif matches! (tile, Tile::Paddle) { self.paddle_pos = pos; }\n\t\t\t\t\t\tif matches! (tile, Tile::Ball) { self.ball_pos = pos; }\n\t\t\t\t\t\tself.grid.set (pos, tile);\n\t\t\t\t\t},\n\t\t\t\t\tCoreNext::Halt =\u003e return Ok (GameNext::Halt),\n\t\t\t\t}\n\t\t\t}\n\t\t\tErr (\"Game max steps exceeded\".into ())\n\t\t}\n\n\t}\n\n\tpub enum GameNext {\n\t\tInput,\n\t\tHalt,\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-13","run.rs"],"content":"use super::*;\n\nuse std::path::PathBuf;\n\nuse input::Input;\nuse model::Coord;\nuse model::Game;\nuse model::GameNext;\nuse model::Tile;\n\n#[ derive (clap::Parser) ]\npub struct RunArgs {\n\n\t#[ clap (from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n\n}\n\n#[ allow (clippy::print_stdout) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim_end ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tlet size = logic::get_size (\u0026 input) ?;\n\tlet mut game = Game::new (\u0026 input, true, size) ?;\n\tfor _ in Coord::ZERO .. size.y + Coord::ONE { println! (); }\n\tloop {\n\t\tlet prev_grid = game.grid ().clone ();\n\t\tif matches! (game.next () ?, GameNext::Halt) { break }\n\t\tprint! (\"\\x1b[{num}A\", num = size.y + Coord::ONE);\n\t\tprintln! (\"{score}\\x1b[K\", score = game.score ());\n\t\tlet mut skipped = 0_u32;\n\t\tfor ((pos, tile), prev_tile) in game.grid ().iter ().zip (prev_grid.values ()) {\n\t\t\tif pos.y \u003e Coord::ZERO \u0026\u0026 pos.x == Coord::ZERO { println! (); skipped = 0; }\n\t\t\tif tile == prev_tile { skipped += 2; continue }\n\t\t\tif skipped \u003e 0 {\n\t\t\t\tprint! (\"\\x1b[{right}C{tile}\", right = skipped, tile = display_tile (tile));\n\t\t\t} else {\n\t\t\t\tprint! (\"{tile}\", tile = display_tile (tile));\n\t\t\t}\n\t\t\tskipped = 0;\n\t\t}\n\t\tprintln! ();\n\t\tthread::sleep (time::Duration::from_micros (10_000));\n\t\tgame.input ((game.ball_pos ().x - game.paddle_pos ().x).signum ());\n\t}\n\tOk (())\n}\n\nconst fn display_tile (tile: Tile) -\u003e \u0026 'static str {\n\tmatch tile {\n\t\tTile::Empty =\u003e \"  \",\n\t\tTile::Wall =\u003e \"\",\n\t\tTile::Block =\u003e \"\",\n\t\tTile::Paddle =\u003e \"\",\n\t\tTile::Ball =\u003e \"\",\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"10 ORE =\u003e 10 A\",\n\t\"1 ORE =\u003e 1 B\",\n\t\"7 A, 1 B =\u003e 1 C\",\n\t\"7 A, 1 C =\u003e 1 D\",\n\t\"7 A, 1 D =\u003e 1 E\",\n\t\"7 A, 1 E =\u003e 1 FUEL\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"9 ORE =\u003e 2 A\",\n\t\"8 ORE =\u003e 3 B\",\n\t\"7 ORE =\u003e 5 C\",\n\t\"3 A, 4 B =\u003e 1 AB\",\n\t\"5 B, 7 C =\u003e 1 BC\",\n\t\"4 C, 1 A =\u003e 1 CA\",\n\t\"2 AB, 3 BC, 4 CA =\u003e 1 FUEL\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"157 ORE =\u003e 5 NZVS\",\n\t\"165 ORE =\u003e 6 DCFZ\",\n\t\"44 XJWVT, 5 KHKGT, 1 QDVJ, 29 NZVS, 9 GPVTF, 48 HKGWZ =\u003e 1 FUEL\",\n\t\"12 HKGWZ, 1 GPVTF, 8 PSHF =\u003e 9 QDVJ\",\n\t\"179 ORE =\u003e 7 PSHF\",\n\t\"177 ORE =\u003e 5 HKGWZ\",\n\t\"7 DCFZ, 7 PSHF =\u003e 2 XJWVT\",\n\t\"165 ORE =\u003e 2 GPVTF\",\n\t\"3 DCFZ, 7 NZVS, 5 HKGWZ, 10 PSHF =\u003e 8 KHKGT\",\n];\n\nconst EXAMPLE_3: \u0026 [\u0026 str] = \u0026 [\n\t\"2 VPVL, 7 FWMGM, 2 CXFTF, 11 MNCFX =\u003e 1 STKFG\",\n\t\"17 NVRVD, 3 JNWZP =\u003e 8 VPVL\",\n\t\"53 STKFG, 6 MNCFX, 46 VJHF, 81 HVMC, 68 CXFTF, 25 GNMV =\u003e 1 FUEL\",\n\t\"22 VJHF, 37 MNCFX =\u003e 5 FWMGM\",\n\t\"139 ORE =\u003e 4 NVRVD\",\n\t\"144 ORE =\u003e 7 JNWZP\",\n\t\"5 MNCFX, 7 RFSQX, 2 FWMGM, 2 VPVL, 19 CXFTF =\u003e 3 HVMC\",\n\t\"5 VJHF, 7 MNCFX, 9 VPVL, 37 CXFTF =\u003e 6 GNMV\",\n\t\"145 ORE =\u003e 6 MNCFX\",\n\t\"1 NVRVD =\u003e 8 CXFTF\",\n\t\"1 VJHF, 6 MNCFX =\u003e 4 RFSQX\",\n\t\"176 ORE =\u003e 6 VJHF\",\n];\n\nconst EXAMPLE_4: \u0026 [\u0026 str] = \u0026 [\n\t\"171 ORE =\u003e 8 CNZTR\",\n\t\"7 ZLQW, 3 BMBT, 9 XCVML, 26 XMNCP, 1 WPTQ, 2 MZWV, 1 RJRHP =\u003e 4 PLWSL\",\n\t\"114 ORE =\u003e 4 BHXH\",\n\t\"14 VRPVC =\u003e 6 BMBT\",\n\t\"6 BHXH, 18 KTJDG, 12 WPTQ, 7 PLWSL, 31 FHTLT, 37 ZDVW =\u003e 1 FUEL\",\n\t\"6 WPTQ, 2 BMBT, 8 ZLQW, 18 KTJDG, 1 XMNCP, 6 MZWV, 1 RJRHP =\u003e 6 FHTLT\",\n\t\"15 XDBXC, 2 LTCX, 1 VRPVC =\u003e 6 ZLQW\",\n\t\"13 WPTQ, 10 LTCX, 3 RJRHP, 14 XMNCP, 2 MZWV, 1 ZLQW =\u003e 1 ZDVW\",\n\t\"5 BMBT =\u003e 4 WPTQ\",\n\t\"189 ORE =\u003e 9 KTJDG\",\n\t\"1 MZWV, 17 XDBXC, 3 XCVML =\u003e 2 XMNCP\",\n\t\"12 VRPVC, 27 CNZTR =\u003e 2 XDBXC\",\n\t\"15 KTJDG, 12 BHXH =\u003e 5 XCVML\",\n\t\"3 BHXH, 2 VRPVC =\u003e 7 MZWV\",\n\t\"121 ORE =\u003e 7 VRPVC\",\n\t\"7 XCVML =\u003e 6 RJRHP\",\n\t\"5 BHXH, 4 VRPVC =\u003e 5 LTCX\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"31\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"165\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"13312\", puzzle.part_one (EXAMPLE_2));\n\tassert_eq_ok! (\"180697\", puzzle.part_one (EXAMPLE_3));\n\tassert_eq_ok! (\"2210736\", puzzle.part_one (EXAMPLE_4));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"82892753\", puzzle.part_two (EXAMPLE_2));\n\tassert_eq_ok! (\"5586022\", puzzle.part_two (EXAMPLE_3));\n\tassert_eq_ok! (\"460664\", puzzle.part_two (EXAMPLE_4));\n}\n","traces":[{"line":72,"address":[44500,42912],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":73,"address":[42929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[42950,43607,43673,42992,43048,44457],"length":1,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[43070,43741,43167,43108,43802,44419],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[44378,43233,43292,43870,43189,43931],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[43358,44060,43314,44337,43417,43999],"length":1,"stats":{"Line":3},"fn_name":null},{"line":78,"address":[43439,43483,43542,44296,44186,44125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[45507,44512],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":83,"address":[44529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[44550,44957,44592,44648,45023,45464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[44670,45091,45152,44708,45426,44767],"length":1,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[44833,44892,45217,45278,45385,44789],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":12,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-14","input.rs"],"content":"use super::*;\nuse model::Reaction;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub reactions: Vec \u003cReaction \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { reactions, params } = [ params, @lines reactions ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_ore: u64 = (\"NUM_ORE=\", 1_000_000_000_000, 1_u64 .. ),\n\t}\n}\n","traces":[{"line":12,"address":[39827,40859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[68146],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-14","lib.rs"],"content":"//! Advent of Code 2019: Day 14: Space Stoichiometry\n//!\n//! [https://adventofcode.com/2019/day/14](https://adventofcode.com/2019/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Space Stoichiometry\";\n\tyear = 2019;\n\tday = 14;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[68690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[69042],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-14","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Reaction;\nuse model::Qty;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cQty\u003e {\n\tlet reactions = get_reactions (input) ?;\n\tlet dependencies = calc_dependencies (\u0026 reactions) ?;\n\tlet order = calc_order (\u0026 reactions, \u0026 dependencies) ?;\n\tcalc_ore (\u0026 reactions, \u0026 order, 1)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cQty\u003e {\n\tlet reactions = get_reactions (input) ?;\n\tlet dependencies = calc_dependencies (\u0026 reactions) ?;\n\tlet order = calc_order (\u0026 reactions, \u0026 dependencies) ?;\n\tlet mut max: Qty = 1;\n\twhile calc_ore (\u0026 reactions, \u0026 order, max) ? \u003c= input.params.num_ore {\n\t\tmax = Qty::mul_2 (max, 2) ?;\n\t}\n\tlet mut min: Qty = max / 2;\n\twhile max - min != 1 {\n\t\tlet guess = min + (max - min) / 2;\n\t\tlet success = calc_ore (\u0026 reactions, \u0026 order, guess) ? \u003c= input.params.num_ore;\n\t\tif success { min = guess; } else { max = guess; }\n\t}\n\tOk (min)\n}\n\npub type Reactions \u003c'inp\u003e = HashMap \u003cInpStr \u003c'inp\u003e, \u0026 'inp Reaction \u003c'inp\u003e\u003e;\npub type Dependencies \u003c'inp\u003e = HashMap \u003cInpStr \u003c'inp\u003e, Vec \u003cInpStr \u003c'inp\u003e\u003e\u003e;\npub type Order \u003c'inp\u003e = Vec \u003cInpStr \u003c'inp\u003e\u003e;\n\nfn get_reactions \u003c'inp\u003e (input: \u0026 'inp Input \u003c'inp\u003e) -\u003e GenResult \u003cReactions \u003c'inp\u003e\u003e {\n\tlet mut reactions = Reactions::new ();\n\tfor reaction in \u0026 input.reactions {\n\t\tlet output_chem = \u0026 reaction.output.chem;\n\t\tif reactions.insert (output_chem.clone (), reaction).is_some () {\n\t\t\treturn Err (format! (\"Duplicated output: {output_chem}\").into ())\n\t\t}\n\t}\n\tOk (reactions)\n}\n\nfn calc_dependencies \u003c'inp\u003e (reactions: \u0026 Reactions \u003c'inp\u003e) -\u003e GenResult \u003cDependencies \u003c'inp\u003e\u003e {\n\tlet mut dependencies: HashMap \u003cInpStr, Vec \u003cInpStr\u003e\u003e = HashMap::new ();\n\tdependencies.insert (InpStr::borrow (\"ORE\"), Vec::new ());\n\tloop {\n\t\tlet mut progress = false;\n\t\tlet mut pending = false;\n\t\tfor reaction in reactions.values () {\n\t\t\tif dependencies.contains_key (\u0026 reaction.output.chem) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif reaction.inputs.iter ().all (|input| dependencies.contains_key (\u0026 input.chem)) {\n\t\t\t\tdependencies.insert (\n\t\t\t\t\treaction.output.chem.clone (),\n\t\t\t\t\treaction.inputs.iter ()\n\t\t\t\t\t\t.flat_map (|input| iter::once (\u0026 input.chem)\n\t\t\t\t\t\t\t.chain (dependencies [\u0026 input.chem].iter ()))\n\t\t\t\t\t\t.cloned ()\n\t\t\t\t\t\t.collect ());\n\t\t\t\tprogress = true;\n\t\t\t} else {\n\t\t\t\tpending = true;\n\t\t\t}\n\t\t}\n\t\tif ! progress { return Err (\"No solution found\".into ()) }\n\t\tif ! pending { break }\n\t}\n\tOk (dependencies)\n}\n\nfn calc_order \u003c'inp\u003e (\n\treactions: \u0026 Reactions \u003c'inp\u003e,\n\tdependencies: \u0026 Dependencies \u003c'inp\u003e,\n) -\u003e GenResult \u003cOrder \u003c'inp\u003e\u003e {\n\tlet mut completed: HashSet \u003cInpStr\u003e = HashSet::new ();\n\tlet mut order: Vec \u003cInpStr\u003e = Vec::new ();\n\tcompleted.insert (InpStr::borrow (\"ORE\"));\n\tloop {\n\t\tlet mut pending = false;\n\t\tlet mut progress = false;\n\t\tfor reaction in reactions.values () {\n\t\t\tif completed.contains (\u0026 reaction.output.chem) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif dependencies [\u0026 reaction.output.chem].iter ()\n\t\t\t\t\t.all (|input| completed.contains (input)) {\n\t\t\t\tcompleted.insert (reaction.output.chem.clone ());\n\t\t\t\torder.push (reaction.output.chem.clone ());\n\t\t\t\tprogress = true;\n\t\t\t} else {\n\t\t\t\tpending = true;\n\t\t\t}\n\t\t}\n\t\tif ! progress { return Err (\"No solution found\".into ()) }\n\t\tif ! pending { break }\n\t}\n\torder.reverse ();\n\tOk (order)\n}\n\nfn calc_ore (reactions: \u0026 Reactions, order: \u0026 Order, num_fuel: Qty) -\u003e GenResult \u003cQty\u003e {\n\tlet mut quantities: HashMap \u003cInpStr, Qty\u003e = HashMap::new ();\n\tquantities.insert (InpStr::borrow (\"FUEL\"), num_fuel);\n\tfor output_chemical in order {\n\t\tlet reaction = \u0026 reactions [output_chemical];\n\t\tlet needed_qty = * quantities.get (output_chemical).ok_or (\"No solution found\") ?;\n\t\tif needed_qty == Qty::ZERO { continue }\n\t\tlet reaction_times = Qty::div_2 (\n\t\t\tQty::sub_2 (Qty::add_2 (needed_qty, reaction.output.qty) ?, 1) ?,\n\t\t\treaction.output.qty) ?;\n\t\tfor input in \u0026 reaction.inputs {\n\t\t\tlet entry = quantities.entry (input.chem.clone ()).or_insert (0);\n\t\t\t* entry = Qty::add_2 (* entry, Qty::mul_2 (input.qty, reaction_times) ?) ?;\n\t\t}\n\t}\n\tOk (quantities.get (\u0026 InpStr::borrow (\"ORE\")).copied ().ok_or (\"No solution found\") ?)\n}\n","traces":[{"line":8,"address":[79488,80145],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[79713,79506,79572],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[79656,79746,79970],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[79829,79988,79852],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[79883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[81271,80160],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[80261,80406,80188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[80352,80713,80439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[80734,80531,80554],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[80755,80624],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[80687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[80786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[80792,80900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[80826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[81051,80838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[80892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[80963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[84529,83072],"length":1,"stats":{"Line":1},"fn_name":"calc_order"},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[86358,84544],"length":1,"stats":{"Line":1},"fn_name":"calc_ore"},{"line":109,"address":[84828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[85206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[85234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[85263,85243,85308],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[85329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[85471,85392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[85774,85757,85809],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[86158,86176],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":49,"coverable":75},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-14","model.rs"],"content":"use super::*;\n\npub type Qty = u64;\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Reaction \u003c'inp\u003e {\n\tpub inputs: Vec \u003cChemQty \u003c'inp\u003e\u003e,\n\tpub output: ChemQty \u003c'inp\u003e,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tReaction \u003c'inp\u003e { inputs, output } = [ @delim_some \", \" inputs, \" =\u003e \", output ]\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct ChemQty \u003c'inp\u003e {\n\tpub chem: InpStr \u003c'inp\u003e,\n\tpub qty: Qty,\n}\n\nstruct_display! {\n\tinput_lifetime = 'inp;\n\tChemQty \u003c'inp\u003e { chem, qty } = [ qty, \" \", chem ]\n}\n\nstruct_parser! {\n\tinput_lifetime = 'inp;\n\tChemQty \u003c'inp\u003e { chem, qty } = [ qty, \" \", chem = parse_chem ]\n}\n\nfn parse_chem \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tparser.take_rest_while (|ch| ch.is_ascii_uppercase (), 1 .. )\n}\n","traces":[{"line":13,"address":[62969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-15","input.rs"],"content":"use super::*;\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-15","lib.rs"],"content":"//! Advent of Code 2019: Day 15: Oxygen System\n//!\n//! [https://adventofcode.com/2019/day/15](https://adventofcode.com/2019/day/15)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Oxygen System\";\n\tyear = 2019;\n\tday = 15;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-15","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\nuse model::Core;\nuse model::CoreStep;\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\nuse model::Tile;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut seen = HashSet::new ();\n\tseen.insert (Pos::ZERO);\n\tlet mut todo = Vec::new ();\n\ttodo.push ((Core::new (input), Pos::ZERO, 0));\n\twhile let Some ((core, pos, dist)) = todo.pop () {\n\t\tfor dir in [ Dir::North, Dir::South, Dir::West, Dir::East ] {\n\t\t\tlet adj_pos = (pos + (dir, 1)) ?;\n\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\tlet mut core = core.clone ();\n\t\t\tmatch core.step (dir) ? {\n\t\t\t\tCoreStep::Blocked =\u003e continue,\n\t\t\t\tCoreStep::Moved =\u003e todo.push ((core, adj_pos, dist + 1)),\n\t\t\t\tCoreStep::Found =\u003e return Ok (dist + 1),\n\t\t\t}\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = calc_grid (input) ?;\n\tcalc_mins (grid)\n}\n\nfn calc_mins (mut grid: Grid) -\u003e GenResult \u003cu32\u003e {\n\tlet mut todo: Vec \u003cPos\u003e =\n\t\tgrid.iter ()\n\t\t\t.filter (|\u0026 (_, tile)| tile == Tile::OxygenSystem)\n\t\t\t.map (|(pos, _)| pos)\n\t\t\t.collect ();\n\tlet mut todo_temp = Vec::new ();\n\tlet mut num_mins = 0;\n\tloop {\n\t\tfor pos in todo.drain ( .. ) {\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\tif 128 \u003c adj_pos.n.abs () + adj_pos.e.abs () {\n\t\t\t\t\treturn Err (\"Giving up due to distance from starting point\".into ());\n\t\t\t\t}\n\t\t\t\tif grid.get (adj_pos).unwrap () != Tile::Empty { continue }\n\t\t\t\tgrid.set (adj_pos, Tile::Oxygen);\n\t\t\t\ttodo_temp.push (adj_pos);\n\t\t\t}\n\t\t}\n\t\tmem::swap (\u0026 mut todo, \u0026 mut todo_temp);\n\t\tif todo.is_empty () { break }\n\t\tnum_mins += 1;\n\t}\n\tOk (num_mins)\n}\n\nfn calc_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tlet mut grid = Grid::new_range (Pos::new (-16, -16), Pos::new (17, 17)) ?;\n\tgrid.set (Pos::ZERO, Tile::Empty);\n\tlet mut todo = Vec::new ();\n\ttodo.push ((Core::new (input), Pos::ZERO));\n\twhile let Some ((core, pos)) = todo.pop () {\n\t\tfor dir in [ Dir::North, Dir::South, Dir::West, Dir::East ] {\n\t\t\tlet adj_pos = (pos + (dir, 1)) ?;\n\t\t\tif 128 \u003c adj_pos.n.abs () + adj_pos.e.abs () {\n\t\t\t\treturn Err (\"Giving up due to distance from starting point\".into ());\n\t\t\t}\n\t\t\tlet adj_tile = grid.get (adj_pos).ok_or (()).or_else (|()| {\n\t\t\t\tgrid = grid.extend_in_place ([(16, 16); 2]) ?;\n\t\t\t\tOk::\u003c_, Overflow\u003e (Tile::Unknown)\n\t\t\t}) ?;\n\t\t\tif adj_tile != Tile::Unknown { continue }\n\t\t\tlet mut core = core.clone ();\n\t\t\tlet adj_tile = match core.step (dir) ? {\n\t\t\t\tCoreStep::Blocked =\u003e Tile::Wall,\n\t\t\t\tCoreStep::Moved =\u003e Tile::Empty,\n\t\t\t\tCoreStep::Found =\u003e Tile::OxygenSystem,\n\t\t\t};\n\t\t\tgrid.set (adj_pos, adj_tile);\n\t\t\tif adj_tile != Tile::Wall {\n\t\t\t\ttodo.push ((core, adj_pos));\n\t\t\t}\n\t\t}\n\t}\n\tOk (grid)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-15","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub use self::core::Core;\npub use self::core::CoreStep;\n\npub type Coord = i16;\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Dir = aoc_pos::DirGeo;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosGeo \u003cCoord\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i32;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tUnknown = \" \",\n\t\tEmpty = \".\",\n\t\tWall = \"#\",\n\t\tOxygenSystem = \"S\",\n\t\tOxygen = \"O\",\n\t}\n}\n\nmod core {\n\n\tuse super::*;\n\n\t#[ derive (Clone) ]\n\tpub struct Core {\n\t\tcpu: Cpu,\n\t}\n\n\timpl Core {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn new (input: \u0026 Input) -\u003e Self {\n\t\t\tlet mut cpu = Cpu::new (input.data.clone ());\n\t\t\tcpu.set_mem_limit (4 * 1024);\n\t\t\tSelf { cpu }\n\t\t}\n\n\t\t#[ allow (clippy::wildcard_enum_match_arm) ]\n\t\t#[ inline ]\n\t\tpub fn step (\u0026 mut self, dir: Dir) -\u003e Result \u003cCoreStep, RunResult\u003e {\n\t\t\tself.cpu.input (match dir {\n\t\t\t\tDir::North =\u003e Val::ONE,\n\t\t\t\tDir::South =\u003e Val::TWO,\n\t\t\t\tDir::West =\u003e Val::THREE,\n\t\t\t\tDir::East =\u003e Val::FOUR,\n\t\t\t});\n\t\t\tself.cpu.set_max_ops (100);\n\t\t\tmatch self.cpu.run () {\n\t\t\t\tRunResult::Output (Val::ZERO) =\u003e Ok (CoreStep::Blocked),\n\t\t\t\tRunResult::Output (Val::ONE) =\u003e Ok (CoreStep::Moved),\n\t\t\t\tRunResult::Output (Val::TWO) =\u003e Ok (CoreStep::Found),\n\t\t\t\tother =\u003e Err (other),\n\t\t\t}\n\t\t}\n\n\t}\n\n\tpub enum CoreStep {\n\t\tBlocked,\n\t\tMoved,\n\t\tFound,\n\t}\n\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-16","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"24176176\", puzzle.part_one (\u0026 [ \"80871224585914546619083218645595\" ]));\n\tassert_eq_ok! (\"73745418\", puzzle.part_one (\u0026 [ \"19617804207202209144916044189917\" ]));\n\tassert_eq_ok! (\"52432133\", puzzle.part_one (\u0026 [ \"69317163492948606335995924319873\" ]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"84462026\", puzzle.part_two (\u0026 [ \"03036732577212944063491565474664\" ]));\n\tassert_eq_ok! (\"78725270\", puzzle.part_two (\u0026 [ \"02935109699940807407585447034323\" ]));\n\tassert_eq_ok! (\"53553731\", puzzle.part_two (\u0026 [ \"03081770884921959731165446850517\" ]));\n}\n","traces":[{"line":6,"address":[38592,39587],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":7,"address":[38609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[38672,39103,39544,38630,38728,39037],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[39506,38847,38788,39171,39232,38750],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[39297,39358,38869,38913,39465,38972],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[40595,39600],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":15,"address":[39617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[39680,39736,40111,40552,39638,40045],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[40514,39796,39855,40240,40179,39758],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[40473,39980,39877,40366,40305,39921],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-16","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cu8\u003e,\n\tpub params: InputParams,\n}\n\nstruct_display! {\n\tInput { data, params } = [ params, @collect data ]\n}\n\nstruct_parser! {\n\tInput { data, params } = [ params, @collect data = parse_num ]\n}\n\nfn parse_num (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tlet ch = parser.expect_next () ?;\n\tif ! ch.is_ascii_digit () { return Err (parser.err ()) }\n\tOk (ch.to_digit (10).unwrap ().pan_u8 ())\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_iters: u32 = (\"NUM_ITERS=\", 100, 1_u32 .. ),\n\t\tpub num_reps: u32 = (\"NUM_REPS=\", 10_000, 1_u32 .. ),\n\t\tpub offset_digits: u32 = (\"OFFSET_DIGITS=\", 7, 1_u32 .. 10_u32),\n\t\tpub result_digits: u32 = (\"RESULT_DIGITS=\", 8, 1_u32 .. 100_u32),\n\t\tpub max_signal: u32 = (\"MAX_SIGNAL=\", 1_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":14,"address":[65399,64967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[70624],"length":1,"stats":{"Line":1},"fn_name":"parse_num"},{"line":18,"address":[70671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[70821,70730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[70807,70732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[72399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[72403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[72407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[72411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[72415],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-16","lib.rs"],"content":"//! Advent of Code 2019: Day 16: Flawed Frequency Transmission\n//!\n//! [https://adventofcode.com/2019/day/16](https://adventofcode.com/2019/day/16)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Flawed Frequency Transmission\";\n\tyear = 2019;\n\tday = 16;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[37092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[37540],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-16","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut signal = input.data.clone ();\n\tif signal.len () \u003c input.params.result_digits.pan_usize () {\n\t\treturn Err (\"Not enough signal data\".into ());\n\t}\n\tif input.params.max_signal.pan_usize () \u003c signal.len () {\n\t\treturn Err (\"Too much signal data\".into ());\n\t}\n\tfor _ in 0 .. input.params.num_iters {\n\t\tsignal = apply_fft (\u0026 signal, 0) ?;\n\t}\n\tOk (\n\t\tsignal.iter ()\n\t\t\t.take (input.params.result_digits.pan_usize ())\n\t\t\t.display_delim (\"\")\n\t\t\t.to_string ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet offset =\n\t\tinput.data.iter ().copied ()\n\t\t\t.take (input.params.offset_digits.pan_usize ())\n\t\t\t.try_fold (0, |sum, item| u32::add_2 (u32::mul_2 (sum, 10) ?, item.pan_u32 ())) ?;\n\tlet signal_len = usize::sub_2 (\n\t\tinput.data.len () * input.params.num_reps.pan_usize (),\n\t\toffset.pan_usize (),\n\t) ?;\n\tif signal_len \u003c input.params.result_digits.pan_usize () {\n\t\treturn Err (\"Not enough signal data\".into ());\n\t}\n\tif input.params.max_signal.pan_usize () \u003c signal_len {\n\t\treturn Err (format! (\"Too much signal data {signal_len}\").into ());\n\t}\n\tlet mut signal: Vec \u003cu8\u003e =\n\t\titer::repeat (\u0026 input.data)\n\t\t\t.flatten ()\n\t\t\t.skip (offset.pan_usize () % input.data.len ())\n\t\t\t.take (signal_len)\n\t\t\t.copied ()\n\t\t\t.collect ();\n\tfor _ in 0 .. input.params.num_iters {\n\t\tsignal = apply_fft (\u0026 signal, offset) ?;\n\t}\n\tOk (\n\t\tsignal.iter ()\n\t\t\t.take (input.params.result_digits.pan_usize ())\n\t\t\t.display_delim (\"\")\n\t\t\t.to_string ()\n\t)\n}\n\n#[ allow (clippy::unnecessary_wraps) ]\nfn apply_fft (data: \u0026 [u8], offset: u32) -\u003e GenResult \u003cVec \u003cu8\u003e\u003e {\n\tlet mut buffer: Vec \u003ci32\u003e =\n\t\tdata.iter ().rev ()\n\t\t\t.map (|\u0026 val| val.pan_i32 ())\n\t\t\t.scan (0_i32, |sum, val| { * sum += val; Some (* sum) })\n\t\t\t.collect ();\n\tbuffer.reverse ();\n\tlet result = (offset .. )\n\t\t.take (data.len ())\n\t\t.map (|dst_idx| {\n\t\t\tlet sum = buffer [(dst_idx - offset).pan_usize () .. ].iter ()\n\t\t\t\t.step_by ((dst_idx + 1).pan_usize ())\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(iter_idx, \u0026 val)| if (iter_idx + 1) \u0026 0x2 == 0 { val } else { - val })\n\t\t\t\t.sum::\u003ci32\u003e ();\n\t\t\t(sum.unsigned_abs () % 10).pan_u8 ()\n\t\t})\n\t\t.collect ();\n\tOk (result)\n}\n","traces":[{"line":6,"address":[34064,34681],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":7,"address":[34087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[34096,34163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[34182,34243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[34324,34331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[34394,34352,34418,34606],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[34443,34578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[34477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[34704,36147],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":26,"address":[34727,35044],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[34766],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[54944,54972],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":31,"address":[35061,36047,35133],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[35349,35292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[35354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[35434,35377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[35532,35446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[36074,35617],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[35646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[35704,35712],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[35773,35728,35798,36002,36106],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[35955,35825],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[35854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[36530,36160],"length":1,"stats":{"Line":1},"fn_name":"apply_fft"},{"line":60,"address":[36187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[43867,43899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[36405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[36409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[55136],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":69,"address":[55466,55150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[55253,55493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[45162,45195,45244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[55385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[36460],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":34},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-17","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-17","lib.rs"],"content":"//! Advent of Code 2019: Day 17: Set and Forget\n//!\n//! [https://adventofcode.com/2019/day/17](https://adventofcode.com/2019/day/17)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Set and Forget\";\n\tyear = 2019;\n\tday = 17;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-17","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Cpu;\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\nuse model::Step;\nuse model::Tile;\nuse model::Turn;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = calc_grid (input) ?;\n\tOk (\n\t\tgrid.iter ()\n\t\t\t.filter (|\u0026 (_, tile)| ! matches! (tile, Tile::Empty))\n\t\t\t.filter (|\u0026 (pos, _)| pos.adjacent_4 ().into_iter ()\n\t\t\t\t.map (|adj_pos| grid.get (adj_pos).unwrap_or (Tile::Empty))\n\t\t\t\t.filter (|\u0026 tile| ! matches! (tile, Tile::Empty))\n\t\t\t\t.count () == 4)\n\t\t\t.map (|(pos, _)| pos.x.pan_u32 () * pos.y.pan_u32 ())\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut grid = calc_grid (input) ?;\n\tlet (bot_pos, bot_dir) = find_bot (\u0026 mut grid) ?;\n\tlet route = find_route (\u0026 grid, bot_pos, bot_dir) ?;\n\tlet (main, funcs) = find_funcs (\u0026 route) ?;\n\tlet result = exec_route (input, \u0026 main, \u0026 funcs) ?;\n\tOk (result)\n}\n\npub type Func = ArrayVec \u003cStep, 10\u003e;\npub type Funcs = ArrayVec \u003cFunc, 3\u003e;\npub type Main = ArrayVec \u003cchar, 10\u003e;\n\nfn calc_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_mem_limit (8_192);\n\tcpu.set_max_ops (100_000);\n\tlet mut output = String::new ();\n\twhile let Some (val) = cpu.run ().output () ? {\n\t\toutput.push (val.to_char () ?);\n\t}\n\tGrid::parse_from_str (output.trim_end ())\n}\n\nfn find_bot (grid: \u0026 mut Grid) -\u003e GenResult \u003c(Pos, Dir)\u003e {\n\tlet (bot_pos, bot_dir) = grid.iter ()\n\t\t.filter_map (|(pos, tile)| Some ((pos, match tile {\n\t\t\tTile::RobotUp =\u003e Dir::Up,\n\t\t\tTile::RobotDown =\u003e Dir::Down,\n\t\t\tTile::RobotLeft =\u003e Dir::Left,\n\t\t\tTile::RobotRight =\u003e Dir::Right,\n\t\t\tTile::Empty | Tile::Scaffold =\u003e return None,\n\t\t})))\n\t\t.exactly_one ().ok ().ok_or (\"Must have exactly one robot tile\") ?;\n\tgrid.set (bot_pos, Tile::Scaffold);\n\tOk ((bot_pos, bot_dir))\n}\n\nfn find_route (grid: \u0026 Grid, mut pos: Pos, mut dir: Dir) -\u003e GenResult \u003cVec \u003cStep\u003e\u003e {\n\tlet mut result = Vec::new ();\n\tlet mut seen = HashSet::new ();\n\tloop {\n\t\tif ! seen.insert (pos) { return Err (\"No solution found\".into ()) }\n\t\tlet has_left = grid.get (pos.try_add ((dir + Turn::Left, 1)) ?) == Some (Tile::Scaffold);\n\t\tlet has_right = grid.get (pos.try_add ((dir + Turn::Right, 1)) ?) == Some (Tile::Scaffold);\n\t\tif ! has_left \u0026\u0026 ! has_right { break }\n\t\tif has_left \u0026\u0026 has_right { return Err (\"No solution found\".into ()) }\n\t\tif has_left { dir = dir + Turn::Left; }\n\t\tif has_right { dir = dir + Turn::Right; }\n\t\tlet mut dist = 0;\n\t\tloop {\n\t\t\tlet next_pos = pos.try_add ((dir, 1)) ?;\n\t\t\tif grid.get (next_pos) != Some (Tile::Scaffold) { break }\n\t\t\tpos = next_pos;\n\t\t\tdist += 1;\n\t\t}\n\t\tresult.push (if has_left { Step::Left (dist) } else { Step::Right (dist) });\n\t}\n\tOk (result)\n}\n\nfn find_funcs (route: \u0026 [Step]) -\u003e GenResult \u003c(Main, Funcs)\u003e {\n\n\tlet mut todo = Vec::new ();\n\ttodo.push ((0, Main::new (), Funcs::new ()));\n\tlet mut num_iters = 1000_u32;\n\n\twhile let Some ((prefix_len, main, funcs)) = todo.pop () {\n\n\t\tif num_iters == 0 { return Err (\"Giving up after too many iterations\".into ()) }\n\t\tnum_iters -= 1;\n\n\t\t// find matching functions for the remaining route\n\n\t\tfor (func_id, func) in ('A' .. ).zip (\u0026 funcs) {\n\t\t\tif ! itertools::equal (\n\t\t\t\t\troute.iter ().copied ().skip (prefix_len).take (func.len ()),\n\t\t\t\t\tfunc.iter ().copied ()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet mut main = main.clone ();\n\t\t\tmain.push (func_id);\n\t\t\tif prefix_len + func.len () == route.len () { return Ok ((main, funcs)) }\n\t\t\ttodo.push ((prefix_len + func.len (), main, funcs.clone ()));\n\t\t}\n\n\t\t// define new functions from prefixes of the remaining route\n\n\t\tif funcs.is_full () { continue }\n\t\tfor func_len in 1 .. (route.len () - prefix_len) {\n\t\t\tlet func: Func =\n\t\t\t\troute [prefix_len .. prefix_len + func_len].iter ().copied ().collect ();\n\t\t\tif 20 \u003c (\u0026 func).display_delim (\",\").to_string ().len () { break }\n\t\t\tif funcs.contains (\u0026 func) { continue }\n\t\t\tlet func_id = ('A'.pan_u32 () + funcs.len ().pan_u32 ()).pan_char ();\n\t\t\tlet mut funcs = funcs.clone ();\n\t\t\tfuncs.push (func);\n\t\t\tlet mut main = main.clone ();\n\t\t\tmain.push (func_id);\n\t\t\ttodo.push ((prefix_len + func_len, main, funcs));\n\t\t}\n\n\t}\n\n\tErr (\"No solution found\".into ())\n\n}\n\nfn exec_route (input: \u0026 Input, main: \u0026 Main, funcs: \u0026 Funcs) -\u003e GenResult \u003cVal\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_mem_limit (8_192);\n\tcpu.set_max_ops (200_000);\n\tcpu.mem_set (Val::ZERO, Val::TWO).unwrap ();\n\tcpu.input_str (\u0026 format! (\"{}\\n\", main.display_delim (\",\")));\n\tfor func in funcs {\n\t\tcpu.input_str (\u0026 format! (\"{}\\n\", func.display_delim (\",\")));\n\t}\n\tcpu.input_str (\"n\\n\");\n\tlet mut last_output = None;\n\twhile let Some (output) = cpu.run ().output () ? { last_output = Some (output); }\n\tOk (last_output.ok_or (\"No solution found\") ?)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-17","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\npub type Turn = pos::Turn2d;\npub type Val = i32;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tEmpty = \".\",\n\t\tScaffold = \"#\",\n\t\tRobotUp = \"^\",\n\t\tRobotDown = \"v\",\n\t\tRobotLeft = \"\u003c\",\n\t\tRobotRight = \"\u003e\",\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Step {\n\tLeft (u32),\n\tRight (u32),\n}\n\nimpl Display for Step {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Left (dist) =\u003e write! (formatter, \"L,{dist}\"),\n\t\t\tSelf::Right (dist) =\u003e write! (formatter, \"R,{dist}\"),\n\t\t}\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"#########\",\n\t\"#b.A.@.a#\",\n\t\"#########\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"########################\",\n\t\"#f.D.E.e.C.b.A.@.a.B.c.#\",\n\t\"######################.#\",\n\t\"#d.....................#\",\n\t\"########################\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"########################\",\n\t\"#...............b.C.D.f#\",\n\t\"#.######################\",\n\t\"#.....@.a.B.c.d.A.e.F.g#\",\n\t\"########################\",\n];\n\nconst EXAMPLE_3: \u0026 [\u0026 str] = \u0026 [\n\t\"#################\",\n\t\"#i.G..c...e..H.p#\",\n\t\"########.########\",\n\t\"#j.A..b...f..D.o#\",\n\t\"########@########\",\n\t\"#k.E..a...g..B.n#\",\n\t\"########.########\",\n\t\"#l.F..d...h..C.m#\",\n\t\"#################\",\n];\n\nconst EXAMPLE_4: \u0026 [\u0026 str] = \u0026 [\n\t\"########################\",\n\t\"#@..............ac.GI.b#\",\n\t\"###d#e#f################\",\n\t\"###A#B#C################\",\n\t\"###g#h#i################\",\n\t\"########################\",\n];\n\nconst EXAMPLE_5: \u0026 [\u0026 str] = \u0026 [\n\t\"#######\",\n\t\"#a.#Cd#\",\n\t\"##...##\",\n\t\"##.@.##\",\n\t\"##...##\",\n\t\"#cB#Ab#\",\n\t\"#######\",\n];\n\nconst EXAMPLE_6: \u0026 [\u0026 str] = \u0026 [\n\t\"###############\",\n\t\"#d.ABC.#.....a#\",\n\t\"######...######\",\n\t\"######.@.######\",\n\t\"######...######\",\n\t\"#b.....#.....c#\",\n\t\"###############\",\n];\n\nconst EXAMPLE_7: \u0026 [\u0026 str] = \u0026 [\n\t\"#############\",\n\t\"#DcBa.#.GhKl#\",\n\t\"#.###...#I###\",\n\t\"#e#d#.@.#j#k#\",\n\t\"###C#...###J#\",\n\t\"#fEbA.#.FgHi#\",\n\t\"#############\",\n];\n\nconst EXAMPLE_8: \u0026 [\u0026 str] = \u0026 [\n\t\"#############\",\n\t\"#g#f.D#..h#l#\",\n\t\"#F###e#E###.#\",\n\t\"#dCba...BcIJ#\",\n\t\"#####.@.#####\",\n\t\"#nK.L...G...#\",\n\t\"#M###N#H###.#\",\n\t\"#o#m..#i#jk.#\",\n\t\"#############\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"8\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"86\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"132\", puzzle.part_one (EXAMPLE_2));\n\tassert_eq_ok! (\"136\", puzzle.part_one (EXAMPLE_3));\n\tassert_eq_ok! (\"81\", puzzle.part_one (EXAMPLE_4));\n\tassert_eq_ok! (\"26\", puzzle.part_one (EXAMPLE_5));\n\tassert_eq_ok! (\"50\", puzzle.part_one (EXAMPLE_6));\n\tassert_eq_ok! (\"127\", puzzle.part_one (EXAMPLE_7));\n\tassert_eq_ok! (\"114\", puzzle.part_one (EXAMPLE_8));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"8\", puzzle.part_two (EXAMPLE_5));\n\tassert_eq_ok! (\"24\", puzzle.part_two (EXAMPLE_6));\n\tassert_eq_ok! (\"32\", puzzle.part_two (EXAMPLE_7));\n\tassert_eq_ok! (\"72\", puzzle.part_two (EXAMPLE_8));\n}\n","traces":[{"line":91,"address":[52304,52308],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":92,"address":[95841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[95904,95862,98561,95960,97029,97095],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[96020,97163,95982,96079,97224,98523],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[96204,98482,96101,97292,96145,97353],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[97482,96329,96226,98441,96270,97421],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[98400,96454,96351,97550,97611,96395],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[96579,97679,97740,96520,96476,98359],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[96601,97808,96645,97869,98318,96704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[96829,97998,96770,96726,97937,98277],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[96851,98124,98236,96895,98063,96954],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[52340,52336],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":106,"address":[98641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[99171,98757,98662,98704,99829,99234],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[99300,99360,98868,98777,99793,98815],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[98888,98932,99486,98988,99426,99754],"length":1,"stats":{"Line":3},"fn_name":null},{"line":110,"address":[99008,99052,99609,99549,99715,99108],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":17,"coverable":17},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-18","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters: u32 = (\"MAX_ITERS=\", 50_000, 1_u32 .. ),\n\t\tpub max_path_starts: u32 = (\"MAX_PATH_STARTS=\", 40, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":18,"address":[104339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[104343],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-18","lib.rs"],"content":"//! Advent of Code 2019: Day 18: Many-Worlds Interpretation\n//!\n//! [https://adventofcode.com/2019/day/18](https://adventofcode.com/2019/day/18)\n//!\n//! # Input\n//!\n//! Grid representation of a map, with the following characters:\n//!\n//! - `.` open space\n//! - `#` wall\n//! - `@` entrance\n//! - `a`-`z` key\n//! - `A`-`Z` door\n//!\n//! # Part one\n//!\n//! Find the lowest number of steps from the entrance to collect all keys. Doors can only be passed\n//! once the corresponding key has been collected.\n//!\n//! # Part two\n//!\n//! Replace the entrance with a nine-by-nine grid of squares with entrances at each corner, and the\n//! rest as walls. The goal is the same, but there are four actors to track instead of one. Keys\n//! collected by any actor can be used by all of them.\n//!\n//! # Algorithm\n//!\n//! First we simplify the map, removing any obvious dead ends.\n//!\n//! Next, we perform path analysis. Find routes from every entrance and key to all other keys which\n//! are in reach. Track any keys or doors which are passed through on each path, and the number of\n//! steps. We track keys the same as doors because there's no point in passing a key without\n//! picking it up, so this makes the subsequent search more efficient.\n//!\n//! Finally, perform a priority search where each node includes the position of all actors and the\n//! keys collected so far. The next nodes at each point are the paths from this point which lead to\n//! unclaimed keys and don't pass through any doors or keys which we haven't collected yet.\n//!\n//! The path-finding part of this algorithm only considers the shortest route, which works fine for\n//! the maps supplied. This would not work if the shortest route passes through a door for which we\n//! don't have a key, but there is a longer route which goes a different way, assuming this would\n//! result in a shorter total number of steps.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\nuse aoc_search::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Many-Worlds Interpretation\";\n\tyear = 2019;\n\tday = 18;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":61,"address":[72337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[72705],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-18","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Grid;\nuse model::Pos;\nuse model::Tile::{ self, DeadEnd, Door, Entrance, Key, Open, Wall };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut grid = input.grid.clone ();\n\tsimplify_grid (\u0026 mut grid);\n\tcalc_result (input, \u0026 grid)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut grid = input.grid.clone ();\n\tmultiply_entrance (\u0026 mut grid) ?;\n\tsimplify_grid (\u0026 mut grid);\n\tcalc_result (input, \u0026 grid)\n}\n\nfn multiply_entrance (grid: \u0026 mut Grid) -\u003e GenResult \u003c()\u003e {\n\tlet (start_pos, _) = grid.iter ()\n\t\t.find (|\u0026 (_, tile)| matches! (tile, Entrance))\n\t\t.ok_or (\"No entrance found\") ?;\n\tfor (offset, tile) in [\n\t\t(Pos { y: -1, x: -1 }, Entrance),\n\t\t(Pos { y: -1, x: 0 }, Wall),\n\t\t(Pos { y: -1, x: 1 }, Entrance),\n\t\t(Pos { y: 0, x: -1 }, Wall),\n\t\t(Pos { y: 0, x: 0 }, Wall),\n\t\t(Pos { y: 0, x: 1 }, Wall),\n\t\t(Pos { y: 1, x: -1 }, Entrance),\n\t\t(Pos { y: 1, x: 0 }, Wall),\n\t\t(Pos { y: 1, x: 1 }, Entrance),\n\t] {\n\t\tlet pos = start_pos.try_add (offset).ok ().ok_or (\"Entrance on edge of map\") ?;\n\t\tgrid.try_set (pos, tile).ok_or (\"Entrance on edge of map\") ?;\n\t}\n\tOk (())\n}\n\nfn calc_result (input: \u0026 Input, grid: \u0026 Grid) -\u003e GenResult \u003cu32\u003e {\n\tif grid.iter ().filter (|\u0026 (_, tile)| matches! (tile, Entrance)).count () \u003e 4 {\n\t\treturn Err (\"More than four entrances\".into ());\n\t}\n\tlet paths = calc_paths (input, grid) ?;\n\tlet need_keys = grid.values ()\n\t\t.filter_map (|tile| match tile {\n\t\t\tKey (id) =\u003e Some (id),\n\t\t\tDeadEnd | Door (_) | Entrance | Open | Wall =\u003e None,\n\t\t})\n\t\t.fold (0_u32, |sum, val| sum | (1 \u003c\u003c val));\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|(posns, need_keys): (ArrayVec \u003cPos, 4\u003e, u32), dist: u32, mut adder: PrioritySearchAdder \u003c_, _, _\u003e| {\n\t\t\tfor (pos_idx, \u0026 pos) in posns.iter ().enumerate () {\n\t\t\t\tfor path in \u0026 paths [\u0026 pos] {\n\t\t\t\t\tif need_keys \u0026 (1 \u003c\u003c path.key_id) == 0 { continue }\n\t\t\t\t\tif need_keys \u0026 path.need_keys != 0 { continue }\n\t\t\t\t\tlet mut posns = posns.clone ();\n\t\t\t\t\tposns [pos_idx] = * path.route.last ().unwrap ();\n\t\t\t\t\tlet need_keys = need_keys \u0026 ! (1 \u003c\u003c path.key_id);\n\t\t\t\t\tlet dist = dist + path.route.len ().pan_u32 ();\n\t\t\t\t\tadder.add ((posns, need_keys), dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\t(posns, need_keys, dist)\n\t\t});\n\tlet start_posns: ArrayVec \u003cPos, 4\u003e =\n\t\tgrid.iter ()\n\t\t\t.filter (|\u0026 (_, tile)| matches! (tile, Tile::Entrance))\n\t\t\t.map (|(pos, _)| pos)\n\t\t\t.collect ();\n\tsearch.push ((start_posns, need_keys), 0_u32);\n\tfor (num_iters, (_, need_keys, dist)) in search.enumerate () {\n\t\tif num_iters.pan_u32 () == input.params.max_iters {\n\t\t\treturn Err (\"Giving up after max iters\".into ());\n\t\t}\n\t\tif need_keys != 0 { continue }\n\t\treturn Ok (dist);\n\t}\n\tErr (\"No solution found\".into ())\n}\n\n#[ derive (Clone, Debug) ]\nstruct Path {\n\tkey_id: u8,\n\tneed_keys: u32,\n\troute: Vec \u003cPos\u003e,\n}\n\ntype Paths = HashMap \u003cPos, Vec \u003cPath\u003e\u003e;\n\nfn calc_paths (input: \u0026 Input, grid: \u0026 Grid) -\u003e GenResult \u003cPaths\u003e {\n\n\tlet mut all_paths = Paths::new ();\n\n\t// iterate over path starting points (entrances and keys)\n\n\tlet mut num_starts = 0;\n\tfor (start_pos, start_tile) in grid.iter ()\n\t\t\t.filter (|\u0026 (_, tile)| matches! (tile, Entrance | Key (_))) {\n\t\tlet mut paths = Vec::new ();\n\t\tnum_starts += 1;\n\t\tif input.params.max_path_starts \u003c num_starts {\n\t\t\treturn Err (\"Refusing to handle too many path start points\".into ());\n\t\t}\n\n\t\t// breadth-first search paths from starting point\n\n\t\tlet mut todo: VecDeque \u003c(u32, Vec \u003cPos\u003e)\u003e = VecDeque::new ();\n\t\ttodo.push_back ((0, vec! [ start_pos ]));\n\t\tlet mut seen: HashSet \u003cPos\u003e = HashSet::new ();\n\t\tseen.insert (start_pos);\n\t\twhile let Some ((need_keys, route)) = todo.pop_front () {\n\t\t\tlet pos = * route.last ().unwrap ();\n\n\t\t\t// iterate next steps\n\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\t\tlet adj_tile = some_or! (grid.get (adj_pos), continue);\n\t\t\t\tif matches! (adj_tile, Wall) { continue }\n\t\t\t\tif matches! (start_tile, Entrance) \u0026\u0026 matches! (adj_tile, Entrance) {\n\t\t\t\t\treturn Err (\"Multiple connected entrances\".into ());\n\t\t\t\t}\n\n\t\t\t\t// continue iteration via this position\n\n\t\t\t\tlet next_need_keys =\n\t\t\t\t\tif let Door (key_id) | Key (key_id) = adj_tile {\n\t\t\t\t\t\tneed_keys | 1 \u003c\u003c key_id\n\t\t\t\t\t} else { need_keys };\n\t\t\t\tlet mut next_route = route.clone ();\n\t\t\t\tnext_route.push (adj_pos);\n\t\t\t\ttodo.push_back ((next_need_keys, next_route));\n\n\t\t\t\t// record path to keys\n\n\t\t\t\tif let Key (key_id) = adj_tile {\n\t\t\t\t\tpaths.push (Path {\n\t\t\t\t\t\tkey_id,\n\t\t\t\t\t\tneed_keys,\n\t\t\t\t\t\troute: route.iter ().skip (1).copied ()\n\t\t\t\t\t\t\t.chain (iter::once (adj_pos))\n\t\t\t\t\t\t\t.collect (),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tall_paths.insert (start_pos, paths);\n\n\t}\n\n\tOk (all_paths)\n\n}\n\nfn simplify_grid (grid: \u0026 mut Grid) {\n\tconst fn can_pass (tile: Option \u003cTile\u003e) -\u003e bool {\n\t\tmatches! (tile, Some (Open | Key (_) | Door (_) | Entrance))\n\t}\n\tfn is_dead_end (grid: \u0026 Grid, pos: Pos) -\u003e bool {\n\t\tmatches! (grid.get (pos), Some (Open))\n\t\t\t\u0026\u0026 pos.adjacent_4 ().into_iter ()\n\t\t\t\t.filter (|\u0026 pos| can_pass (grid.get (pos)))\n\t\t\t\t.count () \u003c= 1\n\t}\n\tlet mut todo: Vec \u003cPos\u003e =\n\t\tgrid.keys ()\n\t\t\t.filter (|\u0026 pos| is_dead_end (grid, pos))\n\t\t\t.collect ();\n\twhile let Some (pos) = todo.pop () {\n\t\tgrid.set (pos, DeadEnd);\n\t\ttodo.extend (pos.adjacent_4 ().iter ().copied ()\n\t\t\t.filter (|\u0026 pos| is_dead_end (grid, pos)));\n\t}\n}\n","traces":[{"line":10,"address":[87456,87562],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[87498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[87509],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[87736,87584],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":18,"address":[87626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[87675],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[87683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[87744,88533],"length":1,"stats":{"Line":1},"fn_name":"multiply_entrance"},{"line":24,"address":[88144,88124],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[88080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[88374,88518,88151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[88431,88392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[88446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[90353,88544],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":45,"address":[44144],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":46,"address":[88707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[89929,88743,88825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[44160],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":54,"address":[44176],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":56,"address":[44224,44258,45302],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":57,"address":[44417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[44688,44708],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[44723,45046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[44752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[45076,44831],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[44851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[44912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[44995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[67071],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[89963,90113,90265,89784,90298,89452,89817],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[89875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[90022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[89884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[90067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[89976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[93580,90368],"length":1,"stats":{"Line":2},"fn_name":"calc_paths"},{"line":102,"address":[90636,90904],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[42853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[93094,90964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[90988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[92991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[91197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[91560,91638,92533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[91731],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[91854,91741,91780,93495],"length":1,"stats":{"Line":6},"fn_name":null},{"line":122,"address":[91887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[91899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[91936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[92725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[91948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[91964,93034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[91984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[92118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[92235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[92354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[92937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[93600,93942],"length":1,"stats":{"Line":1},"fn_name":"simplify_grid"},{"line":164,"address":[93952],"length":1,"stats":{"Line":0},"fn_name":"can_pass"},{"line":165,"address":[45328],"length":1,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[93984],"length":1,"stats":{"Line":0},"fn_name":"is_dead_end"},{"line":168,"address":[81848,82233,86172,86118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[43019,43211,42972,43164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":170,"address":[45313,45312,45349],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":175,"address":[43122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[93778],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[93787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[93806,93840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[42930],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":56,"coverable":68},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-18","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\npub type Turn = pos::Turn2d;\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Tile {\n\t#[ default ]\n\tOpen,\n\tDeadEnd,\n\tWall,\n\tEntrance,\n\tKey (u8),\n\tDoor (u8),\n}\n\nimpl Display for Tile {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Open =\u003e write! (formatter, \".\"),\n\t\t\tSelf::DeadEnd =\u003e write! (formatter, \"~\"),\n\t\t\tSelf::Wall =\u003e write! (formatter, \"#\"),\n\t\t\tSelf::Entrance =\u003e write! (formatter, \"@\"),\n\t\t\tSelf::Key (id) =\u003e write! (formatter, \"{}\", ('a'.pan_u8 () + id).pan_char ()),\n\t\t\tSelf::Door (id) =\u003e write! (formatter, \"{}\", ('A'.pan_u8 () + id).pan_char ()),\n\t\t}\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Tile {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet tile = match parser.peek ().ok_or_else (|| parser.err ()) ? {\n\t\t\t'.' =\u003e Self::Open,\n\t\t\t'#' =\u003e Self::Wall,\n\t\t\t'@' =\u003e Self::Entrance,\n\t\t\tch @ 'a' ..= 'z' =\u003e Self::Key (ch.pan_u8 () - 'a'.pan_u8 ()),\n\t\t\tch @ 'A' ..= 'Z' =\u003e Self::Door (ch.pan_u8 () - 'A'.pan_u8 ()),\n\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t};\n\t\tparser.expect_next () ?;\n\t\tOk (tile)\n\t}\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":7,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-19","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-19","lib.rs"],"content":"//! Advent of Code 2019: Day 19: Tractor Beam\n//!\n//! [https://adventofcode.com/2019/day/19](https://adventofcode.com/2019/day/19)\n//!\n//! # Input\n//!\n//! Comma separated list of initial memory values for [`intcode`] program.\n//!\n//! # Part one\n//!\n//! Run the programme with two inputs representing `x` and `y` coordinates, then read a single\n//! output which is `1` or `0`. Count the number of points with coordinates in the range\n//! `(0 .. 50)` for which the output is `1`.\n//!\n//! # Part two\n//!\n//! Find the closest square of `100x100` to the origin of points which all generate an output of\n//! `1`. Return the `x` coordinate times `10,000` plus the `y` coordinate.\n//!\n//! # Algorithm\n//!\n//! The points which return `1` are contained within two straight lines stretching out from the\n//! origin. Only positive coordinate values need to be considered. This allows us to optimise in\n//! a few ways.\n//!\n//! For part one, we consider a square of increasing size starting at the origin. Every time the\n//! square grows by one, we consider the new points added. Assuming any points are active, we only\n//! need to find the range of points which are active. We also know the number of inactive points\n//! at each end can only increase. We iterate from both ends, skipping the number of inactive\n//! points from the previous iteration, and look for the first active point. With this information\n//! we can deduce the total number of active points in this square which weren't included in the\n//! previous one.\n//!\n//! For part two we start off with something similar, searching ever increasing squares, but we\n//! are looking for any `100x100` square which may contain an origin. If the bottom right point in\n//! a square is not active, then none of the 10,000 points in the square could be a valid origin,\n//! since every one of them would have to include this point.\n//!\n//! Once we find a square which may contain an origin, we repeat the same process with increased\n//! granularity until we find some matches. Since we are searching a square size which doesn't\n//! correspond to the final square size, we start checking four points instead of a single one.\n//! These are still aligned to the bottom right, eg to check if a square of `25x25` might be valid\n//! at the origin then we check `24,24`, `24,99`, `99,24` and `99,99`.\n//!\n//! Every time we increase the search radius for the initial `100x100` square, we find all possible\n//! results before returning and then pick the largest one. We also always cache results because\n//! running the actual programme is rather slow.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Tractor Beam\";\n\tyear = 2019;\n\tday = 19;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-19","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Cpu;\nuse model::Pos;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut lookup = Lookup::new (input.data.clone ());\n\tlet mut num_affected: u32 = 0;\n\tlet mut x_min = 0;\n\tlet mut y_min = 0;\n\tfor size in 0 .. 50 {\n\t\tlet mut new_x_min = x_min;\n\t\tlet mut new_y_min = y_min;\n\t\twhile new_y_min \u003c size * 2 + 1 - new_x_min {\n\t\t\tlet pos = if new_y_min \u003c= size {\n\t\t\t\tPos::new (new_y_min, size)\n\t\t\t} else {\n\t\t\t\tPos::new (size, size * 2 - new_y_min)\n\t\t\t};\n\t\t\tif ! lookup.get (pos) ? { new_y_min += 1; } else { break }\n\t\t}\n\t\twhile new_x_min \u003c size * 2 + 1 - new_y_min {\n\t\t\tlet pos = if new_x_min \u003c= size {\n\t\t\t\tPos::new (size, new_x_min)\n\t\t\t} else {\n\t\t\t\tPos::new (size * 2 - new_x_min, size)\n\t\t\t};\n\t\t\tif ! lookup.get (pos) ? { new_x_min += 1; } else { break }\n\t\t}\n\t\tlet step_affected = size * 2 + 1 - new_y_min - new_x_min;\n\t\tif 0 \u003c step_affected {\n\t\t\ty_min = new_y_min;\n\t\t\tx_min = new_x_min;\n\t\t\tnum_affected += step_affected.pan_u32 ();\n\t\t}\n\t}\n\tOk (num_affected)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut lookup = Lookup::new (input.data.clone ());\n\tlet mut candidates: Vec \u003cPos\u003e = Vec::new ();\n\tfor base_radius in (100 .. 2_500).step_by (100) {\n\n\t\t#[ derive (Clone, Copy) ]\n\t\tenum Level { First, Second, Third }\n\t\tlet mut todo: Vec \u003c(Level, Pos)\u003e = Vec::new ();\n\n\t\tfor coarse_pos in\n\t\t\titer::once (Pos::new (base_radius - 100, base_radius - 100))\n\t\t\t\t.chain ((0 .. base_radius - 100).step_by (100).map (|y| Pos::new (y, base_radius - 100)))\n\t\t\t\t.chain ((0 .. base_radius - 100).step_by (100).map (|x| Pos::new (base_radius - 100, x))) {\n\n\t\t\tif 5_000 \u003c lookup.len () {\n\t\t\t\treturn Err (\"Giving up after too many executions\".into ());\n\t\t\t}\n\n\t\t\tif ! lookup.get (coarse_pos + Pos::new (99, 99)) ? { continue }\n\t\t\ttodo.push ((Level::First, coarse_pos));\n\n\t\t}\n\n\t\twhile let Some ((level, todo_pos)) = todo.pop () {\n\n\t\t\tif 5_000 \u003c lookup.len () {\n\t\t\t\treturn Err (\"Giving up after too many executions\".into ());\n\t\t\t}\n\n\t\t\tlet (size, step, incr, next_level) = match level {\n\t\t\t\tLevel::First =\u003e (100, 25, 24, Some (Level::Second)),\n\t\t\t\tLevel::Second =\u003e (25, 5, 4, Some (Level::Third)),\n\t\t\t\tLevel::Third =\u003e (5, 1, 0, None),\n\t\t\t};\n\n\t\t\tfor search_pos in\n\t\t\t\t(todo_pos.y .. todo_pos.y + size).step_by (step).flat_map (|y|\n\t\t\t\t\t(todo_pos.x .. todo_pos.x + size).step_by (step).map (move |x|\n\t\t\t\t\t\tPos::new (y, x))) {\n\n\t\t\t\tif ! lookup.get (search_pos + Pos::new (99, incr)) ? { continue }\n\t\t\t\tif ! lookup.get (search_pos + Pos::new (incr, 99)) ? { continue }\n\t\t\t\tif ! lookup.get (search_pos + Pos::new (incr, incr)) ? { continue }\n\t\t\t\tif ! lookup.get (search_pos + Pos::new (99, 99)) ? { continue }\n\n\t\t\t\tif let Some (next_level) = next_level {\n\t\t\t\t\ttodo.push ((next_level, search_pos));\n\t\t\t\t} else {\n\t\t\t\t\tcandidates.push (search_pos);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ! candidates.is_empty () { break }\n\n\t}\n\n\tlet closest = candidates.iter ().copied ()\n\t\t.min_by_key (|pos| {\n\t\t\tlet y = pos.y.unsigned_abs ().pan_i32 ();\n\t\t\tlet x = pos.x.unsigned_abs ().pan_i32 ();\n\t\t\ty * y + x * x\n\t\t})\n\t\t.ok_or (\"No solution found\") ?;\n\n\tOk (closest.x.pan_u32 () * 10_000 + closest.y.pan_u32 ())\n\n}\n\nstruct Lookup {\n\tprog: Vec \u003cVal\u003e,\n\tcache: HashMap \u003cPos, bool\u003e,\n}\n\nimpl Lookup {\n\tfn new (prog: Vec \u003cVal\u003e) -\u003e Self {\n\t\tlet cache = HashMap::new ();\n\t\tSelf { prog, cache }\n\t}\n\tfn len (\u0026 self) -\u003e usize {\n\t\tself.cache.len ()\n\t}\n\tfn get (\u0026 mut self, pos: Pos) -\u003e GenResult \u003cbool\u003e {\n\t\tif let Some (\u0026 val) = self.cache.get (\u0026 pos) { return Ok (val) }\n\t\tlet mut cpu = Cpu::new (self.prog.clone ());\n\t\tcpu.set_max_ops (500);\n\t\tcpu.input (Val::from (pos.x));\n\t\tcpu.input (Val::from (pos.y));\n\t\tlet val = match cpu.run ().output () ? {\n\t\t\tSome (1) =\u003e true,\n\t\t\tSome (0) =\u003e false,\n\t\t\tSome (other) =\u003e return Err (format! (\"Invalid output: {other}\").into ()),\n\t\t\tNone =\u003e return Err (\"Machine halted\".into ()),\n\t\t};\n\t\tself.cache.insert (pos, val);\n\t\tOk (val)\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-19","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\npub type Val = i64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\npub const EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"         A           \",\n\t\"         A           \",\n\t\"  #######.#########  \",\n\t\"  #######.........#  \",\n\t\"  #######.#######.#  \",\n\t\"  #######.#######.#  \",\n\t\"  #######.#######.#  \",\n\t\"  #####  B    ###.#  \",\n\t\"BC...##  C    ###.#  \",\n\t\"  ##.##       ###.#  \",\n\t\"  ##...DE  F  ###.#  \",\n\t\"  #####    G  ###.#  \",\n\t\"  #########.#####.#  \",\n\t\"DE..#######...###.#  \",\n\t\"  #.#########.###.#  \",\n\t\"FG..#########.....#  \",\n\t\"  ###########.#####  \",\n\t\"             Z       \",\n\t\"             Z       \",\n];\n\npub const EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"                   A               \",\n\t\"                   A               \",\n\t\"  #################.#############  \",\n\t\"  #.#...#...................#.#.#  \",\n\t\"  #.#.#.###.###.###.#########.#.#  \",\n\t\"  #.#.#.......#...#.....#.#.#...#  \",\n\t\"  #.#########.###.#####.#.#.###.#  \",\n\t\"  #.............#.#.....#.......#  \",\n\t\"  ###.###########.###.#####.#.#.#  \",\n\t\"  #.....#        A   C    #.#.#.#  \",\n\t\"  #######        S   P    #####.#  \",\n\t\"  #.#...#                 #......VT\",\n\t\"  #.#.#.#                 #.#####  \",\n\t\"  #...#.#               YN....#.#  \",\n\t\"  #.###.#                 #####.#  \",\n\t\"DI....#.#                 #.....#  \",\n\t\"  #####.#                 #.###.#  \",\n\t\"ZZ......#               QG....#..AS\",\n\t\"  ###.###                 #######  \",\n\t\"JO..#.#.#                 #.....#  \",\n\t\"  #.#.#.#                 ###.#.#  \",\n\t\"  #...#..DI             BU....#..LF\",\n\t\"  #####.#                 #.#####  \",\n\t\"YN......#               VT..#....QG\",\n\t\"  #.###.#                 #.###.#  \",\n\t\"  #.#...#                 #.....#  \",\n\t\"  ###.###    J L     J    #.#.###  \",\n\t\"  #.....#    O F     P    #.#...#  \",\n\t\"  #.###.#####.#.#####.#####.###.#  \",\n\t\"  #...#.#.#...#.....#.....#.#...#  \",\n\t\"  #.#####.###.###.#.#.#########.#  \",\n\t\"  #...#.#.....#...#.#.#.#.....#.#  \",\n\t\"  #.###.#####.###.###.#.#.#######  \",\n\t\"  #.#.........#...#.............#  \",\n\t\"  #########.###.###.#############  \",\n\t\"           B   J   C               \",\n\t\"           U   P   P               \",\n];\n\npub const EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"             Z L X W       C                 \",\n\t\"             Z P Q B       K                 \",\n\t\"  ###########.#.#.#.#######.###############  \",\n\t\"  #...#.......#.#.......#.#.......#.#.#...#  \",\n\t\"  ###.#.#.#.#.#.#.#.###.#.#.#######.#.#.###  \",\n\t\"  #.#...#.#.#...#.#.#...#...#...#.#.......#  \",\n\t\"  #.###.#######.###.###.#.###.###.#.#######  \",\n\t\"  #...#.......#.#...#...#.............#...#  \",\n\t\"  #.#########.#######.#.#######.#######.###  \",\n\t\"  #...#.#    F       R I       Z    #.#.#.#  \",\n\t\"  #.###.#    D       E C       H    #.#.#.#  \",\n\t\"  #.#...#                           #...#.#  \",\n\t\"  #.###.#                           #.###.#  \",\n\t\"  #.#....OA                       WB..#.#..ZH\",\n\t\"  #.###.#                           #.#.#.#  \",\n\t\"CJ......#                           #.....#  \",\n\t\"  #######                           #######  \",\n\t\"  #.#....CK                         #......IC\",\n\t\"  #.###.#                           #.###.#  \",\n\t\"  #.....#                           #...#.#  \",\n\t\"  ###.###                           #.#.#.#  \",\n\t\"XF....#.#                         RF..#.#.#  \",\n\t\"  #####.#                           #######  \",\n\t\"  #......CJ                       NM..#...#  \",\n\t\"  ###.#.#                           #.###.#  \",\n\t\"RE....#.#                           #......RF\",\n\t\"  ###.###        X   X       L      #.#.#.#  \",\n\t\"  #.....#        F   Q       P      #.#.#.#  \",\n\t\"  ###.###########.###.#######.#########.###  \",\n\t\"  #.....#...#.....#.......#...#.....#.#...#  \",\n\t\"  #####.#.###.#######.#######.###.###.#.#.#  \",\n\t\"  #.......#.......#.#.#.#.#...#...#...#.#.#  \",\n\t\"  #####.###.#####.#.#.#.#.###.###.#.###.###  \",\n\t\"  #.......#.....#.#...#...............#...#  \",\n\t\"  #############.#.#.###.###################  \",\n\t\"               A O F   N                     \",\n\t\"               A A D   M                     \",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"23\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"58\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"77\", puzzle.part_one (EXAMPLE_2));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"26\", puzzle.part_two (EXAMPLE_0));\n\tassert_err! (\"No solution found\", puzzle.part_two (EXAMPLE_1));\n\tassert_eq_ok! (\"396\", puzzle.part_two (EXAMPLE_2));\n}\n","traces":[{"line":108,"address":[41920,42915],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":109,"address":[41937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[42431,42056,41958,42000,42872,42365],"length":1,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[42834,42116,42175,42078,42499,42560],"length":1,"stats":{"Line":3},"fn_name":null},{"line":112,"address":[42197,42241,42300,42793,42686,42625],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[44028,42928],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":117,"address":[42945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[43019,42972,43078,43973,43451,43517],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[43097,43949,43647,43260,43922,43136],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[43689,43386,43330,43889,43293,43750],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-20","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-20","lib.rs"],"content":"//! Advent of Code 2019: Day 20: Donut Maze\n//!\n//! [https://adventofcode.com/2019/day/20](https://adventofcode.com/2019/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\nuse aoc_search::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Donut Maze\";\n\tyear = 2019;\n\tday =20;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-20","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Portal;\nuse model::Pos;\nuse model::Tile::{ Empty, Letter, Passage, Wall };\n\ntype Paths = HashMap \u003cPortal, Vec \u003c(Portal, u32)\u003e\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, false)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, true)\n}\n\nfn calc_result (input: \u0026 Input, recursive: bool) -\u003e GenResult \u003cu32\u003e {\n\tlet paths = get_paths (input) ?;\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|(portal, level), dist, mut adder: PrioritySearchAdder \u003c_, _, _\u003e| {\n\t\t\tif portal != Portal::ZZ.partner () {\n\t\t\t\tfor \u0026 (next_portal, next_dist) in \u0026 paths [\u0026 portal] {\n\t\t\t\t\tlet next_level =\n\t\t\t\t\t\tif next_portal.inner () { level + 1_i32 } else { level - 1_i32 };\n\t\t\t\t\tif next_portal == Portal::AA { continue }\n\t\t\t\t\tif recursive \u0026\u0026 (next_portal == Portal::ZZ) != (next_level \u003c 0_i32) { continue }\n\t\t\t\t\tadder.add ((next_portal.partner (), next_level), dist + next_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\t(portal, level, dist)\n\t\t});\n\tsearch.push ((Portal::AA, 0_i32), 0);\n\tOk (\n\t\tsearch\n\t\t\t.take_while (|\u0026 (_, _, dist)| dist \u003c= 10_000)\n\t\t\t.find (|\u0026 (portal, level, _)|\n\t\t\t\tportal == Portal::ZZ.partner () \u0026\u0026 (! recursive || level == -1_i32))\n\t\t\t.map (|(_, _, dist)| dist - 1)\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\nfn get_paths (input: \u0026 Input) -\u003e GenResult \u003cPaths\u003e {\n\tlet portals = find_portals (input) ?;\n\tlet portals_by_pos: HashMap \u003cPos, Portal\u003e =\n\t\tportals.iter ()\n\t\t\t.map (|\u0026 (portal, pos_0, _)| (pos_0, portal))\n\t\t\t.collect ();\n\tlet mut all_paths = Paths::new ();\n\tfor (portal, pos_0, pos_1) in portals {\n\t\tlet mut paths = Vec::new ();\n\t\tlet mut seen = HashSet::new ();\n\t\tseen.insert (pos_0);\n\t\tseen.insert (pos_1);\n\t\tlet mut todo = Vec::new ();\n\t\ttodo.push ((pos_1, 0));\n\t\twhile let Some ((pos, dist)) = todo.pop () {\n\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\tif ! seen.insert (adj_pos) { continue }\n\t\t\t\tmatch input.grid.get (adj_pos) {\n\t\t\t\t\tSome (Passage) =\u003e todo.push ((adj_pos, dist + 1)),\n\t\t\t\t\tSome (Letter (_)) =\u003e {\n\t\t\t\t\t\tlet next_portal =\n\t\t\t\t\t\t\tportals_by_pos.get (\u0026 adj_pos).copied ()\n\t\t\t\t\t\t\t\t.ok_or (\"Invalid map\") ?;\n\t\t\t\t\t\tpaths.push ((next_portal, dist + 1));\n\t\t\t\t\t},\n\t\t\t\t\tSome (Wall) =\u003e (),\n\t\t\t\t\tSome (Empty) | None =\u003e return Err (\"Invalid map\".into ()),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif all_paths.insert (portal, paths).is_some () {\n\t\t\treturn Err (\"Duplicated portal\".into ());\n\t\t}\n\t}\n\tif ! all_paths.contains_key (\u0026 Portal::AA) { return Err (\"No portal AA\".into ()) }\n\tif ! all_paths.contains_key (\u0026 Portal::ZZ) { return Err (\"No portal ZZ\".into ()) }\n\tfor \u0026 portal in all_paths.keys () {\n\t\tif portal == Portal::AA || portal == Portal::ZZ { continue }\n\t\tif ! all_paths.contains_key (\u0026 portal.partner ()) {\n\t\t\treturn Err (\"Invalid map\".into ());\n\t\t}\n\t}\n\tOk (all_paths)\n}\n\nfn find_portals (input: \u0026 Input) -\u003e GenResult \u003cVec \u003c(Portal, Pos, Pos)\u003e\u003e {\n\tlet mut portals = Vec::new ();\n\tfor (pos, tile) in input.grid.iter () {\n\t\tif ! matches! (tile, Letter (_)) { continue }\n\t\tfor dir in [ Dir::Right, Dir::Down ] {\n\t\t\tlet (label, inner, pos_0, pos_1) = match (\n\t\t\t\tinput.grid.get (pos.try_add ((dir, -1)) ?),\n\t\t\t\tinput.grid.get (pos.try_add ((dir, 0)) ?),\n\t\t\t\tinput.grid.get (pos.try_add ((dir, 1)) ?),\n\t\t\t\tinput.grid.get (pos.try_add ((dir, 2)) ?),\n\t\t\t) {\n\t\t\t\t(None, Some (Letter (ch_0)), Some (Letter (ch_1)), Some (Passage)) =\u003e\n\t\t\t\t\t([ ch_0, ch_1 ], false, pos.try_add ((dir, 1)) ?, pos.try_add ((dir, 2)) ?),\n\t\t\t\t(Some (Passage), Some (Letter (ch_0)), Some (Letter (ch_1)), Some (Empty)) =\u003e\n\t\t\t\t\t([ ch_0, ch_1 ], true, pos, pos.try_add ((dir, -1)) ?),\n\t\t\t\t(Some (Empty), Some (Letter (ch_0)), Some (Letter (ch_1)), Some (Passage)) =\u003e\n\t\t\t\t\t([ ch_0, ch_1 ], true, pos.try_add ((dir, 1)) ?, pos.try_add ((dir, 2)) ?),\n\t\t\t\t(Some (Passage), Some (Letter (ch_0)), Some (Letter (ch_1)), None) =\u003e\n\t\t\t\t\t([ ch_0, ch_1 ], false, pos, pos.try_add ((dir, -1)) ?),\n\t\t\t\t_ =\u003e continue,\n\t\t\t};\n\t\t\tportals.push ((Portal::new (label, inner), pos_0, pos_1));\n\t\t}\n\t}\n\tOk (portals)\n}\n","traces":[{"line":13,"address":[80192],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":14,"address":[80196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[80208],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[80212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[81508,80240],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":22,"address":[80358,81065,80268],"length":1,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[90713,90672],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":25,"address":[90738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[90853,90748,91139,90896],"length":1,"stats":{"Line":8},"fn_name":null},{"line":28,"address":[91211,90915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[90973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[90989,91018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[91028,91254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[91159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[80624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[81110,80661,80864],"length":1,"stats":{"Line":5},"fn_name":null},{"line":39,"address":[47220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[91312],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":41,"address":[47250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[81093,81406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[85411,81520],"length":1,"stats":{"Line":2},"fn_name":"get_paths"},{"line":48,"address":[81556,81588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[72720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[85349,81923,82060],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[82459,82499],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[85298,82527,82471,82616],"length":1,"stats":{"Line":6},"fn_name":null},{"line":63,"address":[82643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[82647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[82711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[83070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[83076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[83678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[83454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[84773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[84441,84753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[84469,84820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[84640,84621],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[84672,84659],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[84720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[84728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[84874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[85424,87228],"length":1,"stats":{"Line":2},"fn_name":"find_portals"},{"line":94,"address":[85657,85570,85764],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[85775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[87203,85803,85891],"length":1,"stats":{"Line":4},"fn_name":null},{"line":97,"address":[86847,86352,86143,86669],"length":1,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[85915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[85985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[86036],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[86091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[86251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[86902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[86745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[86428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[87110],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":49,"coverable":55},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-20","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Dir = pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Tile {\n\t#[ default ]\n\tEmpty,\n\tPassage,\n\tWall,\n\tLetter (char),\n}\n\nimpl Display for Tile {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Empty =\u003e write! (formatter, \" \"),\n\t\t\tSelf::Passage =\u003e write! (formatter, \".\"),\n\t\t\tSelf::Wall =\u003e write! (formatter, \"#\"),\n\t\t\tSelf::Letter (ch) =\u003e write! (formatter, \"{}\", ch),\n\t\t}\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Tile {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet val = match parser.peek ().ok_or_else (|| parser.err ()) ? {\n\t\t\t' ' =\u003e Self::Empty,\n\t\t\t'.' =\u003e Self::Passage,\n\t\t\t'#' =\u003e Self::Wall,\n\t\t\tch @ 'A' ..= 'Z' =\u003e Self::Letter (ch),\n\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t};\n\t\tparser.expect_next () ?;\n\t\tOk (val)\n\t}\n}\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Portal {\n\tlabel: [char; 2],\n\tinner: bool,\n}\n\nimpl Portal {\n\n\t#[ must_use ]\n\tpub fn new (label: [char; 2], inner: bool) -\u003e Self {\n\t\tassert! (label.iter ().all (|\u0026 ch| ch.is_ascii_uppercase ()));\n\t\tSelf { label, inner }\n\t}\n\n\t#[ must_use ]\n\tpub const fn label (self) -\u003e [char; 2] {\n\t\tself.label\n\t}\n\n\t#[ must_use ]\n\tpub const fn inner (self) -\u003e bool {\n\t\tself.inner\n\t}\n\n\t#[ must_use ]\n\tpub const fn partner (self) -\u003e Self {\n\t\tSelf { label: self.label, inner: ! self.inner }\n\t}\n\n\tpub const AA: Self = Self { label: [ 'A', 'A' ], inner: false };\n\tpub const ZZ: Self = Self { label: [ 'Z', 'Z' ], inner: false };\n\n}\n\nimpl Debug for Portal {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter,\n\t\t\t\"Portal (\\\"{ch_0}{ch_1}\\\", {dir})\",\n\t\t\tch_0 = self.label [0],\n\t\t\tch_1 = self.label [1],\n\t\t\tdir = if self.inner { \"inner\" } else { \"outer\" })\n\t}\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[72144],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":52,"address":[59211,59200],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":62,"address":[72288],"length":1,"stats":{"Line":0},"fn_name":"inner"},{"line":63,"address":[72288],"length":1,"stats":{"Line":2},"fn_name":"inner"},{"line":67,"address":[72304],"length":1,"stats":{"Line":0},"fn_name":"partner"},{"line":68,"address":[72307],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-21","emul.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Instr {\n\tAnd (Reg, Reg),\n\tOr (Reg, Reg),\n\tNot (Reg, Reg),\n}\n\nimpl Display for Instr {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::And (src, dst) =\u003e write! (formatter, \"AND {src} {dst}\"),\n\t\t\tSelf::Or (src, dst) =\u003e write! (formatter, \"OR {src} {dst}\"),\n\t\t\tSelf::Not (src, dst) =\u003e write! (formatter, \"NOT {src} {dst}\"),\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Prog {\n\tinstrs: Vec \u003cInstr\u003e,\n}\n\nimpl Prog {\n\n\t#[ must_use ]\n\tpub const fn new () -\u003e Self {\n\t\tSelf { instrs: Vec::new () }\n\t}\n\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.instrs.len ()\n\t}\n\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.instrs.is_empty ()\n\t}\n\n\t#[ must_use ]\n\tpub fn push (\u0026 mut self, instr: Instr) -\u003e Option \u003c()\u003e {\n\t\tif 15 \u003c= self.instrs.len () { return None }\n\t\tself.instrs.push (instr);\n\t\tSome (())\n\t}\n\n\tpub fn eval (\u0026 self, regs: \u0026 mut [bool; 26]) {\n\t\tfor instr in \u0026 self.instrs {\n\t\t\tmatch * instr {\n\t\t\t\tInstr::Or (src, dst) =\u003e\n\t\t\t\t\tregs [dst.idx ()] = regs [src.idx ()] || regs [dst.idx ()],\n\t\t\t\tInstr::And (src, dst) =\u003e\n\t\t\t\t\tregs [dst.idx ()] = regs [src.idx ()] \u0026\u0026 regs [dst.idx ()],\n\t\t\t\tInstr::Not (src, dst) =\u003e\n\t\t\t\t\tregs [dst.idx ()] = ! regs [src.idx ()],\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn test \u003cconst LEN: usize\u003e (\u0026 self, sample: \u0026 [bool]) -\u003e Result \u003c(), Vec \u003cusize\u003e\u003e {\n\t\tlet mut track = Vec::new ();\n\t\tlet mut idx = 0;\n\t\tloop {\n\t\t\ttrack.push (idx);\n\t\t\tif sample.len () \u003c= idx { return Ok (()) }\n\t\t\tlet sample = \u0026 sample [idx .. ];\n\t\t\tif ! sample [0] { return Err (track) }\n\t\t\tlet mut regs = [false; 26];\n\t\t\tfor (reg_idx, reg) in regs.iter_mut ().enumerate () {\n\t\t\t\t* reg = sample.get (reg_idx + 1).copied ().unwrap_or (true);\n\t\t\t}\n\t\t\tself.eval (\u0026 mut regs);\n\t\t\tidx += if regs [Reg::J.idx ()] { 4 } else { 1 };\n\t\t}\n\t}\n\n}\n\nimpl Default for Prog {\n\tfn default () -\u003e Self {\n\t\tSelf::new ()\n\t}\n}\n\nimpl Display for Prog {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor instr in \u0026 self.instrs {\n\t\t\tDisplay::fmt (instr, formatter) ?;\n\t\t\tformatter.write_char ('\\n') ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl \u003c'prog\u003e IntoIterator for \u0026 'prog Prog {\n\ttype Item = \u0026 'prog Instr;\n\ttype IntoIter = SliceIter \u003c'prog, Instr\u003e;\n\tfn into_iter (self) -\u003e SliceIter \u003c'prog, Instr\u003e {\n\t\tself.instrs.iter ()\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Reg {\n\tidx: u8,\n}\n\nimpl Reg {\n\n\t#[ must_use ]\n\tpub fn char (self) -\u003e char {\n\t\tassert! (self.idx \u003c 26);\n\t\t('A'.pan_u32 () + self.idx.pan_u32 ()).pan_char ()\n\t}\n\n\t#[ must_use ]\n\tpub fn idx (self) -\u003e usize {\n\t\tself.idx.pan_usize ()\n\t}\n\n\tpub const J: Self = Self { idx: 9 };\n\tpub const T: Self = Self{ idx: 19 };\n\n}\n\nimpl Display for Reg {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.write_char (self.char ())\n\t}\n}\n\nimpl TryFrom \u003cchar\u003e for Reg {\n\ttype Error = Overflow;\n\tfn try_from (ch: char) -\u003e Result \u003cSelf, Overflow\u003e {\n\t\tif ! ('A' ..= 'Z').contains (\u0026 ch) { return Err (Overflow) }\n\t\tOk (Self { idx: (ch.pan_u32 () - 'A'.pan_u32 ()).pan_u8 () })\n\t}\n}\n\nimpl TryFrom \u003cusize\u003e for Reg {\n\ttype Error = Overflow;\n\tfn try_from (idx: usize) -\u003e Result \u003cSelf, Overflow\u003e {\n\t\tif ! (0 .. 26).contains (\u0026 idx) { return Err (Overflow) }\n\t\tOk (Self { idx: idx.pan_u8 () })\n\t}\n}\n","traces":[{"line":49,"address":[4784],"length":1,"stats":{"Line":0},"fn_name":"eval"},{"line":50,"address":[4858,5545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5583,5646,5122,4984,5065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5275,5500,5208,5601,5628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[5315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5426,5610,5365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[5680],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-21","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_ops: u32 = (\"MAX_OPS=\", 2_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-21","lib.rs"],"content":"//! Advent of Code 2019: Day 21: Springdroid Adventure\n//!\n//! [https://adventofcode.com/2019/day/21](https://adventofcode.com/2019/day/21)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod emul;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Springdroid Adventure\";\n\tyear = 2019;\n\tday = 21;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-21","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse emul::Instr;\nuse emul::Prog;\nuse emul::Reg;\nuse input::Input;\nuse model::Cpu;\nuse model::Frag;\nuse model::Val;\nuse model::Regs;\nuse model::Rules;\nuse model::RulesSet;\nuse model::Sample;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result::\u003c4\u003e (input, \"WALK\")\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcalc_result::\u003c9\u003e (input, \"RUN\")\n}\n\nfn calc_result \u003cconst LEN: usize\u003e (input: \u0026 Input, verb: \u0026 str) -\u003e GenResult \u003cVal\u003e {\n\tlet mut samples: Vec \u003cSample\u003e = Vec::new ();\n\tlet mut rules_set: RulesSet \u003cLEN\u003e = RulesSet::default ();\n\tloop {\n\t\tlet prog = find_prog (\u0026 rules_set) ?;\n\t\tmatch run_prog::\u003cLEN\u003e (input, \u0026 prog, verb) ? {\n\t\t\tRunResult::Success (val) =\u003e return Ok (val),\n\t\t\tRunResult::Failure (sample) =\u003e {\n\t\t\t\tif 40 \u003c sample.len () {\n\t\t\t\t\treturn Err (\"Refusing to handle very large sample\".into ());\n\t\t\t\t}\n\t\t\t\tif 20 \u003c samples.len () {\n\t\t\t\t\treturn Err (\"Refusing to handle too many failures\".into ());\n\t\t\t\t}\n\t\t\t\tif let Some (prev) = samples.iter ().position (|other| other == \u0026 sample) {\n\t\t\t\t\treturn Err (format! (\"Sample repeated ({prev})\").into ());\n\t\t\t\t}\n\t\t\t\tsamples.push (sample.clone ());\n\t\t\t\tlet new_rules_set = analyse::\u003cLEN\u003e (\u0026 sample);\n\t\t\t\trules_set.append (\u0026 new_rules_set);\n\t\t\t},\n\t\t}\n\t}\n}\n\nfn find_prog \u003cconst LEN: usize\u003e (rules_set: \u0026 RulesSet \u003cLEN\u003e) -\u003e GenResult \u003cProg\u003e {\n\tlet mut all_rules: Vec \u003c\u0026 Rules \u003cLEN\u003e\u003e = rules_set.iter ().collect ();\n\tall_rules.sort_by_key (|rules| (rules.num_conflicts (), rules.num_true ()));\n\tfor rules in all_rules {\n\t\tlet frag_sort_key = |\u0026 (frag, num_matches): \u0026 (Frag \u003cLEN\u003e, _)|\n\t\t\tcmp::Reverse (num_matches * 0xffff_u32 / (frag.num_holes () + 4));\n\t\tlet all_frags: Vec \u003c(Frag \u003cLEN\u003e, u32)\u003e = Frag::\u003cLEN\u003e::iter_all ()\n\t\t\t.filter_map (|frag| {\n\t\t\t\tlet mut num_matches = 0;\n\t\t\t\tfor \u0026 (regs, jump) in rules {\n\t\t\t\t\tif ! frag.matches (regs) { continue }\n\t\t\t\t\tif ! jump { return None }\n\t\t\t\t\tnum_matches += 1;\n\t\t\t\t}\n\t\t\t\tif num_matches == 0 { return None }\n\t\t\t\tSome ((frag, num_matches))\n\t\t\t})\n\t\t\t.sorted_by_key (frag_sort_key)\n\t\t\t.collect ();\n\t\t'CHOOSE_FRAGS: for frag_iter in 0 .. 3 {\n\t\t\tif all_frags.len () \u003c frag_iter { break }\n\t\t\tlet mut frags: Vec \u003c(Frag \u003cLEN\u003e, u32)\u003e =\n\t\t\t\tall_frags.iter ().copied ()\n\t\t\t\t\t.skip (frag_iter)\n\t\t\t\t\t.collect ();\n\t\t\tlet mut pending_rules: Vec \u003c(Regs \u003cLEN\u003e, bool)\u003e =\n\t\t\t\trules.iter ().copied ()\n\t\t\t\t\t.filter (|\u0026 (_, jump)| jump)\n\t\t\t\t\t.filter (|\u0026 (regs, _)| regs != Regs::ALL)\n\t\t\t\t\t.collect ();\n\t\t\tlet mut chosen_frags: Vec \u003cFrag \u003cLEN\u003e\u003e = Vec::new ();\n\t\t\twhile ! pending_rules.is_empty () {\n\t\t\t\tlet chosen_frag = some_or! (\n\t\t\t\t\tfrags.iter ().copied ()\n\t\t\t\t\t\t.min_by_key (frag_sort_key)\n\t\t\t\t\t\t.map (|(frag, _)| frag),\n\t\t\t\t\tbreak 'CHOOSE_FRAGS);\n\t\t\t\tchosen_frags.push (chosen_frag);\n\t\t\t\tpending_rules.retain (|\u0026 (regs, _)| ! chosen_frag.matches (regs));\n\t\t\t\tfor \u0026 mut (frag, ref mut num_matches) in frags.iter_mut () {\n\t\t\t\t\t* num_matches =\n\t\t\t\t\t\tpending_rules.iter ().copied ()\n\t\t\t\t\t\t\t.filter (|\u0026 (regs, _)| frag.matches (regs))\n\t\t\t\t\t\t\t.count ()\n\t\t\t\t\t\t\t.pan_u32 ();\n\t\t\t\t}\n\t\t\t\tfrags.retain (|\u0026 (_, num_matches)| num_matches != 0);\n\t\t\t}\n\t\t\tif let Some (frag_idx) =\n\t\t\t\tchosen_frags.iter ()\n\t\t\t\t\t.position (|\u0026 frag| frag.num_regs () == 1) {\n\t\t\t\tlet frag = chosen_frags.remove (frag_idx);\n\t\t\t\tchosen_frags.insert (0, frag);\n\t\t\t}\n\t\t\tif let Some (prog) = assemble_prog (\u0026 chosen_frags) {\n\t\t\t\treturn Ok (prog);\n\t\t\t}\n\t\t}\n\t}\n\tErr (\"Can't find programme\".into ())\n}\n\n/// Build a [`Prog`] from a list of [`Frag`]s\n///\n/// Each [`Frag`] represents a set of registers to be matched to specific values. The resulting\n/// [`Prog`] should leave `true` in the jump register `J` if any of the fragments matches, but not\n/// otherwise.\n///\n/// If the first [`Frag`] only matches a single register then this execute more efficiently, using\n/// only a single instruction. Otherwise there will be one instruction per register, plus an extra\n/// two, or only one if there is only a single negative register match.\n///\n#[ must_use ]\nfn assemble_prog \u003cconst LEN: usize\u003e (frags: \u0026 [Frag \u003cLEN\u003e]) -\u003e Option \u003cProg\u003e {\n\tlet mut prog = Prog::new ();\n\tfor frag in frags.iter () {\n\t\tif prog.is_empty () \u0026\u0026 frag.num_regs () == 1 {\n\t\t\tlet (idx, val) =\n\t\t\t\tfrag.iter ().enumerate ()\n\t\t\t\t\t.find (|\u0026 (_, val)| val.is_some ())\n\t\t\t\t\t.map (|(idx, val)| (idx, val.unwrap ()))\n\t\t\t\t\t.unwrap ();\n\t\t\tassert! (! val);\n\t\t\tprog.push (Instr::Not (idx.try_into ().ok () ?, Reg::J)) ?;\n\t\t\tcontinue;\n\t\t}\n\t\tif frag.num_holes () == 1 {\n\t\t\tlet idx = frag.iter ()\n\t\t\t\t.position (|val| val == Some (false))\n\t\t\t\t.unwrap ();\n\t\t\tprog.push (Instr::Not (idx.try_into ().ok () ?, Reg::T)) ?;\n\t\t} else {\n\t\t\tfor (idx, _) in frag.iter ().enumerate ()\n\t\t\t\t\t.filter (|\u0026 (_, val)| val == Some (false)) {\n\t\t\t\tprog.push (Instr::Or (idx.try_into ().ok () ?, Reg::T)) ?;\n\t\t\t}\n\t\t\tprog.push (Instr::Not (Reg::T, Reg::T)) ?;\n\t\t}\n\t\tfor (idx, _) in frag.iter ().enumerate ()\n\t\t\t\t.filter (|\u0026 (_, val)| val == Some (true)) {\n\t\t\tprog.push (Instr::And (idx.try_into ().ok () ?, Reg::T)) ?;\n\t\t}\n\t\tprog.push (Instr::Or (Reg::T, Reg::J)) ?;\n\t}\n\tSome (prog)\n}\n\n/// Analyse a [`Sample`] to produce a [`RulesSet`]\n///\n/// This performs a branching iteration over paths from the start to the end of the sample,\n/// recording the decision made at each point along with the register values. The result is a list\n/// of rules, where a program that implements any one of them will be able to pass this specific\n/// sample.\n///\nfn analyse \u003cconst LEN: usize\u003e (sample: \u0026 Sample) -\u003e RulesSet \u003cLEN\u003e {\n\tlet mut todo: Vec \u003c(Rules \u003cLEN\u003e, usize)\u003e = Vec::new ();\n\tlet start_rules = Rules::default ();\n\ttodo.push ((start_rules, 0));\n\tlet mut seen: HashSet \u003c(Rules \u003cLEN\u003e, usize)\u003e = HashSet::new ();\n\tlet mut rules_set = RulesSet::new ();\n\twhile let Some ((rules, idx)) = todo.pop () {\n\t\tif ! seen.insert ((rules.clone (), idx)) { continue }\n\t\tif sample [idx .. ].iter ().all (|\u0026 val| val) {\n\t\t\trules_set.push (rules);\n\t\t\tcontinue;\n\t\t}\n\t\tlet regs = Regs::from_slice (\u0026 sample [idx + 1 .. ]);\n\t\tif sample.get (idx + 1).copied ().unwrap_or (true) {\n\t\t\tif let Some (new_rules) = rules.with_rule (regs, false) {\n\t\t\t\ttodo.push ((new_rules, idx + 1));\n\t\t\t}\n\t\t}\n\t\tif sample.get (idx + 4).copied ().unwrap_or (true) {\n\t\t\tif let Some (new_rules) = rules.with_rule (regs, true) {\n\t\t\t\ttodo.push ((new_rules, idx + 4));\n\t\t\t}\n\t\t}\n\t}\n\trules_set\n}\n\nfn run_prog \u003cconst LEN: usize\u003e (input: \u0026 Input, prog: \u0026 Prog, verb: \u0026 str) -\u003e GenResult \u003cRunResult\u003e {\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tcpu.set_max_ops (input.params.max_ops);\n\tcpu.input_str (\u0026 format! (\"{prog}{verb}\\n\"));\n\tlet mut output_str = String::new ();\n\tlet mut output_val = None;\n\twhile let Some (val) = cpu.run ().output () ? {\n\t\tif (0x00_i32 .. 0x80_i32).contains (\u0026 val) { output_str.push (val.pan_char ()); }\n\t\telse if 0x80_i32 \u003c= val { output_val = Some (val); }\n\t\telse { return Err (format! (\"Invalid output: {val}\").into ()) }\n\t}\n\tif let Some (val) = output_val { return Ok (RunResult::Success (val)) }\n\tlet sample = extract_sample::\u003cLEN\u003e (\u0026 output_str) ?;\n\tOk (RunResult::Failure (sample))\n}\n\nfn extract_sample \u003cconst LEN: usize\u003e (output: \u0026 str) -\u003e GenResult \u003cSample\u003e {\n\tlet sample_line =\n\t\toutput.split ('\\n')\n\t\t\t.find (|line| line.starts_with ('#'))\n\t\t\t.ok_or (\"Couldn't find sample in output\") ?;\n\tlet mut sample_data: Vec \u003cbool\u003e =\n\t\tsample_line.chars ()\n\t\t\t.map (|ch| Ok::\u003c_, GenError\u003e (match ch {\n\t\t\t\t'#' =\u003e true,\n\t\t\t\t'.' =\u003e false,\n\t\t\t\tother =\u003e return Err (format! (\"Invalid character in sample: {other}\").into ()),\n\t\t\t}))\n\t\t\t.try_collect () ?;\n\tsample_data.extend (iter::repeat (true).take (LEN));\n\tOk (Sample::from (sample_data))\n}\n\nenum RunResult {\n\tFailure (Sample),\n\tSuccess (Val),\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":134},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-21","model.rs"],"content":"use super::*;\n\npub use frag::Frag;\npub use frag::FragIter;\npub use regs::Regs;\npub use regs::RegsIter;\npub use rules::Rules;\npub use rules_set::RulesSet;\npub use sample::Sample;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type Val = i32;\n\nmod frag {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Frag \u003cconst LEN: usize\u003e {\n\t\tmask: u16,\n\t\tregs: u16,\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Frag \u003cLEN\u003e {\n\n\t\t#[ must_use ]\n\t\tpub const fn get (self, idx: usize) -\u003e Option \u003cbool\u003e {\n\t\t\tif LEN \u003c= idx { return None }\n\t\t\tif self.mask \u003c\u003c (16 - LEN + idx) \u0026 0x8000 == 0 { return None }\n\t\t\tSome (self.regs \u003c\u003c (16 - LEN + idx) \u0026 0x8000 == 0)\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn num_regs (self) -\u003e u32 {\n\t\t\tself.mask.count_ones ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn num_holes (self) -\u003e u32 {\n\t\t\tself.regs.count_ones ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn first_reg (self) -\u003e u32 {\n\t\t\tself.mask.leading_zeros () + LEN.pan_u32 () - 16\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn first_hole (self) -\u003e u32 {\n\t\t\tself.regs.leading_zeros () + LEN.pan_u32 () - 16\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn last_reg (self) -\u003e u32 {\n\t\t\tLEN.pan_u32 () - self.mask.trailing_zeros ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn last_hole (self) -\u003e u32 {\n\t\t\tLEN.pan_u32 () - self.regs.trailing_zeros ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn iter (self) -\u003e FragIter {\n\t\t\tFragIter {\n\t\t\t\tmask: self.mask \u003c\u003c (16 - LEN),\n\t\t\t\tregs: self.regs \u003c\u003c (16 - LEN),\n\t\t\t\tremain: LEN.pan_u16 (),\n\t\t\t}\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn matches (self, regs: Regs \u003cLEN\u003e) -\u003e bool {\n\t\t\tregs.holes () \u0026 self.mask == self.regs\n\t\t}\n\n\t\tpub fn iter_all () -\u003e impl Iterator \u003cItem = Self\u003e {\n\t\t\tlet mut mask = 0;\n\t\t\tlet mut regs = 0;\n\t\t\titer::from_fn (move || {\n\t\t\t\tif Regs::\u003cLEN\u003e::MASK \u003c mask { return None }\n\t\t\t\tregs = (regs | (Regs::\u003cLEN\u003e::MASK \u0026 ! mask)) + 1;\n\t\t\t\tif Regs::\u003cLEN\u003e::MASK \u003c regs {\n\t\t\t\t\tregs = 0;\n\t\t\t\t\tmask += 1;\n\t\t\t\t\tif Regs::\u003cLEN\u003e::MASK \u003c mask { return None }\n\t\t\t\t}\n\t\t\t\tSome (Self { regs: regs \u0026 mask, mask })\n\t\t\t})\n\t\t}\n\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Debug for Frag \u003cLEN\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet mut mask = self.mask \u003c\u003c (16 - LEN);\n\t\t\tlet mut regs = self.regs \u003c\u003c (16 - LEN);\n\t\t\tfor _ in 0 .. LEN {\n\t\t\t\tif mask \u0026 0x8000 == 0 { formatter.write_char ('') ?; }\n\t\t\t\telse if regs \u0026 0x8000 == 0 { formatter.write_char ('#') ?; }\n\t\t\t\telse { formatter.write_char ('_') ?; }\n\t\t\t\tmask \u003c\u003c= 1_u32;\n\t\t\t\tregs \u003c\u003c= 1_u32;\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\tpub struct FragIter {\n\t\tmask: u16,\n\t\tregs: u16,\n\t\tremain: u16,\n\t}\n\n\timpl Iterator for FragIter {\n\t\ttype Item = Option \u003cbool\u003e;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003cOption \u003cbool\u003e\u003e {\n\t\t\tif self.remain == 0 { return None }\n\t\t\tlet val = if self.mask \u0026 0x8000 == 0 { None } else { Some (self.regs \u0026 0x8000 == 0) };\n\t\t\tself.mask \u003c\u003c= 1_u32;\n\t\t\tself.regs \u003c\u003c= 1_u32;\n\t\t\tself.remain -= 1_u16;\n\t\t\tSome (val)\n\t\t}\n\t}\n\n}\n\nmod regs {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Regs \u003cconst LEN: usize\u003e { data: u16 }\n\n\timpl \u003cconst LEN: usize\u003e Regs \u003cLEN\u003e {\n\n\t\t#[ must_use ]\n\t\tpub fn from_slice (slice: \u0026 [bool]) -\u003e Self {\n\t\t\tassert! (LEN \u003c= slice.len ());\n\t\t\tlet mut data = 0;\n\t\t\tfor \u0026 val in slice.iter ().take (LEN) {\n\t\t\t\tdata \u003c\u003c= 1_u32;\n\t\t\t\tif ! val { data |= 1; }\n\t\t\t}\n\t\t\tSelf { data }\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn first_hole (self) -\u003e u32 {\n\t\t\tif self.data == 0 { 0 } else { self.data.leading_zeros () + LEN.pan_u32 () - 16 }\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn last_hole (self) -\u003e u32 {\n\t\t\tif self.data == 0 { 0 } else { LEN.pan_u32 () - self.data.trailing_zeros () }\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn get (self, idx: usize) -\u003e Option \u003cbool\u003e {\n\t\t\t(idx.pan_usize () \u003c LEN).then_some (\n\t\t\t\tself.data \u0026 (0x8000 \u003e\u003e (16 - LEN + idx)) == 0)\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn holes (self) -\u003e u16 {\n\t\t\tself.data\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn not_holes (self) -\u003e u16 {\n\t\t\tself.data ^ Self::MASK\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn iter (self) -\u003e RegsIter \u003cLEN\u003e {\n\t\t\tRegsIter { data: self.data \u003c\u003c (32 - LEN), remain: LEN.pan_u16 () }\n\t\t}\n\n\t\tpub const ALL: Self = Self { data: 0 };\n\t\tpub const NONE: Self = Self { data: Self::MASK };\n\t\tpub const MASK: u16 = ! (u16::MAX \u003c\u003c LEN);\n\n\t}\n\n\timpl \u003cconst LEN: usize\u003e TryFrom \u003cu16\u003e for Regs \u003cLEN\u003e {\n\t\ttype Error = Overflow;\n\t\tfn try_from (data: u16) -\u003e Result \u003cSelf, Overflow\u003e {\n\t\t\tif data \u0026 ! Self::MASK != 0 { return Err (Overflow) }\n\t\t\tOk (Self { data })\n\t\t}\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Display for Regs \u003cLEN\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet mut data = self.data \u003c\u003c (32 - LEN);\n\t\t\tfor _ in 0 .. LEN {\n\t\t\t\tif data \u0026 0x8000 == 0 {\n\t\t\t\t\twrite! (formatter, \"#\") ?;\n\t\t\t\t} else {\n\t\t\t\t\twrite! (formatter, \"_\") ?;\n\t\t\t\t}\n\t\t\t\tdata \u003c\u003c= 1_u32;\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl \u003cconst LEN: usize\u003e IntoIterator for Regs \u003cLEN\u003e {\n\t\ttype Item = bool;\n\t\ttype IntoIter = RegsIter \u003cLEN\u003e;\n\t\tfn into_iter (self) -\u003e RegsIter \u003cLEN\u003e {\n\t\t\tRegsIter { data: self.data \u003c\u003c (32 - LEN), remain: LEN.pan_u16 () }\n\t\t}\n\t}\n\n\tpub struct RegsIter \u003cconst LEN: usize\u003e {\n\t\tdata: u16,\n\t\tremain: u16,\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Iterator for RegsIter \u003cLEN\u003e {\n\t\ttype Item = bool;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003cbool\u003e {\n\t\t\tif self.remain == 0 { return None }\n\t\t\tlet val = self.data \u0026 0x8000 == 0;\n\t\t\tself.data \u003c\u003c= 1_u32;\n\t\t\tself.remain -= 1;\n\t\t\tSome (val)\n\t\t}\n\t}\n\n}\n\nmod rules {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Rules \u003cconst LEN: usize\u003e {\n\t\trules: Vec \u003c(Regs \u003cLEN\u003e, bool)\u003e,\n\t\tstats: RulesStats \u003cLEN\u003e,\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Rules \u003cLEN\u003e {\n\n\t\t#[ must_use ]\n\t\tpub fn new () -\u003e Self {\n\t\t\tSelf {\n\t\t\t\trules: Vec::new (),\n\t\t\t\tstats: RulesStats::new (),\n\t\t\t}\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn len (\u0026 self) -\u003e usize {\n\t\t\tself.rules.len ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\t\tself.rules.is_empty ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn num_true (\u0026 self) -\u003e usize {\n\t\t\tself.stats.num_true.pan_usize ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn num_false (\u0026 self) -\u003e usize {\n\t\t\tself.stats.num_false.pan_usize ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn first_hole (\u0026 self) -\u003e u32 {\n\t\t\tself.stats.first_hole.pan_u32 ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn last_hole (\u0026 self) -\u003e u32 {\n\t\t\tself.stats.last_hole.pan_u32 ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn num_jumps (\u0026 self) -\u003e u32 {\n\t\t\tself.stats.num_jumps.pan_u32 ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn num_jump_holes (\u0026 self) -\u003e u32 {\n\t\t\tself.stats.jump_holes.count_ones ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn num_conflicts (\u0026 self) -\u003e u32 {\n\t\t\t(self.stats.holes \u0026 self.stats.not_holes).count_ones ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub const fn order (\u0026 self) -\u003e u16 {\n\t\t\tself.stats.hash\n\t\t}\n\n\t\tpub fn iter (\u0026 self) -\u003e SliceIter \u003c(Regs \u003cLEN\u003e, bool)\u003e {\n\t\t\tself.rules.iter ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn push (\u0026 mut self, push_regs: Regs \u003cLEN\u003e, push_jump: bool) -\u003e Option \u003c()\u003e {\n\t\t\tfor \u0026 (rule_regs, rule_jump) in \u0026 self.rules {\n\t\t\t\tif rule_regs != push_regs { continue }\n\t\t\t\tif rule_jump != push_jump { return None }\n\t\t\t\treturn Some (());\n\t\t\t}\n\t\t\tself.rules.push ((push_regs, push_jump));\n\t\t\tself.rules.sort ();\n\t\t\tself.stats.update (push_regs, push_jump);\n\t\t\tSome (())\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn with_rule (\u0026 self, with_regs: Regs \u003cLEN\u003e, with_jump: bool) -\u003e Option \u003cSelf\u003e {\n\t\t\tfor \u0026 (rule_regs, rule_jump) in \u0026 self.rules {\n\t\t\t\tif rule_regs != with_regs { continue }\n\t\t\t\tif rule_jump != with_jump { return None }\n\t\t\t\treturn Some (self.clone ());\n\t\t\t}\n\t\t\tlet mut rules = self.rules.clone ();\n\t\t\trules.push ((with_regs, with_jump));\n\t\t\trules.sort ();\n\t\t\tlet mut stats = self.stats;\n\t\t\tstats.update (with_regs, with_jump);\n\t\t\tSome (Self { rules, stats })\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn with_rules (\u0026 self, other: \u0026 Self) -\u003e Option \u003cSelf\u003e {\n\t\t\tlet mut result = self.clone ();\n\t\t\tfor \u0026 (regs, jump) in \u0026 other.rules {\n\t\t\t\tresult = result.with_rule (regs, jump) ?;\n\t\t\t}\n\t\t\tSome (result)\n\t\t}\n\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Debug for Rules \u003cLEN\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tif self.rules.is_empty () {\n\t\t\t\treturn formatter.write_str (\"Rules []\");\n\t\t\t}\n\t\t\tformatter.write_str (\"Rules [\\n\") ?;\n\t\t\tfor \u0026 (regs, jump) in \u0026 self.rules {\n\t\t\t\twrite! (formatter, \"    {} =\u003e {}\\n\", regs, jump) ?;\n\t\t\t}\n\t\t\tformatter.write_str (\"]\") ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Default for Rules \u003cLEN\u003e {\n\t\tfn default () -\u003e Self {\n\t\t\tSelf::new ().with_rule (Regs::ALL, false).unwrap ()\n\t\t}\n\t}\n\n\timpl \u003c'rules, const LEN: usize\u003e IntoIterator for \u0026 'rules Rules \u003cLEN\u003e {\n\t\ttype Item = \u0026 'rules (Regs \u003cLEN\u003e, bool);\n\t\ttype IntoIter = SliceIter \u003c'rules, (Regs \u003cLEN\u003e, bool)\u003e;\n\t\tfn into_iter (self) -\u003e SliceIter \u003c'rules, (Regs \u003cLEN\u003e, bool)\u003e {\n\t\t\tself.rules.iter ()\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tstruct RulesStats \u003cconst LEN: usize\u003e {\n\t\tnum_false: u8,\n\t\tnum_true: u8,\n\t\tfirst_hole: u8,\n\t\tlast_hole: u8,\n\t\tnum_jumps: u8,\n\t\tjump_holes: u16,\n\t\tholes: u16,\n\t\tnot_holes: u16,\n\t\thash: u16,\n\t}\n\n\timpl \u003cconst LEN: usize\u003e RulesStats \u003cLEN\u003e {\n\t\tfn new () -\u003e Self {\n\t\t\tSelf {\n\t\t\t\tnum_false: 0,\n\t\t\t\tnum_true: 0,\n\t\t\t\tfirst_hole: LEN.pan_u8 (),\n\t\t\t\tlast_hole: 0,\n\t\t\t\tnum_jumps: 0,\n\t\t\t\tjump_holes: 0,\n\t\t\t\tholes: 0,\n\t\t\t\tnot_holes: 0,\n\t\t\t\thash: 0,\n\t\t\t}\n\t\t}\n\t\tfn update (\u0026 mut self, regs: Regs \u003cLEN\u003e, jump: bool) {\n\t\t\tif jump { self.num_true += 1; } else { self.num_false += 1; }\n\t\t\tself.first_hole = cmp::min (self.first_hole, regs.first_hole ().pan_u8 ());\n\t\t\tself.last_hole = cmp::max (self.last_hole, regs.last_hole ().pan_u8 ());\n\t\t\tif jump { self.num_jumps += 1; }\n\t\t\tif jump { self.jump_holes |= regs.holes (); }\n\t\t\tlet hash_val = if jump { 0xf000 } else { 0 } | regs.holes ();\n\t\t\tself.holes |= regs.holes ();\n\t\t\tself.not_holes |= regs.holes ();\n\t\t\tself.hash = self.hash.rotate_left (1) ^ hash_val;\n\t\t\tself.hash = (self.hash \u003c\u003c 8_u32) | (self.hash \u003e\u003e 8_u32);\n\t\t}\n\t}\n\n}\n\nmod rules_set {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct RulesSet \u003cconst LEN: usize\u003e {\n\t\trules: Vec \u003cRules \u003cLEN\u003e\u003e,\n\t}\n\n\timpl \u003cconst LEN: usize\u003e RulesSet \u003cLEN\u003e {\n\n\t\t#[ must_use ]\n\t\tpub const fn new () -\u003e Self {\n\t\t\tSelf { rules: Vec::new () }\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\t\tself.rules.is_empty ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn len (\u0026 self) -\u003e usize {\n\t\t\tself.rules.len ()\n\t\t}\n\n\t\tpub fn iter (\u0026 self) -\u003e SliceIter \u003cRules \u003cLEN\u003e\u003e {\n\t\t\tself.rules.iter ()\n\t\t}\n\n\t\tpub fn push (\u0026 mut self, rules: Rules \u003cLEN\u003e) {\n\t\t\tif self.rules.contains (\u0026 rules) { return }\n\t\t\tlet insert_pos = self.rules.binary_search_by_key (\n\t\t\t\t\t\u0026 (rules.num_conflicts (), rules.num_true ()),\n\t\t\t\t\t|rules| (rules.num_conflicts (), rules.num_true ()))\n\t\t\t\t.either ();\n\t\t\tself.rules.insert (insert_pos, rules);\n\t\t}\n\n\t\tpub fn append (\u0026 mut self, other: \u0026 Self) {\n\t\t\tlet mut new_rules = Vec::new ();\n\t\t\tfor self_rules in \u0026 self.rules {\n\t\t\t\tfor other_rules in \u0026 other.rules {\n\t\t\t\t\tif let Some (combined_rules) = self_rules.with_rules (other_rules) {\n\t\t\t\t\t\tnew_rules.push (combined_rules);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnew_rules.sort_by_key (|rules| (rules.num_conflicts (), rules.num_true ()));\n\t\t\tself.rules = new_rules;\n\t\t}\n\n\t}\n\n\timpl \u003cconst LEN: usize\u003e Default for RulesSet \u003cLEN\u003e {\n\t\tfn default () -\u003e Self {\n\t\t\tlet mut result = Self::new ();\n\t\t\tresult.push (Rules::default ());\n\t\t\tresult\n\t\t}\n\t}\n\n\timpl \u003cconst LEN: usize\u003e IntoIterator for RulesSet \u003cLEN\u003e {\n\t\ttype IntoIter = VecIntoIter \u003cRules \u003cLEN\u003e\u003e;\n\t\ttype Item = Rules \u003cLEN\u003e;\n\t\tfn into_iter (self) -\u003e VecIntoIter \u003cRules \u003cLEN\u003e\u003e {\n\t\t\tself.rules.into_iter ()\n\t\t}\n\t}\n\n\timpl \u003c'set, const LEN: usize\u003e IntoIterator for \u0026 'set RulesSet \u003cLEN\u003e {\n\t\ttype IntoIter = SliceIter \u003c'set, Rules \u003cLEN\u003e\u003e;\n\t\ttype Item = \u0026 'set Rules \u003cLEN\u003e;\n\t\tfn into_iter (self) -\u003e SliceIter \u003c'set, Rules \u003cLEN\u003e\u003e {\n\t\t\tself.rules.iter ()\n\t\t}\n\t}\n\n}\n\nmod sample {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Sample {\n\t\tdata: Vec \u003cbool\u003e,\n\t}\n\n\timpl Sample {\n\n\t\t#[ must_use ]\n\t\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\t\tself.data.is_empty ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn len (\u0026 self) -\u003e usize {\n\t\t\tself.data.len ()\n\t\t}\n\n\t}\n\n\timpl Deref for Sample {\n\t\ttype Target = [bool];\n\t\tfn deref (\u0026 self) -\u003e \u0026 [bool] {\n\t\t\t\u0026 self.data\n\t\t}\n\t}\n\n\timpl Display for Sample {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfor \u0026 item in \u0026 self.data {\n\t\t\t\tif item {\n\t\t\t\t\tformatter.write_char ('#') ?;\n\t\t\t\t} else {\n\t\t\t\t\tformatter.write_char ('_') ?;\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl From \u003cVec \u003cbool\u003e\u003e for Sample {\n\t\tfn from (data: Vec \u003cbool\u003e) -\u003e Self {\n\t\t\tSelf { data }\n\t\t}\n\t}\n\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":186},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-22","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub shuffles: Vec \u003cShuffle\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { shuffles, params } = [ params, @lines shuffles ]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub enum Shuffle {\n\tDealIntoNewStack,\n\tCut (i32),\n\tDealWithIncrement (u32),\n}\n\nenum_parser_display! {\n\tShuffle,\n\tDealIntoNewStack = [ \"deal into new stack\" ],\n\tCut (num) = [ \"cut \", num ],\n\tDealWithIncrement (num) = [ \"deal with increment \", num ],\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub deck_size_one: u64 = (\"DECK_SIZE_ONE=\", 10_007, 1_u64 .. ),\n\t\tpub deck_size_two: u64 = (\"DECK_SIZE_TWO=\", 119_315_717_514_047, 1_u64 .. ),\n\t\tpub repeat_two: u64 = (\"REPEAT_TWO=\", 101_741_582_076_661, 1_u64 .. ),\n\t\tpub init_one: u64 = (\"INIT_ONE=\", 2019, 1_u64 .. ),\n\t\tpub init_two: u64 = (\"INIT_TWO=\", 2020, 1_u64 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-22","lib.rs"],"content":"//! Advent of Code 2019: Day 22: Slam Shuffle\n//!\n//! [https://adventofcode.com/2019/day/22](https://adventofcode.com/2019/day/22)\n//!\n//! # Input\n//!\n//! A series of so-called shuffle operations, one per line, with three variants:\n//!\n//! - `deal into new stack`\n//! - `cut n` where `n` is an integer\n//! - `deal with increment n` where `n` is a positive integer\n//!\n//! See the puzzle description for details on what these mean.\n//!\n//! # Part one\n//!\n//! Apply the described operations once with a deck of size `10007`. Return the final position of\n//! card `2019`.\n//!\n//! # Part two\n//!\n//! Apply the desired operations `101741582076661` times with a deck of size `119315717514047`.\n//! Return the value of the card in position `2020`.\n//!\n//! # Algorithm\n//!\n//! The change in a card's position can be modelled as a combination of addition and multiplication\n//! modulo the deck size. This relies on the following two things being true:\n//!\n//! - The deck size is a prime number\n//! - The cards all start out with a position equal to their value\n//!\n//! The operations map as follows:\n//!\n//! - \"Deal into new stack\" is a negation followed by subtracting one, which can be converted to\n//!   multiplication by the deck size minus one, followed by addition of the deck size minus one\n//! - \"Cut\" is subtraction, which can be converted to addition by subtracting the argument from the\n//!   deck size\n//! - \"Deal with increment\" is simple multiplication\n//!\n//! We can combine two steps in sequence using some simple maths. We model an operation as a\n//! multiplication followed by an addition:\n//!\n//! `f (pos, mul, add) = pos  mul + add`\n//!\n//! We can apply this function to itself and then extract a single copy of the original function as\n//! follows. Here we use `mul_a` and `add_a` as the first step's arguments, and `mul_b` and `add_b`\n//! as the second step's:\n//!\n//! ```text\n//! f (f (pos, mul_a, add_a), mul_b, add_b)\n//!     = (pos  mul_a + add_a)  mul_b + add_b\n//!     = pos  mul_a  mul_b + add_a  mul_b + add_b\n//!     = f (pos, mul_a  mul_b, add_a  mul_b + add_b)\n//! ```\n//!\n//! Using this we can collapse the entire sequence of steps to a single step. This doesn't help\n//! much for part one, but it is important for part two. We also need to be able to reverse the\n//! operations. We can derive this from some basic maths identities:\n//!\n//! ```text\n//! pos_1 = f (pos_0, mul, add)\n//!       = pos_0  mul + add\n//! pos_0  mul = pos_1 - add\n//! pos_0 = (pos_1 - add)  mul\n//!       = pos_1  mul - add  mul\n//!       = pos_1  (1  mul) + (- add  mul)\n//!       = f (pos_1, 1  mul, - add  mul)\n//! ```\n//!\n//! I am cheating a little here with the above representation, although the maths is sound. Instead\n//! of dividing, we are actually multiplying by the\n//! [multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse), which\n//! is possible because the modulo is a prime number.\n//!\n//! Now we can represent all the steps as `(mul, add)`, combine steps into the same form, and\n//! find the reverse. We also need to be able to repeat steps many times. To do this, we repeatedly\n//! combine a step with itself to get equivalent steps for repetition counts of increasing powers\n//! of two. We apply these to the input zero or one times to get the right number. This is fairly\n//! simple to do because these are the binary digits of the repetition count.\n//!\n//! With all these operations implemented the algorithm becomes very simple:\n//!\n//! - Convert the shuffles into `(mul, add)` operations\n//! - Combine them into a single operation\n//! - For part two, reverse the operation\n//! - For part two, repeat the operation the specified number of times\n//! - Apply the operation to the input\n//!\n//! Although the numbers involved fit into 64-bits, they are very high, and multiplication will\n//! overflow easily. For this reason we use [`u64`] to store everything, but convert to [`u128`]\n//! to perform operations. Once we modulo the result we can convert back to [`u64`] safely.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Slam Shuffle\";\n\tyear = 2019;\n\tday = 22;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-22","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse input::Shuffle;\nuse model::Operation;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tOk (\n\t\tget_operation (input, input.params.deck_size_one) ?\n\t\t\t.apply (input.params.init_one)\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tOk (\n\t\tget_operation (input, input.params.deck_size_two) ?\n\t\t\t.reverse ().ok_or (\"Desk size must be prime\") ?\n\t\t\t.repeat (input.params.repeat_two)\n\t\t\t.apply (input.params.init_two)\n\t)\n}\n\nfn get_operation (input: \u0026 Input, deck_size: u64) -\u003e GenResult \u003cOperation\u003e {\n\tassert! (0 \u003c deck_size);\n\tinput.shuffles.iter ().copied ()\n\t\t.try_fold (Operation::new (deck_size), |op, shuffle| {\n\t\t\tlet shuffle_op = shuffle_to_operation (shuffle, deck_size) ?;\n\t\t\tOk (op.then (shuffle_op))\n\t\t})\n}\n\nfn shuffle_to_operation (shuffle: Shuffle, deck_size: u64) -\u003e GenResult \u003cOperation\u003e {\n\tmatch shuffle {\n\t\tShuffle::DealIntoNewStack =\u003e {\n\t\t\tOk (\n\t\t\t\tOperation::new (deck_size)\n\t\t\t\t\t.then_multiply (deck_size - 1)\n\t\t\t\t\t.then_add (deck_size - 1)\n\t\t\t)\n\t\t},\n\t\tShuffle::Cut (arg) =\u003e {\n\t\t\tlet arg = if 0_i32 \u003c= arg {\n\t\t\t\tu64::sub_2 (deck_size, arg.pan_u64 ()) ?\n\t\t\t} else {\n\t\t\t\targ.unsigned_abs ().pan_u64 ()\n\t\t\t};\n\t\t\tif deck_size \u003c= arg {\n\t\t\t\treturn Err (format! (\n\t\t\t\t\t\"Invalid shuffle {shuffle:?} for deck size {deck_size}\").into ());\n\t\t\t}\n\t\t\tOk (\n\t\t\t\tOperation::new (deck_size)\n\t\t\t\t\t.then_add (arg)\n\t\t\t)\n\t\t},\n\t\tShuffle::DealWithIncrement (arg) =\u003e {\n\t\t\tlet arg = arg.pan_u64 ();\n\t\t\tif deck_size \u003c= arg {\n\t\t\t\treturn Err (format! (\n\t\t\t\t\t\"Invalid shuffle {shuffle:?} for deck size {deck_size}\").into ());\n\t\t\t}\n\t\t\tOk (\n\t\t\t\tOperation::new (deck_size)\n\t\t\t\t\t.then_multiply (arg)\n\t\t\t)\n\t\t},\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-22","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Operation {\n\tmultiply: u64,\n\tadd: u64,\n\tmodulo: u64,\n}\n\nimpl Operation {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn new (modulo: u64) -\u003e Self {\n\t\tassert! (0 \u003c modulo);\n\t\tSelf {\n\t\t\tmultiply: 1,\n\t\t\tadd: 0,\n\t\t\tmodulo,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn then_add (self, arg: u64) -\u003e Self {\n\t\tlet add = self.add.pan_u128 ();\n\t\tlet modulo = self.modulo.pan_u128 ();\n\t\tlet arg = arg.pan_u128 ();\n\t\tSelf {\n\t\t\tmultiply: self.multiply,\n\t\t\tadd: ((add + arg) % modulo).pan_u64 (),\n\t\t\tmodulo: self.modulo,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn then_multiply (self, arg: u64) -\u003e Self {\n\t\tlet multiply = self.multiply.pan_u128 ();\n\t\tlet add = self.add.pan_u128 ();\n\t\tlet modulo = self.modulo.pan_u128 ();\n\t\tlet arg = arg.pan_u128 ();\n\t\tSelf {\n\t\t\tmultiply: (multiply * arg % modulo).pan_u64 (),\n\t\t\tadd: (add * arg % modulo).pan_u64 (),\n\t\t\tmodulo: self.modulo,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn apply (self, arg: u64) -\u003e u64 {\n\t\tlet multiply = self.multiply.pan_u128 ();\n\t\tlet add = self.add.pan_u128 ();\n\t\tlet modulo = self.modulo.pan_u128 ();\n\t\tlet arg = arg.pan_u128 ();\n\t\t((arg * multiply + add) % modulo).pan_u64 ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn then (self, other: Self) -\u003e Self {\n\t\tassert_eq! (self.modulo, other.modulo);\n\t\tlet self_multiply = self.multiply.pan_u128 ();\n\t\tlet self_add = self.add.pan_u128 ();\n\t\tlet other_multiply = other.multiply.pan_u128 ();\n\t\tlet other_add = other.add.pan_u128 ();\n\t\tlet modulo = self.modulo.pan_u128 ();\n\t\tSelf {\n\t\t\tmultiply: (self_multiply * other_multiply % modulo).pan_u64 (),\n\t\t\tadd: ((self_add * other_multiply + other_add) % modulo).pan_u64 (),\n\t\t\tmodulo: self.modulo,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn reverse (self) -\u003e Option \u003cSelf\u003e {\n\t\tSome (\n\t\t\tSelf::new (self.modulo)\n\t\t\t\t.then_add (self.modulo - self.add)\n\t\t\t\t.then_multiply (modulo_inverse (self.multiply, self.modulo) ?)\n\t\t)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn repeat (self, arg: u64) -\u003e Self {\n\t\tlet mut next_op = self;\n\t\tlet mut result = Self::new (self.modulo);\n\t\tlet mut remain = arg;\n\t\twhile remain != 0 {\n\t\t\tif remain \u0026 0x1 != 0 { result = result.then (next_op); }\n\t\t\tnext_op = next_op.then (next_op);\n\t\t\tremain \u003e\u003e= 1_u32;\n\t\t}\n\t\tresult\n\t}\n\n}\n\nfn modulo_inverse (arg: u64, modulo: u64) -\u003e Option \u003cu64\u003e {\n\tlet (mut bzt, mut new_bzt) = (0_i128, 1_i128);\n\tlet (mut rem, mut new_rem) = (modulo.pan_i128 (), arg.pan_i128 ());\n\twhile new_rem != 0_i128 {\n\t\tlet quot = rem / new_rem;\n\t\t(bzt, new_bzt) = (new_bzt, bzt - quot * new_bzt);\n\t\t(rem, new_rem) = (new_rem, rem - quot * new_rem);\n\t}\n\tif 1_i128 \u003c rem { return None }\n\tif bzt \u003c 0 { bzt += modulo.pan_i128 (); }\n\tSome (bzt.pan_u64 ())\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4512],"length":1,"stats":{"Line":0},"fn_name":"modulo_inverse"},{"line":105,"address":[4658,5170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4688,5409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4768,5436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5468,4975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5225],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[5511,5242,5316],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":53},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-23","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters_one: u32 = (\"MAX_ITERS_ONE=\", 100, 1_u32 .. ),\n\t\tpub max_iters_two: u32 = (\"MAX_ITERS_TWO=\", 1000, 1_u32 .. ),\n\t\tpub max_ops: u32 = (\"MAX_OPS=\", 1000, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-23","lib.rs"],"content":"//! Advent of Code 2019: Day 23: Category Six\n//!\n//! [https://adventofcode.com/2019/day/23](https://adventofcode.com/2019/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Category Six\";\n\tyear = 2019;\n\tday = 23;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-23","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Cpu;\nuse model::RunResult;\nuse model::Val;\n\nuse self::node::Node;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut nodes: Vec \u003cNode\u003e =\n\t\t(0 .. 50)\n\t\t\t.map (|addr| Node::new (input.data.clone (), input.params.max_ops, addr))\n\t\t\t.collect ();\n\tfor _ in 0 .. input.params.max_iters_one {\n\t\tfor node_idx in 0 .. nodes.len () {\n\t\t\tif let Some ((addr, x, y)) = nodes [node_idx].run () ? {\n\t\t\t\tif addr == 255 {\n\t\t\t\t\treturn Ok (y);\n\t\t\t\t} else if (0 .. 50).contains (\u0026 addr) {\n\t\t\t\t\tnodes [addr.pan_usize ()].deliver (x, y);\n\t\t\t\t} else {\n\t\t\t\t\treturn Err (format! (\"Invalid address: {addr}\").into ());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tErr (\"Max iterations\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut nodes: Vec \u003cNode\u003e =\n\t\t(0 .. 50)\n\t\t\t.map (|addr| Node::new (input.data.clone (), input.params.max_ops, addr))\n\t\t\t.collect ();\n\tlet mut cached = None;\n\tlet mut last = None;\n\tfor _ in 0 .. input.params.max_iters_two {\n\t\tfor node_idx in 0 .. nodes.len () {\n\t\t\tif let Some ((addr, x, y)) = nodes [node_idx].run () ? {\n\t\t\t\tif addr == 255 {\n\t\t\t\t\tcached = Some ((x, y));\n\t\t\t\t} else if (0 .. 50).contains (\u0026 addr) {\n\t\t\t\t\tnodes [addr.pan_usize ()].deliver (x, y);\n\t\t\t\t} else {\n\t\t\t\t\treturn Err (format! (\"Invalid address: {addr}\").into ());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif nodes.iter ().all (Node::blocked) {\n\t\t\tlet (x, y) = cached.ok_or (\"Network idle but no cached packet\") ?;\n\t\t\tif last == Some (y) { return Ok (y) }\n\t\t\tnodes [0].deliver (x, y);\n\t\t\tlast = Some (y);\n\t\t}\n\t}\n\tErr (\"Max iterations\".into ())\n}\n\nmod node {\n\n\tuse super::*;\n\n\tpub struct Node {\n\t\tcpu: Cpu,\n\t\tmax_ops: u32,\n\t\tnum_inputs: u32,\n\t\toutput_buffer: Vec \u003cVal\u003e,\n\t}\n\n\timpl Node {\n\n\t\tpub fn new (prog: Vec \u003cVal\u003e, max_ops: u32, addr: Val) -\u003e Self {\n\t\t\tlet mut cpu = Cpu::new (prog);\n\t\t\tcpu.set_mem_limit (4096);\n\t\t\tcpu.input (addr);\n\t\t\tSelf { cpu, max_ops, num_inputs: 0, output_buffer: Vec::new () }\n\t\t}\n\n\t\tpub const fn blocked (\u0026 self) -\u003e bool {\n\t\t\t1 \u003c self.num_inputs\n\t\t}\n\n\t\tpub fn deliver (\u0026 mut self, x: Val, y: Val) {\n\t\t\tself.cpu.input (x);\n\t\t\tself.cpu.input (y);\n\t\t\tself.num_inputs = 0;\n\t\t}\n\n\t\t#[ allow (clippy::wildcard_enum_match_arm) ]\n\t\tpub fn run (\u0026 mut self) -\u003e GenResult \u003cOption \u003c(Val, Val, Val)\u003e\u003e {\n\t\t\tself.cpu.set_max_ops (self.max_ops);\n\t\t\tmatch self.cpu.run () {\n\t\t\t\tRunResult::Output (val) =\u003e {\n\t\t\t\t\tself.output_buffer.push (val);\n\t\t\t\t\tif self.output_buffer.len () \u003c 3 {\n\t\t\t\t\t\tOk (None)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet addr = self.output_buffer [0];\n\t\t\t\t\t\tlet x = self.output_buffer [1];\n\t\t\t\t\t\tlet y = self.output_buffer [2];\n\t\t\t\t\t\tself.output_buffer.clear ();\n\t\t\t\t\t\tOk (Some ((addr, x, y)))\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tRunResult::Input =\u003e {\n\t\t\t\t\tself.cpu.input (-1);\n\t\t\t\t\tself.num_inputs += 1;\n\t\t\t\t\tOk (None)\n\t\t\t\t},\n\t\t\t\tother =\u003e Err (other.into ()),\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-23","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i64;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-24","input.rs"],"content":"use super::*;\n\npub type InputCoord = i8;\npub type InputGrid = GridBuf \u003cVec \u003cInputTile\u003e, InputPos, 2\u003e;\npub type InputPos = pos::PosYX \u003cInputCoord\u003e;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: InputGrid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum InputTile {\n\t\t#[ default ]\n\t\tEmpty = \".\",\n\t\tBug = \"#\",\n\t}\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-24","lib.rs"],"content":"//! Advent of Code 2019: Day 24: Planet of Discord\n//!\n//! [https://adventofcode.com/2019/day/24](https://adventofcode.com/2019/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Planet of Discord\";\n\tyear = 2019;\n\tday = 24;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-24","logic.rs"],"content":"//! Logic for solving the puzzles\n\n#![ allow (clippy::identity_op) ]\n#![ allow (clippy::unusual_byte_groupings) ]\n\nuse super::*;\n\nuse input::Input;\nuse input::InputPos;\nuse input::InputTile;\n\ntype State = Vec \u003cu32\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut state = vec! [ get_state (input) ? ];\n\tlet mut state_temp = Vec::with_capacity (state.len ());\n\tlet mut seen = HashSet::new ();\n\tloop {\n\t\tlet layer_val = state [0];\n\t\tif ! seen.insert (layer_val) {\n\t\t\treturn Ok (layer_val);\n\t\t}\n\t\tnext_state::\u003cfalse\u003e (\u0026 state, \u0026 mut state_temp);\n\t\tmem::swap (\u0026 mut state, \u0026 mut state_temp);\n\t}\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut state: Vec \u003cu32\u003e =\n\t\titer::empty ()\n\t\t\t.chain (iter::repeat (0_u32).take (100))\n\t\t\t.chain (iter::once (get_state (input) ?))\n\t\t\t.chain (iter::repeat (0_u32).take (100))\n\t\t\t.collect ();\n\tlet mut state_temp: Vec \u003cu32\u003e =\n\t\tVec::with_capacity (state.len ());\n\tfor _ in 0_u32 .. 200 {\n\t\tnext_state::\u003ctrue\u003e (\u0026 state, \u0026 mut state_temp);\n\t\tmem::swap (\u0026 mut state, \u0026 mut state_temp);\n\t}\n\tOk (\n\t\tstate.iter ().copied ()\n\t\t\t.map (u32::count_ones)\n\t\t\t.sum ()\n\t)\n}\n\nfn get_state (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.grid.size () != InputPos::new (5, 5) {\n\t\treturn Err (\"Grid must be exactly 55\".into ());\n\t}\n\tOk (\n\t\tinput.grid.values ()\n\t\t\t.fold (0, |mut sum, tile| {\n\t\t\t\tsum \u003e\u003e= 1_u32;\n\t\t\t\tif matches! (tile, InputTile::Bug) { sum |= 1 \u003c\u003c 24_u32; }\n\t\t\t\tsum\n\t\t\t})\n\t)\n}\n\nfn next_state \u003cconst RECURSE: bool\u003e (old_state: \u0026 State, new_state: \u0026 mut State) {\n\tnew_state.clear ();\n\tfor layer_idx in 0 .. old_state.len () {\n\t\tnew_state.push (next_layer::\u003cRECURSE\u003e (old_state, layer_idx));\n\t}\n}\n\nmacro_rules! bitrep {\n\t( $type:ty, $pat:expr, $bits:literal, $num:literal ) =\u003e {\n\t\t{\n\t\t\tconst fn bitrep (num: u32, bits: u32) -\u003e $type {\n\t\t\t\tif num == 0 { 0 } else {\n\t\t\t\t\tbitrep (num - 1, $bits) \u003c\u003c bits | $pat\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst VAL: $type = bitrep ($num, $bits);\n\t\t\tVAL\n\t\t}\n\t};\n}\n\n#[ inline ]\nfn next_layer \u003cconst RECURSE: bool\u003e (state: \u0026 [u32], layer_idx: usize) -\u003e u32 {\n\tlet layer_val = state [layer_idx];\n\tlet outer_val = if RECURSE \u0026\u0026 0 \u003c layer_idx { state [layer_idx - 1] } else { 0 };\n\tlet inner_val = if RECURSE \u0026\u0026 layer_idx + 1 \u003c state.len () { state [layer_idx + 1] } else { 0 };\n\tif layer_val == 0 \u0026\u0026 outer_val == 0 \u0026\u0026 inner_val == 0 { return 0_u32 }\n\tlet mut result = 0_u32;\n\tlet mut pat_layers = calc_pat_layers::\u003cRECURSE\u003e (layer_val, outer_val);\n\tlet inner_pats = if RECURSE { calc_inner_pats (inner_val) } else { [0_u64; 5] };\n\tfor y in 0_u32 .. 5 {\n\t\tlet mut pat_inner = inner_pats [y.pan_usize ()];\n\t\tfor _x in 0_u32 .. 5 {\n\t\t\tlet val = pat_layers \u0026 0b_0000000_0000010_0000000 != 0;\n\t\t\tlet adj_count = (pat_layers \u0026 0b_0000010_0000101_0000010).count_ones ()\n\t\t\t\t+ (pat_inner \u0026 bitrep! (u64, 0b_00000001, 8, 5)).count_ones ();\n\t\t\tresult \u003e\u003e= 1_u32;\n\t\t\tif adj_count == 1 || (adj_count == 2 \u0026\u0026 ! val) { result |= 1 \u003c\u003c 24_u32; }\n\t\t\tpat_layers \u003e\u003e= 1_u32;\n\t\t\tpat_inner \u003e\u003e= 1_u32;\n\t\t}\n\t\tpat_layers \u003e\u003e= 2_u32;\n\t}\n\tif RECURSE { result \u0026= 0b_11111_11111_11011_11111_11111; }\n\tresult\n}\n\n#[ inline ]\nfn calc_pat_layers \u003cconst RECURSE: bool\u003e (layer_val: u32, outer_val: u32) -\u003e u64 {\n\tlet mut pat_layers = 0_u64\n\t\t| (layer_val.pan_u64 () \u0026 (0b_11111 \u003c\u003c 0_u32)) \u003c\u003c 8_u32\n\t\t| (layer_val.pan_u64 () \u0026 (0b_11111 \u003c\u003c 5_u32)) \u003c\u003c 10_u32\n\t\t| (layer_val.pan_u64 () \u0026 (0b_11111 \u003c\u003c 10_u32)) \u003c\u003c 12_u32\n\t\t| (layer_val.pan_u64 () \u0026 (0b_11111 \u003c\u003c 15_u32)) \u003c\u003c 14_u32\n\t\t| (layer_val.pan_u64 () \u0026 (0b_11111 \u003c\u003c 20_u32)) \u003c\u003c 16_u32;\n\tif RECURSE {\n\t\tif outer_val \u0026 (0b_00100 \u003c\u003c 5_u32) != 0 { pat_layers |= 0b_0111110; }\n\t\tif outer_val \u0026 (0b_00100 \u003c\u003c 15_u32) != 0 { pat_layers |= 0b_0111110 \u003c\u003c 28_u32; }\n\t\tif outer_val \u0026 (0b_00010 \u003c\u003c 10_u32) != 0 { pat_layers |= bitrep! (u64, 0b_0000001, 7, 5) \u003c\u003c 7_u32; }\n\t\tif outer_val \u0026 (0b_01000 \u003c\u003c 10_u32) != 0 { pat_layers |= bitrep! (u64, 0b_1000000, 7, 5) \u003c\u003c 7_u32; }\n\t}\n\tpat_layers\n}\n\n#[ inline ]\nconst fn calc_inner_pats (inner_val: u32) -\u003e [u64; 5] {\n\tlet mut result = [0_u64; 5];\n\tlet num_inner_up = (inner_val \u0026 (0b_11111 \u003c\u003c 20)).count_ones ();\n\tresult [3] |= bitrep! (u64, 0b_00000100, 8, 5) \u003e\u003e (40 - num_inner_up * 8);\n\tlet num_inner_down = (inner_val \u0026 0b_11111).count_ones ();\n\tresult [1] |= bitrep! (u64, 0b_00000100, 8, 5) \u003e\u003e (40 - num_inner_down * 8);\n\tlet num_inner_left = (inner_val \u0026 bitrep! (u32, 0b_10000, 5, 5)).count_ones ();\n\tresult [2] |= bitrep! (u64, 0b_00001000, 8, 5) \u003e\u003e (40 - num_inner_left * 8);\n\tlet num_inner_right = (inner_val \u0026 bitrep! (u32, 0b_00001, 5, 5)).count_ones ();\n\tresult [2] |= bitrep! (u64, 0b_00000010, 8, 5) \u003e\u003e (40 - num_inner_right * 8);\n\tresult\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":49},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","game.rs"],"content":"use super::*;\n\nuse model::Cpu;\nuse model::Door;\nuse model::RcStr;\nuse model::RunResult;\nuse model::Val;\n\npub struct Game {\n\tcpu: Cpu,\n}\n\nimpl Game {\n\n\t#[ must_use ]\n\tpub fn new (prog: Vec \u003cVal\u003e) -\u003e Self {\n\t\tlet cpu = Cpu::new (prog);\n\t\tSelf { cpu }\n\t}\n\n\tpub fn read_output (\u0026 mut self) -\u003e GenResult \u003cGameOutputVec\u003e {\n\t\tself.cpu.set_max_ops (20_000);\n\t\tlet mut output_buffer = String::new ();\n\t\tlet mut output_line = String::new ();\n\t\tloop {\n\t\t\t#[ allow (clippy::wildcard_enum_match_arm) ]\n\t\t\tmatch self.cpu.run () {\n\t\t\t\tRunResult::Input | RunResult::Halt =\u003e break,\n\t\t\t\tRunResult::Output (val) =\u003e {\n\t\t\t\t\tlet ch = val.to_char ().map_err (|_err| format! (\"Invalid output: {val}\")) ?;\n\t\t\t\t\toutput_buffer.push (ch);\n\t\t\t\t\tif ch == '\\n' {\n\t\t\t\t\t\toutput_line.clear ();\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput_line.push (ch);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tother =\u003e return Err (other.into ()),\n\t\t\t}\n\t\t}\n\t\tlet output_lines: Vec \u003c\u0026 str\u003e = output_buffer.split ('\\n').collect ();\n\t\tmatch GameOutputVec::parse_from_lines (\u0026 output_lines) {\n\t\t\tOk (output) =\u003e Ok (output),\n\t\t\tErr (err) =\u003e Err (err),\n\t\t}\n\t}\n\n\tpub fn command (\u0026 mut self, command: \u0026 str) {\n\t\tself.cpu.input_str (\u0026 format! (\"{command}\\n\"));\n\t}\n\n}\n\n#[ derive (Clone, Debug) ]\npub struct GameOutputVec {\n\toutputs: Vec \u003cGameOutput\u003e,\n}\n\nimpl Deref for GameOutputVec {\n\ttype Target = [GameOutput];\n\tfn deref (\u0026 self) -\u003e \u0026 [GameOutput] {\n\t\t\u0026 self.outputs\n\t}\n}\n\nstruct_parser! {\n\tGameOutputVec { outputs } = [ @collect outputs ]\n}\n\n#[ derive (Clone, Debug) ]\npub enum GameOutput {\n\tRoom (GameOutputRoom),\n\tTaken (RcStr),\n\tDropped (RcStr),\n\tEjectedLighter,\n\tEjectedHeavier,\n\tPrompt,\n\tSolution (RcStr),\n}\n\nenum_parser! {\n\tGameOutput,\n\tRoom (room) = [ room ],\n\tTaken (item) = [ \"\\nYou take the \", item = parse_item, \".\\n\\n\" ],\n\tDropped (item) = [ \"\\nYou drop the \", item = parse_item, \".\\n\\n\" ],\n\tEjectedLighter = [ \"A loud, robotic voice says \\\"Alert! Droids on this ship are lighter than the detected value!\\\" and you are ejected back to the checkpoint.\\n\" ],\n\tEjectedHeavier = [ \"A loud, robotic voice says \\\"Alert! Droids on this ship are heavier than the detected value!\\\" and you are ejected back to the checkpoint.\\n\" ],\n\tPrompt = [ \"Command?\\n\" ],\n\tSolution (code) = [\n\t\t\"A loud, robotic voice says \\\"Analysis complete! You may proceed.\\\" and you enter the \",\n\t\t\"cockpit.\\n\",\n\t\t\"Santa notices your small droid, looks puzzled for a moment, realizes what has happened, \",\n\t\t\"and radios your ship directly.\\n\",\n\t\t\"\\\"Oh, hello! You should be able to get in by typing \",\n\t\t@str code = (|ch| { ch.is_ascii_digit () }, 1 .. ), \" on the keypad at the main \",\n\t\t\"airlock.\\\"\\n\",\n\t]\n}\n\nfn parse_item (parser: \u0026 mut Parser) -\u003e ParseResult \u003cRcStr\u003e {\n\tlet item = parser.take_rest_while (|ch| ch.is_ascii_alphanumeric () || ch == ' ', .. ) ?;\n\tOk (Rc::from (\u0026 * item))\n}\n\n#[ derive (Clone, Debug) ]\npub struct GameOutputRoom {\n\tpub name: RcStr,\n\tpub descrip: RcStr,\n\tpub doors: Vec \u003cDoor\u003e,\n\tpub items: Vec \u003cRcStr\u003e,\n}\n\nstruct_parser! {\n\tGameOutputRoom { name, descrip, doors, items } = [\n\t\t\"\\n\\n\\n\",\n\t\tname = parse_room_name,\n\t\tdescrip, \"\\n\",\n\t\t\"\\n\",\n\t\t\"Doors here lead:\\n\",\n\t\t@collect doors { door = [ \"- \", door, \"\\n\" ] },\n\t\t\"\\n\",\n\t\titems = parse_room_items,\n\t]\n}\n\nfn parse_room_name (parser: \u0026 mut Parser) -\u003e ParseResult \u003cRcStr\u003e {\n\tparse! (parser, \"== \", rest: InpStr, \"\\n\");\n\tlet name = rest.borrowed ().strip_suffix (\" ==\").ok_or_else (|| parser.err ()) ?;\n\tOk (RcStr::from (name))\n}\n\nfn parse_room_items (parser: \u0026 mut Parser) -\u003e ParseResult \u003cVec \u003cRcStr\u003e\u003e {\n\tif parser.expect (\"Items here:\\n\").is_err () { return Ok (Vec::new ()) }\n\tlet items = parser\n\t\t.repeat (|parser| {\n\t\t\tparse! (parser, \"- \", item, \"\\n\");\n\t\t\tOk (item)\n\t\t})\n\t\t.collect ();\n\tparser.expect (\"\\n\") ?;\n\tOk (items)\n}\n","traces":[{"line":126,"address":[13504,12928],"length":1,"stats":{"Line":0},"fn_name":"parse_room_name"},{"line":127,"address":[12947,13080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[11906,11888],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":129,"address":[13378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[13745,13520],"length":1,"stats":{"Line":0},"fn_name":"parse_room_items"},{"line":133,"address":[13535,13581,13591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[11920,12200],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":136,"address":[12061,11935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[12157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[13613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[13691],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","input.rs"],"content":"use super::*;\n\nuse model::Val;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cVal\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @delim \",\" data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","lib.rs"],"content":"//! Advent of Code 2019: Day 25: Cryostasis\n//!\n//! [https://adventofcode.com/2019/day/25](https://adventofcode.com/2019/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_2019_intcode as intcode;\nuse aoc_common::*;\n\npub mod game;\npub mod input;\npub mod logic;\npub mod model;\npub mod run;\n\npuzzle_info! {\n\tname = \"Cryostasis\";\n\tyear = 2019;\n\tday = 25;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = run::run; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse game::Game;\nuse game::GameOutput;\nuse game::GameOutputRoom;\nuse input::Input;\nuse model::Door;\nuse model::RcStr;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut game = Game::new (input.data.clone ());\n\tlet (items, door) = explore (\u0026 mut game) ?;\n\ttry_combinations (\u0026 mut game, \u0026 items, door)\n}\n\nfn try_combinations (game: \u0026 mut Game, items: \u0026 [RcStr], door: Door) -\u003e GenResult \u003cString\u003e {\n\tfor item in items {\n\t\tgame.command (\u0026 format! (\"drop {item}\"));\n\t\tgame.read_output () ?;\n\t}\n\tlet mut combo_idx = 1_usize;\n\twhile combo_idx \u003c (1 \u003c\u003c items.len ()) {\n\t\tlet combo_items: Vec \u003cRcStr\u003e =\n\t\t\titems.iter ().enumerate ()\n\t\t\t\t.filter (|\u0026 (item_idx, _)| combo_idx \u0026 (1 \u003c\u003c item_idx) != 0)\n\t\t\t\t.map (|(_, item)| Rc::clone (item))\n\t\t\t\t.collect ();\n\t\tfor item in \u0026 combo_items {\n\t\t\tgame.command (\u0026 format! (\"take {item}\"));\n\t\t\tgame.read_output () ?;\n\t\t}\n\t\tgame.command (\u0026 door.to_string ());\n\t\tlet outputs = game.read_output () ?;\n\t\tlet lighter = match outputs.get (1) {\n\t\t\tSome (\u0026 GameOutput::Solution (ref code)) =\u003e return Ok (code.to_string ()),\n\t\t\tSome (\u0026 GameOutput::EjectedLighter) =\u003e true,\n\t\t\tSome (\u0026 GameOutput::EjectedHeavier) =\u003e false,\n\t\t\tSome (other) =\u003e return Err (format! (\"Unexpected output: {other:?}\").into ()),\n\t\t\tNone =\u003e return Err (\"No output\".into ()),\n\t\t};\n\t\tfor item in \u0026 combo_items {\n\t\t\tgame.command (\u0026 format! (\"drop {item}\"));\n\t\t\tgame.read_output () ?;\n\t\t}\n\t\tif lighter {\n\t\t\tcombo_idx += ((combo_idx - 1) \u0026 ! combo_idx) + 1;\n\t\t} else {\n\t\t\tcombo_idx += 1;\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\nfn explore (game: \u0026 mut Game) -\u003e GenResult \u003c(Vec \u003cRcStr\u003e, Door)\u003e {\n\tlet explorer = Explorer::new (game) ?;\n\tlet \u0026 (door, _) =\n\t\texplorer.rooms [\u0026 explorer.player].doors.iter ()\n\t\t\t.find (|\u0026\u0026 (_, ref dest)| dest.is_none ())\n\t\t\t.unwrap ();\n\tOk ((explorer.items, door))\n}\n\npub struct Explorer {\n\tpub rooms: HashMap \u003cRcStr, Room\u003e,\n\tpub items: Vec \u003cRcStr\u003e,\n\tpub player: RcStr,\n}\n\nimpl Explorer {\n\tpub fn new (game: \u0026 mut Game) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet outputs = game.read_output () ?;\n\t\tlet output = match outputs.get (0) {\n\t\t\tSome (\u0026 GameOutput::Room (ref room)) =\u003e room,\n\t\t\tSome (other) =\u003e return Err (format! (\"Unexpected output: {other:?}\").into ()),\n\t\t\tNone =\u003e return Err (\"No output\".into ()),\n\t\t};\n\t\tlet mut explorer = Self {\n\t\t\trooms: HashMap::new (),\n\t\t\titems: Vec::new (),\n\t\t\tplayer: Rc::clone (\u0026 output.name),\n\t\t};\n\t\texplorer.track_room (output);\n\t\texplorer.explore (game) ?;\n\t\tOk (explorer)\n\t}\n\tfn explore (\u0026 mut self, game: \u0026 mut Game) -\u003e GenResult \u003c()\u003e {\n\t\tlet mut route = VecDeque::new ();\n\t\tloop {\n\t\t\tif route.is_empty () {\n\t\t\t\tfor (path_route, path_dest) in self.iter_paths () {\n\t\t\t\t\tif path_dest.as_ref () == \"Security Checkpoint\" { continue }\n\t\t\t\t\tlet \u0026 (unexplored_door, _) = some_or! (\n\t\t\t\t\t\tself.rooms [\u0026 path_dest].doors.iter ()\n\t\t\t\t\t\t\t.find (|\u0026\u0026 (_, ref dest)| dest.is_none ()),\n\t\t\t\t\t\tcontinue);\n\t\t\t\t\tfor path_door in path_route { route.push_back (path_door); }\n\t\t\t\t\troute.push_back (unexplored_door);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif route.is_empty () {\n\t\t\t\tif self.player.as_ref () == \"Security Checkpoint\" { break }\n\t\t\t\tfor (path_route, path_dest) in self.iter_paths () {\n\t\t\t\t\tif path_dest.as_ref () != \"Security Checkpoint\" { continue }\n\t\t\t\t\tfor path_door in path_route { route.push_back (path_door); }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif route.is_empty () {\n\t\t\t\t\treturn Err (\"Didn't find Security Checkpoint\".into ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet chosen_door = route.pop_front ().unwrap ();\n\t\t\tgame.command (\u0026 chosen_door.to_string ());\n\t\t\tlet outputs = game.read_output () ?;\n\t\t\tlet output = match outputs.get (0) {\n\t\t\t\tSome (\u0026 GameOutput::Room (ref output)) =\u003e output,\n\t\t\t\tSome (other) =\u003e return Err (format! (\"Unexpected output: {other:?}\").into ()),\n\t\t\t\tNone =\u003e return Err (\"No output\".into ()),\n\t\t\t};\n\t\t\tself.track_step (chosen_door, output) ?;\n\t\t\tfor item in \u0026 output.items {\n\t\t\t\tif [\n\t\t\t\t\t\"escape pod\",\n\t\t\t\t\t\"giant electromagnet\",\n\t\t\t\t\t\"infinite loop\",\n\t\t\t\t\t\"molten lava\",\n\t\t\t\t\t\"photons\",\n\t\t\t\t].contains (\u0026 item.as_ref ()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tgame.command (\u0026 format! (\"take {item}\"));\n\t\t\t\tgame.read_output () ?;\n\t\t\t\tself.items.push (Rc::clone (item));\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\tfn track_room (\u0026 mut self, output: \u0026 GameOutputRoom) {\n\t\tif self.rooms.contains_key (\u0026 output.name) { return }\n\t\tlet new_room = Room {\n\t\t\tname: Rc::clone (\u0026 output.name),\n\t\t\tdescrip: Rc::clone (\u0026 output.descrip),\n\t\t\tdoors: output.doors.iter ().map (|\u0026 door| (door, None)).collect (),\n\t\t};\n\t\tself.rooms.insert (Rc::clone (\u0026 new_room.name), new_room);\n\t}\n\tfn track_step (\u0026 mut self, through_door: Door, output: \u0026 GameOutputRoom) -\u003e GenResult \u003c()\u003e {\n\t\tlet from_room_name = Rc::clone (\u0026 self.player);\n\t\tself.track_room (output);\n\t\tself.player = Rc::clone (\u0026 output.name);\n\t\tlet to_room_name = Rc::clone (\u0026 self.player);\n\t\tself.set_door_dest (\u0026 from_room_name, through_door, \u0026 to_room_name) ?;\n\t\tself.set_door_dest (\u0026 to_room_name, through_door.rev (), \u0026 from_room_name) ?;\n\t\tOk (())\n\t}\n\tfn set_door_dest (\u0026 mut self, from: \u0026 RcStr, door: Door, to: \u0026 RcStr) -\u003e GenResult \u003c()\u003e {\n\t\tlet room = self.rooms.get_mut (from).unwrap ();\n\t\tlet \u0026 mut (_, ref mut door_dest) =\n\t\t\troom.doors.iter_mut ().find (|\u0026\u0026 mut (room_door, _)| room_door == door)\n\t\t\t\t.ok_or (\"Inconsistent rooms/doors\") ?;\n\t\tif let Some (ref val) = * door_dest {\n\t\t\tif val != to { return Err (\"Inconsistent rooms/doors\".into ()); }\n\t\t}\n\t\t* door_dest = Some (Rc::clone (to));\n\t\tOk (())\n\t}\n\tfn iter_paths (\u0026 self) -\u003e impl Iterator \u003cItem = (Vec \u003cDoor\u003e, RcStr)\u003e + '_ {\n\t\tlet mut seen = HashSet::new ();\n\t\tseen.insert (Rc::clone (\u0026 self.player));\n\t\tlet mut todo = VecDeque::new ();\n\t\ttodo.push_back ((Vec::new (), Rc::clone (\u0026 self.player)));\n\t\titer::from_fn (move || {\n\t\t\tlet (route, room_name) = some_or! (todo.pop_front (), return None);\n\t\t\tfor \u0026 (door, ref dest_room) in \u0026 self.rooms [\u0026 room_name].doors {\n\t\t\t\tlet dest_room = some_or! (dest_room.as_ref (), continue);\n\t\t\t\tif ! seen.insert (Rc::clone (dest_room)) { continue }\n\t\t\t\tlet mut route = route.clone ();\n\t\t\t\troute.push (door);\n\t\t\t\ttodo.push_back ((route, Rc::clone (dest_room)));\n\t\t\t}\n\t\t\tSome ((route, room_name))\n\t\t})\n\t}\n}\n\n#[ derive (Clone, Debug) ]\npub struct Room {\n\tpub name: RcStr,\n\tpub descrip: RcStr,\n\tpub doors: Vec \u003c(Door, Option \u003cRcStr\u003e)\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","model.rs"],"content":"use super::*;\n\npub type Cpu = intcode::Machine \u003cVal\u003e;\npub type RcStr = Rc \u003cstr\u003e;\npub type RunResult = intcode::RunResult \u003cVal\u003e;\npub type Val = i64;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\n\tpub enum Door {\n\t\tNorth = \"north\",\n\t\tSouth = \"south\",\n\t\tEast = \"east\",\n\t\tWest = \"west\",\n\t}\n}\n\nimpl Door {\n\n\t#[ must_use ]\n\tpub const fn rev (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::North =\u003e Self::South,\n\t\t\tSelf::South =\u003e Self::North,\n\t\t\tSelf::East =\u003e Self::West,\n\t\t\tSelf::West =\u003e Self::East,\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","day-25","run.rs"],"content":"#![ allow (clippy::print_stdout) ]\n\nuse super::*;\n\nuse std::path::PathBuf;\n\nuse game::Game;\nuse input::Input;\nuse logic::Explorer;\nuse logic::Room;\nuse model::Cpu;\nuse model::Door;\nuse model::RcStr;\nuse model::RunResult;\nuse model::Val;\n\n#[ derive (clap::Parser) ]\npub struct RunArgs {\n\n\t#[ clap (from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::wildcard_enum_match_arm) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim_end ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tlet mut cpu = Cpu::new (input.data.clone ());\n\tlet mut input_buf = String::new ();\n\tlet mut output_buf = String::new ();\n\tloop {\n\t\tmatch cpu.run () {\n\t\t\tRunResult::Input =\u003e {\n\t\t\t\tinput_buf.clear ();\n\t\t\t\tio::stdin ().read_line (\u0026 mut input_buf) ?;\n\t\t\t\tmatch input_buf.as_str ().trim () {\n\t\t\t\t\t\"explore\" =\u003e explore (input.data.clone ()) ?,\n\t\t\t\t\t_ =\u003e cpu.input_str (\u0026 input_buf),\n\t\t\t\t}\n\t\t\t},\n\t\t\tRunResult::Output (val) =\u003e {\n\t\t\t\tlet ch = val.pan_char ();\n\t\t\t\tif ch == '\\n' {\n\t\t\t\t\tprintln! (\"{output_buf}\");\n\t\t\t\t\toutput_buf.clear ();\n\t\t\t\t} else {\n\t\t\t\t\toutput_buf.push (ch);\n\t\t\t\t}\n\t\t\t},\n\t\t\tRunResult::Halt =\u003e break,\n\t\t\tother =\u003e return Err (other.into ()),\n\t\t}\n\t}\n\tOk (())\n}\n\nfn explore (prog: Vec \u003cVal\u003e) -\u003e GenResult \u003c()\u003e {\n\tlet mut game = Game::new (prog);\n\tlet explorer = Explorer::new (\u0026 mut game) ?;\n\tlet mut posns: HashMap \u003cRcStr, (i8, i8)\u003e = HashMap::new ();\n\tlet mut todo = Vec::new ();\n\ttodo.push (((0, 0), Rc::from (\"Hull Breach\")));\n\tlet mut seen = HashSet::new ();\n\tseen.insert (Rc::from (\"Hull Breach\"));\n\twhile let Some (((n, e), room_name)) = todo.pop () {\n\t\tposns.insert (Rc::clone (\u0026 room_name), (n, e));\n\t\tfor \u0026 (door, ref dest) in \u0026 explorer.rooms [\u0026 room_name].doors {\n\t\t\tlet dest = some_or! (dest, continue);\n\t\t\tif ! seen.insert (Rc::clone (dest)) { continue }\n\t\t\tlet (n, e) = match door {\n\t\t\t\tDoor::North =\u003e (n + 1, e),\n\t\t\t\tDoor::South =\u003e (n - 1, e),\n\t\t\t\tDoor::East =\u003e (n, e + 1),\n\t\t\t\tDoor::West =\u003e (n, e - 1),\n\t\t\t};\n\t\t\ttodo.push (((n, e), Rc::clone (dest)));\n\t\t}\n\t}\n\tlet rooms: Vec \u003c\u0026 Room\u003e =\n\t\texplorer.rooms.values ()\n\t\t\t.sorted_by_key (|\u0026 room| \u0026 room.name)\n\t\t\t.collect ();\n\tfor room in rooms {\n\t\tprintln! (\"Room: {}\", room.name);\n\t\tprintln! (\"  {}\", room.descrip);\n\t}\n\tOk (())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","intcode","intcode.rs"],"content":"use aoc_common::*;\n\npub type Mem \u003cVal\u003e = Vec \u003cVal\u003e;\n\n#[ derive (Clone) ]\npub struct Machine \u003cVal: Int\u003e {\n\tmem: Mem \u003cVal\u003e,\n\tpos: Val,\n\trel: Val,\n\tinput_buffer: VecDeque \u003cVal\u003e,\n\tmax_ops: u32,\n\tmem_limit: u32,\n}\n\nimpl \u003cVal: Int\u003e Machine \u003cVal\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new (mem: Mem \u003cVal\u003e) -\u003e Self {\n\t\tSelf {\n\t\t\tmem,\n\t\t\tpos: Val::ZERO,\n\t\t\trel: Val::ZERO,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t\tmax_ops: u32::MAX,\n\t\t\tmem_limit: 1024 * 1024,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn set_max_ops (\u0026 mut self, max_ops: u32) {\n\t\tself.max_ops = max_ops;\n\t}\n\n\t#[ inline ]\n\tpub fn set_mem_limit (\u0026 mut self, mem_limit: u32) {\n\t\tself.mem_limit = mem_limit;\n\t}\n\n\t#[ inline ]\n\tpub fn input (\u0026 mut self, value: Val) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\t#[ inline ]\n\tpub fn input_char (\u0026 mut self, value: char) {\n\t\tself.input (Val::from_char (value).unwrap ());\n\t}\n\n\t#[ inline ]\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (Val::from_char (ch).unwrap ());\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn input_line (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_char (ch);\n\t\t}\n\t\tself.input_char ('\\n');\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn run (\u0026 mut self) -\u003e RunResult \u003cVal\u003e {\n\t\tmatch self.run_real () {\n\t\t\tOk (val) =\u003e val,\n\t\t\tErr (RunResult::Instr (_, _)) =\u003e {\n\t\t\t\tlet opcode_val = self.mem_get_real (self.pos).unwrap ();\n\t\t\t\tRunResult::Instr (self.pos, opcode_val)\n\t\t\t},\n\t\t\tErr (val) =\u003e val,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn run_real (\u0026 mut self) -\u003e Result \u003cRunResult \u003cVal\u003e, RunResult \u003cVal\u003e\u003e {\n\t\tloop {\n\t\t\tif self.max_ops == 0 { return Err (RunResult::MaxOps) }\n\t\t\tself.max_ops -= 1;\n\t\t\tlet opcode = Opcode::from_int (self.mem_get (self.pos).ok_or (RunResult::Memory) ?)\n\t\t\t\t.ok_or (RunResult::Instr (Val::ZERO, Val::ZERO)) ?;\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstr::Add =\u003e {\n\t\t\t\t\tself.param_set (opcode, 2, Val::add_2 (\n\t\t\t\t\t\tself.param_get (opcode, 0) ?,\n\t\t\t\t\t\tself.param_get (opcode, 1) ?,\n\t\t\t\t\t) ?) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::FOUR) ?;\n\t\t\t\t},\n\t\t\t\tInstr::Multiply =\u003e {\n\t\t\t\t\tself.param_set (opcode, 2, Val::mul_2 (\n\t\t\t\t\t\tself.param_get (opcode, 0) ?,\n\t\t\t\t\t\tself.param_get (opcode, 1) ?,\n\t\t\t\t\t) ?) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::FOUR) ?;\n\t\t\t\t},\n\t\t\t\tInstr::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (opcode, 0, value) ?;\n\t\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::TWO) ?;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Ok (RunResult::Input);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstr::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (opcode, 0) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::TWO) ?;\n\t\t\t\t\treturn Ok (RunResult::Output (value));\n\t\t\t\t},\n\t\t\t\tInstr::JumpIfTrue =\u003e {\n\t\t\t\t\tif self.param_get (opcode, 0) ? != Val::ZERO {\n\t\t\t\t\t\tself.pos = self.param_get (opcode, 1) ?;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::THREE) ?;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstr::JumpIfFalse =\u003e {\n\t\t\t\t\tif self.param_get (opcode, 0) ? == Val::ZERO {\n\t\t\t\t\t\tself.pos = self.param_get (opcode, 1) ?;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::THREE) ?;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstr::LessThan =\u003e {\n\t\t\t\t\tlet value = self.param_get (opcode, 0) ? \u003c self.param_get (opcode, 1) ?;\n\t\t\t\t\tself.param_set (opcode, 2, if value { Val::ONE } else { Val::ZERO }) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::FOUR) ?;\n\t\t\t\t},\n\t\t\t\tInstr::Equals =\u003e {\n\t\t\t\t\tlet value = self.param_get (opcode, 0) ? == self.param_get (opcode, 1) ?;\n\t\t\t\t\tself.param_set (opcode, 2, if value { Val::ONE } else { Val::ZERO }) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::FOUR) ?;\n\t\t\t\t},\n\t\t\t\tInstr::AdjustRelBase =\u003e {\n\t\t\t\t\tself.rel = Val::add_2 (self.rel, self.param_get (opcode, 0) ?) ?;\n\t\t\t\t\tself.pos = Val::add_2 (self.pos, Val::TWO) ?;\n\t\t\t\t},\n\t\t\t\tInstr::Halt =\u003e return Ok (RunResult::Halt),\n\t\t\t}\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn param_raw (\u0026 self, num: u8) -\u003e Result \u003cVal, RunResult \u003cVal\u003e\u003e {\n\t\tlet addr = Val::add_3 (self.pos, Val::ONE, Val::from_u8 (num).unwrap ()) ?;\n\t\tself.mem_get_real (addr)\n\t}\n\n\t#[ inline ]\n\tfn param_get (\u0026 self, opcode: Opcode, num: u8) -\u003e Result \u003cVal, RunResult \u003cVal\u003e\u003e {\n\t\tlet raw = self.param_raw (num) ?;\n\t\tmatch opcode.modes [num.qck_usize ()] {\n\t\t\tMode::Position =\u003e self.mem_get_real (raw),\n\t\t\tMode::Immediate =\u003e Ok (raw),\n\t\t\tMode::Relative =\u003e self.mem_get_real (Val::add_2 (raw, self.rel) ?),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn param_set (\u0026 mut self, opcode: Opcode, num: u8, value: Val) -\u003e Result \u003c(), RunResult \u003cVal\u003e\u003e {\n\t\tlet param = self.param_raw (num) ?;\n\t\tmatch opcode.modes [num.qck_usize ()] {\n\t\t\tMode::Position =\u003e self.mem_set_real (param, value),\n\t\t\tMode::Immediate =\u003e Err (RunResult::Instr (Val::ZERO, Val::ZERO)),\n\t\t\tMode::Relative =\u003e self.mem_set_real (param + self.rel, value),\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn mem_get (\u0026 self, addr: Val) -\u003e Option \u003cVal\u003e {\n\t\tself.mem_get_real (addr).ok ()\n\t}\n\n\t#[ inline ]\n\tfn mem_get_real (\u0026 self, addr: Val) -\u003e Result \u003cVal, RunResult \u003cVal\u003e\u003e {\n\t\tlet addr = addr.to_usize ().map_err (|_err| RunResult::Memory) ?;\n\t\tOk (self.mem.get (addr).copied ().unwrap_or (Val::ZERO))\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn mem_set (\u0026 mut self, addr: Val, value: Val) -\u003e Option \u003c()\u003e {\n\t\tself.mem_set_real (addr, value).ok ()\n\t}\n\n\t#[ inline ]\n\tfn mem_set_real (\u0026 mut self, addr: Val, value: Val) -\u003e Result \u003c(), RunResult \u003cVal\u003e\u003e {\n\t\tself.mem_extend (addr) ?;\n\t\tself.mem [addr.qck_usize ()] = value;\n\t\tOk (())\n\t}\n\n\t#[ inline ]\n\tfn mem_extend (\u0026 mut self, addr: Val) -\u003e Result \u003c(), RunResult \u003cVal\u003e\u003e {\n\t\tif addr \u003c Val::ZERO || addr == Val::MAX { return Err (RunResult::Memory) }\n\t\tlet size = addr.qck_usize () + 1;\n\t\tif size \u003c self.mem.len () { return Ok (()) }\n\t\tif self.mem_limit.qck_usize () \u003c size { return Err (RunResult::Memory) }\n\t\tself.mem.resize ((size + 0xff) \u0026 ! 0xff, Val::ZERO);\n\t\tOk (())\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n#[ must_use ]\npub enum RunResult \u003cVal\u003e {\n\tHalt,\n\tOutput (Val),\n\tInput,\n\tInstr (Val, Val),\n\tMaxOps,\n\tOverflow,\n\tMemory,\n}\n\nimpl \u003cVal: Int\u003e RunResult \u003cVal\u003e {\n\n\t#[ inline ]\n\tpub const fn halt (self) -\u003e Result \u003c(), Self\u003e {\n\t\tif ! matches! (self, Self::Halt) { return Err (self) }\n\t\tOk (())\n\t}\n\n\t#[ allow (clippy::wildcard_enum_match_arm) ]\n\t#[ inline ]\n\tpub const fn output (self) -\u003e Result \u003cOption \u003cVal\u003e, Self\u003e {\n\t\tmatch self {\n\t\t\tSelf::Halt =\u003e Ok (None),\n\t\t\tSelf::Output (val) =\u003e Ok (Some (val)),\n\t\t\tother =\u003e Err (other),\n\t\t}\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e Display for RunResult \u003cVal\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Halt =\u003e write! (formatter, \"Halted\") ?,\n\t\t\tSelf::Output (val) =\u003e write! (formatter, \"Output: {val}\") ?,\n\t\t\tSelf::Input =\u003e write! (formatter, \"Waiting for input\") ?,\n\t\t\tSelf::Instr (addr, val) =\u003e write! (formatter, \"Invalid instruction {val} at {addr}\") ?,\n\t\t\tSelf::MaxOps =\u003e write! (formatter, \"Max operations exceeded\") ?,\n\t\t\tSelf::Overflow =\u003e write! (formatter, \"Numeric overflow\") ?,\n\t\t\tSelf::Memory =\u003e write! (formatter, \"Memory limit exceeded\") ?,\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e Error for RunResult \u003cVal\u003e {\n}\n\nimpl \u003cVal: Int\u003e From \u003cOverflow\u003e for RunResult \u003cVal\u003e {\n\n\t#[ inline ]\n\tfn from (_overflow: Overflow) -\u003e Self {\n\t\tSelf::Overflow\n\t}\n\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instr,\n\tmodes: [Mode; 3],\n}\n\nimpl Opcode {\n\n\tfn from_int \u003cVal: Int\u003e (value: Val) -\u003e Option \u003cSelf\u003e {\n\t\t#[ inline ]\n\t\tfn decode_mode \u003cVal: Int\u003e (value: Val, multiple: Val) -\u003e Option \u003c(Val, Val)\u003e {\n\t\t\tif value \u003c Val::ZERO || multiple * Val::THREE \u003c= value { None }\n\t\t\telse if multiple * Val::TWO \u003c= value { Some ((value - multiple * Val::TWO, Val::TWO)) }\n\t\t\telse if multiple * Val::ONE \u003c= value { Some ((value - multiple * Val::ONE, Val::ONE)) }\n\t\t\telse { Some ((value, Val::ZERO)) }\n\t\t}\n\t\tlet value = value.to_u32 ().ok () ?;\n\t\tlet (value, mode_0) = decode_mode (value, 10_000) ?;\n\t\tlet (value, mode_1) = decode_mode (value, 1_000) ?;\n\t\tlet (value, mode_2) = decode_mode (value, 100) ?;\n\t\tSome (Self {\n\t\t\tinstr: Instr::from_int (value) ?,\n\t\t\tmodes: [\n\t\t\t\tMode::from_int (mode_2) ?,\n\t\t\t\tMode::from_int (mode_1) ?,\n\t\t\t\tMode::from_int (mode_0) ?,\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instr {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl Instr {\n\n\tfn from_int \u003cVal: Int\u003e (value: Val) -\u003e Option \u003cSelf\u003e {\n\t\tif value == Val::ONE { Some (Self::Add) }\n\t\telse if value == Val::TWO { Some (Self::Multiply) }\n\t\telse if value == Val::THREE { Some (Self::Input) }\n\t\telse if value == Val::FOUR { Some (Self::Output) }\n\t\telse if value == Val::FIVE { Some (Self::JumpIfTrue) }\n\t\telse if value == Val::SIX { Some (Self::JumpIfFalse) }\n\t\telse if value == Val::SEVEN { Some (Self::LessThan) }\n\t\telse if value == Val::EIGHT { Some (Self::Equals) }\n\t\telse if value == Val::NINE { Some (Self::AdjustRelBase) }\n\t\telse {\n\t\t\tlet value = value.to_u32 ().ok () ?;\n\t\t\tif value == 99 { Some (Self::Halt) }\n\t\t\telse { None }\n\t\t}\n\t}\n\n}\n\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl Mode {\n\n\tfn from_int \u003cVal: Int\u003e (value: Val) -\u003e Option \u003cSelf\u003e {\n\t\tif value == Val::ZERO { Some (Self::Position) }\n\t\telse if value == Val::ONE { Some (Self::Immediate) }\n\t\telse if value == Val::TWO { Some (Self::Relative) }\n\t\telse { None }\n\t}\n\n}\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":160},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2019_day_01 as day_01;\npub use aoc_2019_day_02 as day_02;\npub use aoc_2019_day_03 as day_03;\npub use aoc_2019_day_04 as day_04;\npub use aoc_2019_day_05 as day_05;\npub use aoc_2019_day_06 as day_06;\npub use aoc_2019_day_07 as day_07;\npub use aoc_2019_day_08 as day_08;\npub use aoc_2019_day_09 as day_09;\npub use aoc_2019_day_10 as day_10;\npub use aoc_2019_day_11 as day_11;\npub use aoc_2019_day_12 as day_12;\npub use aoc_2019_day_13 as day_13;\npub use aoc_2019_day_14 as day_14;\npub use aoc_2019_day_15 as day_15;\npub use aoc_2019_day_16 as day_16;\npub use aoc_2019_day_17 as day_17;\npub use aoc_2019_day_18 as day_18;\npub use aoc_2019_day_19 as day_19;\npub use aoc_2019_day_20 as day_20;\npub use aoc_2019_day_21 as day_21;\npub use aoc_2019_day_22 as day_22;\npub use aoc_2019_day_23 as day_23;\npub use aoc_2019_day_24 as day_24;\npub use aoc_2019_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"1721\",\n\t\"979\",\n\t\"366\",\n\t\"299\",\n\t\"675\",\n\t\"1456\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"514579\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"241861950\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":15,"address":[35232,35236],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":16,"address":[43594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[43828,43615,43762,43932,43705,43653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[35264,35268],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":22,"address":[43994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[44162,44053,44015,44332,44228,44105],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-01","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub entries: Vec \u003cu16\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { entries, params } = [\n\t\tparams,\n\t\t@lines entries,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[27348],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-01","lib.rs"],"content":"//! Advent of Code 2020: Day 1: Report Repair\n//!\n//! [https://adventofcode.com/2020/day/01](https://adventofcode.com/2020/day/01)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Report Repair\";\n\tyear = 2020;\n\tday = 1;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[35784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[36104],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-01","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet entries: Vec \u003cu16\u003e =\n\t\tinput.entries.iter ().copied ()\n\t\t\t.filter (|\u0026 val| val \u003c 2020)\n\t\t\t.sorted ()\n\t\t\t.dedup ()\n\t\t\t.collect ();\n\tlet (entry_0, entry_1) =\n\t\tfind_two (\n\t\t\t\tentries.iter ().copied (),\n\t\t\t\tentries.iter ().rev ().copied (),\n\t\t\t\t2020)\n\t\t\t.ok_or (\"No solution found\") ?;\n\tOk (entry_0.pan_u32 () * entry_1.pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet entries: Vec \u003cu16\u003e =\n\t\tinput.entries.iter ().copied ()\n\t\t\t.filter (|\u0026 val| val \u003c 2020)\n\t\t\t.sorted ()\n\t\t\t.dedup ()\n\t\t\t.collect ();\n\tfor \u0026 entry_0 in entries.iter () {\n\t\tif let Some ((entry_1, entry_2)) =\n\t\t\tfind_two (\n\t\t\t\tentries.iter ().copied ().filter (|\u0026 entry_1| entry_1 != entry_0),\n\t\t\t\tentries.iter ().rev ().copied ().filter (|\u0026 entry_2| entry_2 != entry_0),\n\t\t\t\t2020 - entry_0) {\n\t\t\treturn Ok (entry_0.pan_u32 () * entry_1.pan_u32 () * entry_2.pan_u32 ());\n\t\t}\n\t}\n\tErr (\"No solution found\".into ())\n}\n\nfn find_two (\n\titer_fwd: impl Iterator \u003cItem = u16\u003e,\n\titer_rev: impl Iterator \u003cItem = u16\u003e,\n\tsum: u16,\n) -\u003e Option \u003c(u16, u16)\u003e {\n\tlet mut iter_fwd = iter_fwd.peekable ();\n\tlet mut iter_rev = iter_rev.peekable ();\n\tloop {\n\t\tlet low_val = * iter_fwd.peek () ?;\n\t\tlet high_val = * iter_rev.peek () ?;\n\t\tmatch Ord::cmp (\u0026 (low_val + high_val), \u0026 sum) {\n\t\t\tOrdering::Less =\u003e iter_fwd.next ().unwrap (),\n\t\t\tOrdering::Greater =\u003e iter_rev.next ().unwrap (),\n\t\t\tOrdering::Equal =\u003e return Some ((low_val, high_val)),\n\t\t};\n\t}\n}\n","traces":[{"line":7,"address":[46704,47263],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[49344],"length":1,"stats":{"Line":2},"fn_name":"call_mut\u003c(\u0026u16), aoc_2020_day_01::logic::part_one::{closure_env#0}\u003e"},{"line":20,"address":[47105,47187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[47280,48082],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":26,"address":[34787,34583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[47559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[47714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[45031,45735,46071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[28021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[47681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[47872,47952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[47733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[50016,50432],"length":1,"stats":{"Line":2},"fn_name":"find_two\u003ccore::iter::adapters::filter::Filter\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003cu16\u003e\u003e, aoc_2020_day_01::logic::part_two::{closure_env#1}\u003e, core::iter::adapters::filter::Filter\u003ccore::iter::adapters::copied::Copied\u003ccore::iter::adapters::rev::Rev\u003ccore::slice::iter::Iter\u003cu16\u003e\u003e\u003e, aoc_2020_day_01::logic::part_two::{closure_env#2}\u003e\u003e"},{"line":47,"address":[50034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[50045],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[50199,50499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[50729,50520,50246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[50526,50556,50755,50841,50282,50253,50394],"length":1,"stats":{"Line":5},"fn_name":null},{"line":53,"address":[50762,50302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[50103,50564],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"1-3 a: abcde\",\n\t\"1-3 b: cdefg\",\n\t\"2-9 c: ccccccccc\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[31844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[45690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[45749,45858,45924,46028,45801,45711],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[31812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[46090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[46428,46201,46258,46149,46111,46324],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-02","input.rs"],"content":"use super::*;\n\nuse model::PassPolicy;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub pass_policies: Vec \u003cPassPolicy \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { pass_policies, params } = [ params, @lines pass_policies ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[30427,29350],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-02","lib.rs"],"content":"//! Advent of Code 2020: Day 2: Password Philosophy\n//!\n//! [https://adventofcode.com/2020/day/02](https://adventofcode.com/2020/day/02)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Password Philosophy\";\n\tyear = 2020;\n\tday = 2;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[34600],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-02","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.pass_policies.iter ()\n\t\t\t.filter (|pass_policy|\n\t\t\t\t(pass_policy.num_0 ..= pass_policy.num_1).contains (\n\t\t\t\t\t\u0026 pass_policy.password.chars ()\n\t\t\t\t\t\t.filter (|\u0026 ch| ch == pass_policy.ch)\n\t\t\t\t\t\t.count ()\n\t\t\t\t\t\t.pan_u32 ()))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.pass_policies.iter ()\n\t\t\t.filter (|pass_policy|\n\t\t\t\tpass_policy.password.chars ().enumerate ()\n\t\t\t\t\t.filter (|\u0026 (ch_idx, ch)|\n\t\t\t\t\t\t((ch_idx + 1).pan_u32 () == pass_policy.num_0\n\t\t\t\t\t\t\t\t|| (ch_idx + 1).pan_u32 () == pass_policy.num_1)\n\t\t\t\t\t\t\t\u0026\u0026 ch == pass_policy.ch)\n\t\t\t\t\t.count () == 1)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n","traces":[{"line":7,"address":[36432],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[49264],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":11,"address":[45024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[33408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[49490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[36688],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":24,"address":[49552],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":25,"address":[45306,45338],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[49760,49767],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[49770,49919,49895,49835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[49892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[49897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[49739],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-02","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct PassPolicy \u003c'inp\u003e {\n\tpub num_0: u32,\n\tpub num_1: u32,\n\tpub ch: char,\n\tpub password: InpStr \u003c'inp\u003e,\n}\n\nstruct_parser! {\n\tinput_lifetime = 'inp;\n\tPassPolicy \u003c'inp\u003e { num_0, num_1, ch, password } = [\n\t\tnum_0 = 1 .. , \"-\",\n\t\tnum_1 = 1 .. , \" \",\n\t\tch = 'a' ..= 'z', \": \",\n\t\t@str password = ('a' ..= 'z', 1 .. ),\n\t]\n}\nstruct_display! {\n\tinput_lifetime = 'inp;\n\tPassPolicy \u003c'inp\u003e { num_0, num_1, ch, password } = [\n\t\tnum_0 = 1 .. , \"-\",\n\t\tnum_1 = 1 .. , \" \",\n\t\tch = 'a' ..= 'z', \": \",\n\t\t@str password = ('a' ..= 'z', 1 .. ),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"..##.......\",\n\t\"#...#...#..\",\n\t\".#....#..#.\",\n\t\"..#.#...#.#\",\n\t\".#...##..#.\",\n\t\"..#.##.....\",\n\t\".#.#.#....#\",\n\t\".#........#\",\n\t\"#.##...#...\",\n\t\"#...##....#\",\n\t\".#..#...#.#\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"7\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"336\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":20,"address":[39828,39824],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[61498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[61557,61732,61836,61519,61666,61609],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[39860,39856],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[61898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[62066,61957,62132,62009,61919,62236],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-03","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-03","lib.rs"],"content":"//! Advent of Code 2020: Day 3: Toboggan Trajectory\n//!\n//! [https://adventofcode.com/2020/day/03](https://adventofcode.com/2020/day/03)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Toboggan Trajectory\";\n\tyear = 2020;\n\tday = 3;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-03","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Pos;\nuse model::Tile;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (calc_result (input, Pos::new (1, 3)))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tconst TRAJS: \u0026 [Pos] = \u0026 [\n\t\tPos::new (1, 1),\n\t\tPos::new (1, 3),\n\t\tPos::new (1, 5),\n\t\tPos::new (1, 7),\n\t\tPos::new (2, 1),\n\t];\n\tOk (\n\t\tTRAJS.iter ().copied ()\n\t\t\t.map (|traj| calc_result (input, traj).pan_u64 ())\n\t\t\t.product ()\n\t)\n}\n\nfn calc_result (input: \u0026 Input, traj: Pos) -\u003e u32 {\n\titertools::iterate (\n\t\t\tPos::ZERO,\n\t\t\t|\u0026 pos| {\n\t\t\t\tlet mut pos = pos + traj;\n\t\t\t\twhile input.grid.size ().x \u003c= pos.x { pos.x -= input.grid.size ().x; }\n\t\t\t\tpos\n\t\t\t})\n\t\t.take_while (|pos| pos.y \u003c input.grid.size ().y)\n\t\t.map (|pos| input.grid.get (pos).unwrap ())\n\t\t.filter (|\u0026 tile| tile == Tile::Tree)\n\t\t.count ()\n\t\t.pan_u32 ()\n}\n","traces":[{"line":9,"address":[39008],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":10,"address":[39123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[39152],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":23,"address":[39300,39296,39460],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":28,"address":[39472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[39600],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":32,"address":[39608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[39690,39652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[39760],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":37,"address":[39776,39791,39777],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"}],"covered":7,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-03","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tOpen = \".\",\n\t\tTree = \"#\",\n\t}\n}\n","traces":[{"line":8,"address":[32234,31128],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-04","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"ecl:gry pid:860033327 eyr:2020 hcl:#fffffd\",\n\t\"byr:1937 iyr:2017 cid:147 hgt:183cm\",\n\t\"\",\n\t\"iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884\",\n\t\"hcl:#cfa07d byr:1929\",\n\t\"\",\n\t\"hcl:#ae17e1 iyr:2013\",\n\t\"eyr:2024\",\n\t\"ecl:brn pid:760753108 byr:1931\",\n\t\"hgt:179cm\",\n\t\"\",\n\t\"hcl:#cfa07d eyr:2025 pid:166559648\",\n\t\"iyr:2011 ecl:brn hgt:59in\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"eyr:1972 cid:100\",\n\t\"hcl:#18171d ecl:amb hgt:170 pid:186cm iyr:2018 byr:1926\",\n\t\"\",\n\t\"iyr:2019\",\n\t\"hcl:#602927 eyr:1967 hgt:170cm\",\n\t\"ecl:grn pid:012533040 byr:1946\",\n\t\"\",\n\t\"hcl:dab227 iyr:2012\",\n\t\"ecl:brn hgt:182cm pid:021572410 eyr:2020 byr:1992 cid:277\",\n\t\"\",\n\t\"hgt:59cm ecl:zzz\",\n\t\"eyr:2038 hcl:74454a iyr:2023\",\n\t\"pid:3556412378 byr:2007\",\n\t\"\",\n\t\"pid:087499704 hgt:74in ecl:grn iyr:2012 eyr:2030 byr:1980\",\n\t\"hcl:#623a2f\",\n\t\"\",\n\t\"eyr:2029 ecl:blu cid:129 byr:1989\",\n\t\"iyr:2014 pid:896056539 hcl:#a97842 hgt:165cm\",\n\t\"\",\n\t\"hcl:#888785\",\n\t\"hgt:164cm byr:2001 iyr:2015 cid:88\",\n\t\"pid:545766238 ecl:hzl\",\n\t\"eyr:2022\",\n\t\"\",\n\t\"iyr:2010 hgt:158cm hcl:#b6652a ecl:blu byr:1944 eyr:2021 pid:093154719\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"8\", puzzle.part_one (EXAMPLE_1));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"4\", puzzle.part_two (EXAMPLE_1));\n}\n","traces":[{"line":51,"address":[30416,30420],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":52,"address":[36529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[36879,36550,37138,36644,36816,36591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[36664,37102,36942,36701,36754,37002],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[30452,30448],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":59,"address":[37217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[37826,37504,37332,37567,37238,37279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[37690,37790,37352,37442,37389,37630],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-04","input.rs"],"content":"use super::*;\n\nuse model::Passport;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub passports: Vec \u003cPassport \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { passports, params } = [ params, @delim \"\\n\" passports ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[38244],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-04","lib.rs"],"content":"//! Advent of Code 2020: Day 4: Passport Processing\n//!\n//! [https://adventofcode.com/2020/day/04](https://adventofcode.com/2020/day/04)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Passport Processing\";\n\tyear = 2020;\n\tday = 4;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-04","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse self::PassportError::{ Length, Missing, Parse, Range };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.passports.iter ()\n\t\t\t.filter (|\u0026 passport| passport_errors (passport).iter ()\n\t\t\t\t.all (|error| ! matches! (* error, Missing (_))))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.passports.iter ()\n\t\t\t.filter (|\u0026 passport| passport_errors (passport).iter ()\n\t\t\t\t.all (|error| ! matches! (* error,\n\t\t\t\t\tMissing (_) | Length (_, _) | Parse (_, _) | Range (_, _))))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\nfn passport_errors \u003c'inp\u003e (\n\tpassport: \u0026 Vec \u003c(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e)\u003e,\n) -\u003e Vec \u003cPassportError \u003c'inp\u003e\u003e {\n\n\tmacro_rules! check_fields {\n\n\t\t(\n\t\t\tvars { $passport:ident, $errors:ident }\n\t\t\t$( $field:ident { $($checks:tt)* } )*\n\t\t) =\u003e {\n\t\t\t$( let mut $field: Option \u003cInpStr \u003c'inp\u003e\u003e = None; )*\n\t\t\tfor \u0026 (ref name, ref value) in $passport {\n\t\t\t\tmatch name.as_ref () {\n\t\t\t\t\t$( stringify! ($field) =\u003e {\n\t\t\t\t\t\tif $field.is_some () {\n\t\t\t\t\t\t\t$errors.push (PassportError::Duplicated (stringify! ($field)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$field = Some (value.clone ());\n\t\t\t\t\t\t}\n\t\t\t\t\t}, )*\n\t\t\t\t\t_ =\u003e $errors.push (PassportError::Unrecognised (name.clone ())),\n\t\t\t\t}\n\t\t\t}\n\t\t\t$( check_fields! (@field ($field, stringify! ($field), $errors) { $($checks)* }); )*\n\t\t};\n\n\t\t( @field ($val:expr, $name:expr, $errors:ident) { reqd; $($rest:tt)* } ) =\u003e {\n\t\t\tif let Some (val) = $val {\n\t\t\t\tcheck_fields! (@field_rest (val, $name, val, $errors) { $($rest)* });\n\t\t\t} else {\n\t\t\t\t$errors.push (PassportError::Missing ($name));\n\t\t\t}\n\t\t};\n\t\t( @field ($val:expr, $name:expr, $errors:ident) { opt; $($rest:tt)* } ) =\u003e {\n\t\t\tif let Some (val) = $val {\n\t\t\t\tcheck_fields! (@field_rest (val, $name, val, $errors) { $($rest)* });\n\t\t\t}\n\t\t};\n\n\t\t( @field_rest ($val:expr, $name:expr, $orig:expr, $errors:ident) { len $len:literal; $($rest:tt)* } ) =\u003e {\n\t\t\tif $val.chars ().count () == $len {\n\t\t\t\tcheck_fields! (@field_rest ($val, $name, $orig, $errors) { $($rest)* });\n\t\t\t} else {\n\t\t\t\t$errors.push (PassportError::Length ($name, $orig));\n\t\t\t}\n\t\t};\n\t\t( @field_rest ($val:expr, $name:expr, $orig:expr, $errors:ident) { parse $parse:path; $($rest:tt)* } ) =\u003e {\n\t\t\tif let Ok (val) = $parse (\u0026 $val) {\n\t\t\t\tcheck_fields! (@field_rest (val, $name, $orig, $errors) { $($rest)* });\n\t\t\t} else {\n\t\t\t\t$errors.push (PassportError::Parse ($name, $orig));\n\t\t\t}\n\t\t};\n\t\t( @field_rest ($val:expr, $name:expr, $orig:expr, $errors:ident) { range ($range:pat); $($rest:tt)* } ) =\u003e {\n\t\t\tif matches! ($val, $range) {\n\t\t\t\tcheck_fields! (@field_rest ($val, $name, $orig, $errors) { $($rest)* });\n\t\t\t} else {\n\t\t\t\t$errors.push (PassportError::Range ($name, $orig));\n\t\t\t}\n\t\t};\n\t\t( @field_rest ($val:expr, $name:expr, $orig:expr, $errors:ident) { } ) =\u003e {\n\t\t\t#[ allow (clippy::let_underscore_drop) ]\n\t\t\tlet _ = $val;\n\t\t};\n\t}\n\n\tlet mut errors = Vec::new ();\n\tuse Height::{ Cm, In };\n\tcheck_fields! {\n\t\tvars { passport, errors }\n\t\tbyr { reqd; len 4; parse u32::from_str; range (1920 ..= 2002); }\n\t\tiyr { reqd; len 4; parse u32::from_str; range (2010 ..= 2020); }\n\t\teyr { reqd; len 4; parse u32::from_str; range (2020 ..= 2030); }\n\t\thgt { reqd; parse Height::from_str; range (Cm (150 ..= 193) | In (59 ..= 76)); }\n\t\thcl { reqd; parse RgbColour::from_str; }\n\t\tecl { reqd; parse EyeColour::from_str; }\n\t\tpid { reqd; len 9; parse u32::from_str; }\n\t\tcid { opt; }\n\t}\n\terrors\n\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nenum PassportError \u003c'inp\u003e {\n\tMissing (\u0026 'static str),\n\tUnrecognised (InpStr \u003c'inp\u003e),\n\tDuplicated (\u0026 'static str),\n\tLength (\u0026 'static str, InpStr \u003c'inp\u003e),\n\tParse (\u0026 'static str, InpStr \u003c'inp\u003e),\n\tRange (\u0026 'static str, InpStr \u003c'inp\u003e),\n}\n\nenum Height { Cm (u32), In (u32) }\n\nimpl FromStr for Height {\n\ttype Err = Option \u003cParseIntError\u003e;\n\tfn from_str (src: \u0026 str) -\u003e Result \u003cSelf, Option \u003cParseIntError\u003e\u003e {\n\t\tif let Some (val_src) = src.strip_suffix (\"cm\") {\n\t\t\tval_src.parse ().map (Height::Cm).map_err (Some)\n\t\t} else if let Some (val_src) = src.strip_suffix (\"in\") {\n\t\t\tval_src.parse ().map (Height::In).map_err (Some)\n\t\t} else { Err (None) }\n\t}\n}\n\nstruct RgbColour;\n\nimpl FromStr for RgbColour {\n\ttype Err = ();\n\tfn from_str (src: \u0026 str) -\u003e Result \u003cSelf, ()\u003e {\n\t\tsrc.chars ().enumerate ()\n\t\t\t.try_fold (0_u32, |count, (ch_idx, ch)| {\n\t\t\t\tlet valid = if 0 \u003c ch_idx {\n\t\t\t\t\tch.is_ascii_hexdigit () \u0026\u0026 ! ch.is_ascii_uppercase ()\n\t\t\t\t} else { ch == '#' };\n\t\t\t\tif valid { Ok (count + 1) } else { Err (()) }\n\t\t\t})\n\t\t\t.and_then (|count| if count == 7 { Ok (Self) } else { Err (()) })\n\t}\n}\n\nparse_display_enum! {\n\tenum EyeColour {\n\t\tAmb = \"amb\", Blu = \"blu\", Brn = \"brn\", Gry = \"gry\",\n\t\tGrn = \"grn\", Hzl = \"hzl\", Oth = \"oth\",\n\t}\n}\n","traces":[{"line":8,"address":[49072],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":11,"address":[59885,59701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[59870,59788,59803],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[49328],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":21,"address":[33090,33269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[35216,33195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[59653,59587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[58497,49584],"length":1,"stats":{"Line":2},"fn_name":"passport_errors"},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":136},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[58544],"length":1,"stats":{"Line":2},"fn_name":"from_str"},{"line":127,"address":[58586],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[58590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[58695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[58699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[54901],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[35232],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":142,"address":[54985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[32121,31936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[32049,32211,31918,31942,32109,32127],"length":1,"stats":{"Line":4},"fn_name":null},{"line":147,"address":[35360],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"}],"covered":21,"coverable":67},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-04","model.rs"],"content":"use super::*;\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct Passport \u003c'inp\u003e {\n\t\tfields: Vec \u003c(InpStr \u003c'inp\u003e, InpStr \u003c'inp\u003e)\u003e,\n\t}\n}\n\nimpl \u003c'inp\u003e Display for Passport \u003c'inp\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut col = 0;\n\t\tfor \u0026 (ref name, ref value) in \u0026 self.fields {\n\t\t\tlet name_len = name.chars ().count ();\n\t\t\tlet value_len = value.chars ().count ();\n\t\t\tif 0 \u003c col \u0026\u0026 80 \u003c col + name_len + value_len + 2 {\n\t\t\t\twrite! (formatter, \"\\n\") ?;\n\t\t\t\tcol = 0;\n\t\t\t} else if 0 \u003c col {\n\t\t\t\twrite! (formatter, \" \") ?;\n\t\t\t\tcol += 1;\n\t\t\t}\n\t\t\twrite! (formatter, \"{name}:{value}\") ?;\n\t\t\tcol += name_len + value_len + 1;\n\t\t}\n\t\twrite! (formatter, \"\\n\") ?;\n\t\tOk (())\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Passport \u003c'inp\u003e {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet mut fields = Vec::new ();\n\t\twhile parser.peek ().unwrap_or ('\\n') != '\\n' {\n\t\t\tlet name = parser.take_rest_while (|ch| ch.is_ascii_alphanumeric (), 1 .. ) ?;\n\t\t\tparser.expect (\":\") ?;\n\t\t\tlet value = parser.take_rest_while (|ch| ! ch.is_whitespace (), 1 .. ) ?;\n\t\t\tfields.push ((name, value));\n\t\t\tif matches! (parser.peek (), Some (' ' | '\\n')) { parser.expect_next () ?; }\n\t\t}\n\t\tOk (Self { fields })\n\t}\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[60096,60996],"length":1,"stats":{"Line":1},"fn_name":"from_parser"},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":8,"coverable":24},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-05","input.rs"],"content":"use super::*;\n\nuse model::Seat;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub seats: Vec \u003cSeat\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { seats, params } = [ params, @lines seats ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-05","lib.rs"],"content":"//! Advent of Code 2020: Day 5: Binary Boarding\n//!\n//! [https://adventofcode.com/2020/day/05](https://adventofcode.com/2020/day/05)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Binary Boarding\";\n\tyear = 2020;\n\tday = 5;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-05","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Seat;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tOk (input.seats.iter ().map (Seat::id).max ().ok_or (\"Input is empty\") ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tlet seats: Vec \u003cu16\u003e =\n\t\tinput.seats.iter ()\n\t\t\t.map (Seat::id)\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tlet min = * seats.first ().ok_or (\"Input is empty\") ?;\n\tlet max = * seats.last ().ok_or (\"Input is empty\") ?;\n\tOk (\n\t\tseats.iter ().copied ()\n\t\t\t.zip (min ..= max)\n\t\t\t.find (|\u0026 (actual, expected)| actual != expected)\n\t\t\t.map (|(_, expected)| expected)\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-05","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Seat {\n\tpub row: [SeatRow; 7],\n\tpub col: [SeatCol; 3],\n}\n\nstruct_parser_display! {\n\tSeat { row, col } = [ @array row, @array col ]\n}\n\nimpl Seat {\n\t#[ must_use ]\n\tpub fn id (\u0026 self) -\u003e u16 {\n\t\tlet row = self.row.iter ().fold (0, |sum, \u0026 row|\n\t\t\tsum \u003c\u003c 1_u32 | u16::from (matches! (row, SeatRow::Back)));\n\t\tlet col = self.col.iter ().fold (0, |sum, \u0026 col|\n\t\t\tsum \u003c\u003c 1_u32 | u16::from (matches! (col, SeatCol::Right)));\n\t\trow \u003c\u003c 3_u32 | col\n\t}\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum SeatRow { Back = \"B\", Front = \"F\" }\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum SeatCol { Left = \"L\", Right = \"R\" }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-06","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub groups: Vec \u003cInputGroup \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { groups, params } = [ params, @delim \"\\n\\n\" groups ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputGroup \u003c'inp\u003e {\n\t\tpub people: Vec \u003cInputPerson \u003c'inp\u003e\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInputGroup \u003c'inp\u003e { people } = [ @lines people ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputPerson \u003c'inp\u003e {\n\t\tpub answers: InpStr \u003c'inp\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInputPerson \u003c'inp\u003e { answers } = [ @str answers = ('a' ..= 'z', 1 ..= 26) ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-06","lib.rs"],"content":"//! Advent of Code 2020: Day 6: Custom Customs\n//!\n//! [https://adventofcode.com/2020/day/06](https://adventofcode.com/2020/day/06)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Custom Customs\";\n\tyear = 2020;\n\tday = 6;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-06","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse input::InputPerson;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (calc_result (input, |sum, item| sum | item))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (calc_result (input, |sum, item| sum \u0026 item))\n}\n\nfn calc_result (input: \u0026 Input, reduce_fn: fn (u32, u32) -\u003e u32) -\u003e u32 {\n\tinput.groups.iter ()\n\t\t.map (|group| group.people.iter ()\n\t\t\t.map (get_bits)\n\t\t\t.reduce (reduce_fn)\n\t\t\t.unwrap_or (0))\n\t\t.map (u32::count_ones)\n\t\t.sum ()\n}\n\nfn get_bits (person: \u0026 InputPerson) -\u003e u32 {\n\tperson.chars ()\n\t\t.fold (0, |sum, ch| {\n\t\t\tassert! (('a' ..= 'z').contains (\u0026 ch));\n\t\t\tlet bit = ch.pan_u32 () - 'a'.pan_u32 ();\n\t\t\tsum | (1 \u003c\u003c bit)\n\t\t})\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-07","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub bags_contain: Vec \u003cInputBagContains \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { bags_contain, params } = [ params, @lines bags_contain ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputBagContains \u003c'inp\u003e {\n\tpub colour: InpStr \u003c'inp\u003e,\n\tpub contains: Vec \u003cInputNumBags \u003c'inp\u003e\u003e,\n}\n\nimpl \u003c'inp\u003e Display for InputBagContains \u003c'inp\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet \u0026 Self { ref colour, ref contains } = self;\n\t\tdisplay! (formatter, colour, \" bags contain \");\n\t\tif self.contains.is_empty () {\n\t\t\tdisplay! (formatter, \"no other bags.\");\n\t\t} else {\n\t\t\tdisplay! (formatter, @delim \", \" contains, \".\");\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for InputBagContains \u003c'inp\u003e {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tparse! (parser, colour = parse_colour, \" bags contain \");\n\t\tlet contains = parser.any ()\n\t\t\t.of (|parser| { parse! (parser, @delim \", \" contains, \".\"); Ok (contains) })\n\t\t\t.of (|parser| { parse! (parser, \"no other bags.\"); Ok (Vec::new ()) })\n\t\t\t.done () ?;\n\t\tOk (Self { colour, contains })\n\t}\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputNumBags \u003c'inp\u003e {\n\tpub num: u32,\n\tpub colour: InpStr \u003c'inp\u003e,\n}\n\nimpl \u003c'inp\u003e Display for InputNumBags \u003c'inp\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter,\n\t\t\t\"{num} {colour} {noun}\",\n\t\t\tnum = self.num,\n\t\t\tcolour = self.colour,\n\t\t\tnoun = if self.num != 1 { \"bags\" } else { \"bag\" })\n\t}\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for InputNumBags \u003c'inp\u003e {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tparse! (parser, num, \" \", colour = parse_colour, \" \");\n\t\tparser.any ()\n\t\t\t.of (|parser| { parser.expect (\"bags\") ?; Ok (()) })\n\t\t\t.of (|parser| { parser.expect (\"bag\") ?; Ok (()) })\n\t\t\t.done () ?;\n\t\tOk (Self { num, colour })\n\t}\n}\n\nfn parse_colour \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tlet num_chars =\n\t\tparser.peek_rest ().chars ().enumerate ()\n\t\t\t.filter (|\u0026 (_, ch)| ! ch.is_ascii_lowercase ())\n\t\t\t.nth (1)\n\t\t\t.map_or_else (\n\t\t\t\t|| parser.peek_rest ().chars ().count (),\n\t\t\t\t|(pos, _)| pos)\n\t\t\t.pan_u32 ();\n\tparser.take_rest_while (|ch| ch.is_ascii_lowercase () || ch == ' ', ..= num_chars)\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters_one: u32 = (\"MAX_ITERS_ONE=\", 200, 1_u32 .. ),\n\t\tpub max_iters_two: u32 = (\"MAX_ITERS_TWO=\", 100, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-07","lib.rs"],"content":"//! Advent of Code 2020: Day 7: Handy Haversacks\n//!\n//! [https://adventofcode.com/2020/day/07](https://adventofcode.com/2020/day/07)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Handy Haversacks\";\n\tyear = 2020;\n\tday = 7;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-07","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut direct_containers: HashMap \u003cInpStr, HashSet \u003cInpStr\u003e\u003e = HashMap::new ();\n\tfor bag_contains in \u0026 input.bags_contain {\n\t\tfor contents in \u0026 bag_contains.contains {\n\t\t\tdirect_containers.entry (contents.colour.clone ())\n\t\t\t\t.or_default ()\n\t\t\t\t.insert (bag_contains.colour.clone ());\n\t\t}\n\t}\n\tlet mut todo = Vec::new ();\n\ttodo.push (InpStr::borrow (\"shiny gold\"));\n\tlet mut seen = HashSet::new ();\n\tlet mut num_iters = 0;\n\twhile let Some (this_colour) = todo.pop () {\n\t\tif num_iters == input.params.max_iters_one {\n\t\t\treturn Err (\"Giving up after max iters\".into ());\n\t\t}\n\t\tnum_iters += 1;\n\t\tfor container in direct_containers.get (\u0026 this_colour).unwrap_or (\u0026 HashSet::new ()) {\n\t\t\tif ! seen.insert (container.clone ()) { continue }\n\t\t\ttodo.push (container.clone ());\n\t\t}\n\t}\n\tOk (seen.len ().pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet direct_contents: HashMap \u003cInpStr, Vec \u003c(InpStr, u32)\u003e\u003e =\n\t\tinput.bags_contain.iter ()\n\t\t\t.map (|bag_contains| (\n\t\t\t\tbag_contains.colour.clone (),\n\t\t\t\tbag_contains.contains.iter ()\n\t\t\t\t\t.map (|contained| (contained.colour.clone (), contained.num))\n\t\t\t\t\t.collect ()\n\t\t\t))\n\t\t\t.collect ();\n\tlet mut todo = Vec::new ();\n\ttodo.push ((InpStr::borrow (\"shiny gold\"), 1));\n\tlet mut total_bags = 0_u32;\n\tlet mut num_iters = 0;\n\twhile let Some ((this_colour, this_num_bags)) = todo.pop () {\n\t\tif num_iters == input.params.max_iters_two {\n\t\t\treturn Err (\"Giving up after max iters\".into ());\n\t\t}\n\t\tnum_iters += 1;\n\t\ttotal_bags = u32::add_2 (total_bags, this_num_bags) ?;\n\t\tfor \u0026 (ref contains_colour, contains_num_bags) in\n\t\t\tdirect_contents.get (\u0026 this_colour)\n\t\t\t\t.ok_or_else (|| format! (\"No rules for {this_colour} bags\")) ? {\n\t\t\ttodo.push ((\n\t\t\t\tcontains_colour.clone (),\n\t\t\t\tu32::mul_2 (this_num_bags, contains_num_bags) ?,\n\t\t\t));\n\t\t}\n\t}\n\tOk (total_bags - 1)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-08","input.rs"],"content":"use super::*;\n\nuse model::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-08","lib.rs"],"content":"//! Advent of Code 2020: Day 8: Handheld Halting\n//!\n//! [https://adventofcode.com/2020/day/08](https://adventofcode.com/2020/day/08)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Handheld Halting\";\n\tyear = 2020;\n\tday = 8;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-08","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Instr;\nuse model::Op;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet (_, acc) = run (\u0026 input.instrs) ?;\n\tOk (acc)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet mut instrs = input.instrs.clone ();\n\tlet end = Val::from_usize (instrs.len ()).unwrap ();\n\tlet mut result = None;\n\tfor change_idx in 0 .. instrs.len () {\n\t\tlet old_op = instrs [change_idx].op;\n\t\tlet new_op = match old_op {\n\t\t\tOp::Acc =\u003e continue,\n\t\t\tOp::Jmp =\u003e Op::Nop,\n\t\t\tOp::Nop =\u003e Op::Jmp,\n\t\t};\n\t\tinstrs [change_idx].op = new_op;\n\t\tlet (pos, acc) = run (\u0026 instrs) ?;\n\t\tif pos == end {\n\t\t\tif result.is_some () { return Err (\"Multiple solutions found\".into ()) }\n\t\t\tresult = Some (acc);\n\t\t}\n\t\tinstrs [change_idx].op = old_op;\n\t}\n\tOk (result.ok_or (\"No solution found\") ?)\n}\n\n/// Run the programme until termination or looping, returning final position and accumulator\n///\nfn run (instrs: \u0026 [Instr]) -\u003e GenResult \u003c(Val, Val)\u003e {\n\tlet mut acc = Val::ZERO;\n\tlet mut seen: HashSet \u003cusize\u003e = HashSet::new ();\n\tlet mut pos = Val::ZERO;\n\tloop {\n\t\tif pos \u003c Val::ZERO || instrs.len () \u003c= pos.pan_usize () { break }\n\t\tlet instr_idx = pos.pan_usize ();\n\t\tif ! seen.insert (instr_idx) { break }\n\t\tlet instr = instrs [instr_idx];\n\t\tif instr.op == Op::Acc { acc = Val::add_2 (acc, instr.arg) ?; }\n\t\tpos = Val::add_2 (pos, if instr.op == Op::Jmp { instr.arg } else { Val::ONE }) ?;\n\t}\n\tOk ((pos, acc))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-08","model.rs"],"content":"use super::*;\n\npub type Val = i32;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Op { Acc = \"acc\", Jmp = \"jmp\", Nop = \"nop\" }\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Instr { pub op: Op, pub arg: Val }\n\nstruct_parser_display! {\n\tInstr { op, arg } = [ op, \" \", arg ]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-09","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cu64\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @lines data ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-09","lib.rs"],"content":"//! Advent of Code 2020: Day 9: Encoding Error\n//!\n//! [https://adventofcode.com/2020/day/09](https://adventofcode.com/2020/day/09)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Encoding Error\";\n\tyear = 2020;\n\tday = 9;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-09","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tOk (find_invalid (\u0026 input.data).ok_or (\"No solution found\") ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet invalid = find_invalid (\u0026 input.data).ok_or (\"No solution found\") ?;\n\tlet range = find_contiguous (\u0026 input.data, invalid).ok_or (\"No solution found\") ?;\n\tlet min = input.data [range.clone ()].iter ().copied ().min ().unwrap ();\n\tlet max = input.data [range].iter ().copied ().max ().unwrap ();\n\tOk (min + max)\n}\n\nfn find_invalid (data: \u0026 [u64]) -\u003e Option \u003cu64\u003e {\n\tlet mut window = Vec::new ();\n\tfor (idx, num) in data.iter ().copied ().enumerate () {\n\t\tif window.len () == 25 \u0026\u0026 ! contains_sum (window.iter ().map (|\u0026 (_, num)| num), num) {\n\t\t\treturn Some (num);\n\t\t}\n\t\tif 25 \u003c= idx { window.retain (|\u0026 (prev_idx, _)| prev_idx != idx - 25); }\n\t\tlet insert_idx = window.binary_search_by_key (\u0026 num, |\u0026 (_, num)| num).either ();\n\t\twindow.insert (insert_idx, (idx, num));\n\t}\n\tNone\n}\n\nfn contains_sum (\n\titer: impl Iterator \u003cItem = u64\u003e + Clone + ExactSizeIterator + DoubleEndedIterator,\n\tsum: u64,\n) -\u003e bool {\n\tlet mut fwd_iter = iter.clone ().enumerate ().peekable ();\n\tlet mut rev_iter = iter.enumerate ().rev ().peekable ();\n\tloop {\n\t\tlet \u0026 (fwd_idx, fwd_val) = fwd_iter.peek ().unwrap ();\n\t\tlet \u0026 (rev_idx, rev_val) = rev_iter.peek ().unwrap ();\n\t\tif fwd_idx == rev_idx { return false }\n\t\tmatch sum.cmp (\u0026 (fwd_val + rev_val)) {\n\t\t\tOrdering::Equal =\u003e return true,\n\t\t\tOrdering::Less =\u003e rev_iter.next ().unwrap (),\n\t\t\tOrdering::Greater =\u003e fwd_iter.next ().unwrap (),\n\t\t};\n\t}\n}\n\nfn find_contiguous (data: \u0026 [u64], target: u64) -\u003e Option \u003cRange \u003cusize\u003e\u003e {\n\tfor idx_0 in 0 .. data.len () - 2 {\n\t\tlet mut sum = data [idx_0];\n\t\tfor idx_1 in idx_0 + 1 .. data.len () {\n\t\t\tsum += data [idx_1];\n\t\t\tif target == sum { return Some (idx_0 .. idx_1 + 1) }\n\t\t\tif target \u003c sum { break }\n\t\t}\n\t}\n\tNone\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-10","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub adapters: Vec \u003cu16\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { adapters, params } = [ params, @lines adapters ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-10","lib.rs"],"content":"//! Advent of Code 2020: Day 10: Adapter Array\n//!\n//! [https://adventofcode.com/2020/day/10](https://adventofcode.com/2020/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Adapter Array\";\n\tyear = 2020;\n\tday = 10;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-10","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tlet sequence = get_sequence (input) ?;\n\tlet (num_ones, num_threes) =\n\t\tsequence.iter ().copied ()\n\t\t\t.tuple_windows ()\n\t\t\t.map (|(prev, next)| next - prev)\n\t\t\t.fold ((0, 0), |(num_ones, num_threes), diff| (\n\t\t\t\tnum_ones + u16::from (diff == 1),\n\t\t\t\tnum_threes + u16::from (diff == 3),\n\t\t\t));\n\tOk (num_ones * num_threes)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet sequence = get_sequence (input) ?;\n\tlet mut work = vec! [0; sequence.len ()];\n\twork [0] = 1;\n\tfor idx in 0 .. work.len () {\n\t\tlet cur = sequence [idx];\n\t\tlet num = work [idx];\n\t\tfor (next_idx, \u0026 next) in sequence [idx + 1 .. ].iter ().enumerate () {\n\t\t\tlet next_idx = idx + 1 + next_idx;\n\t\t\tif cur + 3 \u003c next { break }\n\t\t\twork [next_idx] = Int::add_2 (work [next_idx], num) ?;\n\t\t}\n\t}\n\tOk (* work.last ().unwrap ())\n}\n\nfn get_sequence (input: \u0026 Input) -\u003e GenResult \u003cVec \u003cu16\u003e\u003e {\n\tlet mut sequence: Vec \u003cu16\u003e =\n\t\tinput.adapters.iter ().copied ()\n\t\t\t.chain (iter::once (0))\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tsequence.push (* sequence.last ().unwrap () + 3);\n\tif sequence.iter ().tuple_windows ().any (|(\u0026 a, \u0026 b)| a == b) {\n\t\treturn Err (\"Duplicated adapter\".into ());\n\t}\n\tOk (sequence)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-11","input.rs"],"content":"use super::*;\n\nuse model::Tiles;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub tiles: Tiles,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { tiles, params } = [ params, tiles ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters: u32 = (\"MAX_ITERS=\", 100, 1_u32 .. ),\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-11","lib.rs"],"content":"//! Advent of Code 2020: Day 11: Seating System\n//!\n//! [https://adventofcode.com/2020/day/11](https://adventofcode.com/2020/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Seating System\";\n\tyear = 2020;\n\tday = 11;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-11","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse input::InputParams;\nuse model::Tiles;\nuse model::TilesCursor;\nuse model::Pos;\nuse model::Tile;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tlet state = input.tiles.clone ();\n\n\tlet dirs: Vec \u003c_\u003e = [\n\t\tPos::new (-1, -1), Pos::new (-1, 0), Pos::new (-1, 1),\n\t\tPos::new (0, -1), Pos::new (0, 1),\n\t\tPos::new (1, -1), Pos::new (1, 0), Pos::new (1, 1),\n\t].into_iter ()\n\t\t.map (|pos| state.offset (pos))\n\t\t.try_collect () ?;\n\n\tcalc_result (\u0026 input.params, state, |state: \u0026 Tiles, cursor| {\n\t\tlet num_adj = dirs.iter ()\n\t\t\t.filter_map (|\u0026 dir| cursor.try_add (dir)\n\t\t\t\t.map (|adj_cursor| adj_cursor.get (state))\n\t\t\t\t.ok ())\n\t\t\t.filter (|\u0026 tile| tile == Tile::Occupied)\n\t\t\t.count ();\n\t\tmatches! ((cursor.get (state), num_adj), (Tile::Empty, 0) | (Tile::Occupied, 0 ..= 3))\n\t})\n\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tlet state = input.tiles.clone ();\n\n\tlet dirs: Vec \u003c_\u003e = [\n\t\tPos::new (-1, -1), Pos::new (-1, 0), Pos::new (-1, 1),\n\t\tPos::new (0, -1), Pos::new (0, 1),\n\t\tPos::new (1, -1), Pos::new (1, 0), Pos::new (1, 1),\n\t].into_iter ().map (|pos| state.offset (pos)).try_collect () ?;\n\n\tcalc_result (\u0026 input.params, state, move |state, cursor| {\n\t\tlet num_adj = dirs.iter ()\n\t\t\t.filter_map (|\u0026 dir| {\n\t\t\t\tlet mut adj_cursor = cursor;\n\t\t\t\tloop {\n\t\t\t\t\tadj_cursor = adj_cursor.try_add (dir).ok () ?;\n\t\t\t\t\tlet adj_tile = adj_cursor.get (state);\n\t\t\t\t\tif adj_tile == Tile::Floor { continue }\n\t\t\t\t\treturn Some (adj_tile);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.filter (|\u0026 tile| tile == Tile::Occupied)\n\t\t\t.count ();\n\t\tmatches! ((cursor.get (state), num_adj), (Tile::Empty, 0) | (Tile::Occupied, 0 ..= 4))\n\t})\n\n}\n\n#[ inline ]\nfn calc_result \u003cEvalFn\u003e (params: \u0026 InputParams, mut state: Tiles, mut eval_fn: EvalFn) -\u003e GenResult \u003cu32\u003e\n\twhere EvalFn: FnMut (\u0026 Tiles, TilesCursor) -\u003e bool {\n\n\tfor _ in 0 .. params.max_iters {\n\n\t\tlet next_state = state.map (|cursor| {\n\t\t\tlet tile = cursor.get (\u0026 state);\n\t\t\tif tile == Tile::Floor { return Tile::Floor }\n\t\t\tif eval_fn (\u0026 state, cursor) { Tile::Occupied } else { Tile::Empty }\n\t\t});\n\n\t\tif state == next_state { \n\t\t\treturn Ok (\n\t\t\t\tstate.values ()\n\t\t\t\t\t.filter (|\u0026 tile| tile == Tile::Occupied)\n\t\t\t\t\t.count ()\n\t\t\t\t\t.pan_u32 ()\n\t\t\t);\n\t\t}\n\n\t\tstate = next_state;\n\n\t}\n\n\tErr (\"Giving up after max iterations\".into ())\n\n}\n","traces":[{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-11","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Tiles = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type TilesCursor = GridCursor \u003cPos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tFloor = \".\",\n\t\tEmpty = \"L\",\n\t\tOccupied = \"#\",\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-12","input.rs"],"content":"use super::*;\n\nuse model::Step;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @lines steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-12","lib.rs"],"content":"//! Advent of Code 2020: Day 12: Rain Risk\n//!\n//! [https://adventofcode.com/2020/day/12](https://adventofcode.com/2020/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Rain Risk\";\n\tyear = 2020;\n\tday = 12;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-12","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Pos;\nuse model::Step;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut pos = Pos::ZERO;\n\tlet mut dir = Dir::East;\n\tfor \u0026 step in \u0026 input.steps {\n\t\tmatch step {\n\t\t\tStep::North (arg) =\u003e pos = (pos + (Dir::North, arg)) ?,\n\t\t\tStep::South (arg) =\u003e pos = (pos + (Dir::South, arg)) ?,\n\t\t\tStep::East (arg) =\u003e pos = (pos + (Dir::East, arg)) ?,\n\t\t\tStep::West (arg) =\u003e pos = (pos + (Dir::West, arg)) ?,\n\t\t\tStep::Left (90_i32) | Step::Right (270_i32) =\u003e dir = dir.left (),\n\t\t\tStep::Right (90_i32) | Step::Left (270_i32) =\u003e dir = dir.right (),\n\t\t\tStep::Left (180_i32) | Step::Right (180_i32) =\u003e dir = dir.around (),\n\t\t\tStep::Forwards (arg) =\u003e pos = (pos + (dir, arg)) ?,\n\t\t\tStep::Left (_) | Step::Right (_) =\u003e\n\t\t\t\treturn Err (format! (\"Invalid step: {step:?}\").into ()),\n\t\t}\n\t}\n\tOk (pos.n.unsigned_abs ().pan_u32 () + pos.e.unsigned_abs ().pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut pos = Pos::ZERO;\n\tlet mut way = Pos { n: 1_i32, e: 10_i32 };\n\tfor \u0026 step in \u0026 input.steps {\n\t\tmatch step {\n\t\t\tStep::North (arg) =\u003e way = (way + (Dir::North, arg)) ?,\n\t\t\tStep::South (arg) =\u003e way = (way + (Dir::South, arg)) ?,\n\t\t\tStep::East (arg) =\u003e way = (way + (Dir::East, arg)) ?,\n\t\t\tStep::West (arg) =\u003e way = (way + (Dir::West, arg)) ?,\n\t\t\tStep::Left (90_i32) | Step::Right (270_i32) =\u003e way = way.left (),\n\t\t\tStep::Right (90_i32) | Step::Left (270_i32) =\u003e way = way.right (),\n\t\t\tStep::Left (180_i32) | Step::Right (180_i32) =\u003e way = way.around (),\n\t\t\tStep::Forwards (arg) =\u003e pos = pos.try_add (way.try_mul (arg) ?) ?,\n\t\t\tStep::Left (_) | Step::Right (_) =\u003e\n\t\t\t\treturn Err (format! (\"Invalid step: {step:?}\").into ()),\n\t\t}\n\t}\n\tOk (pos.n.unsigned_abs ().pan_u32 () + pos.e.unsigned_abs ().pan_u32 ())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-12","model.rs"],"content":"use super::*;\n\npub type Coord = i32;\npub type Dir = aoc_pos::DirGeo;\npub type Pos = aoc_pos::PosGeo \u003cCoord\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Step {\n\tNorth (Coord),\n\tSouth (Coord),\n\tEast (Coord),\n\tWest (Coord),\n\tLeft (Coord),\n\tRight (Coord),\n\tForwards (Coord),\n}\n\nenum_parser_display! {\n\tStep,\n\tNorth (val) = [ \"N\", @confirm, val ],\n\tSouth (val) = [ \"S\", @confirm, val ],\n\tEast (val) = [ \"E\", @confirm, val ],\n\tWest (val) = [ \"W\", @confirm, val ],\n\tLeft (val) = [ \"L\", @confirm, val ],\n\tRight (val) = [ \"R\", @confirm, val ],\n\tForwards (val) = [ \"F\", @confirm, val ],\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"939\",\n\t\"7,13,x,x,59,x,31,19\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"295\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1068781\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[38304,38695],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":12,"address":[38314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[38335,38652,38482,38548,38373,38425],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[39095,38704],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":18,"address":[38714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[38773,38735,38882,39052,38825,38948],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-13","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub earliest: u32,\n\tpub bus_ids: Vec \u003cOption \u003cu32\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { earliest, bus_ids, params } = [\n\t\tparams,\n\t\tearliest, \"\\n\",\n\t\t@delim \",\" bus_ids {\n\t\t\ttype = Option \u003cu32\u003e;\n\t\t\tSome (bus_id) = [ bus_id ],\n\t\t\tNone = [ \"x\" ],\n\t\t}\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub max_iters: u32 = (\"MAX_ITERS=\", 1_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":11,"address":[57837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[58157],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-13","lib.rs"],"content":"//! Advent of Code 2020: Day 13: Shuttle Search\n//!\n//! [https://adventofcode.com/2020/day/13](https://adventofcode.com/2020/day/13)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Shuttle Search\";\n\tyear = 2020;\n\tday = 13;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[45719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[46071],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-13","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut time_now = input.earliest;\n\tlet bus_ids: Vec \u003cu32\u003e =\n\t\tinput.bus_ids.iter ().copied ()\n\t\t\t.flatten ()\n\t\t\t.collect ();\n\tfor _ in 0 .. input.params.max_iters {\n\t\tfor \u0026 bus_id in bus_ids.iter () {\n\t\t\tif chk! (time_now % bus_id) ? == 0 {\n\t\t\t\treturn Ok (chk! (bus_id * (time_now - input.earliest)) ?);\n\t\t\t}\n\t\t}\n\t\ttime_now += 1;\n\t}\n\tErr (\"Giving up after max iterations\".into ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu128\u003e {\n\tlet bus_idx_ids: Vec \u003c(u128, u128)\u003e =\n\t\tinput.bus_ids.iter ().copied ().enumerate ()\n\t\t\t.filter_map (|(idx, id)| id.map (|id| (idx.pan_u128 (), id.pan_u128 ())))\n\t\t\t.collect ();\n\tlet mut time: u128 = 0;\n\tfor _ in 0 .. input.params.max_iters {\n\t\tlet mut incr: u128 = 1;\n\t\tlet mut matches = true;\n\t\tfor \u0026 (bus_idx, bus_id) in \u0026 bus_idx_ids {\n\t\t\tif chk! ((time + bus_idx) % bus_id) ? == 0 {\n\t\t\t\tchk! (incr *= bus_id) ?;\n\t\t\t} else {\n\t\t\t\tmatches = false;\n\t\t\t}\n\t\t}\n\t\tif matches { return Ok (time) }\n\t\tchk! (time += incr) ?;\n\t}\n\tErr (\"Giving up after max iterations\".into ())\n}\n","traces":[{"line":7,"address":[54192,54708],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[54212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[54292,54483,54287],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[54370],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[28688,28736,28740],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":16,"address":[28880,28768,28819,28771,28848,28832,28799],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":19,"address":[54654,54448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[54489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[54720,55472],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":27,"address":[28529,28512,28654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[54814,54805,55310],"length":1,"stats":{"Line":3},"fn_name":null},{"line":33,"address":[54938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[29055,28977,29040,28944,28912,28976],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":35,"address":[29107,29133,29104],"length":1,"stats":{"Line":1},"fn_name":"{closure#3}"},{"line":40,"address":[55426,55232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[29200],"length":1,"stats":{"Line":1},"fn_name":"{closure#4}"},{"line":43,"address":[55316],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":17},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X\",\n\t\"mem[8] = 11\",\n\t\"mem[7] = 101\",\n\t\"mem[8] = 0\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"mask = 000000000000000000000000000000X1001X\",\n\t\"mem[42] = 100\",\n\t\"mask = 00000000000000000000000000000000X0XX\",\n\t\"mem[26] = 1\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"165\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"208\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":20,"address":[26916,26912],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[46234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[46345,46255,46402,46468,46572,46293],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[26944,26948],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":27,"address":[46634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[46655,46745,46972,46802,46868,46693],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-14","input.rs"],"content":"use super::*;\n\nuse model::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[29974,30491],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-14","lib.rs"],"content":"//! Advent of Code 2020: Day 14: Docking Data\n//!\n//! [https://adventofcode.com/2020/day/14](https://adventofcode.com/2020/day/14)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Docking Data\";\n\tyear = 2020;\n\tday = 14;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[43496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[43816],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-14","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Instr;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut memory: HashMap \u003cu64, u64\u003e = HashMap::new ();\n\tlet mut keep = 0;\n\tlet mut set = 0;\n\tfor \u0026 instr in \u0026 input.instrs {\n\t\tmatch instr {\n\t\t\tInstr::Mask { mask, val } =\u003e (keep, set) = (! mask, val),\n\t\t\tInstr::Store { addr, val } =\u003e { memory.insert (addr, val \u0026 keep | set); },\n\t\t}\n\t}\n\tOk (memory.values ().sum ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut stores: Vec \u003c(u64, u64, u64)\u003e = Vec::new ();\n\tlet mut keep = 0;\n\tlet mut set = 0;\n\tlet mut fixed = 0;\n\tfor \u0026 instr in \u0026 input.instrs {\n\t\tmatch instr {\n\t\t\tInstr::Mask { mask, val } =\u003e {\n\t\t\t\tkeep = mask \u0026 ! val;\n\t\t\t\tset = mask \u0026 val;\n\t\t\t\tfixed = mask;\n\t\t\t},\n\t\t\tInstr::Store { addr, val } =\u003e {\n\t\t\t\tstores.push ((addr \u0026 keep | set, fixed, val));\n\t\t\t},\n\t\t}\n\t}\n\tlet mut memory = HashSet::new ();\n\tlet mut sum = 0;\n\tlet mut num_iters = 0;\n\tfor \u0026 (addr, fixed, val) in stores.iter ().rev () {\n\t\tlet mut float = 0;\n\t\twhile float \u003c (1 \u003c\u003c 36_u32) {\n\t\t\tif num_iters == 200_000_u32 {\n\t\t\t\treturn Err (\"Giving up due to max iterations\".into ());\n\t\t\t}\n\t\t\tnum_iters += 1;\n\t\t\tif memory.insert (addr | float) {\n\t\t\t\tif 100_000_usize \u003c memory.len () {\n\t\t\t\t\treturn Err (\"Giving up due to memory limit\".into ());\n\t\t\t\t}\n\t\t\t\tsum += val;\n\t\t\t}\n\t\t\tfloat = ((float | fixed) + 1) \u0026 ! fixed;\n\t\t}\n\t}\n\tOk (sum)\n}\n","traces":[{"line":8,"address":[51117,50608],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[50800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[50825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[50852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[50831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[51020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[51136,52017],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":26,"address":[51253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[51286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[51380],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[51374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[51597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[51723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[51648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[51657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[51682,51666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[51686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[51697],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[51708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[51872],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":20,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-14","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum Instr {\n\tMask { val: u64, mask: u64 },\n\tStore { addr: u64, val: u64 },\n}\n\nenum_parser_display! {\n\tInstr,\n\tMask { val, mask } = [ \"mask\", @confirm, \" = \", (val, mask) = (mask_parse, mask_display) ],\n\tStore { addr, val } = [ \"mem\", @confirm, \"[\", addr, \"] = \", val ],\n}\n\nfn mask_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003c(u64, u64)\u003e {\n\tlet mut val = 0;\n\tlet mut mask = 0;\n\tfor _ in 0_u32 .. 36 {\n\t\tval \u003c\u003c= 1_u32;\n\t\tmask \u003c\u003c= 1_u32;\n\t\tmatch parser.peek () {\n\t\t\tSome ('X') =\u003e (),\n\t\t\tSome ('0') =\u003e mask |= 1,\n\t\t\tSome ('1') =\u003e { val |= 1; mask |= 1; },\n\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t}\n\t\tparser.expect_next ().unwrap ();\n\t}\n\tOk ((val, mask))\n}\n\nfn mask_display (\n\t\u0026 (\u0026 (mut val), \u0026 (mut mask)): \u0026 (\u0026 u64, \u0026 u64),\n\tformatter: \u0026 mut fmt::Formatter,\n) -\u003e fmt::Result {\n\tfor _ in 0_u32 .. 36 {\n\t\tlet mask_bit = mask \u0026 (1 \u003c\u003c 35_u32) != 0;\n\t\tlet val_bit = val \u0026 (1 \u003c\u003c 35_u32) != 0;\n\t\tmatch (mask_bit, val_bit) {\n\t\t\t(false, _) =\u003e formatter.write_char ('X') ?,\n\t\t\t(true, false) =\u003e formatter.write_char ('0') ?,\n\t\t\t(true, true) =\u003e formatter.write_char ('1') ?,\n\t\t}\n\t\tval \u003c\u003c= 1_u32;\n\t\tmask \u003c\u003c= 1_u32;\n\t}\n\tOk (())\n}\n","traces":[{"line":15,"address":[31104],"length":1,"stats":{"Line":2},"fn_name":"mask_parse"},{"line":18,"address":[31302],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[31152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[31155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[31224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[31248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[31334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[31313],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":7,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLES: \u0026 [\u0026 [\u0026 str]] = \u0026 [\n\t\u0026 [ \"0,3,6\" ],\n\t\u0026 [ \"1,3,2\" ],\n    \u0026 [ \"2,1,3\" ],\n    \u0026 [ \"1,2,3\" ],\n    \u0026 [ \"2,3,1\" ],\n    \u0026 [ \"3,2,1\" ],\n    \u0026 [ \"3,1,2\" ],\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"436\", puzzle.part_one (EXAMPLES [0]));\n\tassert_eq_ok! (\"1\", puzzle.part_one (EXAMPLES [1]));\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLES [2]));\n\tassert_eq_ok! (\"27\", puzzle.part_one (EXAMPLES [3]));\n\tassert_eq_ok! (\"78\", puzzle.part_one (EXAMPLES [4]));\n\tassert_eq_ok! (\"438\", puzzle.part_one (EXAMPLES [5]));\n\tassert_eq_ok! (\"1836\", puzzle.part_one (EXAMPLES [6]));\n}\n\n#[ test ]\nfn part_two_0 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"175594\", puzzle.part_two (EXAMPLES [0]));\n}\n\n#[ test ]\nfn part_two_1 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2578\", puzzle.part_two (EXAMPLES [1]));\n}\n\n#[ test ]\nfn part_two_2 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3544142\", puzzle.part_two (EXAMPLES [2]));\n}\n\n#[ test ]\nfn part_two_3 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"261214\", puzzle.part_two (EXAMPLES [3]));\n}\n\n#[ test ]\nfn part_two_4 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6895259\", puzzle.part_two (EXAMPLES [4]));\n}\n\n#[ test ]\nfn part_two_5 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"18\", puzzle.part_two (EXAMPLES [5]));\n}\n\n#[ test ]\nfn part_two_6 () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"362\", puzzle.part_two (EXAMPLES [6]));\n}\n","traces":[{"line":16,"address":[53076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[40145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[40166,40208,41073,40264,41139,42263],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[40383,40286,40324,41268,41207,42225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[41336,40405,42184,41397,40508,40449],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[41465,42143,40574,40633,40530,41526],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[41594,40758,40699,41655,42102,40655],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[42061,40824,40780,40883,41723,41784],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[42020,41910,40949,41008,40905,41849],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[30576,30580],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":29,"address":[42330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[42389,42351,42441,42498,42564,42668],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[30608,30612],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":35,"address":[42730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[42964,42789,42751,42898,42841,43068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[30640,30644],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":41,"address":[43130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[43241,43298,43364,43189,43151,43468],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[30672,30676],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":47,"address":[43530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[43641,43868,43698,43551,43589,43764],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[44311,43920],"length":1,"stats":{"Line":2},"fn_name":"part_two_4"},{"line":53,"address":[43930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[44268,44041,43951,43989,44098,44164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[30736,30740],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":59,"address":[44330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[44498,44668,44441,44564,44389,44351],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[30768,30772],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":65,"address":[44730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[44898,44964,45068,44841,44789,44751],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":30,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-15","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub start_nums: Vec \u003cu32\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { start_nums, params } = [ params, @delim \",\" start_nums ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub ord_one: u32 = (\"ORD_ONE=\", 2020, 1_u32 .. ),\n\t\tpub ord_two: u32 = (\"ORD_TWO=\", 30_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":10,"address":[36732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[38067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[38071],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-15","lib.rs"],"content":"//! Advent of Code 2020: Day 15: Rambunctious Recitation\n//!\n//! [https://adventofcode.com/2020/day/15](https://adventofcode.com/2020/day/15)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Rambunctious Recitation\";\n\tyear = 2020;\n\tday = 15;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-15","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, input.params.ord_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result (input, input.params.ord_two)\n}\n\nfn calc_result (input: \u0026 Input, ord: u32) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tgame_iter (\u0026 input.start_nums) ?\n\t\t\t.nth ((ord - 1).pan_usize ())\n\t\t\t.unwrap ()\n\t)\n}\n\nfn game_iter (start: \u0026 [u32]) -\u003e GenResult \u003cimpl Iterator \u003cItem = u32\u003e + '_\u003e {\n\tif start.is_empty () { return Err (\"Must have at least one starting number\".into ()) }\n\tlet mut posns: HashMap \u003cu32, u32\u003e =\n\t\tstart.iter ().enumerate ()\n\t\t\t.map (|(idx, \u0026 num)| (num, idx.pan_u32 ()))\n\t\t\t.collect ();\n\tlet mut pos = start.len ().pan_u32 () - 1;\n\tlet \u0026 (mut next) = start.last ().unwrap ();\n\tOk (\n\t\tstart.iter ().copied ()\n\t\t\t.take (pos.pan_usize ())\n\t\t\t.chain (iter::from_fn (move || {\n\t\t\t\tlet num = next;\n\t\t\t\tlet \u0026 prev_pos = posns.get (\u0026 num).unwrap_or (\u0026 pos);\n\t\t\t\tnext = pos - prev_pos;\n\t\t\t\tposns.insert (num, pos);\n\t\t\t\tpos += 1;\n\t\t\t\tSome (num)\n\t\t\t}))\n\t)\n}\n","traces":[{"line":7,"address":[27312],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[27316],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[27344],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":12,"address":[56689],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[27376,27887],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":17,"address":[27722,27464,27424,27582],"length":1,"stats":{"Line":6},"fn_name":null},{"line":18,"address":[27652,27837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[28257,27904],"length":1,"stats":{"Line":2},"fn_name":"game_iter"},{"line":24,"address":[28158,27922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[30208,30262,30212],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":29,"address":[28207,28024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[28034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[28094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":35,"address":[30282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[30422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[30433,30484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[30445],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[30457,30511],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[30467],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":17,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-16","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"class: 1-3 or 5-7\",\n\t\"row: 6-11 or 33-44\",\n\t\"seat: 13-40 or 45-50\",\n\t\"\",\n\t\"your ticket:\",\n\t\"7,1,14\",\n\t\"\",\n\t\"nearby tickets:\",\n\t\"7,3,47\",\n\t\"40,4,50\",\n\t\"55,2,20\",\n\t\"38,6,12\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"class: 0-1 or 4-19\",\n\t\"departure row: 0-5 or 8-19\",\n\t\"departure seat: 0-13 or 16-19\",\n\t\"\",\n\t\"your ticket:\",\n\t\"11,12,13\",\n\t\"\",\n\t\"nearby tickets:\",\n\t\"3,9,18\",\n\t\"15,1,5\",\n\t\"5,14,9\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"71\", puzzle.part_one (EXAMPLE_0));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"143\", puzzle.part_two (EXAMPLE_1));\n}\n","traces":[{"line":35,"address":[32503,32112],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":36,"address":[32122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[32290,32143,32233,32460,32356,32181],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[32512,32903],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":42,"address":[32522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[32581,32633,32690,32543,32756,32860],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-16","input.rs"],"content":"use super::*;\n\nuse model::Field;\nuse model::Ticket;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub fields: Vec \u003cField \u003c'inp\u003e\u003e,\n\tpub your_ticket: Ticket,\n\tpub nearby_tickets: Vec \u003cTicket\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { fields, your_ticket, nearby_tickets, params } = [\n\t\tparams,\n\t\t@lines fields, \"\\n\",\n\t\t\"\\n\",\n\t\t\"your ticket:\\n\",\n\t\tyour_ticket, \"\\n\",\n\t\t\"\\n\",\n\t\t\"nearby tickets:\\n\",\n\t\t@lines nearby_tickets,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":16,"address":[87167],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-16","lib.rs"],"content":"//! Advent of Code 2020: Day 16: Ticket Translation\n//!\n//! [https://adventofcode.com/2020/day/16](https://adventofcode.com/2020/day/16)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Ticket Translation\";\n\tyear = 2020;\n\tday = 16;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[77574],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[78020],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-16","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Field;\nuse model::Ticket;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tcheck_input (input) ?;\n\tlet matches = get_matches (input);\n\tOk (\n\t\tinput.nearby_tickets.iter ()\n\t\t\t.flat_map (|ticket| ticket.iter ())\n\t\t\t.filter (|\u0026\u0026 val| matches [val.pan_usize ()] == 0)\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcheck_input (input) ?;\n\tlet matches = get_matches (input);\n\tlet tickets: Vec \u003c\u0026 Ticket\u003e =\n\t\tinput.nearby_tickets.iter ()\n\t\t\t.filter (|ticket| ticket.iter ().all (|\u0026 val| matches [val.pan_usize ()] != 0))\n\t\t\t.collect ();\n\tlet field_idxes = get_field_idxes (\u0026 input.fields, \u0026 matches, \u0026 tickets);\n\tOk (\n\t\tget_field_mappings (\u0026 field_idxes) ?.iter ()\n\t\t\t.enumerate ()\n\t\t\t.filter (|\u0026 (_, name)| name.starts_with (\"departure \"))\n\t\t\t.map (|(idx, _)| input.your_ticket [idx].pan_u64 ())\n\t\t\t.try_fold (1, |prod, val| chk! (prod * val)) ?\n\t)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif 32 \u003c= input.fields.len () {\n\t\treturn Err (\"Don't know how to handle more than 32 fields\".into ());\n\t}\n\tfor field in \u0026 input.fields { check_field (field) ?; }\n\tcheck_ticket (\u0026 input.your_ticket, input.fields.len ()) ?;\n\tfor ticket in \u0026 input.nearby_tickets { check_ticket (ticket, input.fields.len ()) ?; }\n\tOk (())\n}\n\nfn check_field (field: \u0026 Field) -\u003e GenResult \u003c()\u003e {\n\tif ! (field.first.0 \u003c field.first.1 \u0026\u0026 field.second.0 \u003c field.second.1) {\n\t\treturn Err (\"Field value ranges must be from lower to higher value\".into ());\n\t}\n\tOk (())\n}\n\nfn check_ticket (ticket: \u0026 Ticket, num_fields: usize) -\u003e GenResult \u003c()\u003e {\n\tif ticket.len () != num_fields {\n\t\treturn Err (\"Tickets must all have the same number of fields\".into ());\n\t}\n\tif ticket.iter ().any (|\u0026 val| 1000 \u003c= val) {\n\t\treturn Err (\"Field values must be less than 1000\".into ());\n\t}\n\tOk (())\n}\n\nfn get_field_mappings \u003c'inp\u003e (\n\tfield_idxes: \u0026 [(InpStr \u003c'inp\u003e, u32)],\n) -\u003e GenResult \u003cVec \u003cInpStr \u003c'inp\u003e\u003e\u003e {\n\tlet mut pending = field_idxes.to_vec ();\n\tlet mut ordered: Vec \u003cOption \u003cInpStr\u003e\u003e = vec! [ None; field_idxes.len () ];\n\tlet mut remaining: u32 = u32::MAX \u003e\u003e (u32::BITS - field_idxes.len ().pan_u32 ());\n\twhile remaining != 0 {\n\t\tlet mut progress = false;\n\t\tlet mut error = false;\n\t\tpending.retain_mut (|\u0026 mut (ref name, ref mut idxes)| {\n\t\t\t* idxes \u0026= remaining;\n\t\t\tif * idxes == 0 { error = true; return true }\n\t\t\tif 1 \u003c idxes.count_ones () { return true }\n\t\t\tlet idx = idxes.trailing_zeros ();\n\t\t\tordered [idx.pan_usize ()] = Some (name.clone ());\n\t\t\tremaining \u0026= ! (1 \u003c\u003c idx);\n\t\t\tprogress = true;\n\t\t\tfalse\n\t\t});\n\t\tif ! progress || error { return Err (\"No solution found\".into ()) }\n\t}\n\tOk (ordered.into_iter ().flatten ().collect ())\n}\n\nfn get_field_idxes \u003c'inp\u003e (\n\tfields: \u0026 [Field \u003c'inp\u003e],\n\tmatches: \u0026 [u32],\n\ttickets: \u0026 [\u0026 Ticket],\n) -\u003e Vec \u003c(InpStr \u003c'inp\u003e, u32)\u003e {\n\tlet mut temp = vec! [ u32::MAX \u003e\u003e (u32::BITS - fields.len ().pan_u32 ()); fields.len () ];\n\tfor ticket in tickets {\n\t\tfor (\u0026 val, temp) in ticket.iter ().zip (temp.iter_mut ()) {\n\t\t\t* temp \u0026= matches [val.pan_usize ()];\n\t\t}\n\t}\n\tfields.iter ()\n\t\t.map (|field| field.name.clone ())\n\t\t.zip ((0 .. matches.len ())\n\t\t\t.map (|idx| temp.iter ().enumerate ()\n\t\t\t\t.filter (|\u0026 (_, \u0026 temp)| temp \u0026 1 \u003c\u003c idx != 0)\n\t\t\t\t.fold (0, |idxes, (idx, \u0026 _)| idxes | 1 \u003c\u003c idx)))\n\t\t.collect ()\n}\n\nfn get_matches (input: \u0026 Input) -\u003e Vec \u003cu32\u003e {\n\tlet mut matches_temp = vec! [ (0, 0), (1000, 0) ];\n\tfor (idx, field) in input.fields.iter ().enumerate () {\n\t\tlet bit = 1 \u003c\u003c idx;\n\t\tfor (min, max) in [ field.first, field.second ] {\n\t\t\tlet idx = match matches_temp.binary_search_by_key (\u0026 min, |\u0026 (val, _)| val) {\n\t\t\t\tOk (idx) =\u003e { matches_temp [idx].1 |= bit; idx },\n\t\t\t\tErr (idx) =\u003e { matches_temp.insert (idx, (min, matches_temp [idx - 1].1 | bit)); idx },\n\t\t\t};\n\t\t\tlet mut prev = matches_temp [idx].1;\n\t\t\tfor (offset, \u0026 mut (val, ref mut fields)) in \u0026 mut matches_temp [idx .. ].iter_mut ().enumerate () {\n\t\t\t\tlet idx = idx + offset;\n\t\t\t\tif val \u003c= max { * fields |= bit; }\n\t\t\t\tif max \u003c val {\n\t\t\t\t\tif val != max + 1 { matches_temp.insert (idx, (max + 1, prev \u0026 ! bit)); }\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tprev = * fields;\n\t\t\t}\n\t\t}\n\t}\n\tmatches_temp.into_iter ()\n\t\t.tuple_windows ()\n\t\t.flat_map (|((val_0, fld_0), (val_1, _))|\n\t\t\titer::repeat (fld_0).take ((val_1 - val_0).pan_usize ()))\n\t\t.collect ()\n}\n","traces":[{"line":10,"address":[80476,80272],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[80287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[80338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[63792,63821],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":16,"address":[63840,63929,63845],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":21,"address":[80496,81253],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[80519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[80578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[91864],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[80710],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[80803,80768,80883,80965],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[64096,64120],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":33,"address":[64152,64144],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":34,"address":[64256,65120,65088],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":38,"address":[81264],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":39,"address":[81282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[81288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[81383,81538,81414],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[81574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[81719,81684,81825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[81428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[81360],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[81872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[81734,81884,81456],"length":1,"stats":{"Line":4},"fn_name":null},{"line":57,"address":[81648,81976,81550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[81517,81967,81794,81783,81506,81952,81959],"length":1,"stats":{"Line":8},"fn_name":null},{"line":60,"address":[81524,81801,82012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[82599,82032],"length":1,"stats":{"Line":1},"fn_name":"get_field_mappings"},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[82608,83355],"length":1,"stats":{"Line":1},"fn_name":"get_field_idxes"},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[84852,83376],"length":1,"stats":{"Line":2},"fn_name":"get_matches"},{"line":110,"address":[83435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[83604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[83613,84687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[84822,83652,83788],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[65072],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":115,"address":[83937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[83961,84008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[84058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[84227,84208],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[84222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[84230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[84260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[84361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[62149,62501,62058,62562],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":56,"coverable":71},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-16","model.rs"],"content":"use super::*;\n\npub type Val = u16;\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Field \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub first: (Val, Val),\n\tpub second: (Val, Val),\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tField \u003c'inp\u003e { name, first: (first_min, first_max), second: (second_min, second_max) } = [\n\t\t@str name = (|ch| { ch.is_ascii_lowercase () || ch == ' ' }, 1 .. ), \": \",\n\t\tfirst_min, \"-\", first_max, \" or \", second_min, \"-\", second_max,\n\t]\n}\n\nimpl \u003c'inp\u003e Field \u003c'inp\u003e {\n\t#[ must_use ]\n\tpub fn contains (\u0026 self, val: Val) -\u003e bool {\n\t\t(self.first.0 ..= self.first.1).contains (\u0026 val)\n\t\t\t|| (self.second.0 ..= self.second.1).contains (\u0026 val)\n\t}\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Ticket {\n\t\tpub fields: Vec \u003cVal\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tTicket { fields } = [ @delim \",\" fields ]\n}\n","traces":[{"line":14,"address":[90171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[34361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[36004],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-17","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\".#.\",\n\t\"..#\",\n\t\"###\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"112\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"848\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":12,"address":[41860],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[72074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[72412,72242,72133,72095,72308,72185],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[41892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[72474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[72585,72708,72812,72642,72495,72533],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-17","input.rs"],"content":"use super::*;\n\nuse model::Grid;\nuse model::PosXY;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid \u003cPosXY, 2\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub iters_one: u32 = (\"ITERS_ONE=\", 6, 1_u32 .. ),\n\t\tpub iters_two: u32 = (\"ITERS_TWO=\", 6, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":19,"address":[104019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[104023],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-17","lib.rs"],"content":"//! Advent of Code 2020: Day 17: Conway Cubes\n//!\n//! [https://adventofcode.com/2020/day/17](https://adventofcode.com/2020/day/17)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Conway Cubes\";\n\tyear = 2020;\n\tday = 17;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-17","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::GenPos;\nuse model::Grid;\nuse model::PosXYZ;\nuse model::PosXYZW;\nuse model::Tile::{ self, Active, Inactive };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result::\u003cPosXYZ, 3\u003e (input, input.params.iters_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcalc_result::\u003cPosXYZW, 4\u003e (input, input.params.iters_two)\n}\n\nfn calc_result \u003cPos: GenPos \u003cDIMS\u003e, const DIMS: usize\u003e (\n\tinput: \u0026 Input,\n\tnum_iters: u32,\n) -\u003e GenResult \u003cu32\u003e {\n\tlet mut grid = get_grid (input) ?;\n\tlet base_dirs: Vec \u003cPos\u003e = get_base_dirs ();\n\tfor _ in 0 .. num_iters { grid = next_grid (\u0026 grid, \u0026 base_dirs) ?; }\n\tOk (\n\t\tgrid.values ()\n\t\t\t.filter (|\u0026 tile| tile == Tile::Active)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\n#[ inline ]\nfn next_grid \u003cPos: GenPos \u003cDIMS\u003e, const DIMS: usize\u003e (\n\tgrid: \u0026 Grid \u003cPos, DIMS\u003e,\n\tbase_dirs: \u0026 [Pos],\n) -\u003e GenResult \u003cGrid \u003cPos, DIMS\u003e\u003e {\n\tlet grid = grid.resize (\n\t\tgrid.start ().map (|val| val - Coord::ONE).into (),\n\t\tgrid.end ().map (|val| val + Coord::ONE).into ()) ?;\n\tlet grid = \u0026 grid;\n\tlet dirs: Vec \u003cGridOffset \u003cPos, DIMS\u003e\u003e =\n\t\tbase_dirs.iter ()\n\t\t\t.map (|\u0026 pos| grid.offset (pos))\n\t\t\t.try_collect () ?;\n\tOk (grid.map (move |cur| {\n\t\tlet adj_active = dirs.iter ()\n\t\t\t.filter_map (|\u0026 dir| cur.try_add (dir).map (|cur| cur.get (grid)).ok ())\n\t\t\t.fold (0_u32, |sum, tile| sum + u32::from (tile == Tile::Active));\n\t\tlet active = matches! ((cur.get (grid), adj_active), (Active, 2 | 3) | (Inactive, 3));\n\t\tif active { Active } else { Inactive }\n\t}))\n}\n\n#[ inline ]\nfn get_grid \u003cPos: GenPos \u003cDIMS\u003e, const DIMS: usize\u003e (\n\tinput: \u0026 Input,\n) -\u003e GenResult \u003cGrid \u003cPos, DIMS\u003e\u003e {\n\tlet input_size = input.grid.size ();\n\tif 8 \u003c input_size.x || 8 \u003c input_size.y {\n\t\treturn Err (\"Max grid size is 88\".into ());\n\t}\n\tlet input_size_arr: [Coord; 2] = input_size.into ();\n\tlet size = array::from_fn (|idx| if idx \u003c 2 { input_size_arr [idx] } else { 1 }).into ();\n\tlet mut grid = Grid::new_size (size);\n\tfor (pos, tile) in input.grid.iter () {\n\t\tlet pos =\n\t\t\tarray::from_fn (|idx| match idx { 0 =\u003e pos.x, 1 =\u003e pos.y, _ =\u003e Coord::ZERO })\n\t\t\t\t.into ();\n\t\tgrid.set (pos, tile);\n\t}\n\tOk (grid)\n}\n\n#[ inline ]\nfn get_base_dirs \u003cPos: GenPos \u003cDIMS\u003e, const DIMS: usize\u003e () -\u003e Vec \u003cPos\u003e {\n\titer::repeat ([ Coord::NEG_ONE, Coord::ZERO, Coord::ONE ])\n\t\t.take (DIMS)\n\t\t.multi_cartesian_product ()\n\t\t.map (|combo| \u003c[Coord; DIMS]\u003e::try_from (combo).unwrap ().into ())\n\t\t.filter (|\u0026 pos| pos != Pos::ZERO)\n\t\t.collect ()\n}\n","traces":[{"line":13,"address":[72000],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":14,"address":[72004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[72032],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[64183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[135104,134352,135094,135846],"length":1,"stats":{"Line":2},"fn_name":"calc_result\u003caoc_pos::PosXYZ\u003ci8\u003e, 3\u003e"},{"line":25,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[135888,137721,136859,136880],"length":1,"stats":{"Line":2},"fn_name":"next_grid\u003caoc_pos::PosXYZ\u003ci8\u003e, 3\u003e"},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[139216,139193,138336,140087],"length":1,"stats":{"Line":2},"fn_name":"get_grid\u003caoc_pos::PosXYZW\u003ci8\u003e, 4\u003e"},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":23,"coverable":43},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-17","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type PosXY = pos::PosXY \u003cCoord\u003e;\npub type PosXYZ = pos::PosXYZ \u003cCoord\u003e;\npub type PosXYZW = pos::PosXYZW \u003cCoord\u003e;\npub type Grid \u003cPos, const DIMS: usize\u003e = GridBuf \u003cVec \u003cTile\u003e, Pos, DIMS\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tInactive = \".\",\n\t\tActive = \"#\",\n\t}\n}\n\npub trait GenPos \u003cconst DIMS: usize\u003e:\n\tpos::GenPos \u003cDIMS, Val = Coord\u003e +\n\tGridPos \u003cDIMS, Coord = Coord\u003e {\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GenPos \u003cDIMS\u003e for Pos where Pos:\n\tpos::GenPos \u003cDIMS, Val = Coord\u003e +\n\tGridPos \u003cDIMS, Coord = Coord\u003e {\n}\n","traces":[{"line":10,"address":[34199,34416],"length":1,"stats":{"Line":12},"fn_name":"next\u003caoc_2020_day_17::model::Tile\u003e"}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"1 + 2 * 3 + 4 * 5 + 6\",\n\t\"1 + (2 * 3) + (4 * (5 + 6))\",\n\t\"2 * 3 + (4 * 5)\",\n\t\"5 + (8 * 3 + 9 + 3 * 4 * 3)\",\n\t\"5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4))\",\n\t\"((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"26457\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"694173\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":15,"address":[42496,42887],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":16,"address":[42506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[42674,42740,42527,42565,42844,42617],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[42896,43287],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":22,"address":[42906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[43074,43017,43244,42927,42965,43140],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-18","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub exprs: Vec \u003cInputExpr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { exprs, params } = [ params, @lines exprs ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct InputExpr {\n\t\tpub tokens: Vec \u003cInputToken\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tInputExpr { tokens } = [ @collect tokens ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum InputToken {\n\tParenOpen,\n\tParenClose,\n\tNumber (u16),\n\tAdd,\n\tMul,\n}\n\nenum_parser_display! {\n\tInputToken,\n\tParenOpen = [ \"(\" ],\n\tParenClose = [ \")\" ],\n\tNumber (val) = [ val ],\n\tAdd = [ @skip \" \", \"+\", @skip \" \" ],\n\tMul = [ @skip \" \", \"*\", @skip \" \" ],\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[28667,28022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[28483],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-18","lib.rs"],"content":"//! Advent of Code 2020: Day 18: Operation Order\n//!\n//! [https://adventofcode.com/2020/day/18](https://adventofcode.com/2020/day/18)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Operation Order\";\n\tyear = 2020;\n\tday = 18;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-18","logic.rs"],"content":"//! Logic for solving the puzzles\n\n#![ allow (clippy::wildcard_enum_match_arm) ]\n\nuse super::*;\n\nuse input::Input;\nuse input::InputToken::{ self, ParenOpen, ParenClose, Number, Add, Mul };\n\npub type TokensIter \u003c'tok\u003e = Peekable \u003citer::Copied \u003cSliceIter \u003c'tok, InputToken\u003e\u003e\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tinput.exprs.iter ()\n\t\t.map (|expr| eval_one (\u0026 mut expr.iter ().copied ().peekable ()))\n\t\t.try_fold (0_u64, |sum, val| val.and_then (|val| Ok (chk! (sum + val) ?)))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tinput.exprs.iter ()\n\t\t.map (|expr| eval_two (\u0026 mut expr.iter ().copied ().peekable ()))\n\t\t.try_fold (0_u64, |sum, val| {\n\t\t\tlet val = val ?;\n\t\t\tOk::\u003c_, GenError\u003e (chk! (sum + val) ?)\n\t\t})\n}\n\nfn eval_one (iter: \u0026 mut TokensIter) -\u003e GenResult \u003cu64\u003e {\n\n\tfn level_0 (iter: \u0026 mut TokensIter, depth: u32) -\u003e GenResult \u003cu64\u003e {\n\t\tif 1000 \u003c depth { return Err (\"Too much nesting\".into ()) }\n\t\tlet mut val = level_1 (iter, depth + 1) ?;\n\t\tloop {\n\t\t\tif matches! (iter.peek (), None | Some (\u0026 ParenClose)) { return Ok (val) }\n\t\t\tmatch iter.next ().unwrap () {\n\t\t\t\tAdd =\u003e chk! (val += level_1 (iter, depth + 1) ?) ?,\n\t\t\t\tMul =\u003e chk! (val *= level_1 (iter, depth + 1) ?) ?,\n\t\t\t\tother =\u003e return Err (format! (\"Unexpected token: {other:?}\").into ()),\n\t\t\t}\n\t\t}\n\t}\n\n\tfn level_1 (iter: \u0026 mut TokensIter, depth: u32) -\u003e GenResult \u003cu64\u003e {\n\t\tif 1000 \u003c depth { return Err (\"Too much nesting\".into ()) }\n\t\tmatch iter.next ().ok_or (\"Unexpected end of token stream\") ? {\n\t\t\tParenOpen =\u003e {\n\t\t\t\tlet result = level_0 (iter, depth + 1) ?;\n\t\t\t\tlet next = iter.next ().ok_or (\"Unexpected end of token stream\") ?;\n\t\t\t\tif next != ParenClose { return Err (\"Expected closing parenthesis\".into ()) }\n\t\t\t\tOk (result)\n\t\t\t},\n\t\t\tNumber (val) =\u003e Ok (val.pan_u64 ()),\n\t\t\tother =\u003e Err (format! (\"Unexpected token: {other:?}\").into ()),\n\t\t}\n\t}\n\n\tlet val = level_0 (iter, 0) ?;\n\tif let Some (token) = iter.next () {\n\t\treturn Err (format! (\"Unexpected token: {token:?}\").into ());\n\t}\n\tOk (val)\n\n}\n\nfn eval_two (iter: \u0026 mut TokensIter) -\u003e GenResult \u003cu64\u003e {\n\n\tfn level_0 (iter: \u0026 mut TokensIter, depth: u32) -\u003e GenResult \u003cu64\u003e {\n\t\tif 1000 \u003c depth { return Err (\"Too much nesting\".into ()) }\n\t\tlet mut val = level_1 (iter, depth + 1) ?;\n\t\tloop {\n\t\t\tif matches! (iter.peek (), None | Some (\u0026 ParenClose)) { return Ok (val) }\n\t\t\tmatch iter.next ().unwrap () {\n\t\t\t\tInputToken::Mul =\u003e chk! (val *= level_1 (iter, depth + 1) ?) ?,\n\t\t\t\tother =\u003e return Err (format! (\"Unexpected token: {other:?}\").into ()),\n\t\t\t}\n\t\t}\n\t}\n\n\tfn level_1 (iter: \u0026 mut TokensIter, depth: u32) -\u003e GenResult \u003cu64\u003e {\n\t\tif 1000 \u003c depth { return Err (\"Too much nesting\".into ()) }\n\t\tlet mut val = level_2 (iter, depth + 1) ?;\n\t\tloop {\n\t\t\tif matches! (iter.peek (), None | Some (\u0026 ParenClose | \u0026 Mul)) { return Ok (val) }\n\t\t\tmatch iter.next ().unwrap () {\n\t\t\t\tInputToken::Add =\u003e chk! (val += level_2 (iter, depth + 1) ?) ?,\n\t\t\t\tother =\u003e return Err (format! (\"Unexpected token: {other:?}\").into ()),\n\t\t\t}\n\t\t}\n\t}\n\n\tfn level_2 (iter: \u0026 mut TokensIter, depth: u32) -\u003e GenResult \u003cu64\u003e {\n\t\tif 1000 \u003c depth { return Err (\"Too much nesting\".into ()) }\n\t\tmatch iter.next ().ok_or (\"Unexpected end of token stream\") ? {\n\t\t\tParenOpen =\u003e {\n\t\t\t\tlet result = level_0 (iter, depth + 1) ?;\n\t\t\t\tlet next = iter.next ().ok_or (\"Unexpected end of token stream\") ?;\n\t\t\t\tif next != ParenClose { return Err (\"Expected closing parenthesis\".into ()) }\n\t\t\t\tOk (result)\n\t\t\t},\n\t\t\tNumber (val) =\u003e Ok (val.pan_u64 ()),\n\t\t\tother =\u003e Err (format! (\"Unexpected token: {other:?}\").into ()),\n\t\t}\n\t}\n\n\tlet val = level_0 (iter, 0) ?;\n\tif let Some (token) = iter.next () {\n\t\treturn Err (format! (\"Unexpected token: {token:?}\").into ());\n\t}\n\tOk (val)\n\n}\n","traces":[{"line":12,"address":[44432],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":13,"address":[33114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[31620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[32272,32331,32384,31712,31625,31662,32294,32352],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[44512],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":19,"address":[44563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[31795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[31800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[31876,32448,32416,31913],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[44768],"length":1,"stats":{"Line":1},"fn_name":"eval_one"},{"line":29,"address":[45088],"length":1,"stats":{"Line":1},"fn_name":"level_0"},{"line":30,"address":[45105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[45789,45239,45143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[45579,45376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[32480],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[32512],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":37,"address":[45734,45632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[45856],"length":1,"stats":{"Line":1},"fn_name":"level_1"},{"line":43,"address":[45871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[46009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[46479,46118,46328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[46434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[46462,46444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[46446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[46102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[46197,46296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[44792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[44948,44925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[45053,44966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[44931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[46512],"length":1,"stats":{"Line":1},"fn_name":"eval_two"},{"line":66,"address":[46832],"length":1,"stats":{"Line":1},"fn_name":"level_0"},{"line":67,"address":[46849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[46888,47428,46984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[47114,47233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[32544],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":73,"address":[47259,47358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[47488],"length":1,"stats":{"Line":1},"fn_name":"level_1"},{"line":79,"address":[47505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[47546,48085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[47879,47760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[32576],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":85,"address":[47904,48003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[48144],"length":1,"stats":{"Line":1},"fn_name":"level_2"},{"line":91,"address":[48159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[48297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[48616,48767,48406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[48722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[48732,48750],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[48734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[48390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[48584,48485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[46536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[46669,46692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[46710,46797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[46675],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":47,"coverable":56},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\"0: 4 1 5\",\n\t\"1: 2 3 | 3 2\",\n\t\"2: 4 4 | 5 5\",\n\t\"3: 4 5 | 5 4\",\n\t\"4: \\\"a\\\"\",\n\t\"5: \\\"b\\\"\",\n\t\"\",\n\t\"ababbb\",\n\t\"bababa\",\n\t\"abbbab\",\n\t\"aaabbb\",\n\t\"aaaabbb\",\n];\n\nconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\"42: 9 14 | 10 1\",\n\t\"9: 14 27 | 1 26\",\n\t\"10: 23 14 | 28 1\",\n\t\"1: \\\"a\\\"\",\n\t\"11: 42 31\",\n\t\"5: 1 14 | 15 1\",\n\t\"19: 14 1 | 14 14\",\n\t\"12: 24 14 | 19 1\",\n\t\"16: 15 1 | 14 14\",\n\t\"31: 14 17 | 1 13\",\n\t\"6: 14 14 | 1 14\",\n\t\"2: 1 24 | 14 4\",\n\t\"0: 8 11\",\n\t\"13: 14 3 | 1 12\",\n\t\"15: 1 | 14\",\n\t\"17: 14 2 | 1 7\",\n\t\"23: 25 1 | 22 14\",\n\t\"28: 16 1\",\n\t\"4: 1 1\",\n\t\"20: 14 14 | 1 15\",\n\t\"3: 5 14 | 16 1\",\n\t\"27: 1 6 | 14 18\",\n\t\"14: \\\"b\\\"\",\n\t\"21: 14 1 | 1 14\",\n\t\"25: 1 1 | 1 14\",\n\t\"22: 14 14\",\n\t\"8: 42\",\n\t\"26: 14 22 | 1 20\",\n\t\"18: 15 15\",\n\t\"7: 14 5 | 1 21\",\n\t\"24: 14 1\",\n\t\"\",\n\t\"abbbbbabbbaaaababbaabbbbabababbbabbbbbbabaaaa\",\n\t\"bbabbbbaabaabba\",\n\t\"babbbbaabbbbbabbbbbbaabaaabaaa\",\n\t\"aaabbbbbbaaaabaababaabababbabaaabbababababaaa\",\n\t\"bbbbbbbaaaabbbbaaabbabaaa\",\n\t\"bbbababbbbaaaaaaaabbababaaababaabab\",\n\t\"ababaaaaaabaaab\",\n\t\"ababaaaaabbbaba\",\n\t\"baabbaaaabbaaaababbaababb\",\n\t\"abbbbabbbbaaaababbbbbbaaaababb\",\n\t\"aaaaabbaabaaaaababaa\",\n\t\"aaaabbaaaabbaaa\",\n\t\"aaaabbaabbaaaaaaabbbabbbaaabbaabaaa\",\n\t\"babaaabbbaaabaababbaabababaaab\",\n\t\"aabbbbbaabbbaaaaaabbbbbababaaaaabbaaabba\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_ONE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"12\", puzzle.part_two (EXAMPLE_TWO));\n}\n","traces":[{"line":71,"address":[47056,47447],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":72,"address":[47066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[47177,47087,47125,47234,47404,47300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":77,"address":[47456,47847],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":78,"address":[47466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[47577,47487,47804,47700,47525,47634],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","input.rs"],"content":"use super::*;\n\nuse model::Rule;\nuse model::RuleId;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub rules: Vec \u003cInputRule\u003e,\n\tpub messages: Vec \u003cInputMessage \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { rules, messages, params } = [\n\t\tparams,\n\t\t@lines rules, \"\\n\",\n\t\t\"\\n\",\n\t\t@lines messages,\n\t]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputRule  {\n\tpub id: RuleId,\n\tpub rule: Rule,\n}\n\nstruct_parser_display! {\n\tInputRule { id, rule } = [ id, \": \", rule ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct InputMessage \u003c'inp\u003e {\n\t\tmessage: InpStr \u003c'inp\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInputMessage \u003c'inp\u003e { message } = [ @str message = (|ch| { ch.is_ascii_lowercase () }, 1 .. ) ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[85524],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","lib.rs"],"content":"//! Advent of Code 2020: Day 19: Monster Messages\n//!\n//! [https://adventofcode.com/2020/day/19](https://adventofcode.com/2020/day/19)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod matcher;\npub mod model;\n\npuzzle_info! {\n\tname = \"Monster Messages\";\n\tyear = 2020;\n\tday = 19;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[72112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[72592],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse input::InputRule;\nuse matcher::Matcher;\nuse matcher::MatcherBuilder;\nuse model::Rule;\nuse model::RuleId;\nuse model::RuleItem;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet rules = get_rules (input) ?;\n\tlet mut builder = Builder::new (\u0026 rules);\n\tlet matcher = builder.matcher (0) ?;\n\tOk (\n\t\tinput.messages.iter ()\n\t\t\t.filter (|\u0026 msg| matcher.matches (msg))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet rules = get_rules (input) ?;\n\tlet mut builder = Builder::new (\u0026 rules);\n\tlet prefixes = builder.matcher (42) ?;\n\tlet suffixes = builder.matcher (31) ?;\n\tinput.messages.iter ()\n\t\t.map (|msg| match_message (\u0026 prefixes, \u0026 suffixes, msg))\n\t\t.try_fold (0, |sum, item| item.map (|val| sum + u32::from (val)))\n}\n\npub fn match_message (prefixes: \u0026 Matcher, suffixes: \u0026 Matcher, msg: \u0026 str) -\u003e GenResult \u003cbool\u003e {\n\tlet mut todo = Vec::new ();\n\ttodo.push ((msg, 0_u32, 0_u32));\n\tlet mut num_iters = 0_u32;\n\twhile let Some ((msg, num_prefix, num_suffix)) = todo.pop () {\n\t\tif num_iters == 100 { return Err (\"Giving up after max iters\".into ()) }\n\t\tnum_iters += 1;\n\t\tif num_suffix == 0 {\n\t\t\tfor (_, msg) in prefixes.match_prefix (msg) {\n\t\t\t\ttodo.push ((msg, num_prefix + 1, num_suffix));\n\t\t\t}\n\t\t}\n\t\tif 2 \u003c= num_prefix \u0026\u0026 num_suffix \u003c num_prefix - 1 {\n\t\t\tfor (_, msg) in suffixes.match_prefix (msg) {\n\t\t\t\tif msg.is_empty () { return Ok (true) }\n\t\t\t\ttodo.push ((msg, num_prefix, num_suffix + 1));\n\t\t\t}\n\t\t}\n\t}\n\tOk (false)\n}\n\nfn get_rules (input: \u0026 Input) -\u003e GenResult \u003cHashMap \u003cRuleId, Rule\u003e\u003e {\n\tlet mut rules: HashMap \u003cRuleId, Rule\u003e = HashMap::new ();\n\tfor \u0026 InputRule { id: rule_id, ref rule } in \u0026 input.rules {\n\t\tif rules.contains_key (\u0026 rule_id) {\n\t\t\treturn Err (format! (\"Duplicated rule id: {rule_id}\").into ());\n\t\t}\n\t\trules.insert (rule_id, rule.clone ());\n\t}\n\tfor (\u0026 rule_id, rule) in \u0026 rules {\n\t\tif let Some (dep) = rule.deps ().find (|dep| ! rules.contains_key (dep)) {\n\t\t\treturn Err (format! (\"Rule {rule_id} references rule {dep} which doesn't exist\")\n\t\t\t\t.into ());\n\t\t}\n\t}\n\tOk (rules)\n}\n\nstruct Builder \u003c'rul\u003e {\n\tcache: HashMap \u003cRuleId, Matcher\u003e,\n\trules: \u0026 'rul HashMap \u003cRuleId, Rule\u003e,\n\tbuilder: MatcherBuilder,\n}\n\nimpl \u003c'rul\u003e Builder \u003c'rul\u003e {\n\tfn new (rules: \u0026 'rul HashMap \u003cRuleId, Rule\u003e) -\u003e Self {\n\t\tBuilder {\n\t\t\tcache: HashMap::new (),\n\t\t\trules,\n\t\t\tbuilder: MatcherBuilder::new (),\n\t\t}\n\t}\n\tfn matcher (\u0026 mut self, rule_id: RuleId) -\u003e GenResult \u003cMatcher\u003e {\n\t\tif ! self.rules.contains_key (\u0026 rule_id) {\n\t\t\treturn Err (format! (\"No such rule: {rule_id}\").into ());\n\t\t}\n\t\tlet mut todo = Vec::new ();\n\t\ttodo.push (rule_id);\n\t\t'OUTER: while let Some (rule_id) = todo.pop () {\n\t\t\tfor dep_rule_id in self.rules [\u0026 rule_id].deps () {\n\t\t\t\tif self.cache.contains_key (\u0026 dep_rule_id) { continue }\n\t\t\t\tif dep_rule_id == rule_id {\n\t\t\t\t\treturn Err (format! (\"Rule {rule_id} directly references itself\").into ());\n\t\t\t\t}\n\t\t\t\tif todo.contains (\u0026 dep_rule_id) {\n\t\t\t\t\treturn Err (format! (\"Rule {rule_id} indirectly references itself\").into ());\n\t\t\t\t}\n\t\t\t\ttodo.push (rule_id);\n\t\t\t\ttodo.push (dep_rule_id);\n\t\t\t\tcontinue 'OUTER;\n\t\t\t}\n\t\t\tlet matcher =\n\t\t\t\tself.rules [\u0026 rule_id].options.iter ()\n\t\t\t\t\t.map (|option| option.items.iter ()\n\t\t\t\t\t\t.map (|\u0026 item| match item {\n\t\t\t\t\t\t\tRuleItem::Rule (rule_id) =\u003e Ok (self.cache [\u0026 rule_id].clone ()),\n\t\t\t\t\t\t\tRuleItem::Char (ch) =\u003e self.builder.char (ch),\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.try_fold (self.builder.empty () ?, |matcher, item| matcher.concat (item ?)))\n\t\t\t\t\t.try_fold (self.builder.none (), |matcher, option| matcher.union (option ?)) ?;\n\t\t\tself.cache.insert (rule_id, matcher);\n\t\t}\n\t\tif 5000 \u003c self.builder.len () { return Err (\"Giving up due to complexity\".into ()) }\n\t\tOk (self.cache.remove (\u0026 rule_id).unwrap ())\n\t}\n}\n","traces":[{"line":13,"address":[59726,58848],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":14,"address":[59304,58876,58958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[59271,59325,59251],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[103252,103808,103834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[59744,60524],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":26,"address":[59771,60180,59844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[60198,60137,60160],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[60236,60307,60213],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[103844,103840,103871],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":32,"address":[70218,70237],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[62758,60544],"length":1,"stats":{"Line":1},"fn_name":"match_message"},{"line":39,"address":[60842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[60851,62444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[60861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[60952,61414,62733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[61423,62555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[61607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[62235,61721,62718,62167],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[62253,62516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[62259,62582],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[62431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[62768,63982],"length":1,"stats":{"Line":2},"fn_name":"get_rules"},{"line":59,"address":[62995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[63155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[63805,63719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[63172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[63446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[63549,57841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[63566,63676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[63877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":48,"coverable":59},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","matcher.rs"],"content":"use super::*;\n\nconst MAX_BUILDER_DEPTH: u32 = 100;\n\n#[ derive (Clone) ]\npub struct Matcher {\n\tinner: Rc \u003cMatcherInner\u003e,\n}\n\nimpl Debug for Matcher {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.debug_struct (\"Matcher\")\n\t\t\t.field (\"id\", \u0026 self.inner.id)\n\t\t\t.field (\"matches\", \u0026 self.inner.matches)\n\t\t\t.field (\"next\", \u0026 self.inner.next)\n\t\t\t.finish ()\n\t}\n}\n\n#[ derive (Clone) ]\npub struct MatcherInner {\n\tid: u32,\n\tmatches: bool,\n\tnext: Vec \u003c(char, Matcher)\u003e,\n\tbuilder: RcWeak \u003cRefCell \u003cMatcherBuilderInner\u003e\u003e,\n}\n\nimpl Matcher {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.inner.next.is_empty () \u0026\u0026 ! self.inner.matches\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn matches (\u0026 self, msg: \u0026 str) -\u003e bool {\n\t\tself.match_prefix (msg).any (|(_, suffix)| suffix.is_empty ())\n\t}\n\n\t#[ allow (clippy::string_slice) ]\n\t#[ inline ]\n\tpub fn match_prefix \u003c'msg: 'iter, 'iter\u003e (\n\t\t\u0026 self,\n\t\tmsg: \u0026 'msg str,\n\t) -\u003e impl Iterator \u003cItem = (\u0026 'iter str, \u0026 'iter str)\u003e + 'msg {\n\t\tlet mut matcher = Some (self.clone ());\n\t\tlet mut msg_chars = msg.chars ();\n\t\tlet mut match_len = 0;\n\t\titer::from_fn (move || {\n\t\t\tlet matcher_val = some_or! (matcher.as_ref (), return None);\n\t\t\tlet result = matcher_val.inner.matches.then (||\n\t\t\t\t(\u0026 msg [ .. match_len], \u0026 msg [match_len .. ]));\n\t\t\tlet msg_ch = some_or! (msg_chars.next (), {\n\t\t\t\tmatcher = None;\n\t\t\t\treturn Some (result);\n\t\t\t});\n\t\t\tlet next_matcher = matcher_val.inner.next.iter ().find (|\u0026\u0026 (ch, _)| ch == msg_ch);\n\t\t\tlet \u0026 (_, ref next_matcher) = some_or! (next_matcher, {\n\t\t\t\tmatcher = None;\n\t\t\t\treturn Some (result);\n\t\t\t});\n\t\t\tmatcher = Some (next_matcher.clone ());\n\t\t\tmatch_len += msg_ch.len_utf8 ();\n\t\t\tSome (result)\n\t\t}).flatten ()\n\t}\n\n\t#[ inline ]\n\tpub fn push_empty (self) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet builder = self.inner.builder.upgrade ().unwrap ();\n\t\tlet mut builder = builder.deref ().borrow_mut ();\n\t\tbuilder.push_empty (self, 0)\n\t}\n\n\t#[ inline ]\n\tpub fn push_char (self, new_ch: char) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet builder = self.inner.builder.upgrade ().unwrap ();\n\t\tlet mut builder = builder.deref ().borrow_mut ();\n\t\tbuilder.push_char (self, new_ch, 0)\n\t}\n\n\t#[ inline ]\n\tpub fn concat (self, other: Self) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet builder = self.inner.builder.upgrade ().unwrap ();\n\t\tlet mut builder = builder.deref ().borrow_mut ();\n\t\tbuilder.concat (self, other, 0)\n\t}\n\n\t#[ inline ]\n\tpub fn union (self, other: Self) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet builder = self.inner.builder.upgrade ().unwrap ();\n\t\tlet mut builder = builder.deref ().borrow_mut ();\n\t\tbuilder.union (self, other, 0)\n\t}\n\n}\n\npub struct MatcherBuilder {\n\tinner: Rc \u003cRefCell \u003cMatcherBuilderInner\u003e\u003e,\n}\n\n#[ derive (Debug) ]\nstruct MatcherBuilderInner {\n\tnext_id: u32,\n\tnone: Matcher,\n\tpush_empty: HashMap \u003cu32, Matcher\u003e,\n\tpush_char: HashMap \u003c(u32, char), Matcher\u003e,\n\tunion: HashMap \u003c(u32, u32), Matcher\u003e,\n\tconcat: HashMap \u003c(u32, u32), Matcher\u003e,\n}\n\nimpl MatcherBuilder {\n\n\t#[ must_use ]\n\tpub fn new () -\u003e Self {\n\t\tSelf {\n\t\t\tinner: Rc::new_cyclic (|builder| RefCell::new (\n\t\t\t\tMatcherBuilderInner {\n\t\t\t\t\tnext_id: 1_u32,\n\t\t\t\t\tnone: Matcher {\n\t\t\t\t\t\tinner: Rc::new (MatcherInner {\n\t\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\t\tmatches: false,\n\t\t\t\t\t\t\tnext: Vec::new (),\n\t\t\t\t\t\t\tbuilder: RcWeak::clone (builder),\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t\tpush_empty: HashMap::new (),\n\t\t\t\t\tpush_char: HashMap::new (),\n\t\t\t\t\tunion: HashMap::new (),\n\t\t\t\t\tconcat: HashMap::new (),\n\t\t\t\t}\n\t\t\t)),\n\t\t}\n\t}\n\n\tpub fn char (\u0026 self, ch: char) -\u003e GenResult \u003cMatcher\u003e {\n\t\tself.none ().push_char (ch)\n\t}\n\n\tpub fn empty (\u0026 self) -\u003e GenResult \u003cMatcher\u003e {\n\t\tself.none ().push_empty ()\n\t}\n\n\t#[ must_use ]\n\tpub fn none (\u0026 self) -\u003e Matcher {\n\t\tself.inner.deref ().borrow ().none.clone ()\n\t}\n\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.deref ().borrow ();\n\t\t[\n\t\t\tinner.push_empty.len (),\n\t\t\tinner.push_char.len (),\n\t\t\tinner.concat.len (),\n\t\t\tinner.union.len (),\n\t\t].into_iter ().sum ()\n\t}\n\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.len () == 0\n\t}\n\n}\n\nimpl Default for MatcherBuilder {\n\tfn default () -\u003e Self { Self::new () }\n}\n\nimpl MatcherBuilderInner {\n\n\tfn push_char (\n\t\t\u0026 mut self,\n\t\tmut matcher: Matcher,\n\t\tnew_ch: char,\n\t\tdepth: u32,\n\t) -\u003e GenResult \u003cMatcher\u003e {\n\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\n\t\tlet cache_key = (matcher.inner.id, new_ch);\n\t\tif let Some (matcher) = self.push_char.get (\u0026 cache_key) {\n\t\t\treturn Ok (matcher.clone ());\n\t\t}\n\n\t\tlet inner = Rc::make_mut (\u0026 mut matcher.inner);\n\t\tinner.id = self.next_id;\n\t\tself.next_id += 1;\n\n\t\tif let Some (idx) = inner.next.iter ().position (|\u0026 (ch, _)| ch == new_ch) {\n\t\t\tinner.next [idx].1 =\n\t\t\t\tself.push_empty (\n\t\t\t\t\tinner.next [idx].1.clone (),\n\t\t\t\t\tdepth + 1) ?;\n\t\t} else {\n\t\t\tinner.next.push ((\n\t\t\t\tnew_ch,\n\t\t\t\tself.push_empty (\n\t\t\t\t\tself.none.clone (),\n\t\t\t\t\tdepth + 1) ?,\n\t\t\t));\n\t\t\tinner.next.sort_by_key (|\u0026 (ch, _)| ch);\n\t\t}\n\t\tself.push_char.insert (cache_key, matcher.clone ());\n\n\t\tOk (matcher)\n\n\t}\n\n\tfn push_empty (\n\t\t\u0026 mut self,\n\t\tmut matcher: Matcher,\n\t\tdepth: u32,\n\t) -\u003e GenResult \u003cMatcher\u003e {\n\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\t\tif matcher.inner.matches { return Ok (matcher) }\n\n\t\tlet cache_key = matcher.inner.id;\n\t\tif let Some (matcher) = self.push_empty.get (\u0026 cache_key) {\n\t\t\treturn Ok (matcher.clone ());\n\t\t}\n\n\t\tlet inner = Rc::make_mut (\u0026 mut matcher.inner);\n\t\tinner.id = self.next_id;\n\t\tself.next_id += 1;\n\n\t\tinner.matches = true;\n\n\t\tself.push_empty.insert (cache_key, matcher.clone ());\n\t\tOk (matcher)\n\n\t}\n\n\tfn concat (\n\t\t\u0026 mut self,\n\t\tmut matcher: Matcher,\n\t\tother: Matcher,\n\t\tdepth: u32,\n\t) -\u003e GenResult \u003cMatcher\u003e {\n\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\n\t\tlet cache_key = (matcher.inner.id, other.inner.id);\n\t\tif let Some (matcher) = self.concat.get (\u0026 cache_key) {\n\t\t\treturn Ok (matcher.clone ());\n\t\t}\n\n\t\tlet inner = Rc::make_mut (\u0026 mut matcher.inner);\n\t\tinner.id = self.next_id;\n\t\tself.next_id += 1;\n\n\t\tself.concat_real (inner, \u0026 other, depth) ?;\n\n\t\tself.concat.insert (cache_key, matcher.clone ());\n\t\tOk (matcher)\n\n\t}\n\n\tfn union (\n\t\t\u0026 mut self,\n\t\tmut matcher: Matcher,\n\t\tother: Matcher,\n\t\tdepth: u32\n\t) -\u003e GenResult \u003cMatcher\u003e {\n\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\n\t\tlet cache_key = (matcher.inner.id, other.inner.id);\n\t\tif let Some (matcher) = self.union.get (\u0026 cache_key) {\n\t\t\treturn Ok (matcher.clone ());\n\t\t}\n\n\t\tlet inner = Rc::make_mut (\u0026 mut matcher.inner);\n\t\tinner.id = self.next_id;\n\t\tself.next_id += 1;\n\n\t\tself.union_real (inner, \u0026 other, depth + 1) ?;\n\n\t\tself.union.insert (cache_key, matcher.clone ());\n\t\tOk (matcher)\n\n\t}\n\n\tfn concat_real (\n\t\t\u0026 mut self,\n\t\tinner: \u0026 mut MatcherInner,\n\t\tother: \u0026 Matcher,\n\t\tdepth: u32,\n\t) -\u003e GenResult \u003c()\u003e {\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\t\tfor \u0026 mut (_, ref mut next_matcher) in inner.next.iter_mut () {\n\t\t\t* next_matcher =\n\t\t\t\tself.concat (\n\t\t\t\t\tnext_matcher.clone (),\n\t\t\t\t\tother.clone (),\n\t\t\t\t\tdepth + 1) ?;\n\t\t}\n\t\tif inner.matches {\n\t\t\tinner.matches = false;\n\t\t\tself.union_real (inner, other, depth + 1) ?;\n\t\t}\n\t\tOk (())\n\t}\n\n\tfn union_real (\n\t\t\u0026 mut self,\n\t\tinner: \u0026 mut MatcherInner,\n\t\tother: \u0026 Matcher,\n\t\tdepth: u32,\n\t) -\u003e GenResult \u003c()\u003e {\n\t\tif MAX_BUILDER_DEPTH \u003c depth { return Err (\"Too much recursion\".into ()) }\n\t\tif other.inner.matches { inner.matches = true; }\n\t\tfor \u0026 (other_ch, ref other_matcher) in \u0026 other.inner.next {\n\t\t\tif let Some (idx) = inner.next.iter ().position (|\u0026 (ch, _)| ch == other_ch) {\n\t\t\t\tinner.next [idx].1 =\n\t\t\t\t\tself.union (\n\t\t\t\t\t\tinner.next [idx].1.clone (),\n\t\t\t\t\t\tother_matcher.clone (),\n\t\t\t\t\t\tdepth + 1) ?;\n\t\t\t} else {\n\t\t\t\tinner.next.push ((other_ch, other_matcher.clone ()));\n\t\t\t\tinner.next.sort_by_key (|\u0026 (ch, _)| ch);\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[40015,39776],"length":1,"stats":{"Line":1},"fn_name":"matches"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[40183,39984,40032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[60914,61680],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[51440],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":52,"address":[51467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[51475,52016,51481],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[41872],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":119,"address":[41872],"length":1,"stats":{"Line":4},"fn_name":"new"},{"line":139,"address":[41888],"length":1,"stats":{"Line":2},"fn_name":"char"},{"line":140,"address":[41896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[41936],"length":1,"stats":{"Line":0},"fn_name":"empty"},{"line":144,"address":[41940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[42137,41968],"length":1,"stats":{"Line":2},"fn_name":"none"},{"line":149,"address":[42023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[42160,42361],"length":1,"stats":{"Line":2},"fn_name":"len"},{"line":154,"address":[42210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[42384,43634],"length":1,"stats":{"Line":2},"fn_name":"push_char"},{"line":183,"address":[42406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[42450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[42609,42665],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[42642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[42672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[42680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[42689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[42817,42847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[43277,43521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[43228,43189,43166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[43141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[43146,43469,43556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[42924,42949],"length":1,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[42899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[42904,43424,43594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[53232],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":208,"address":[43341,43280],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[43358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[44124,43648],"length":1,"stats":{"Line":2},"fn_name":"push_empty"},{"line":220,"address":[43668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[43710],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[43746],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[43886,43940],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[43919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[43947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[43952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[44070,43962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[43980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[43984,44036],"length":1,"stats":{"Line":4},"fn_name":null},{"line":235,"address":[44056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[44144,44747],"length":1,"stats":{"Line":2},"fn_name":"concat"},{"line":246,"address":[44171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[44213],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[44384,44474],"length":1,"stats":{"Line":4},"fn_name":null},{"line":250,"address":[44417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[44481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[44486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[44670,44495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[44520],"length":1,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[44554,44617],"length":1,"stats":{"Line":4},"fn_name":null},{"line":260,"address":[44637],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[44768,45388],"length":1,"stats":{"Line":2},"fn_name":"union"},{"line":271,"address":[44795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[44837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[45008,45098],"length":1,"stats":{"Line":4},"fn_name":null},{"line":275,"address":[45041],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[45105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[45110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[45119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":282,"address":[45139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[45249,45186],"length":1,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[45269],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[46023,45408],"length":1,"stats":{"Line":2},"fn_name":"concat_real"},{"line":295,"address":[45427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[45763,45543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[45718,45957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[45865,45700,45666],"length":1,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[45614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[45650],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[45655,45896,45982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[45791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[45797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[45923,45801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[46032,47048],"length":1,"stats":{"Line":2},"fn_name":"union_real"},{"line":316,"address":[46055],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[46092],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[46164,46202,46774],"length":1,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[46238,46339,46348],"length":1,"stats":{"Line":5},"fn_name":null},{"line":320,"address":[46935,46723,46738],"length":1,"stats":{"Line":4},"fn_name":null},{"line":321,"address":[46817,46688,46647],"length":1,"stats":{"Line":4},"fn_name":null},{"line":322,"address":[46592,46545],"length":1,"stats":{"Line":4},"fn_name":null},{"line":323,"address":[46631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[46883,46986,46636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[53264],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"}],"covered":104,"coverable":124},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-19","model.rs"],"content":"use super::*;\n\npub type RuleId = u8;\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Rule {\n\tpub options: Vec \u003cRuleOption\u003e,\n}\n\nstruct_parser_display! {\n\tRule { options } = [ @delim \" | \" options ]\n}\n\n#[ derive (Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct RuleOption {\n\tpub items: Vec \u003cRuleItem\u003e,\n}\n\nstruct_parser_display! {\n\tRuleOption { items } = [ @delim \" \" items ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub enum RuleItem {\n\tRule (RuleId),\n\tChar (char),\n}\n\nenum_parser_display! {\n\tRuleItem,\n\tRule (rule_id) = [ rule_id ],\n\tChar (ch) = [ \"\\\"\", @char ch = |ch| { ch.is_ascii_lowercase () }, \"\\\"\" ],\n}\n\nimpl Rule {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn two (rule_id_0: RuleId, rule_id_1: RuleId) -\u003e Self {\n\t\tSelf { options: vec! [\n\t\t\tRuleOption { items: vec! [\n\t\t\t\tRuleItem::Rule (rule_id_0),\n\t\t\t\tRuleItem::Rule (rule_id_1),\n\t\t\t] },\n\t\t] }\n\t}\n\n\t#[ inline ]\n\tpub fn deps (\u0026 self) -\u003e impl Iterator \u003cItem = RuleId\u003e + '_ {\n\t\tself.options.iter ()\n\t\t\t.flat_map (|option| option.items.iter ()\n\t\t\t\t.filter_map (|\u0026 item| match item {\n\t\t\t\t\tRuleItem::Rule (rule_id) =\u003e Some (rule_id),\n\t\t\t\t\tRuleItem::Char (_) =\u003e None,\n\t\t\t\t}))\n\t}\n\n}\n","traces":[{"line":11,"address":[86214,85871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[70843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Tile 2311:\",\n\t\"..##.#..#.\",\n\t\"##..#.....\",\n\t\"#...##..#.\",\n\t\"####.#...#\",\n\t\"##.##.###.\",\n\t\"##...#.###\",\n\t\".#.#.#..##\",\n\t\"..#....#..\",\n\t\"###...#.#.\",\n\t\"..###..###\",\n\t\"\",\n\t\"Tile 1951:\",\n\t\"#.##...##.\",\n\t\"#.####...#\",\n\t\".....#..##\",\n\t\"#...######\",\n\t\".##.#....#\",\n\t\".###.#####\",\n\t\"###.##.##.\",\n\t\".###....#.\",\n\t\"..#.#..#.#\",\n\t\"#...##.#..\",\n\t\"\",\n\t\"Tile 1171:\",\n\t\"####...##.\",\n\t\"#..##.#..#\",\n\t\"##.#..#.#.\",\n\t\".###.####.\",\n\t\"..###.####\",\n\t\".##....##.\",\n\t\".#...####.\",\n\t\"#.##.####.\",\n\t\"####..#...\",\n\t\".....##...\",\n\t\"\",\n\t\"Tile 1427:\",\n\t\"###.##.#..\",\n\t\".#..#.##..\",\n\t\".#.##.#..#\",\n\t\"#.#.#.##.#\",\n\t\"....#...##\",\n\t\"...##..##.\",\n\t\"...#.#####\",\n\t\".#.####.#.\",\n\t\"..#..###.#\",\n\t\"..##.#..#.\",\n\t\"\",\n\t\"Tile 1489:\",\n\t\"##.#.#....\",\n\t\"..##...#..\",\n\t\".##..##...\",\n\t\"..#...#...\",\n\t\"#####...#.\",\n\t\"#..#.#.#.#\",\n\t\"...#.#.#..\",\n\t\"##.#...##.\",\n\t\"..##.##.##\",\n\t\"###.##.#..\",\n\t\"\",\n\t\"Tile 2473:\",\n\t\"#....####.\",\n\t\"#..#.##...\",\n\t\"#.##..#...\",\n\t\"######.#.#\",\n\t\".#...#.#.#\",\n\t\".#########\",\n\t\".###.#..#.\",\n\t\"########.#\",\n\t\"##...##.#.\",\n\t\"..###.#.#.\",\n\t\"\",\n\t\"Tile 2971:\",\n\t\"..#.#....#\",\n\t\"#...###...\",\n\t\"#.#.###...\",\n\t\"##.##..#..\",\n\t\".#####..##\",\n\t\".#..####.#\",\n\t\"#..#.#..#.\",\n\t\"..####.###\",\n\t\"..#.#.###.\",\n\t\"...#.#.#.#\",\n\t\"\",\n\t\"Tile 2729:\",\n\t\"...#.#.#.#\",\n\t\"####.#....\",\n\t\"..#.#.....\",\n\t\"....#..#.#\",\n\t\".##..##.#.\",\n\t\".#.####...\",\n\t\"####.#.#..\",\n\t\"##.####...\",\n\t\"##..#.##..\",\n\t\"#.##...##.\",\n\t\"\",\n\t\"Tile 3079:\",\n\t\"#.#.#####.\",\n\t\".#..######\",\n\t\"..#.......\",\n\t\"######....\",\n\t\"####.#..#.\",\n\t\".#...#.##.\",\n\t\"#.#####.##\",\n\t\"..#.###...\",\n\t\"..#.......\",\n\t\"..#.###...\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"20899048083289\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"273\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":116,"address":[62260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[79850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[79909,80018,79871,80188,79961,80084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[62292],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[80250],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[80484,80361,80309,80418,80271,80588],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-20","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub tiles: Vec \u003cInputTile\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { tiles, params } = [ params, @delim \"\\n\\n\" tiles ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputTile  {\n\tpub id: u16,\n\tpub grid: Grid,\n}\n\nstruct_parser_display! {\n\tInputTile { id, grid } = [ \"Tile \", id, \":\\n\", grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[52870,53595,57860],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-20","lib.rs"],"content":"//! Advent of Code 2020: Day 20: Jurassic Jigsaw\n//!\n//! [https://adventofcode.com/2020/day/20](https://adventofcode.com/2020/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Jurassic Jigsaw\";\n\tyear = 2020;\n\tday = 20;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[107000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[107320],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-20","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Dir;\nuse model::Grid;\nuse model::Pixel;\nuse model::Pos;\nuse model::Tag;\nuse model::Tile;\nuse model::Tiles;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcheck_input (input) ?;\n\tlet tiles: Tiles =\n\t\tinput.tiles.iter ()\n\t\t\t.map (|tile| (tile.id, Tile::new (tile.id, tile.grid.clone ())))\n\t\t\t.collect ();\n\tOk (\n\t\ttiles.values ()\n\t\t\t.filter (|tile| get_shared_sides (\u0026 tiles, tile).count_ones () == 2)\n\t\t\t.map (|tile| tile.id.pan_u64 ())\n\t\t\t.try_fold (1, |prod, val| chk! (prod * val)) ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\n\tcheck_input (input) ?;\n\n\tlet grid = assemble_image (input) ?;\n\n\tlet (row_dir, col_dir, posns) =\n\t\tfind_monsters (\u0026 grid).ok_or (\"No monsters found\") ?;\n\n\tlet mut grid = grid.transform (Pos::ZERO, [ row_dir, col_dir ]) ?;\n\tremove_monsters (\u0026 mut grid, \u0026 posns);\n\n\tOk (\n\t\tgrid.values ()\n\t\t\t.filter (|\u0026 pixel| pixel == Pixel::White)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n\n}\n\nconst MONSTER: [u128; 3] = [\n\t0b_0000_0000_0000_0000_0010,\n\t0b_1000_0110_0001_1000_0111,\n\t0b_0100_1001_0010_0100_1000,\n];\n\nfn find_monsters (grid: \u0026 Grid) -\u003e Option \u003c(Dir, Dir, Vec \u003cPos\u003e)\u003e {\n\tlet Pos { y: height, x: width } = grid.size ();\n\t[\n\t\t(Pos::ZERO, Dir::Down, Dir::Right, width),\n\t\t(Pos::ZERO, Dir::Right, Dir::Down, height),\n\t\t(Pos::new (0, grid.last_key ().x), Dir::Down, Dir::Left, width),\n\t\t(Pos::new (0, grid.last_key ().x), Dir::Left, Dir::Down, height),\n\t\t(Pos::new (grid.last_key ().y, 0), Dir::Up, Dir::Right, width),\n\t\t(Pos::new (grid.last_key ().y, 0), Dir::Right, Dir::Up, height),\n\t\t(grid.last_key (), Dir::Up, Dir::Left, width),\n\t\t(grid.last_key (), Dir::Left, Dir::Up, height),\n\t].into_iter ()\n\t\t.map (|(start, row_dir, col_dir, size)|\n\t\t\t(row_dir, col_dir, find_monsters_transform (grid, start, row_dir, col_dir, size)))\n\t\t.find (|\u0026 (_, _, ref posns)| ! posns.is_empty ())\n}\n\nfn find_monsters_transform (\n\tgrid: \u0026 Grid,\n\tstart: Pos,\n\trow_dir: Dir,\n\tcol_dir: Dir,\n\tsize: i8,\n) -\u003e Vec \u003cPos\u003e {\n\tlet row_off = grid.offset (row_dir.into ()).unwrap ();\n\tlet col_off = grid.offset (col_dir.into ()).unwrap ();\n\tgrid.cursor (start).unwrap ().walk (row_off)\n\t\t.map (|cur| cur.walk (col_off)\n\t\t\t.fold (0_u128, |sum, cur|\n\t\t\t\tsum \u003c\u003c 1_u32 | u128::from (cur.get (grid) == Pixel::White)))\n\t\t.tuple_windows ()\n\t\t.enumerate ()\n\t\t.flat_map (|(y, (mut a, mut b, mut c))| {\n\t\t\tlet y = y.pan_i8 ();\n\t\t\tlet mut results = Vec::new ();\n\t\t\tfor x in (0 .. size - 19).rev () {\n\t\t\t\tif detect_monster ([a, b, c]) {\n\t\t\t\t\tresults.push (Pos::new (y, x));\n\t\t\t\t}\n\t\t\t\ta \u003e\u003e= 1_u32;\n\t\t\t\tb \u003e\u003e= 1_u32;\n\t\t\t\tc \u003e\u003e= 1_u32;\n\t\t\t}\n\t\t\tresults\n\t\t})\n\t\t.collect ()\n}\n\nconst fn detect_monster (rows: [u128; 3]) -\u003e bool {\n\tif rows [0] \u0026 MONSTER [0] != MONSTER [0] { return false }\n\tif rows [1] \u0026 MONSTER [1] != MONSTER [1] { return false }\n\tif rows [2] \u0026 MONSTER [2] != MONSTER [2] { return false }\n\ttrue\n}\n\nfn remove_monsters (grid: \u0026 mut Grid, posns: \u0026 [Pos]) {\n\tfor \u0026 pos in posns {\n\t\tlet mut bit = 1 \u003c\u003c 19_u32;\n\t\tfor x in 0 .. 20 {\n\t\t\tfor y in 0 .. 3 {\n\t\t\t\tif MONSTER [y.pan_usize ()] \u0026 bit != 0 {\n\t\t\t\t\tgrid.set (pos + Pos::new (y, x), Pixel::Black);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbit \u003e\u003e= 1_u32;\n\t\t}\n\t}\n}\n\nfn assemble_image (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tlet mut tiles: Tiles =\n\t\tinput.tiles.iter ()\n\t\t\t.map (|tile| (tile.id, Tile::new (tile.id, tile.grid.clone ())))\n\t\t\t.collect ();\n\tlet first = pick_first (\u0026 mut tiles) ?;\n\tlet mut translate = Pos::ZERO;\n\tlet mut result = first.grid.clone ();\n\tlet mut prev_row = first.tags [2];\n\tlet mut prev_col = first.tags [1];\n\tloop {\n\t\tloop {\n\t\t\ttranslate.x += first.grid.size ().x;\n\t\t\tlet mut next = some_or! (pick_next (\u0026 mut tiles, 4, prev_col) ?, break);\n\t\t\tpaint_next (\u0026 mut result, \u0026 mut next, translate) ?;\n\t\t\tprev_col = next.tags [1];\n\t\t}\n\t\ttranslate.y += first.grid.size ().y;\n\t\ttranslate.x = 0;\n\t\tlet mut next = some_or! (pick_next (\u0026 mut tiles, 7, prev_row) ?, break);\n\t\tpaint_next (\u0026 mut result, \u0026 mut next, translate) ?;\n\t\tprev_row = next.tags [2];\n\t\tprev_col = next.tags [1];\n\t}\n\tif ! tiles.is_empty () { return Err (\"Failed to assemble all tiles\".into ()) }\n\tOk (result)\n}\n\nfn pick_next (tiles: \u0026 mut Tiles, tag_idx: u8, tag: Tag) -\u003e GenResult \u003cOption \u003cTile\u003e\u003e {\n\tlet tile_id = some_or! (\n\t\ttiles.values ().find (|tile| tile.tags.contains (\u0026 tag)),\n\t\treturn Ok (None)\n\t).id;\n\tlet mut tile = tiles.remove (\u0026 tile_id).unwrap ();\n\tmatch (tag_idx, tile.tags.into_iter ().position (|other_tag| other_tag == tag).unwrap ()) {\n\t\t(4, 0) | (7, 3) =\u003e { tile.flip () ?; },\n\t\t(4, 1) | (7, 0) =\u003e { tile.flip () ?; tile.rotate_right () ?; },\n\t\t(4, 2) | (7, 1) =\u003e { tile.flip () ?; tile.rotate_around () ?; },\n\t\t(4, 3) | (7, 2) =\u003e { tile.flip () ?; tile.rotate_left () ?; },\n\t\t(4, 4) | (7, 7) =\u003e { },\n\t\t(4, 5) | (7, 4) =\u003e { tile.rotate_right () ?; },\n\t\t(4, 6) | (7, 5) =\u003e { tile.rotate_around () ?; },\n\t\t(4, 7) | (7, 6) =\u003e { tile.rotate_left () ?; },\n\t\t_ =\u003e unreachable! (),\n\t}\n\tif tile.tags [0 .. 4].contains (\u0026 tag) { tile.flip () ?; }\n\twhile tile.tags [tag_idx.pan_usize ()] != tag { tile.rotate_left () ?; }\n\tOk (Some (tile))\n}\n\nfn paint_next (result: \u0026 mut Grid, tile: \u0026 mut Tile, translate: Pos) -\u003e GenResult \u003c()\u003e {\n\tlet required_size = chk! (translate + tile.grid.size ()) ?;\n\tif result.size ().y \u003c required_size.y || result.size ().x \u003c required_size.x {\n\t\t* result = result.resize (\n\t\t\tPos::ZERO,\n\t\t\tPos::new (\n\t\t\t\tcmp::max (result.size ().y, required_size.y),\n\t\t\t\tcmp::max (result.size ().x, required_size.x)),\n\t\t) ?;\n\t}\n\tfor (pos, pixel) in tile.grid.translate (translate) ?.iter () {\n\t\tresult.set (pos, pixel);\n\t}\n\tOk (())\n}\n\nfn pick_first (tiles: \u0026 mut Tiles) -\u003e GenResult \u003cTile\u003e {\n\tlet id = tiles.values ()\n\t\t.find (|tile| get_shared_sides (tiles, tile).count_ones () == 2)\n\t\t.map (|tile| tile.id)\n\t\t.ok_or (\"No solution found\") ?;\n\tlet mut tile = tiles.remove (\u0026 id).unwrap ();\n\tmatch get_shared_sides (tiles, \u0026 tile) {\n\t\t0b_0110 =\u003e (),\n\t\t0b_0011 =\u003e tile.rotate_left () ?,\n\t\t0b_1001 =\u003e tile.rotate_around () ?,\n\t\t0b_1100 =\u003e tile.rotate_right () ?,\n\t\t_ =\u003e return Err (\"No solution found\".into ()),\n\t}\n\tOk (tile)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.tiles.len () \u003c 2 { return Err (\"Must provide at least two tiles\".into ()) }\n\tif input.tiles.iter ().duplicates_by (|tile| tile.id).next ().is_some () {\n\t\treturn Err (\"Every tile must have a unique id\".into ());\n\t}\n\tif ! input.tiles.iter ().map (|tile| tile.grid.size ()).all_equal () {\n\t\treturn Err (\"Tile sizes must all be the same size\".into ());\n\t}\n\tlet tile_size = input.tiles [0].grid.size ();\n\tif tile_size.y != tile_size.x {\n\t\treturn Err (\"Tile size must be a square\".into ());\n\t}\n\tif tile_size.y \u003c 3 || tile_size.x \u003c 3 {\n\t\treturn Err (\"Tile size must be at least 33\".into ());\n\t}\n\tif 32 \u003c tile_size.y || 32 \u003c tile_size.x {\n\t\treturn Err (\"Tile size must be at most 3232\".into ());\n\t}\n\tOk (())\n}\n\nfn get_shared_sides (tiles: \u0026 Tiles, tile: \u0026 Tile) -\u003e u8 {\n\ttile.tags.into_iter ().take (4)\n\t\t.map (|tag| tiles.values ()\n\t\t\t.filter (|other| tile.id != other.id)\n\t\t\t.any (|other| other.tags.contains (\u0026 tag)))\n\t\t.fold (0_u8, |sum, val| (sum \u003c\u003c 1_u32) | u8::from (val))\n}\n","traces":[{"line":14,"address":[132781,132496],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":15,"address":[132511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[56000,56038,55984],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":21,"address":[132687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[55207,55104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[56112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[58224,58256,56176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[132800,133568],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":30,"address":[132822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[132876,132913,133268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[132952,132984,133312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[133079,133007,133419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[133145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[134594,133584],"length":1,"stats":{"Line":1},"fn_name":"find_monsters"},{"line":67,"address":[56208],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":68,"address":[120783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[56320,56328],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":72,"address":[134608],"length":1,"stats":{"Line":1},"fn_name":"find_monsters_transform"},{"line":80,"address":[134729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[134826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[54494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[54517,56336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[54613,54623,56351,56401,56391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[56468,56891,56448],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":90,"address":[56839,56583,56738,56615],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[56695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[56703,56713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[56708,56716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[135584],"length":1,"stats":{"Line":0},"fn_name":"detect_monster"},{"line":104,"address":[56740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[135589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[135601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[135632],"length":1,"stats":{"Line":1},"fn_name":"remove_monsters"},{"line":111,"address":[136410,135672,135749],"length":1,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[135850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[135942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[136445,136008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[135813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[136560,137794],"length":1,"stats":{"Line":1},"fn_name":"assemble_image"},{"line":127,"address":[56928,56912,56966],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":129,"address":[137407,136640,136695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[136840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[136831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[137111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[136994,136880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[137053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[137094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[137129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[137143,137250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[137313],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[137362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[137353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[137549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[137651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[141198,137808],"length":1,"stats":{"Line":1},"fn_name":"pick_next"},{"line":153,"address":[138115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[58288,58296,58371],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":155,"address":[138398],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[120480,120530],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[139890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[139640,140206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[139748,140283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[140082,139532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[139924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[139958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[139856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[140399,140559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[140877,141010,140657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[140956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[142448,141216],"length":1,"stats":{"Line":1},"fn_name":"paint_next"},{"line":175,"address":[49526,48373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[141296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[142392,141490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[141314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[141337],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[141932,141595,141544,142302,142433,141735],"length":1,"stats":{"Line":5},"fn_name":null},{"line":190,"address":[143784,142464],"length":1,"stats":{"Line":1},"fn_name":"pick_first"},{"line":191,"address":[142826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[57061,57170,57056],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":193,"address":[57216],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":196,"address":[142987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[143539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[143570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[143601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[143217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[143644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[143792,144280],"length":1,"stats":{"Line":2},"fn_name":"check_input"},{"line":207,"address":[143810],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[95723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[144090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[57248,57256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[144186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[144160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":216,"address":[144200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[144164],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[144233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[144173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[144245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[144288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[144340,144292,142660,142718,142909,142972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[57282,57264],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":230,"address":[39505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[55385,57628,57659,57731,57509,57648],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[39258,39555],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":84,"coverable":104},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-20","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Dir = aoc_pos::Dir2d;\npub type Grid = GridBuf \u003cVec \u003cPixel\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Tag = u16;\npub type TileId = u16;\npub type Tiles = HashMap \u003cTileId, Tile\u003e;\npub type Turn = aoc_pos::Turn2d;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Pixel {\n\t\t#[ default ]\n\t\tBlack = \".\",\n\t\tWhite = \"#\",\n\t}\n}\n\n#[ derive (Clone, Debug) ]\npub struct Tile {\n\tpub id: TileId,\n\tpub grid: Grid,\n\tpub tags: [Tag; 8],\n}\n\nimpl Tile {\n\n\t#[ must_use ]\n\tpub fn new (id: TileId, grid: Grid) -\u003e Self {\n\t\tlet mut cur = grid.cursor (Pos::ZERO).unwrap ();\n\t\tlet tags = [\n\t\t\tDir::Right, Dir::Down, Dir::Left, Dir::Up,\n\t\t\tDir::Down, Dir::Right, Dir::Up, Dir::Left,\n\t\t].map (|dir| {\n\t\t\tlet offset = grid.offset (Pos::ZERO.try_add ((dir, 1)).unwrap ()).unwrap ();\n\t\t\tlet mut tag = 0_u16;\n\t\t\tloop {\n\t\t\t\ttag \u003c\u003c= 1_u32;\n\t\t\t\tif matches! (cur.get (\u0026 grid), Pixel::White) { tag |= 1; }\n\t\t\t\tif cur.try_add_assign (offset).is_err () { break }\n\t\t\t}\n\t\t\ttag\n\t\t});\n\t\tlet grid = grid\n\t\t\t.extend_in_place ([ (-1, -1), (-1, -1) ]).unwrap ()\n\t\t\t.translate (Pos::new (-1, -1)).unwrap ();\n\t\tSelf { id, grid, tags }\n\t}\n\n\tpub fn rotate_left (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.grid = self.grid.transform (Pos::ZERO, [ Dir::Left, Dir::Down ]) ?;\n\t\tself.tags = [\n\t\t\tself.tags [1], self.tags [2], self.tags [3], self.tags [0],\n\t\t\tself.tags [7], self.tags [4], self.tags [5], self.tags [6],\n\t\t];\n\t\tOk (())\n\t}\n\n\tpub fn rotate_right (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.grid = self.grid.transform (Pos::ZERO, [ Dir::Right, Dir::Up ]) ?;\n\t\tself.tags = [\n\t\t\tself.tags [3], self.tags [0], self.tags [1], self.tags [2],\n\t\t\tself.tags [5], self.tags [6], self.tags [7], self.tags [4],\n\t\t];\n\t\tOk (())\n\t}\n\n\tpub fn rotate_around (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.grid = self.grid.transform (Pos::ZERO, [ Dir::Up, Dir::Left ]) ?;\n\t\tself.tags = [\n\t\t\tself.tags [2], self.tags [3], self.tags [0], self.tags [1],\n\t\t\tself.tags [6], self.tags [7], self.tags [4], self.tags [5],\n\t\t];\n\t\tOk (())\n\t}\n\n\tpub fn flip (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.grid = self.grid.transform (Pos::ZERO, [ Dir::Right, Dir::Down ]) ?;\n\t\tself.tags = [\n\t\t\tself.tags [4], self.tags [5], self.tags [6], self.tags [7],\n\t\t\tself.tags [0], self.tags [1], self.tags [2], self.tags [3],\n\t\t];\n\t\tOk (())\n\t}\n\n}\n\nimpl Eq for Tile {}\n\nimpl Hash for Tile {\n\tfn hash \u003cState: Hasher\u003e (\u0026 self, state: \u0026 mut State) {\n\t\tself.id.hash (state);\n\t}\n}\n\nimpl PartialEq for Tile {\n\t#[ inline ]\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.id == other.id\n\t}\n}\n","traces":[{"line":13,"address":[50681,54603,56382],"length":1,"stats":{"Line":11},"fn_name":null},{"line":31,"address":[118402,117744],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":36,"address":[45904],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":37,"address":[45923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[46135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[46145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[118078,118023],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[118372,118141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[118416],"length":1,"stats":{"Line":0},"fn_name":"rotate_left"},{"line":53,"address":[118431,118589,118478,118564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[118534],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[118511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[118523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[118624],"length":1,"stats":{"Line":0},"fn_name":"rotate_right"},{"line":62,"address":[139910,143369,140102,143420,139232,139286,139673,143587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[118742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[118719],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[118730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[118832],"length":1,"stats":{"Line":0},"fn_name":"rotate_around"},{"line":71,"address":[118847,118894,118944,118969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[118928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[119008],"length":1,"stats":{"Line":0},"fn_name":"flip"},{"line":80,"address":[119151,119070,119023,119126],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[119111],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[119107],"length":1,"stats":{"Line":3},"fn_name":null},{"line":83,"address":[119103],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":22,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-21","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"mxmxvkd kfcds sqjhc nhms (contains dairy, fish)\",\n\t\"trh fvjkl sbzzf mxmxvkd (contains dairy)\",\n\t\"sqjhc fvjkl (contains soy)\",\n\t\"sqjhc mxmxvkd sbzzf (contains fish)\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"mxmxvkd,sqjhc,fvjkl\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":13,"address":[58208,58599],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":14,"address":[58218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[58386,58277,58329,58239,58452,58556],"length":1,"stats":{"Line":3},"fn_name":null},{"line":19,"address":[58999,58608],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":20,"address":[58618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[58786,58852,58729,58956,58639,58677],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-21","input.rs"],"content":"use super::*;\n\nuse model::Food;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub foods: Vec \u003cFood \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { foods, params } = [ params, @lines foods ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[42694,43851],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-21","lib.rs"],"content":"//! Advent of Code 2020: Day 21: Allergen Assessment\n//!\n//! [https://adventofcode.com/2020/day/21](https://adventofcode.com/2020/day/21)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Allergen Assessment\";\n\tyear = 2020;\n\tday = 21;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[45848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[46172],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-21","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\ntype Alrgns \u003c'inp\u003e = HashMap \u003cInpStr \u003c'inp\u003e, Ingrs \u003c'inp\u003e\u003e;\ntype Ingrs \u003c'inp\u003e = HashSet \u003cInpStr \u003c'inp\u003e\u003e;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet (_, ingrs) = get_alrgns_ingrs (input);\n\tOk (\n\t\tinput.foods.iter ()\n\t\t\t.flat_map (|food| \u0026 food.ingrs)\n\t\t\t.filter (|ingr| ! ingrs.contains (ingr))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet (mut pending_alrgns, mut pending_ingrs) = get_alrgns_ingrs (input);\n\tlet mut result: Vec \u003c(InpStr, InpStr)\u003e = Vec::new ();\n\twhile ! pending_alrgns.is_empty () {\n\t\tlet mut progress = false;\n\t\tlet mut error = false;\n\t\tpending_alrgns.retain (|alrgn, ingrs| {\n\t\t\tingrs.retain (|ingr| pending_ingrs.contains (ingr));\n\t\t\tif 1 \u003c ingrs.len () { return true }\n\t\t\tif ingrs.is_empty () { error = true; return true }\n\t\t\tlet ingr = ingrs.iter ().next ().unwrap ().clone ();\n\t\t\tpending_ingrs.remove (\u0026 ingr);\n\t\t\tresult.push ((alrgn.clone (), ingr));\n\t\t\tprogress = true;\n\t\t\tfalse\n\t\t});\n\t\tif ! progress || error { return Err (\"No solution found\".into ()) }\n\t}\n\tresult.sort_by_key (|\u0026 (ref alrgn, _)| alrgn.clone ());\n\tOk (result.iter ().map (|\u0026 (_, ref ingr)| ingr).display_delim (\",\").to_string ())\n}\n\nfn get_alrgns_ingrs \u003c'inp\u003e (input: \u0026 'inp Input) -\u003e (Alrgns \u003c'inp\u003e, Ingrs \u003c'inp\u003e) {\n\tlet mut alrgns: HashMap \u003cInpStr, HashSet \u003cInpStr\u003e\u003e = default ();\n\tfor food in \u0026 input.foods {\n\t\tfor alrgn in \u0026 food.alrgns {\n\t\t\talrgns.entry (alrgn.clone ())\n\t\t\t\t.and_modify (|ingrs| ingrs.retain (|ingr| food.ingrs.contains (ingr)))\n\t\t\t\t.or_insert_with (|| food.ingrs.iter ().cloned ().collect ());\n\t\t}\n\t}\n\tlet ingrs: HashSet \u003cInpStr\u003e = alrgns.values ().flatten ().cloned ().collect ();\n\t(alrgns, ingrs)\n}\n","traces":[{"line":10,"address":[30208,30475],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[30231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[57315,57312],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":15,"address":[32156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[30496,31130],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[30526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[30801,30670],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[30720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[30725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[57344,57832],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":28,"address":[29987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[57391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[57404,57519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[57613,57568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[57731],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[30980,30773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[57920,57856],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":40,"address":[30928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":21,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-21","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Food \u003c'inp\u003e {\n\tpub ingrs: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n\tpub alrgns: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tFood \u003c'inp\u003e { ingrs, alrgns } = [\n\t\t@delim \" \" ingrs = parse_name, \" (contains \",\n\t\t@delim \", \" alrgns = parse_name, \")\",\n\t]\n}\n\nfn parse_name \u003c'inp\u003e (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\tparser.take_rest_while (|ch| ch.is_ascii_lowercase (), 1 .. )\n}\n","traces":[{"line":11,"address":[72848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"Player 1:\",\n\t\"9\",\n\t\"2\",\n\t\"6\",\n\t\"3\",\n\t\"1\",\n\t\"\",\n\t\"Player 2:\",\n\t\"5\",\n\t\"8\",\n\t\"4\",\n\t\"7\",\n\t\"10\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"306\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"291\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":22,"address":[49808,50199],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":23,"address":[49818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[49839,50156,50052,49877,49929,49986],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[50208,50599],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":29,"address":[50218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[50277,50386,50329,50452,50239,50556],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-22","input.rs"],"content":"use super::*;\n\nuse model::Card;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub player_1: Vec \u003cCard\u003e,\n\tpub player_2: Vec \u003cCard\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { player_1, player_2, params } = [\n\t\tparams,\n\t\t\"Player 1:\\n\", @lines player_1, \"\\n\",\n\t\t\"\\n\",\n\t\t\"Player 2:\\n\", @lines player_2,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[40818],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-22","lib.rs"],"content":"//! Advent of Code 2020: Day 22: Crab Combat\n//!\n//! [https://adventofcode.com/2020/day/22](https://adventofcode.com/2020/day/22)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Crab Combat\";\n\tyear = 2020;\n\tday = 22;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[57184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[57664],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-22","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Deck;\nuse model::Game;\nuse model::Pool;\nuse model::State;\nuse model::Winner;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet mut deck_1: Deck = input.player_1.iter ().copied ().collect ();\n\tlet mut deck_2: Deck = input.player_2.iter ().copied ().collect ();\n\tlet mut seen = HashSet::new ();\n\twhile ! deck_1.is_empty () \u0026\u0026 ! deck_2.is_empty () {\n\t\tif ! seen.insert (State::new (\u0026 deck_1, \u0026 deck_2)) {\n\t\t\treturn Err (\"Game is looping\".into ());\n\t\t}\n\t\tlet card_1 = deck_1.pop_front ().unwrap ();\n\t\tlet card_2 = deck_2.pop_front ().unwrap ();\n\t\tif card_1 \u003c card_2 {\n\t\t\tdeck_2.push_back (card_2);\n\t\t\tdeck_2.push_back (card_1);\n\t\t} else {\n\t\t\tdeck_1.push_back (card_1);\n\t\t\tdeck_1.push_back (card_2);\n\t\t}\n\t}\n\tlet winner = if deck_1.is_empty () { deck_2 } else { deck_1 };\n\tOk (\n\t\twinner.iter ().rev ().enumerate ()\n\t\t\t.map (|(idx, card)| (idx.pan_u32 () + 1) * card.pan_u32 ())\n\t\t\t.try_fold (0_u32, |sum, item| chk! (sum + item)) ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet mut pool = Pool::new ();\n\tlet mut stack: Vec \u003cGame\u003e = Vec::new ();\n\tlet mut game = Game::new (\u0026 mut pool, input.player_1.iter (), input.player_2.iter ());\n\tlet mut games = 0_u32;\n\tlet mut rounds = 0_u32;\n\tlet mut cache: HashMap \u003cState, Winner\u003e = HashMap::new ();\n\tlet winner = 'OUTER: loop {\n\t\tif games == 50_000 { return Err (\"Giving up after max games\".into ()) }\n\t\tgames += 1;\n\t\tlet winner = loop {\n\t\t\tif rounds == 2_000_000 { return Err (\"Giving up after max rounds\".into ()) }\n\t\t\trounds += 1;\n\t\t\tlet state = State::new (\u0026 game.deck_1, \u0026 game.deck_2);\n\t\t\tif let Some (\u0026 winner) = cache.get (\u0026 state) { break winner }\n\t\t\tif ! game.seen.insert (state) { break Winner::One }\n\t\t\tgame.card_1 = some_or! (game.deck_1.pop_front (), break Winner::Two);\n\t\t\tgame.card_2 = some_or! (game.deck_2.pop_front (), break Winner::One);\n\t\t\tif game.card_1.pan_usize () \u003c= game.deck_1.len ()\n\t\t\t\t\t\u0026\u0026 game.card_2.pan_usize () \u003c= game.deck_2.len () {\n\t\t\t\tlet new_game = Game::new (\u0026 mut pool,\n\t\t\t\t\tgame.deck_1.iter ().take (game.card_1.pan_usize ()),\n\t\t\t\t\tgame.deck_2.iter ().take (game.card_2.pan_usize ()));\n\t\t\t\tstack.push (game);\n\t\t\t\tgame = new_game;\n\t\t\t\tcontinue 'OUTER;\n\t\t\t}\n\t\t\tif game.card_1 \u003c game.card_2 {\n\t\t\t\tgame.deck_2.push_back (game.card_2);\n\t\t\t\tgame.deck_2.push_back (game.card_1);\n\t\t\t} else {\n\t\t\t\tgame.deck_1.push_back (game.card_1);\n\t\t\t\tgame.deck_1.push_back (game.card_2);\n\t\t\t}\n\t\t};\n\t\tcache.insert (game.start_state, winner);\n\t\tlet prev_game = some_or! (stack.pop (), break winner);\n\t\tgame.free (\u0026 mut pool);\n\t\tgame = prev_game;\n\t\tmatch winner {\n\t\t\tWinner::One =\u003e {\n\t\t\t\tgame.deck_1.push_back (game.card_1);\n\t\t\t\tgame.deck_1.push_back (game.card_2);\n\t\t\t},\n\t\t\tWinner::Two =\u003e {\n\t\t\t\tgame.deck_2.push_back (game.card_2);\n\t\t\t\tgame.deck_2.push_back (game.card_1);\n\t\t\t},\n\t\t}\n\t};\n\tlet winner = match winner {\n\t\tWinner::One =\u003e game.deck_1,\n\t\tWinner::Two =\u003e game.deck_2,\n\t};\n\tOk (\n\t\twinner.iter ().rev ().enumerate ()\n\t\t\t.map (|(idx, card)| (idx.pan_u32 () + 1) * card.pan_u32 ())\n\t\t\t.try_fold (0_u32, |sum, item| chk! (sum + item)) ?\n\t)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif ! input.player_1.iter ().chain (\u0026 input.player_2).all_unique () {\n\t\treturn Err (\"No two cards can be the same\".into ());\n\t}\n\tif 63 \u003c input.player_1.len () + input.player_2.len () {\n\t\treturn Err (\"Can't play with more than 63 cards\".into ());\n\t}\n\tfor player in [ \u0026 input.player_1, \u0026 input.player_2 ] {\n\t\tif player.iter ().any (|\u0026 card| card == 0) {\n\t\t\treturn Err (\"Card must not be zero\".into ());\n\t\t}\n\t}\n\tOk (())\n}\n","traces":[{"line":12,"address":[61652,59360],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":13,"address":[59383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[59432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[59481],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[59730,59711],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[60044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[61109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[60105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[60177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[60196],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[60529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[60625],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[56201,56254,56144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":35,"address":[56592,56336,56576],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":39,"address":[61664,65650],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":40,"address":[61687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[61810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[64155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[62106,62180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[62193,65293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[63445,62757,62745],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[62838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[62893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[62953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[63036,63119],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[63116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[64404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[64436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[64551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[63125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[63223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[63355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[63626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[63708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[63745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[63769],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[63968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[64055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[63778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[63865],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[64940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[56462,56352,56409],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":97,"address":[56544,56608,56624],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":101,"address":[66184,65664],"length":1,"stats":{"Line":1},"fn_name":"check_input"},{"line":102,"address":[65681,65840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[65893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[66130,65844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[65879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[66169,65926,66041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[56560],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":110,"address":[66100],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":42,"coverable":51},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-22","model.rs"],"content":"use super::*;\n\npub type Card = u8;\npub type Deck = VecDeque \u003cu8\u003e;\n\n#[ derive (Clone, Copy, Debug) ]\npub enum Winner { One, Two }\n\npub struct Pool {\n\tdecks: Vec \u003cDeck\u003e,\n\tseens: Vec \u003cHashSet \u003cState\u003e\u003e,\n}\n\nimpl Pool {\n\n\t#[ must_use ]\n\tpub const fn new () -\u003e Self {\n\t\tSelf {\n\t\t\tdecks: Vec::new (),\n\t\t\tseens: Vec::new (),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn new_deck (\u0026 mut self, iter: impl Iterator \u003cItem = Card\u003e) -\u003e Deck {\n\t\tlet mut deck = self.decks.pop ().unwrap_or_default ();\n\t\tdeck.clear ();\n\t\tdeck.extend (iter);\n\t\tdeck\n\t}\n\n\t#[ inline ]\n\tfn free_deck (\u0026 mut self, deck: Deck) {\n\t\tself.decks.push (deck);\n\t}\n\n\t#[ inline ]\n\tfn new_seen (\u0026 mut self) -\u003e HashSet \u003cState\u003e {\n\t\tlet mut seen = self.seens.pop ().unwrap_or_default ();\n\t\tseen.clear ();\n\t\tseen\n\t}\n\n\t#[ inline ]\n\tfn free_seen (\u0026 mut self, seen: HashSet \u003cState\u003e) {\n\t\tself.seens.push (seen);\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct State {\n\tdecks: [Card; 64],\n}\n\nimpl State {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new (deck_1: \u0026 Deck, deck_2: \u0026 Deck) -\u003e Self {\n\t\tlet mut decks = [0; 64];\n\t\tlet mut idx = 0;\n\t\tfor \u0026 val in deck_1 { decks [idx] = val; idx += 1; }\n\t\tidx += 1;\n\t\tfor \u0026 val in deck_2 { decks [idx] = val; idx += 1; }\n\t\tSelf { decks }\n\t}\n\n}\n\npub struct Game {\n\tpub start_state: State,\n\tpub deck_1: Deck,\n\tpub deck_2: Deck,\n\tpub card_1: Card,\n\tpub card_2: Card,\n\tpub seen: HashSet \u003cState\u003e,\n}\n\nimpl Game {\n\n\t#[ inline ]\n\tpub fn new \u003c'card\u003e (\n\t\tpool: \u0026 mut Pool,\n\t\tdeck_1: impl Iterator \u003cItem = \u0026 'card Card\u003e,\n\t\tdeck_2: impl Iterator \u003cItem = \u0026 'card Card\u003e,\n\t) -\u003e Self {\n\t\tlet deck_1 = pool.new_deck (deck_1.copied ());\n\t\tlet deck_2 = pool.new_deck (deck_2.copied ());\n\t\tlet start_state = State::new (\u0026 deck_1, \u0026 deck_2);\n\t\tSelf {\n\t\t\tstart_state,\n\t\t\tdeck_1,\n\t\t\tdeck_2,\n\t\t\tcard_1: 0,\n\t\t\tcard_2: 0,\n\t\t\tseen: pool.new_seen (),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn free (self, pool: \u0026 mut Pool) {\n\t\tpool.free_deck (self.deck_1);\n\t\tpool.free_deck (self.deck_2);\n\t\tpool.free_seen (self.seen);\n\t}\n\n}\n","traces":[{"line":17,"address":[48624],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":25,"address":[40314,38910,40335,38931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[49452,49362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[48656],"length":1,"stats":{"Line":1},"fn_name":"new_seen"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":64,"address":[49154],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[49291,49198],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[37584,39008,40396,38992],"length":1,"stats":{"Line":2},"fn_name":"new\u003ccore::slice::iter::Iter\u003cu8\u003e, core::slice::iter::Iter\u003cu8\u003e\u003e"},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"389125467\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"67384529\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"149245887792\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[45268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[62858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[62917,63092,63196,63026,62879,62969],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[45444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[63258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[63596,63279,63369,63492,63426,63317],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-23","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub start: InpStr \u003c'inp\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { start, params } = [\n\t\tparams,\n\t\t@str start = ('1' ..= '9', 9 ..= 9),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub iters_one: u32 = (\"ITERS_ONE=\", 100, 1_u32 .. ),\n\t\tpub iters_two: u32 = (\"ITERS_TWO=\", 10_000_000, 1_u32 .. ),\n\t\tpub deck_size_two: u32 = (\"DECK_SIZE_TWO=\", 1_000_000, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":11,"address":[42394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[43280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[43284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[43288],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-23","lib.rs"],"content":"//! Advent of Code 2020: Day 23: Crab Cups\n//!\n//! [https://adventofcode.com/2020/day/23](https://adventofcode.com/2020/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Crab Cups\";\n\tyear = 2020;\n\tday = 23;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[33671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[34092],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-23","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Card;\nuse model::Deck;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet mut deck =\n\t\tcalc_final_deck (\n\t\t\tinput,\n\t\t\tCard::new (9).unwrap (),\n\t\t\tinput.params.iters_one) ?;\n\tdeck.move_after (Card::new (1).unwrap ());\n\tlet mut result = String::new ();\n\tfor _ in 0_u32 .. 8 {\n\t\tlet next = deck.pick ();\n\t\tresult.push (char::from_digit (next.get (), 10).unwrap ());\n\t}\n\tOk (result)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut deck =\n\t\tcalc_final_deck (\n\t\t\tinput,\n\t\t\tCard::new (input.params.deck_size_two).unwrap (),\n\t\t\tinput.params.iters_two) ?;\n\tdeck.move_after (Card::new (1).unwrap ());\n\tOk (chk! (deck.pick ().get ().pan_u64 () * deck.pick ().get ().pan_u64 ()) ?)\n}\n\nfn calc_final_deck (input: \u0026 Input, deck_size: Card, num_rounds: u32) -\u003e GenResult \u003cDeck\u003e {\n\tlet mut deck = build_deck (input, deck_size) ?;\n\tfor _ in 0 .. num_rounds {\n\t\tplay_one_round (\u0026 mut deck, deck_size);\n\t}\n\tOk (deck)\n}\n\nfn build_deck (input: \u0026 Input, deck_size: Card) -\u003e GenResult \u003cDeck\u003e {\n\tif input.start.chars ().duplicates ().next ().is_some () {\n\t\treturn Err (\"Duplicate cards\".into ());\n\t}\n\tOk (\n\t\tinput.start.chars ()\n\t\t\t.map (|ch| ch.to_digit (10).unwrap ().pan_u32 ())\n\t\t\t.chain (10 ..= deck_size.get ())\n\t\t\t.map (|val| Card::new (val).unwrap ())\n\t\t\t.take (deck_size.get ().pan_usize ())\n\t\t\t.collect ()\n\t)\n}\n\nfn play_one_round (deck: \u0026 mut Deck, deck_size: Card) {\n\tlet cur = deck.pick ();\n\tlet picked: [Card; 3] = array::from_fn (|_| deck.pick ());\n\tlet mut prev = get_prev (cur, deck_size);\n\twhile prev == picked [0] || prev == picked [1] || prev == picked [2] {\n\t\tprev = get_prev (prev, deck_size);\n\t}\n\tdeck.place_after (prev, \u0026 picked);\n\tdeck.place (cur);\n}\n\nfn get_prev (card: Card, deck_size: Card) -\u003e Card {\n\tCard::new (card.get () - 1).unwrap_or (deck_size)\n}\n","traces":[{"line":9,"address":[49034,48400],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":13,"address":[48422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[48442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[48602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[48739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[48741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[48825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[49056,49654],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":28,"address":[49072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[49090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[49258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[37687,37680,37792],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":34,"address":[49869,49664,49623,48987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[48449,49138,49099,49689,48870,49812,49719,49519,48487],"length":1,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[49167,49186,49763,48530,48516],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[49768,48532,49188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[48544,49200,49780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[50466,49888],"length":1,"stats":{"Line":2},"fn_name":"build_deck"},{"line":43,"address":[50183,50123,50451],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[50187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[34589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[36852],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[50480],"length":1,"stats":{"Line":1},"fn_name":"play_one_round"},{"line":57,"address":[50493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[37084,37664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[50631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[50644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[50657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[50595],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-23","model.rs"],"content":"use super::*;\n\npub type Card = std::num::NonZeroU32;\n\n#[ derive (Debug) ]\npub struct Deck {\n\tfirst: Option \u003cCard\u003e,\n\tlast: Option \u003cCard\u003e,\n\tnext: Vec \u003cOption \u003cCard\u003e\u003e,\n}\n\nimpl Deck {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn new () -\u003e Self {\n\t\tSelf {\n\t\t\tfirst: None,\n\t\t\tlast: None,\n\t\t\tnext: Vec::new (),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn pick (\u0026 mut self) -\u003e Card {\n\t\tlet card = self.first.take ().unwrap ();\n\t\tself.first = self.next [card.get ().pan_usize () - 1].take ();\n\t\tif self.first.is_none () { self.last = None }\n\t\tcard\n\t}\n\n\t#[ inline ]\n\tpub fn place (\u0026 mut self, card: Card) {\n\t\tdebug_assert! (! self.contains (card));\n\t\tif let Some (last) = self.last {\n\t\t\tself.next [last.get ().pan_usize () - 1] = Some (card);\n\t\t} else {\n\t\t\tself.first = Some (card);\n\t\t}\n\t\tself.last = Some (card);\n\t}\n\n\t#[ inline ]\n\tpub fn extend (\u0026 mut self, iter: impl IntoIterator \u003cItem = Card\u003e) {\n\t\tlet mut iter = iter.into_iter ();\n\t\tlet (size_min, size_max) = iter.size_hint ();\n\t\tself.next.resize (size_max.unwrap_or (size_min), None);\n\t\tlet mut prev = if let Some (prev) = self.last { prev } else {\n\t\t\tlet card = some_or! (iter.next (), return);\n\t\t\tdebug_assert! (! self.contains (card));\n\t\t\tself.first = Some (card);\n\t\t\tcard\n\t\t};\n\t\tfor card in iter {\n\t\t\tdebug_assert! (! self.contains (card));\n\t\t\tself.next [prev.get ().pan_usize () - 1].replace (card);\n\t\t\tprev = card;\n\t\t}\n\t\tself.last = Some (prev);\n\t}\n\n\t#[ inline ]\n\tpub fn place_after (\u0026 mut self, after: Card, cards: \u0026 [Card]) {\n\t\tlet mut cards_iter = cards.iter ().copied ().peekable ();\n\t\tlet first = some_or! (cards_iter.next (), return);\n\t\tlet resume = self.next [after.get ().pan_usize () - 1].replace (first);\n\t\tlet mut prev = first;\n\t\tfor card in cards_iter {\n\t\t\tself.next [prev.get ().pan_usize () - 1] = Some (card);\n\t\t\tprev = card;\n\t\t}\n\t\tself.next [prev.get ().pan_usize () - 1] = resume;\n\t\tif resume.is_none () { self.last = Some (prev); }\n\t}\n\n\t#[ inline ]\n\tpub fn move_after (\u0026 mut self, card: Card) {\n\t\tloop {\n\t\t\tlet scan = self.pick ();\n\t\t\tself.place (scan);\n\t\t\tif scan == card { return }\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn contains (\u0026 self, card: Card) -\u003e bool{\n\t\tself.next [card.get ().pan_usize () - 1].is_some () || self.last == Some (card)\n\t}\n\n}\n\nimpl Default for Deck {\n\tfn default () -\u003e Self {\n\t\tSelf::new ()\n\t}\n}\n\nimpl FromIterator \u003cCard\u003e for Deck {\n\tfn from_iter \u003cSomeIter\u003e (iter: SomeIter) -\u003e Self\n\t\t\twhere SomeIter: IntoIterator \u003cItem = Card\u003e {\n\t\tlet mut deck = Self::new ();\n\t\tdeck.extend (iter);\n\t\tdeck\n\t}\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[47488,47585],"length":1,"stats":{"Line":0},"fn_name":"from_iter\u003ccore::iter::adapters::take::Take\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::chain::Chain\u003ccore::iter::adapters::map::Map\u003ccore::str::iter::Chars, aoc_2020_day_23::logic::build_deck::{closure_env#0}\u003e, core::ops::range::RangeInclusive\u003cu32\u003e\u003e, aoc_2020_day_23::logic::build_deck::{closure_env#1}\u003e\u003e\u003e"},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":33,"coverable":48},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-24","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"sesenwnenenewseeswwswswwnenewsewsw\",\n\t\"neeenesenwnwwswnenewnwwsewnenwseswesw\",\n\t\"seswneswswsenwwnwse\",\n\t\"nwnwneseeswswnenewneswwnewseswneseene\",\n\t\"swweswneswnenwsewnwneneseenw\",\n\t\"eesenwseswswnenwswnwnwsewwnwsene\",\n\t\"sewnenenenesenwsewnenwwwse\",\n\t\"wenwwweseeeweswwwnwwe\",\n\t\"wsweesenenewnwwnwsenewsenwwsesesenwne\",\n\t\"neeswseenwwswnwswswnw\",\n\t\"nenwswwsewswnenenewsenwsenwnesesenew\",\n\t\"enewnwewneswsewnwswenweswnenwsenwsw\",\n\t\"sweneswneswneneenwnewenewwneswswnese\",\n\t\"swwesenesewenwneswnwwneseswwne\",\n\t\"enesenwswwswneneswsenwnewswseenwsese\",\n\t\"wnwnesenesenenwwnenwsewesewsesesew\",\n\t\"nenewswnwewswnenesenwnesewesw\",\n\t\"eneswnwswnwsenenwnwnwwseeswneewsenese\",\n\t\"neswnwewnwnwseenwseesewsenwsweewe\",\n\t\"wseweeenwnesenwwwswnew\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2208\", puzzle.part_two (EXAMPLE));\n}\n\n#[ test ]\nfn part_two_bits () {\n\tlet input = input::Input::parse_from_lines (EXAMPLE).unwrap ();\n\tassert_eq_ok! (2208, logic::part_two_bits (\u0026 input));\n}\n","traces":[{"line":29,"address":[35508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[116234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[116293,116572,116345,116402,116468,116255],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[35780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[116634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[116868,116655,116745,116802,116972,116693],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[35188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[117091,117257,117194,117107],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":8,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-24","input.rs"],"content":"use super::*;\n\nuse model::Step;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub tiles: Vec \u003cInputTile\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { tiles, params } = [ params, @lines tiles ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputTile {\n\t\tpub steps: Vec \u003cStep\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tInputTile { steps } = [ @collect steps ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_iters: u32 = (\"NUM_ITERS=\", 100, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":12,"address":[52379],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[34739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[52765],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-24","lib.rs"],"content":"//! Advent of Code 2020: Day 24: Lobby Layout\n//!\n//! [https://adventofcode.com/2020/day/24](https://adventofcode.com/2020/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Lobby Layout\";\n\tyear = 2020;\n\tday = 24;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[80727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[81079],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-24","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Grid;\nuse model::Pos;\nuse model::Tile::{ self, White, Black };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = get_start_grid (input) ?;\n\tOk (count_black (\u0026 grid))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tconst EXTEND_AMT: Coord = 1;\n\tconst EXTEND_AMTS: [(Coord, Coord); 2] = [(EXTEND_AMT, EXTEND_AMT); 2];\n\tlet mut grid = get_start_grid (input) ?;\n\tlet mut needs_extend = true;\n\tfor _ in 0_u32 .. input.params.num_iters {\n\t\t//println! (\"\\x1bc{grid}\");\n\t\t//thread::sleep (time::Duration::from_micros (200_000));\n\t\t(grid, needs_extend) = if needs_extend {\n\t\t\tnext_grid (\u0026 grid.extend (EXTEND_AMTS) ?) ?\n\t\t} else {\n\t\t\tnext_grid (\u0026 grid) ?\n\t\t};\n\t}\n\tOk (count_black (\u0026 grid))\n}\n\nfn next_grid (grid: impl GridView \u003cPos, 2, Item = Tile\u003e) -\u003e GenResult \u003c(Grid, bool)\u003e {\n\tlet offsets: ArrayVec \u003c_, 6\u003e =\n\t\tPos::ZERO.adjacent ().into_iter ()\n\t\t\t.map (|pos| grid.offset (pos))\n\t\t\t.try_collect () ?;\n\tlet mut needs_extend = false;\n\tlet grid = grid.map (|cur| {\n\t\tlet (num_adjacent, num_total) =\n\t\t\toffsets.iter ()\n\t\t\t\t.filter_map (|\u0026 off| chk! (cur + off).map (|cur| cur.get (grid)).ok ())\n\t\t\t\t.fold ((0_u32, 0_u32), |(num_adj, num_tot), item|\n\t\t\t\t\t(num_adj + u32::from (item == Black), num_tot + 1));\n\t\tlet black = matches! ((cur.get (grid), num_adjacent), (Black, 1 ..= 2) | (White, 2));\n\t\tif black \u0026\u0026 num_total \u003c 6 { needs_extend = true; }\n\t\tif black { Black } else { White }\n\t});\n\tOk ((grid, needs_extend))\n}\n\nfn count_black (grid: \u0026 Grid) -\u003e u32 {\n\tgrid.values ()\n\t\t.filter (|\u0026 tile| tile == Black)\n\t\t.count ()\n\t\t.pan_u32 ()\n}\n\nfn get_start_grid (input: \u0026 Input) -\u003e GenResult \u003cGrid\u003e {\n\tlet tile_posns: Vec \u003cPos\u003e = input.tiles.iter ()\n\t\t.map (|tile_steps| {\n\t\t\tlet mut pos = Pos::ZERO;\n\t\t\tfor \u0026 step in \u0026 ** tile_steps {\n\t\t\t\tpos = pos.try_add (step.into ()) ?;\n\t\t\t}\n\t\t\tOk::\u003c_, Overflow\u003e (pos)\n\t\t})\n\t\t.try_collect () ?;\n\tlet (min, max) = tile_posns.iter ()\n\t\t.fold ((Pos::ZERO, Pos::ZERO), |(min, max), \u0026 pos| (\n\t\t\tPos::new (cmp::min (min.nw, pos.nw), cmp::min (min.e, pos.e)),\n\t\t\tPos::new (cmp::max (max.nw, pos.nw), cmp::max (max.e, pos.e)),\n\t\t));\n\tif 30 \u003c max.nw - min.nw || 30 \u003c max.e - min.e {\n\t\treturn Err (\"Max initial grid size is 3030\".into ());\n\t}\n\tlet mut grid = Grid::new_range (min, max + Pos::new (1, 1)) ?;\n\tfor tile_pos in tile_posns {\n\t\tlet tile_prev = grid.get (tile_pos).unwrap ();\n\t\tlet tile_next = match tile_prev { White =\u003e Black, Black =\u003e White };\n\t\tgrid.set (tile_pos, tile_next);\n\t}\n\tOk (grid)\n}\n\npub fn part_two_bits (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet grid = get_start_grid (input) ?;\n\tlet mut grid = grid_to_bits (\u0026 grid);\n\tfor _ in 0_u32 .. input.params.num_iters {\n\t\tif grid [0] != 0 || grid [grid.len () - 1] != 0\n\t\t\t\t|| grid.iter ().any (|\u0026 val| val \u0026 (1 \u003c\u003c (grid.len () - 1)) != 0 || val \u0026 1 != 0) {\n\t\t\tgrid = iter::empty ()\n\t\t\t\t.chain (iter::once (0))\n\t\t\t\t.chain (grid)\n\t\t\t\t.chain (iter::once (0))\n\t\t\t\t.map (|val| val \u003c\u003c 1_u32)\n\t\t\t\t.collect ();\n\t\t}\n\t\tgrid = next_grid_bits (\u0026 grid);\n\t}\n\tOk (grid.iter ().map (|\u0026 val| val.count_ones ()).sum ())\n}\n\nfn grid_to_bits (grid: \u0026 Grid) -\u003e Vec \u003cu128\u003e {\n\tlet cur = grid.cursor (grid.first_key ()).unwrap ();\n\tlet north_west = grid.offset (Pos::ZERO.north_west (1).unwrap ()).unwrap ();\n\tlet east = grid.offset (Pos::ZERO.east (1).unwrap ()).unwrap ();\n\tcur.walk (north_west)\n\t\t.map (|cur| cur.walk (east)\n\t\t\t.fold (0_u128, |sum, cur| sum \u003c\u003c 1_u32 | u128::from (cur.get (grid) == Black)))\n\t\t.collect ()\n}\n\n#[ allow (clippy::unusual_byte_groupings) ]\nfn next_grid_bits (grid: \u0026 [u128]) -\u003e Vec \u003cu128\u003e {\n\tlet grid: Vec \u003cu128\u003e = iter::empty ()\n\t\t.chain (iter::once (0))\n\t\t.chain (grid.iter ().copied ())\n\t\t.chain (iter::once (0))\n\t\t.map (|val| val \u003c\u003c 1_u32)\n\t\t.tuple_windows ()\n\t\t.map (|(mut a, mut b, mut c)| {\n\t\t\tlet mut row = 0;\n\t\t\tfor _ in 0 .. grid.len () {\n\t\t\t\tlet black = b \u0026 0b_010 != 0;\n\t\t\t\tlet num_adj = (a.qck_u8 () \u0026 0b_110).count_ones ()\n\t\t\t\t\t+ (b.qck_u8 () \u0026 0b_101).count_ones ()\n\t\t\t\t\t+ (c.qck_u8 () \u0026 0b_011).count_ones ();\n\t\t\t\tlet black = matches! ((black, num_adj), (true, 1 ..= 2) | (false, 2));\n\t\t\t\trow = row \u003e\u003e 1_u32 | (u128::from (black) \u003c\u003c (grid.len () - 1));\n\t\t\t\ta \u003e\u003e= 1_u32;\n\t\t\t\tb \u003e\u003e= 1_u32;\n\t\t\t\tc \u003e\u003e= 1_u32;\n\t\t\t}\n\t\t\trow\n\t\t})\n\t\t.collect ();\n\tgrid\n}\n","traces":[{"line":11,"address":[97319,96960],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":12,"address":[97020,96981,97227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[97193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[97328,98366],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":19,"address":[98141,97398,97356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[97447,97941,97440],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[97859,97903,98305,97472],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[97685,97820,98243,97478,97552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[98214,97568,97644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[98104],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[86912,87710,87728,88487],"length":1,"stats":{"Line":2},"fn_name":"next_grid\u003c\u0026aoc_grid::extend::GridExtend\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_24::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e\u003e"},{"line":34,"address":[86934,87753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[88825,88672,88691,88496,88515,88646],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_24::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e\u003e"},{"line":38,"address":[88139,87312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[88147,87320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[84209,84429],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[50362,50096,50166,50292],"length":1,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[89264,89328],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_24::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e\u003e"},{"line":44,"address":[50407,50192,50215,50434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[57358,57440,57011,56965,56988,57390],"length":1,"stats":{"Line":9},"fn_name":null},{"line":46,"address":[57018,57406,57001,57449],"length":1,"stats":{"Line":5},"fn_name":null},{"line":49,"address":[87568,88343],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[89392,89398],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":59,"address":[98384,99730],"length":1,"stats":{"Line":2},"fn_name":"get_start_grid"},{"line":60,"address":[98540,98791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[89408],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":63,"address":[67106,67201],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[67151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[98830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[89648],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":71,"address":[65845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[65895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[98837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[98890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[99046,99001,99498],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[99080,99119,99188,99677],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[99427],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[99458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[99744,101343],"length":1,"stats":{"Line":1},"fn_name":"part_two_bits"},{"line":87,"address":[101072,99772,99814],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[99876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[99889,99898,100531],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[100046,100716,99989],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[67725,67672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[100187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[100062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[49881,49830],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[100496,101260,100476,100514],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[66448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[101360],"length":1,"stats":{"Line":1},"fn_name":"grid_to_bits"},{"line":106,"address":[101641],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[101849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[59705,59744,59291,59253],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[59739,59281],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[102352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[84384],"length":1,"stats":{"Line":0},"fn_name":"call_once\u003c(u128), aoc_2020_day_24::logic::next_grid_bits::{closure_env#0}\u003e"},{"line":122,"address":[90238,90224],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":124,"address":[90634,90271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[90460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[90368,90496,90456],"length":1,"stats":{"Line":3},"fn_name":null},{"line":127,"address":[90404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[90421],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[90499,90464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[90513,90540,90685,90478,90592],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[90595,90587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[90608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[90621],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":62,"coverable":67},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-24","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Dir = aoc_pos::DirGeoHexLat;\n//pub type Grid = GridBuf \u003caoc_bitvec::BitVec \u003cTile\u003e, Pos, 2\u003e;\npub type Grid = GridBuf \u003cVec \u003cTile\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosGeoHexLat \u003cCoord\u003e;\n\n/*\npub trait Grid: GridView \u003cPos, 2, Item = Tile\u003e + GridViewIter \u003cPos, 2, Item = Tile\u003e {\n}\n\nimpl \u003cSomeGrid\u003e Grid for SomeGrid\n\twhere SomeGrid: GridView \u003cPos, 2, Item = Tile\u003e + GridViewIter \u003cPos, 2, Item = Tile\u003e {\n}\n*/\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Step {\n\t\tEast = \"e\",\n\t\tSouthEast = \"se\",\n\t\tSouthWest = \"sw\",\n\t\tWest = \"w\",\n\t\tNorthWest = \"nw\",\n\t\tNorthEast = \"ne\",\n\t}\n}\n\n#[ allow (clippy::fallible_impl_from) ]\nimpl From \u003cStep\u003e for Pos {\n\tfn from (step: Step) -\u003e Self {\n\t\tmatch step {\n\t\t\tStep::East =\u003e Self::ZERO.east (1).unwrap (),\n\t\t\tStep::SouthEast =\u003e Self::ZERO.south_east (1).unwrap (),\n\t\t\tStep::SouthWest =\u003e Self::ZERO.south_west (1).unwrap (),\n\t\t\tStep::West =\u003e Self::ZERO.west (1).unwrap (),\n\t\t\tStep::NorthWest =\u003e Self::ZERO.north_west (1).unwrap (),\n\t\t\tStep::NorthEast =\u003e Self::ZERO.north_east (1).unwrap (),\n\t\t}\n\t}\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Tile {\n\t\t#[ default ]\n\t\tWhite = \"  \",\n\t\tBlack = \" \",\n\t}\n}\n\nimpl aoc_bitvec::BitVecNative for Tile {\n\tconst BITS: u32 = 1;\n\t#[ inline ]\n\tfn encode (self) -\u003e usize {\n\t\tmatch self {\n\t\t\tSelf::White =\u003e 0b_0_usize,\n\t\t\tSelf::Black =\u003e 0b_1_usize,\n\t\t}\n\t}\n\t#[ inline ]\n\tfn decode (val: usize) -\u003e Self {\n\t\tmatch val {\n\t\t\t0b_0_usize =\u003e Self::White,\n\t\t\t0b_1_usize =\u003e Self::Black,\n\t\t\t_ =\u003e unreachable! (),\n\t\t}\n\t}\n}\n","traces":[{"line":32,"address":[48192],"length":1,"stats":{"Line":2},"fn_name":"from"},{"line":33,"address":[48197],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[112809,115097],"length":1,"stats":{"Line":8},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-25","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"5764801\",\n\t\"17807724\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"14897079\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":11,"address":[32423,30996,32032],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":12,"address":[32042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[32063,32210,32380,32153,32101,32276],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-25","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub pub_key_0: u32,\n\tpub pub_key_1: u32,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { pub_key_0, pub_key_1, params } = [ params, pub_key_0, \"\\n\", pub_key_1 ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-25","lib.rs"],"content":"//! Advent of Code 2020: Day 25: Combo Breaker\n//!\n//! [https://adventofcode.com/2020/day/25](https://adventofcode.com/2020/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Combo Breaker\";\n\tyear = 2020;\n\tday = 25;\n\tparse = |input| input::Input::parse_from_lines (input);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n","traces":[{"line":18,"address":[34475],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","day-25","logic.rs"],"content":"//! Logic for solving the puzzles\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet pub_key_0 = input.pub_key_0.pan_u64 ();\n\tlet pub_key_1 = input.pub_key_1.pan_u64 ();\n\tlet mut val = 1_u64;\n\tlet mut num_loops = 0_u32;\n\tlet pub_key = loop {\n\t\tif val == pub_key_0 { break pub_key_1 }\n\t\tif val == pub_key_1 { break pub_key_0 }\n\t\tval = chk! ((val * 7) % 20_201_227) ?;\n\t\tnum_loops += 1;\n\t\tif num_loops == 1_000_000 { return Err (\"Giving up after one million loops\".into ()) }\n\t};\n\tval = 1_u64;\n\tfor _ in 0 .. num_loops {\n\t\tval = chk! ((val * pub_key) % 20_201_227) ?;\n\t}\n\tOk (val.pan_u32 ())\n}\n","traces":[{"line":7,"address":[23168],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[23186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[23251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[23312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[23321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[23388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[23408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[23455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[23550],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[23661],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2020","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2020_day_01 as day_01;\npub use aoc_2020_day_02 as day_02;\npub use aoc_2020_day_03 as day_03;\npub use aoc_2020_day_04 as day_04;\npub use aoc_2020_day_05 as day_05;\npub use aoc_2020_day_06 as day_06;\npub use aoc_2020_day_07 as day_07;\npub use aoc_2020_day_08 as day_08;\npub use aoc_2020_day_09 as day_09;\npub use aoc_2020_day_10 as day_10;\npub use aoc_2020_day_11 as day_11;\npub use aoc_2020_day_12 as day_12;\npub use aoc_2020_day_13 as day_13;\npub use aoc_2020_day_14 as day_14;\npub use aoc_2020_day_15 as day_15;\npub use aoc_2020_day_16 as day_16;\npub use aoc_2020_day_17 as day_17;\npub use aoc_2020_day_18 as day_18;\npub use aoc_2020_day_19 as day_19;\npub use aoc_2020_day_20 as day_20;\npub use aoc_2020_day_21 as day_21;\npub use aoc_2020_day_22 as day_22;\npub use aoc_2020_day_23 as day_23;\npub use aoc_2020_day_24 as day_24;\npub use aoc_2020_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-01","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"199\", \"200\", \"208\", \"210\", \"200\", \"207\", \"240\", \"269\", \"260\", \"263\"\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"7\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":10,"address":[23312,23316],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":11,"address":[38730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[38964,39068,38841,38751,38789,38898],"length":1,"stats":{"Line":3},"fn_name":null},{"line":16,"address":[23344,23348],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":17,"address":[39130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[39298,39241,39364,39468,39151,39189],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-01","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub report: Vec \u003cu16\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { report, params } = [ params, @lines report ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[34566,35067],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-01","lib.rs"],"content":"//! Advent of Code 2021: Day 1: Sonar Sweep\n//!\n//! [https://adventofcode.com/2021/day/1](https://adventofcode.com/2021/day/1)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Sonar Sweep\";\n\tyear = 2021;\n\tday = 1;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[45848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[46168],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-01","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.report.iter ().copied ()\n\t\t\t.tuple_windows ()\n\t\t\t.filter (|\u0026 (a, b)| a \u003c b)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.report.iter ().copied ()\n\t\t\t.tuple_windows ()\n\t\t\t.filter (|\u0026 (a, _, _, b)| a \u003c b)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n","traces":[{"line":5,"address":[24448],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[22315,21643,22720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[24848],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":19,"address":[22679,22552,21880],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"forward 5\",\n\t\"down 5\",\n\t\"forward 8\",\n\t\"up 3\",\n\t\"down 8\",\n\t\"forward 2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"150\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"900\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":15,"address":[22068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[42602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[42770,42940,42713,42661,42623,42836],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[22244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[43002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[43236,43061,43023,43113,43170,43340],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","input.rs"],"content":"use super::*;\n\nuse model::Command;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub commands: Vec \u003cCommand\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { commands, params } = [ params, @lines commands ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[21803],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","lib.rs"],"content":"//! Advent of Code 2021: Day 2: Dive!\n//!\n//! [https://adventofcode.com/2021/day/2](https://adventofcode.com/2021/day/2)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Dive!\";\n\tyear = 2021;\n\tday = 2;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[33352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[33672],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Command;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tlet mut distance = 0_i32;\n\tlet mut depth = 0_i32;\n\tfor \u0026 cmd in \u0026 input.commands {\n\t\tmatch cmd {\n\t\t\tCommand::Forward (val) =\u003e chk! (distance += val.pan_i32 ()) ?,\n\t\t\tCommand::Down (val) =\u003e chk! (depth += val.pan_i32 ()) ?,\n\t\t\tCommand::Up (val) =\u003e chk! (depth -= val.pan_i32 ()) ?,\n\t\t}\n\t}\n\tOk (chk! (distance * depth) ?)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci32\u003e {\n\tlet mut distance = 0_i32;\n\tlet mut depth = 0_i32;\n\tlet mut aim = 0_i32;\n\tfor \u0026 cmd in \u0026 input.commands {\n\t\tmatch cmd {\n\t\t\tCommand::Forward (val) =\u003e {\n\t\t\t\tchk! (distance += val.pan_i32 ()) ?;\n\t\t\t\tchk! (depth += aim * val.pan_i32 ()) ?;\n\t\t\t},\n\t\t\tCommand::Down (val) =\u003e aim += val.pan_i32 (),\n\t\t\tCommand::Up (val) =\u003e aim -= val.pan_i32 (),\n\t\t}\n\t}\n\tOk (chk! (distance * depth) ?)\n}\n","traces":[{"line":6,"address":[41504],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":9,"address":[41616,41819,41564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[41631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[41793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[44304],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":13,"address":[39179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[41854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[41936],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":23,"address":[42004,42080,42412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[42095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[42295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[42387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[42218,42554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[42148,42527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[42458],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":13,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","model.rs"],"content":"use super::*;\n\npub type Val = u16;\n\n#[ derive (Clone, Copy, Debug) ]\npub enum Command {\n\tDown (Val),\n\tUp (Val),\n\tForward (Val),\n}\n\nenum_parser_display! {\n\tCommand,\n\tForward (val) = [ \"forward \", val ],\n\tDown (val) = [ \"down \", val ],\n\tUp (val) = [ \"up \", val ],\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-03","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"00100\", \"11110\", \"10110\", \"10111\", \"10101\", \"01111\",\n\t\"00111\", \"11100\", \"10000\", \"11001\", \"00010\", \"01010\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"198\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"230\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[27764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[33642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[33663,33876,33980,33701,33753,33810],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[27796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[34042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[34210,34101,34063,34380,34276,34153],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-03","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub readings: Vec \u003cu16\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { readings, params } = [\n\t\tparams,\n\t\t@lines readings = (reading_parse, reading_display),\n\t ]\n}\n\nfn reading_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu16\u003e {\n\tlet rest = parser.take_rest_while (|ch| ('0' ..= '1').contains (\u0026 ch), 1 .. 16) ?;\n\tOk (u16::from_str_radix (\u0026 rest, 2).unwrap ())\n}\n\nfn reading_display (reading: \u0026 u16, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\twrite! (formatter, \"{reading:012b}\")\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[27419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[39216,39462],"length":1,"stats":{"Line":2},"fn_name":"reading_parse"},{"line":17,"address":[27829],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[39366,39348],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-03","lib.rs"],"content":"//! Advent of Code 2021: Day 3: Binary Diagnostic\n//!\n//! [https://adventofcode.com/2021/day/3](https://adventofcode.com/2021/day/3)\n//!\n//! # Input\n//!\n//! Readings as binary numbers, one per line.\n//!\n//! # Part one\n//!\n//! Find the most common binary digit, `0` or `1`, in each position, and construct a value using\n//! those digits in those places. Do the same for the least common, then return their product.\n//!\n//! # Part two\n//!\n//! Starting with the most significant digit, keep all readings where this digit has the most\n//! common value, or `1` if there is a tie. Repeat with subsequent digits until only one remains.\n//! Repeat with the least common value, using `0` for a tie, then return the product of the two\n//! outcomes.\n//!\n//! # Algorithm\n//!\n//! Just follow the instructions, there's nothing clever here. I have some helper functions, one to\n//! iterate bits from the highest to the lowest, and another to check if there are more ones or\n//! zeros in a given position, or if there is a tie. For part two I have a function which is used\n//! for both calculations, which accepts a function to decide which bit value to keep, instead of\n//! duplicating all the logic twice.\n//!\n//! I cheat a little, converting the numbers to [`u16`] in the parsing phase and discarding the\n//! number of digits. Instead I use the most significant set bit in the list of readings to\n//! determine the bits to consider. This makes fuzzing easier, and doesn't affect the output for\n//! the examples I've seen.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Binary Diagnostic\";\n\tyear = 2021;\n\tday = 3;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":47,"address":[36920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[37240],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-03","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.readings.is_empty () { return Err (\"No readings provided\".into ()) }\n\tlet (gamma, epsilon) = iter_bits (\u0026 input.readings)\n\t\t.try_fold ((0, 0), |(gamma, epsilon), bit| {\n\t\t\tmatch count_ones (\u0026 input.readings, bit) {\n\t\t\t\tOrdering::Less =\u003e Ok ((gamma, epsilon | bit)),\n\t\t\t\tOrdering::Equal =\u003e Err (\"No solution found\"),\n\t\t\t\tOrdering::Greater =\u003e Ok ((gamma | bit, epsilon)),\n\t\t\t}\n\t\t}) ?;\n\tOk (gamma.pan_u32 () * epsilon.pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tuse Ordering::{ Less, Equal, Greater };\n\tif input.readings.is_empty () { return Err (\"No readings provided\".into ()) }\n\tlet oxygen = calc_rating (\u0026 input.readings, |ord| matches! (ord, Equal | Greater)) ?;\n\tlet co2 = calc_rating (\u0026 input.readings, |ord| matches! (ord, Less)) ?;\n\tOk (oxygen.pan_u32 () * co2.pan_u32 ())\n}\n\nfn calc_rating (readings: \u0026 [u16], keep_fn: fn (Ordering) -\u003e bool) -\u003e GenResult \u003cu16\u003e {\n\tlet mut readings = readings.to_vec ();\n\tlet mut bits_iter = iter_bits (\u0026 readings);\n\tloop {\n\t\tif readings.is_empty () { return Err (\"No solution found\".into ()) }\n\t\tif readings.len () == 1 { return Ok (readings [0]) }\n\t\tlet bit = some_or! (bits_iter.next (), break);\n\t\tlet keep = if keep_fn (count_ones (\u0026 readings, bit)) { bit } else { 0 };\n\t\treadings.retain (|\u0026 rdng| (rdng \u0026 bit) == keep);\n\t}\n\tErr (\"No solution found\".into ())\n}\n\nfn iter_bits (readings: \u0026 [u16]) -\u003e impl Iterator \u003cItem = u16\u003e {\n\tlet max = readings.iter ().copied ().max ().unwrap ();\n\tlet high = if 0 \u003c max { 0x8000 \u003e\u003e max.leading_zeros () } else { 0 };\n\titertools::iterate (high, |\u0026 bit| bit \u003e\u003e 1_u32)\n\t\t.take_while (|\u0026 bit| bit != 0)\n}\n\nfn count_ones (readings: \u0026 [u16], bit: u16) -\u003e Ordering {\n\tlet num_ones =\n\t\treadings.iter ().copied ()\n\t\t\t.filter (|\u0026 rdng| rdng \u0026 bit != 0)\n\t\t\t.count ();\n\t(num_ones * 2).cmp (\u0026 readings.len ())\n}\n","traces":[{"line":5,"address":[31552],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":6,"address":[31661,31576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":7,"address":[32027,31604,31639],"length":1,"stats":{"Line":3},"fn_name":null},{"line":8,"address":[50080],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":9,"address":[50254,50108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[50311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[50289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[31902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[32126,32192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[32208],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[32232,32312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[32248,32339],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[50432],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":23,"address":[32541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[33268,32592],"length":1,"stats":{"Line":1},"fn_name":"calc_rating"},{"line":28,"address":[32781],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[33027,32805],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[33073],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[32855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[32896,32956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[50448],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[33094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[33280],"length":1,"stats":{"Line":1},"fn_name":"iter_bits"},{"line":40,"address":[33466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[33482,33499],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[41958,41801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[31784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[33536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[34592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[32930,31849,32165,33565,33592,33152],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":25,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1\",\n\t\"\",\n\t\"22 13 17 11  0\",\n\t\" 8  2 23  4 24\",\n\t\"21  9 14 16  7\",\n\t\" 6 10  3 18  5\",\n\t\" 1 12 20 15 19\",\n\t\"\",\n\t\" 3 15  0  2 22\",\n\t\" 9 18 13 17  5\",\n\t\"19  8  7 25 23\",\n\t\"20 11 10 24  4\",\n\t\"14 21 16 12  6\",\n\t\"\",\n\t\"14 21 17 24  4\",\n\t\"10 16 15  9 19\",\n\t\"18  8 23 26 20\",\n\t\"22 11 13  6  5\",\n\t\" 2  0 12  3  7\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4512\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1924\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":28,"address":[51140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[66650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[66818,66988,66761,66709,66671,66884],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[51380],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[67050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[67388,67071,67218,67284,67109,67161],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","input.rs"],"content":"use super::*;\n\nuse model::Board;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub call_order: Vec \u003cu8\u003e,\n\tpub boards: Vec \u003cBoard\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { call_order, boards, params } = [\n\t\tparams,\n\t\t@delim \",\" call_order, \"\\n\",\n\t\t\"\\n\",\n\t\t@delim \"\\n\\n\" boards = (board_parse, board_display),\n\t ]\n}\n\nfn board_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cBoard\u003e {\n\tparser.nest (|parser| {\n\t\tparser.set_ignore_whitespace (true);\n\t\tparser.item ()\n\t})\n}\n\nfn board_display (board: \u0026 Board, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\tboard.display_with_delim (\" \", formatter)\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[43181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[42800],"length":1,"stats":{"Line":0},"fn_name":"board_parse"}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","lib.rs"],"content":"//! Advent of Code 2021: Day 4: Giant Squid\n//!\n//! [https://adventofcode.com/2021/day/4](https://adventofcode.com/2021/day/4)\n//!\n//! # Input\n//!\n//! TODO\n//!\n//! # Part one\n//!\n//! Work out which board will win first. Add up all numbers which haven't been called and multiply\n//! by the last number called.\n//!\n//! # Part two\n//!\n//! Same as part two, but for the last board to win.\n//!\n//! # Algorithm\n//!\n//! For each board we work which turn it will win, find the lowest/highest, and then work out the\n//! score.\n//!\n//! To work out the winning turn, we create a new board replacing the numbers with the turn on\n//! which they are called. We then find the highest turn from each line, and then the lowest of\n//! these is the turn on which the board will win.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod model;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Giant Squid\";\n\tyear = 2021;\n\tday = 4;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":43,"address":[49056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[49536],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Board;\nuse model::Dir;\nuse model::Grid;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\tinput.boards.iter ()\n\t\t\t.filter_map (|board| calc_win_turn (input, board).map (|turn| (board, turn)))\n\t\t\t.min_by_key (|\u0026 (_, turn)| turn)\n\t\t\t.map (|(board, turn)| calc_score (input, board, turn))\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\tinput.boards.iter ()\n\t\t\t.filter_map (|board| calc_win_turn (input, board).map (|turn| (board, turn)))\n\t\t\t.max_by_key (|\u0026 (_, turn)| turn)\n\t\t\t.map (|(board, turn)| calc_score (input, board, turn))\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.boards.is_empty () {\n\t\treturn Err (\"Must have at least one board\".into ());\n\t}\n\tfor board in \u0026 input.boards {\n\t\tif board.size ().row \u003c 2 || board.size ().col \u003c 2 {\n\t\t\treturn Err (\"Board size must be at least 22\".into ());\n\t\t}\n\t}\n\tOk (())\n}\n\nfn calc_win_turn (input: \u0026 Input, board: \u0026 Board) -\u003e Option \u003cu16\u003e {\n\tlet call_order = \u0026 input.call_order;\n\tlet turns: Grid \u003cOption \u003cu16\u003e\u003e =\n\t\tboard.map (|cur| {\n\t\t\tlet num = cur.get (board);\n\t\t\tcall_order.iter ()\n\t\t\t\t.position (|\u0026 called_num| called_num == num)\n\t\t\t\t.map (usize::pan_u16)\n\t\t});\n\tlet turns = \u0026 turns;\n\tlet down = turns.offset (Dir::Down.into ()).unwrap ();\n\tlet right = turns.offset (Dir::Right.into ()).unwrap ();\n\tlet cur = turns.cursor (Pos::ZERO).unwrap ();\n\t[ (down, right), (right, down) ].into_iter ()\n\t\t.flat_map (|(dir_0, dir_1)| cur.walk (dir_0)\n\t\t\t.map (move |cur| cur.walk (dir_1)\n\t\t\t\t.map (|cur| cur.get (turns))\n\t\t\t\t.max ()\n\t\t\t\t.unwrap ()))\n\t\t.flatten ()\n\t\t.min ()\n}\n\nfn calc_score (input: \u0026 Input, board: \u0026 Board, turn: u16) -\u003e u32 {\n\tlet called = \u0026 input.call_order [ .. turn.pan_usize () + 1];\n\tlet uncalled_sum: u32 =\n\t\tboard.values ()\n\t\t\t.filter (|\u0026 num| ! called.contains (\u0026 num))\n\t\t\t.map (u8::pan_u32)\n\t\t\t.sum ();\n\tcalled [called.len () - 1].pan_u32 () * uncalled_sum\n}\n","traces":[{"line":9,"address":[64352],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[64368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[64534,64499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[44135,48034,48000,48032,48004,48021],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[48048],"length":1,"stats":{"Line":1},"fn_name":"{closure#2}"},{"line":20,"address":[64576],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[64592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[64758,64723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[38579,39348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[64746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[64800],"length":1,"stats":{"Line":1},"fn_name":"check_input"},{"line":32,"address":[64815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[64928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[64875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[64890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[64914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[66171,64976],"length":1,"stats":{"Line":1},"fn_name":"calc_win_turn"},{"line":47,"address":[44434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[44498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[44560,48128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[65185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[65348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[65507],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[40724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[50201],"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[41004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[48199,48260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[66192],"length":1,"stats":{"Line":1},"fn_name":"calc_score"},{"line":67,"address":[66266,66551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[48502,48433,48432],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":73,"address":[66578,66465,66532],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","model.rs"],"content":"use super::*;\n\npub type Board = Grid \u003cu8\u003e;\npub type Coord = i8;\npub type Dir = pos::Dir2d;\npub type Grid \u003cVal\u003e = GridBuf \u003cVec \u003cVal\u003e, Pos, 2\u003e;\npub type Pos = pos::PosRowCol \u003ci8\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"0,9 -\u003e 5,9\",\n\t\"8,0 -\u003e 0,8\",\n\t\"9,4 -\u003e 3,4\",\n\t\"2,2 -\u003e 2,1\",\n\t\"7,0 -\u003e 7,4\",\n\t\"6,4 -\u003e 2,0\",\n\t\"0,9 -\u003e 2,9\",\n\t\"3,4 -\u003e 1,4\",\n\t\"0,0 -\u003e 8,8\",\n\t\"5,5 -\u003e 8,2\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () -\u003e GenResult \u003c()\u003e {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"12\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","input.rs"],"content":"use super::*;\n\nuse model::Vent;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub vents: Vec \u003cVent\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { vents, params } = [ params, @lines vents ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","lib.rs"],"content":"//! Advent of Code 2021: Day 5: Hydrothermal Venture\n//!\n//! [https://adventofcode.com/2021/day/5](https://adventofcode.com/2021/day/5)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Hydrothermal Venture\";\n\tyear = 2021;\n\tday = 5;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Grid;\nuse model::Pos;\nuse nums::IntConv;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tcalc_result (input, false)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tcalc_result (input, true)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tfor \u0026 vent in \u0026 input.vents {\n\t\tif ! vent.is_valid () {\n\t\t\treturn Err (format! (\"Vent is at an invalid angle: {vent:?}\").into ());\n\t\t}\n\t}\n\tOk (())\n}\n\nfn calc_result (input: \u0026 Input, include_diagonal: bool) -\u003e GenResult \u003cu32\u003e {\n\tlet vents: Vec \u003c_\u003e =\n\t\tinput.vents.iter ()\n\t\t\t.filter (|vent| include_diagonal || ! vent.is_diagonal ())\n\t\t\t.collect ();\n\tlet (start, end) = vents.iter ()\n\t\t.flat_map (|vent| [ vent.start, vent.end ])\n\t\t.fold ((Pos::ZERO, Pos::new (1, 1)), |(min, max), pos| (\n\t\t\tPos::new (cmp::min (min.y, pos.y), cmp::min (min.x, pos.x)),\n\t\t\tPos::new (cmp::max (max.y, pos.y + 1), cmp::max (max.x, pos.x + 1))));\n\tlet mut grid: Grid = Grid::new_range (start, end) ?;\n\tfor vent in vents {\n\t\tlet step = Pos::new (\n\t\t\t(vent.end.y - vent.start.y).signum (),\n\t\t\t(vent.end.x - vent.start.x).signum ());\n\t\tlet mut pos = vent.start;\n\t\tloop {\n\t\t\t* grid.get_mut (pos).unwrap () += 1;\n\t\t\tif pos == vent.end { break }\n\t\t\tpos += step;\n\t\t}\n\t}\n\tOk (\n\t\tgrid.values ()\n\t\t\t.filter (|\u0026 num| 1 \u003c num)\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cVal\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Val = u16;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub struct Vent {\n\tpub start: Pos,\n\tpub end: Pos,\n}\n\nstruct_parser_display! {\n\tVent {\n\t\tstart: Pos { y: start_y, x: start_x },\n\t\tend: Pos { y: end_y, x: end_x },\n\t} = [\n\t\tstart_x, \",\", start_y, \" -\u003e \",\n\t\tend_x, \",\", end_y,\n\t]\n}\n\nimpl Vent {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_point (self) -\u003e bool {\n\t\tself.start.y == self.end.y \u0026\u0026 self.start.x == self.end.x\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_straight (self) -\u003e bool {\n\t\t(self.start.y == self.end.y) != (self.start.x == self.end.x)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_diagonal (self) -\u003e bool {\n\t\tself.start.y != self.end.y \u0026\u0026 self.start.x != self.end.x\n\t\t\t\u0026\u0026 (self.end.y - self.start.y).unsigned_abs ()\n\t\t\t\t== (self.end.x - self.start.x).unsigned_abs ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_valid (self) -\u003e bool {\n\t\tself.is_point () || self.is_straight () || self.is_diagonal ()\n\t}\n\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-06","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"3,4,3,1,2\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"5934\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"26984457539\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[25108],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[41194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[41215,41253,41305,41362,41428,41532],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[25076],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[41594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[41705,41932,41615,41653,41762,41828],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-06","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub fish: Vec \u003cu8\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { fish, params } = [ params, @delim \",\" fish = (0 ..= 8) ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[22036],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-06","lib.rs"],"content":"//! Advent of Code 2021: Day 6: Lanternfish\n//!\n//! [https://adventofcode.com/2021/day/6](https://adventofcode.com/2021/day/6)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Lanternfish\";\n\tyear = 2021;\n\tday = 6;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-06","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, 80)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, 256)\n}\n\npub fn calc_result (input: \u0026 Input, days: u32) -\u003e GenResult \u003cu64\u003e {\n\tlet mut fishes: [u64; 9] = [0; 9];\n\tfor \u0026 fish in \u0026 input.fish {\n\t\tfishes [fish.pan_usize ()] += 1;\n\t}\n\tfor _ in 0 .. days {\n\t\tfishes = [\n\t\t\tfishes [1],\n\t\t\tfishes [2],\n\t\t\tfishes [3],\n\t\t\tfishes [4],\n\t\t\tfishes [5],\n\t\t\tfishes [6],\n\t\t\tfishes [7] + fishes [0],\n\t\t\tfishes [8],\n\t\t\tfishes [0],\n\t\t];\n\t}\n\tOk (fishes.into_iter ().sum::\u003cu64\u003e ())\n}\n","traces":[{"line":5,"address":[38912],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":6,"address":[37352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[38944],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":10,"address":[37688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[38976],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":14,"address":[39001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[39186,39053],"length":1,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[39623,39159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[39243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[39288,39706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[39594],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":9,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-07","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"16,1,2,0,4,2,7,1,2,14\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"37\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"168\", puzzle.part_two (EXAMPLE));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-07","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub crabs: Vec \u003cu16\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { crabs, params } = [ params, @delim \",\" crabs = (0 ..= 9_999) ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-07","lib.rs"],"content":"//! Advent of Code 2021: Day 7: The Treachery of Whales\n//!\n//! [https://adventofcode.com/2021/day/7](https://adventofcode.com/2021/day/7)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub mod logic;\npub mod input;\n\npuzzle_info! {\n\tname = \"The Treachery of Whales\";\n\tyear = 2021;\n\tday = 7;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-07","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet crabs_map = get_crabs_map (input) ?;\n\tOk (\n\t\tcalc_result (\n\t\t\tget_crabs_range (input),\n\t\t\t(0, 0),\n\t\t\t|\u0026 mut (ref mut fuel, ref mut crabs), pos| {\n\t\t\t\t* fuel += * crabs;\n\t\t\t\t* crabs += crabs_map.get (\u0026 pos).copied ().unwrap_or (0).pan_u64 ();\n\t\t\t\tSome (* fuel)\n\t\t\t})\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet crabs_map = get_crabs_map (input) ?;\n\tOk (\n\t\tcalc_result (\n\t\t\tget_crabs_range (input),\n\t\t\t(0, 0, 0),\n\t\t\t|\u0026 mut (ref mut fuel, ref mut incr, ref mut crabs), pos| {\n\t\t\t\t* incr += * crabs;\n\t\t\t\t* fuel += * incr;\n\t\t\t\t* crabs += crabs_map.get (\u0026 pos).copied ().unwrap_or (0).pan_u64 ();\n\t\t\t\tSome (* fuel)\n\t\t\t})\n\t)\n}\n\nfn get_crabs_range (input: \u0026 Input) -\u003e RangeInclusive \u003cu16\u003e {\n\tlet min = input.crabs.iter ().copied ().min ().unwrap ();\n\tlet max = input.crabs.iter ().copied ().max ().unwrap ();\n\tmin ..= max\n}\n\nfn get_crabs_map (input: \u0026 Input) -\u003e GenResult \u003cHashMap \u003cu16, u16\u003e\u003e {\n\tif input.crabs.is_empty () {\n\t\treturn Err (\"Must provide at least one crab position\".into ());\n\t}\n\tOk (\n\t\tinput.crabs.iter ().copied ()\n\t\t\t.fold (HashMap::new (), |mut all_crabs, crab| {\n\t\t\t\tall_crabs.entry (crab).and_modify (|num| * num += 1).or_insert (1);\n\t\t\t\tall_crabs\n\t\t\t})\n\t)\n}\n\nfn calc_result \u003cState, ScanFn\u003e (\n\tpos_range: RangeInclusive \u003cu16\u003e,\n\tinitial_state: State,\n\tscan_fn: ScanFn,\n) -\u003e u64\n\twhere\n\t\tScanFn: Fn (\u0026 mut State, u16) -\u003e Option \u003cu64\u003e + Clone,\n\t\tState: Copy {\n\titer::zip (\n\t\t\tpos_range.clone ().scan (initial_state, scan_fn.clone ()),\n\t\t\tpos_range.rev ()\n\t\t\t\t.scan (initial_state, scan_fn)\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t\t\t\t.into_iter ()\n\t\t\t\t.rev ())\n\t\t.map (|(lower, higher)| lower + higher)\n\t\t.min ()\n\t\t.unwrap ()\n}\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe\",\n\t\"edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc\",\n\t\"fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg\",\n\t\"fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb\",\n\t\"aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea\",\n\t\"fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb\",\n\t\"dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe\",\n\t\"bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef\",\n\t\"egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb\",\n\t\"gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"26\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"61229\", puzzle.part_two (EXAMPLE));\n}\n\n#[ test ]\nfn part_two_solver () {\n\tlet puzzle = puzzle_metadata ();\n\tlet lines: Vec \u003c\u0026 str\u003e =\n\t\t[ \"USE_SOLVER=true\" ].into_iter ()\n\t\t\t.chain (EXAMPLE.iter ().copied ())\n\t\t\t.collect ();\n\tassert_eq_ok! (\"61229\", puzzle.part_two (\u0026 lines));\n}\n","traces":[{"line":19,"address":[105456,105847],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":20,"address":[105466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[105700,105487,105577,105525,105804,105634],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[106247,105856],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":26,"address":[105866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[105887,106034,106204,106100,105925,105977],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[106845,106256],"length":1,"stats":{"Line":2},"fn_name":"part_two_solver"},{"line":32,"address":[106269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[106329,106773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[106428,106472,106664,106527,106788,106598],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","input.rs"],"content":"use super::*;\n\nuse model::Display;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub displays: Vec \u003cDisplay\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { displays, params } = [ params, @lines displays ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub use_solver: bool = (\"USE_SOLVER=\", false, false ..= true ),\n\t}\n}\n","traces":[{"line":12,"address":[68767,67479],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","lib.rs"],"content":"//! Advent of Code 2021: Day 8: Seven Segment Search\n//!\n//! [https://adventofcode.com/2021/day/8](https://adventofcode.com/2021/day/8)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\nmod solver;\n\npuzzle_info! {\n\tname = \"Seven Segment Search\";\n\tyear = 2021;\n\tday = 8;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Digit;\nuse model::Display;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tOk (\n\t\tinput.displays.iter ()\n\t\t\t.flat_map (|display| display.value.iter ().copied ()\n\t\t\t\t.map (Digit::num_segments))\n\t\t\t.filter (|\u0026 num_segments| matches! (num_segments, 2 | 3 | 4 | 7))\n\t\t\t.count ()\n\t\t\t.pan_u32 ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tif input.params.use_solver {\n\t\tsolver::part_two (input)\n\t} else {\n\t\tbits::part_two (input)\n\t}\n}\n\nfn decode_value (display: Display, digits: [u8; 10]) -\u003e GenResult \u003cu16\u003e {\n\tlet decode =\n\t\t|digit: Digit| digits.iter ()\n\t\t\t.position (|\u0026 val| digit.on () == val)\n\t\t\t.map (usize::pan_u16)\n\t\t\t.ok_or (\"No solution found\");\n\tdisplay.value.iter ()\n\t\t.try_fold (0_u16, |sum, \u0026 digit| Ok (sum * 10 + decode (digit) ?))\n}\n\nmod bits {\n\n\tuse super::*;\n\n\tpub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\t\n\t\tinput.displays.iter ()\n\t\t\t.map (|\u0026 display| decode_display (display))\n\t\t\t.try_fold (0_u32, |sum, val| Ok (sum + val ?.pan_u32 ()))\n\t}\n\n\tfn decode_display (display: Display) -\u003e GenResult \u003cu16\u003e {\n\t\tdecode_value (display, get_digits (display) ?)\n\t}\n\n\tfn get_digits (display: Display) -\u003e GenResult \u003c[u8; 10]\u003e {\n\t\tlet mut temp = display.digits.map (Digit::num_segments);\n\t\ttemp.sort ();\n\t\tif temp != [2, 3, 4, 5, 5, 5, 6, 6, 6, 7] {\n\t\t\treturn Err (\"No solution found\".into ());\n\t\t}\n\t\tlet [mut segs_acf, mut segs_bcdf, mut segs_bcef, mut segs_cde, mut segs_cf] = [0; 5];\n\t\tlet segs_abcdefg = 0x7f;\n\t\tfor \u0026 digit in \u0026 display.digits {\n\t\t\tmatch digit.num_segments () {\n\t\t\t\t2 =\u003e segs_cf = digit.on (),\n\t\t\t\t3 =\u003e segs_acf = digit.on (),\n\t\t\t\t4 =\u003e segs_bcdf = digit.on (),\n\t\t\t\t5 =\u003e segs_bcef |= digit.off (),\n\t\t\t\t6 =\u003e segs_cde |= digit.off (),\n\t\t\t\t7 =\u003e (),\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t}\n\t\tlet seg_a = segs_acf \u0026 ! segs_cf;\n\t\tlet seg_d = segs_cde \u0026 ! segs_bcef;\n\t\tlet seg_b = segs_bcdf \u0026 ! (segs_cf | seg_d);\n\t\tlet seg_f = segs_cf \u0026 ! segs_cde;\n\t\tlet seg_c = segs_cf \u0026 ! seg_f;\n\t\tlet seg_e = segs_cde \u0026 ! (seg_c | seg_d);\n\t\tlet seg_g = segs_abcdefg \u0026 ! (segs_bcdf | seg_a | seg_e);\n\t\tOk ([\n\t\t\tsegs_abcdefg \u0026 ! seg_d,\n\t\t\tseg_c | seg_f,\n\t\t\tsegs_abcdefg \u0026 ! (seg_b | seg_f),\n\t\t\tsegs_abcdefg \u0026 ! (seg_b | seg_e),\n\t\t\tsegs_abcdefg \u0026 ! (seg_a | seg_e | seg_g),\n\t\t\tsegs_abcdefg \u0026 ! (seg_c | seg_e),\n\t\t\tsegs_abcdefg \u0026 ! seg_c,\n\t\t\tseg_a | seg_c | seg_f,\n\t\t\tsegs_abcdefg,\n\t\t\tsegs_abcdefg \u0026 ! seg_e,\n\t\t])\n\t}\n\n}\n\nmod solver {\n\n\tuse super::*;\n\tuse crate::solver::*;\n\n\tpub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\t\n\t\tlet solver = DigitsSolver::build ();\n\t\tinput.displays.iter ()\n\t\t\t.map (|\u0026 display| decode_display (\u0026 solver, display))\n\t\t\t.try_fold (0_u32, |sum, val| Ok (sum + val ?.pan_u32 ()))\n\t}\n\n\tfn decode_display (solver: \u0026 DigitsSolver, display: Display) -\u003e GenResult \u003cu16\u003e {\n\t\tdecode_value (display, solver.solve (display.digits) ?)\n\t}\n\n\tpub struct DigitsSolver {\n\t\tsolver: Solver \u003cu8\u003e,\n\t\tdigit_vars: [SolverVar; 10],\n\t}\n\n\timpl DigitsSolver {\n\n\t\tfn build () -\u003e Self {\n\n\t\t\t#[ inline ] const fn inv (val: u8) -\u003e u8 { val ^ 0x7f }\n\n\t\t\tlet (mut solver, vars) = make_solver! {\n\t\t\t\tvalue_type = u8;\n\t\t\t\tvariables {\n\t\t\t\t\t(zero, one, two, three, four, five, six, seven, eight, nine) = 0 ..= 0x7f;\n\t\t\t\t\tunique (a, b, c, d, e, f, g) = (0_u8 .. 7).map (|bit| 1 \u003c\u003c bit);\n\t\t\t\t}\n\t\t\t\tconstraints {\n\t\t\t\t\t|zero, d| inv (zero) == d;\n\t\t\t\t\t|one, c, f| one == c | f;\n\t\t\t\t\t|two, b, f| inv (two) == b | f;\n\t\t\t\t\t|three, b, e| inv (three) == b | e;\n\t\t\t\t\t|four, a, e, g| inv (four) == a | e | g;\n\t\t\t\t\t|five, c, e| inv (five) == c | e;\n\t\t\t\t\t|six, c| inv (six) == c;\n\t\t\t\t\t|seven, a, c, f| seven == a | c | f;\n\t\t\t\t\t|eight| inv (eight) == 0;\n\t\t\t\t\t|nine, e| inv (nine) == e;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlet digit_vars = [\n\t\t\t\tvars.zero, vars.one, vars.two, vars.three, vars.four,\n\t\t\t\tvars.five, vars.six, vars.seven, vars.eight, vars.nine,\n\t\t\t];\n\n\t\t\tsolver.reduce ();\n\n\t\t\tSelf { solver, digit_vars }\n\n\t\t}\n\n\t\tpub fn solve (\u0026 self, digits: [Digit; 10]) -\u003e GenResult \u003c[u8; 10]\u003e {\n\t\t\tlet mut solver = self.solver.clone ();\n\t\t\tfor (digit_idx, \u0026 num_segs) in DIGIT_SEGMENTS.iter ().enumerate () {\n\t\t\t\tlet samples: ArrayVec \u003cu8, 3\u003e = digits.iter ()\n\t\t\t\t\t.filter (|digit| digit.num_segments () == num_segs)\n\t\t\t\t\t.map (|digit| digit.on ())\n\t\t\t\t\t.collect ();\n\t\t\t\tsolver.constrain (\n\t\t\t\t\t\u0026 [ self.digit_vars [digit_idx] ],\n\t\t\t\t\tmove |vars| samples.contains (\u0026 vars [0]));\n\t\t\t}\n\t\t\tsolver.reduce ();\n\t\t\tlet soln = solver.iter ().next ().ok_or (\"No solution found\") ?;\n\t\t\tOk (self.digit_vars.map (|var| soln [var]))\n\t\t}\n\n\t}\n\n\tconst DIGIT_SEGMENTS: [u32; 10] = [ 6, 2, 5, 5, 4, 5, 6, 3, 7, 6 ];\n\n}\n","traces":[{"line":7,"address":[121008],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[97263,87945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[121176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[87766,87711,88006,96673,97351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[123209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[123223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[121184],"length":1,"stats":{"Line":1},"fn_name":"decode_value"},{"line":27,"address":[121205,121465],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[48672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[121210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[121424,121678,121696,121444,121623,121741],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":40,"address":[146304],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":41,"address":[123262],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[146560,146742],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":43,"address":[95579,95474,95606],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[95293,95403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[146928],"length":1,"stats":{"Line":1},"fn_name":"get_digits"},{"line":53,"address":[147088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[147090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[147200,147328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[147243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[147288],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[147295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[147349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[147361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[147373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[147389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[147396,147421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[147401,147423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[147469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[147426],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[147410,147430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[147435,147412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[147415,147440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[147418,147447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[147454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[147457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[147460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[81488,81640],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":98,"address":[81513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[95664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[95980,95848,95953],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[81648],"length":1,"stats":{"Line":0},"fn_name":"decode_display"},{"line":105,"address":[95777,95667],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[81840,84664],"length":1,"stats":{"Line":1},"fn_name":"build"},{"line":117,"address":[86346,87376,85776,86154,86561,86746,86912],"length":1,"stats":{"Line":7},"fn_name":null},{"line":119,"address":[83170,82265,82856,82992,82133,82920,83036,82001,82331,82199,82397,81935,82664,83248,82595,82728,82792,83312,82463,84631,82529,82067],"length":1,"stats":{"Line":21},"fn_name":null},{"line":123,"address":[51104,51162,50602,50544,50256,50314,50400,50816,50112,50170,50874,50458,50960,51018],"length":1,"stats":{"Line":7},"fn_name":null},{"line":126,"address":[85779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[85962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[86157],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[86349],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[86565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[86749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[86915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[87123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[87238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[87379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[84397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[84672,85618],"length":1,"stats":{"Line":1},"fn_name":"solve"},{"line":151,"address":[84709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[84808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[47924,47962],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[99083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[84913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[85406,85576,84889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[51965,51889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[84953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[85367,85529,85154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[85327],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":64,"coverable":70},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","model.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Display {\n\tpub digits: [Digit; 10],\n\tpub value: [Digit; 4],\n}\n\nstruct_parser_display! {\n\tDisplay { digits, value } = [ @array_delim \" \" digits, \" | \", @array_delim \" \" value ]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Digit {\n\tpub segments: u8,\n}\n\nimpl Digit {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn on (self) -\u003e u8 {\n\t\tself.segments\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn off (self) -\u003e u8 {\n\t\tself.segments ^ 0x7f\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn num_segments (self) -\u003e u32 {\n\t\tself.segments.count_ones ()\n\t}\n\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Digit {\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet mut segments = 0_u8;\n\t\tlet err = parser.err ();\n\t\tlet rest = parser.take_rest_while (|ch| ('a' ..= 'g').contains (\u0026 ch), 2 ..= 7) ?;\n\t\tfor ch in rest.chars () {\n\t\t\tlet bit = 1 \u003c\u003c (ch.pan_u32 () - 'a'.pan_u32 ());\n\t\t\tif segments \u0026 bit != 0 { return Err (err) }\n\t\t\tsegments |= bit;\n\t\t}\n\t\tOk (Self { segments })\n\t}\n}\n\nimpl fmt::Display for Digit {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut segments = self.segments;\n\t\tlet mut ch = 'a';\n\t\tfor _ in 0_u32 .. 7 {\n\t\t\tif segments \u0026 1 != 0 { formatter.write_char (ch) ?; }\n\t\t\tsegments \u003e\u003e= 1_u32;\n\t\t\tch = (ch.pan_u32 () + 1).pan_char ();\n\t\t}\n\t\tOk (())\n\t}\n}\n","traces":[{"line":10,"address":[100664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[99408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":9,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","solver.rs"],"content":"use super::*;\n\npub trait Constraint \u003cVal\u003e {\n\tfn check (\u0026 self, vals: \u0026 [Val]) -\u003e bool;\n\tfn clone_box (\u0026 self) -\u003e Box \u003cdyn Constraint \u003cVal\u003e\u003e;\n}\n\npub type BoxConstraint \u003cVal\u003e = Box \u003cdyn Constraint \u003cVal\u003e\u003e;\n\n#[ derive (Clone) ]\npub struct FnConstraint \u003cCheckFn\u003e {\n\tcheck_fn: CheckFn,\n}\n\nimpl \u003cCheckFn\u003e FnConstraint \u003cCheckFn\u003e {\n\tpub const fn new (check_fn: CheckFn) -\u003e Self {\n\t\tSelf { check_fn }\n\t}\n}\n\nimpl \u003cCheckFn, Val\u003e Constraint \u003cVal\u003e for FnConstraint \u003cCheckFn\u003e\n\twhere CheckFn: Fn (\u0026 [Val]) -\u003e bool + Clone + 'static {\n\n\tfn check (\u0026 self, vals: \u0026 [Val]) -\u003e bool {\n\t\t(self.check_fn) (vals)\n\t}\n\n\tfn clone_box (\u0026 self) -\u003e Box \u003cdyn Constraint \u003cVal\u003e\u003e {\n\t\tBox::new (self.clone ())\n\t}\n\n}\n\npub struct Solver \u003cVal\u003e {\n\tvariables: Vec \u003c(Rc \u003cstr\u003e, Vec \u003cVal\u003e)\u003e,\n\tconstraints: Vec \u003c(Vec \u003cusize\u003e, Box \u003cdyn Constraint \u003cVal\u003e\u003e)\u003e,\n}\n\nimpl \u003cVal: Clone\u003e Clone for Solver \u003cVal\u003e {\n\tfn clone (\u0026 self) -\u003e Self {\n\t\tSelf {\n\t\t\tvariables: self.variables.clone (),\n\t\t\tconstraints: self.constraints.iter ()\n\t\t\t\t.map (|\u0026 (ref vars, ref cnstr)| (vars.clone (), cnstr.clone_box ()))\n\t\t\t\t.collect (),\n\t\t}\n\t}\n}\n\nimpl \u003cVal: Clone + Debug\u003e Solver \u003cVal\u003e {\n\n\tpub fn new () -\u003e Self {\n\t\tSelf::new_from_parts (None)\n\t}\n\n\tfn new_from_parts (parts: Option \u003cSolverParts \u003cVal\u003e\u003e) -\u003e Self {\n\t\tlet parts = parts.unwrap_or_else (|| SolverParts {\n\t\t\tvariables: Vec::new (),\n\t\t\tconstraints: Vec::new (),\n\t\t});\n\t\tSelf {\n\t\t\tvariables: parts.variables,\n\t\t\tconstraints: parts.constraints,\n\t\t}\n\t}\n\n\tfn into_parts (mut self) -\u003e SolverParts \u003cVal\u003e {\n\t\tself.variables.clear ();\n\t\tself.constraints.clear ();\n\t\tSolverParts {\n\t\t\tvariables: self.variables,\n\t\t\tconstraints: self.constraints,\n\t\t}\n\t}\n\n\tpub fn declare (\n\t\t\u0026 mut self,\n\t\tname: Rc \u003cstr\u003e,\n\t\tvalues: impl IntoIterator \u003cItem = Val\u003e,\n\t) -\u003e SolverVar {\n\t\tassert! (! self.variables.iter ().any (|\u0026 (ref var_name, _)| var_name == \u0026 name),\n\t\t\t\"Variable declared twice: {name}\");\n\t\tlet idx = self.variables.len ();\n\t\tself.variables.push ((name, values.into_iter ().collect ()));\n\t\tSolverVar { idx }\n\t}\n\n\tpub fn get_var (\u0026 self, name: \u0026 str) -\u003e SolverVar {\n\t\tSolverVar {\n\t\t\tidx: self.variables.iter ()\n\t\t\t\t.position (|\u0026 (ref var_name, _)| var_name.as_ref () == name)\n\t\t\t\t.unwrap (),\n\t\t}\n\t}\n\n\tpub fn add_constraint (\u0026 mut self, vars: \u0026 [SolverVar], cnstr: BoxConstraint \u003cVal\u003e) {\n\t\tself.constraints.push ((\n\t\t\tvars.iter ().map (|var| var.idx).collect (),\n\t\t\tcnstr,\n\t\t));\n\t}\n\n\tpub fn constrain \u003cCheckFn\u003e (\u0026 mut self, vars: \u0026 [SolverVar], check_fn: CheckFn)\n\t\t\twhere CheckFn: Fn (\u0026 [Val]) -\u003e bool + Clone + 'static {\n\t\tself.add_constraint (vars, Box::new (FnConstraint::new (check_fn)));\n\t}\n\n\tpub fn reduce (\u0026 mut self) {\n\t\tlet mut solver_parts = None;\n\t\tlet mut cnstrs_todo: VecDeque \u003c_\u003e =\n\t\t\tself.constraints.iter ()\n\t\t\t\t.sorted_by_cached_key (|\u0026\u0026 (ref cnstr_vars, _)| (cnstr_vars.len (), cnstr_vars.iter ()\n\t\t\t\t\t.map (|\u0026 var_idx| self.variables [var_idx].1.len ())\n\t\t\t\t\t.product::\u003cusize\u003e ()))\n\t\t\t\t.collect ();\n\t\tlet mut cnstrs_done = Vec::with_capacity (self.constraints.len ());\n\t\tlet mut inner_vars = Vec::with_capacity (self.variables.len ());\n\t\twhile let Some (cnstr_ref) = cnstrs_todo.pop_front () {\n\t\t\tlet \u0026 (ref cnstr_vars, ref cnstr) = cnstr_ref;\n\t\t\tlet mut solver = Self::new_from_parts (solver_parts);\n\t\t\tfor \u0026 var_idx in cnstr_vars {\n\t\t\t\tlet \u0026 (ref var_name, ref var_values) = \u0026 self.variables [var_idx];\n\t\t\t\tsolver.declare (Rc::clone (var_name), var_values.clone ());\n\t\t\t}\n\t\t\tinner_vars.clear ();\n\t\t\tinner_vars.extend ((0 .. cnstr_vars.len ()).map (|idx| SolverVar { idx }));\n\t\t\tsolver.add_constraint (\u0026 inner_vars, cnstr.clone_box ());\n\t\t\tsolver.reduce_brute ();\n\t\t\tfor (solver_var_idx, \u0026 var_idx) in cnstr_vars.iter ().enumerate () {\n\t\t\t\tif self.variables [var_idx].1.len () == solver.variables [solver_var_idx].1.len () {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tself.variables [var_idx].1 = mem::take (\u0026 mut solver.variables [solver_var_idx].1);\n\t\t\t\tcnstrs_done.retain (|\u0026 other_ref: \u0026\u0026 (Vec \u003cusize\u003e, _)| {\n\t\t\t\t\tlet \u0026 (ref other_vars, _) = other_ref;\n\t\t\t\t\tif ! other_vars.iter ().any (|\u0026 other_var_idx| other_var_idx == var_idx) { return true }\n\t\t\t\t\tcnstrs_todo.push_back (other_ref);\n\t\t\t\t\tfalse\n\t\t\t\t});\n\t\t\t}\n\t\t\tcnstrs_done.push (cnstr_ref);\n\t\t\tsolver_parts = Some (solver.into_parts ());\n\t\t}\n\t}\n\n\tfn reduce_brute (\u0026 mut self) {\n\t\tlet mut one_value = Vec::with_capacity (1);\n\t\tlet mut solver_iter_parts: Option \u003cSolverIterParts \u003c_\u003e\u003e = None;\n\t\tfor var_idx in 0 .. self.variables.len () {\n\t\t\tlet mut values = mem::take (\u0026 mut self.variables [var_idx].1);\n\t\t\tvalues.retain (|val| {\n\t\t\t\tone_value.clear ();\n\t\t\t\tone_value.push (val.clone ());\n\t\t\t\tself.variables [var_idx].1 = mem::take (\u0026 mut one_value);\n\t\t\t\tlet mut solver_iter = SolverIter::new_with_parts (self, mem::take (\u0026 mut solver_iter_parts));\n\t\t\t\tlet result = solver_iter.find_next ();\n\t\t\t\tsolver_iter_parts = Some (solver_iter.into_parts ());\n\t\t\t\tone_value = mem::take (\u0026 mut self.variables [var_idx].1);\n\t\t\t\tresult\n\t\t\t});\n\t\t\tself.variables [var_idx].1 = values;\n\t\t}\n\t}\n\n\tpub fn iter (\u0026 self) -\u003e SolverIter \u003cVal\u003e {\n\t\tSolverIter::new (self)\n\t}\n\n}\n\nstruct SolverParts \u003cVal\u003e {\n\tvariables: Vec \u003c(Rc \u003cstr\u003e, Vec \u003cVal\u003e)\u003e,\n\tconstraints: Vec \u003c(Vec \u003cusize\u003e, Box \u003cdyn Constraint \u003cVal\u003e\u003e)\u003e,\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct SolverVar {\n\tidx: usize,\n}\n\nstruct SolverIterParts \u003cVal\u003e {\n\tvalues: Vec \u003cOption \u003cVal\u003e\u003e,\n\ttodo: Vec \u003c(usize, usize)\u003e,\n\tcnstr_vals: Vec \u003cVal\u003e,\n}\n\n#[ derive (Clone) ]\npub struct SolverIter \u003c'slvr, Val\u003e {\n\tsolver: \u0026 'slvr Solver \u003cVal\u003e,\n\tvalues: Vec \u003cOption \u003cVal\u003e\u003e,\n\ttodo: Vec \u003c(usize, usize)\u003e,\n\tcnstr_vals: Vec \u003cVal\u003e,\n\tfound: bool,\n}\n\nimpl \u003c'slvr, Val: Clone + Debug\u003e SolverIter \u003c'slvr, Val\u003e {\n\tfn new (solver: \u0026 'slvr Solver \u003cVal\u003e) -\u003e Self {\n\t\tSelf::new_with_parts (solver, None)\n\t}\n\tfn new_with_parts (solver: \u0026 'slvr Solver \u003cVal\u003e, parts: Option \u003cSolverIterParts \u003cVal\u003e\u003e) -\u003e Self {\n\t\tlet mut result = if let Some (parts) = parts {\n\t\t\tSelf {\n\t\t\t\tsolver,\n\t\t\t\tvalues: parts.values,\n\t\t\t\ttodo: parts.todo,\n\t\t\t\tcnstr_vals: parts.cnstr_vals,\n\t\t\t\tfound: false,\n\t\t\t}\n\t\t} else {\n\t\t\tSelf {\n\t\t\t\tsolver,\n\t\t\t\tvalues: Vec::new (),\n\t\t\t\ttodo: Vec::new (),\n\t\t\t\tcnstr_vals: Vec::new (),\n\t\t\t\tfound: false,\n\t\t\t}\n\t\t};\n\t\tresult.init ();\n\t\tresult\n\t}\n\tfn into_parts (mut self) -\u003e SolverIterParts \u003cVal\u003e {\n\t\tself.values.clear ();\n\t\tself.todo.clear ();\n\t\tself.cnstr_vals.clear ();\n\t\tSolverIterParts {\n\t\t\tvalues: self.values,\n\t\t\ttodo: self.todo,\n\t\t\tcnstr_vals: self.cnstr_vals,\n\t\t}\n\t}\n\tfn init (\u0026 mut self) {\n\t\tself.values.extend (iter::repeat (None).take (self.solver.variables.len ()));\n\t\tself.todo.push ((0, 0));\n\t}\n\tpub fn find_next (\u0026 mut self) -\u003e bool {\n\t\t'OUTER: while let Some ((mut var_idx, mut val_idx)) = self.todo.pop () {\n\t\t\tloop {\n\t\t\t\tfor val in \u0026 mut self.values [var_idx .. ] { * val = None; }\n\t\t\t\tif var_idx == self.values.len () { self.found = true; return true }\n\t\t\t\tlet \u0026 (_, ref values) = \u0026 self.solver.variables [var_idx];\n\t\t\t\tif val_idx + 1 \u003c values.len () {\n\t\t\t\t\tself.todo.push ((var_idx, val_idx + 1));\n\t\t\t\t}\n\t\t\t\tself.values [var_idx] = Some (values [val_idx].clone ());\n\t\t\t\tfor \u0026 (ref cnstr_var_idxes, ref cnstr) in \u0026 self.solver.constraints {\n\t\t\t\t\tif cnstr_var_idxes.iter ().any (|\u0026 cnstr_var_idx| var_idx \u003c cnstr_var_idx) { continue }\n\t\t\t\t\tif ! cnstr_var_idxes.iter ().any (|\u0026 cnstr_var_idx| cnstr_var_idx == var_idx) { continue }\n\t\t\t\t\tself.cnstr_vals.extend (\n\t\t\t\t\t\tcnstr_var_idxes.iter ()\n\t\t\t\t\t\t\t.map (|\u0026 cnstr_var_idx| self.values [cnstr_var_idx].as_ref ().unwrap ().clone ()));\n\t\t\t\t\tlet found = cnstr.check (\u0026 self.cnstr_vals);\n\t\t\t\t\tself.cnstr_vals.clear ();\n\t\t\t\t\tif ! found { continue 'OUTER }\n\t\t\t\t}\n\t\t\t\tvar_idx += 1;\n\t\t\t\tval_idx = 0;\n\t\t\t}\n\t\t}\n\t\tfalse\n\t}\n\n\tpub fn get (\u0026 self) -\u003e Solution \u003cVal\u003e {\n\t\tassert! (self.found);\n\t\tSolution {\n\t\t\tvalues: self.values.iter ().flatten ().cloned ().collect (),\n\t\t}\n\t}\n\n}\n\nimpl \u003c'slvr, Val: Clone + Debug\u003e Iterator for SolverIter \u003c'slvr, Val\u003e {\n\n\ttype Item = Solution \u003cVal\u003e;\n\n\tfn next (\u0026 mut self) -\u003e Option \u003cSolution \u003cVal\u003e\u003e {\n\t\tself.find_next ().then (|| self.get ())\n\t}\n\n}\n\npub struct Solution \u003cVal\u003e {\n\tvalues: Vec \u003cVal\u003e,\n}\n\nimpl \u003cVal\u003e Index \u003cSolverVar\u003e for Solution \u003cVal\u003e {\n\ttype Output = Val;\n\t#[ inline ]\n\tfn index (\u0026 self, var: SolverVar) -\u003e \u0026 Val {\n\t\t\u0026 self.values [var.idx]\n\t}\n}\n\n#[ macro_export ]\nmacro_rules! solver_constrain {\n\t(\n\t\tsolver = $solver:expr;\n\t\tvalue_type = $val_type:ty;\n\t\t$( |$($arg:ident),*| $check:expr; )*\n\t) =\u003e { $( {\n\t\t#[ derive (Clone) ]\n\t\tstruct MyConstraint;\n\t\timpl Constraint \u003c$val_type\u003e for MyConstraint {\n\t\t\tfn check (\u0026 self, vals: \u0026 [$val_type]) -\u003e bool {\n\t\t\t\tlet mut vals_iter = vals.iter ().copied ();\n\t\t\t\t$(\n\t\t\t\t\tlet $arg = vals_iter.next ().unwrap ().clone ();\n\t\t\t\t)*\n\t\t\t\t$check\n\t\t\t}\n\t\t\tfn clone_box (\u0026 self) -\u003e Box \u003cdyn Constraint \u003c$val_type\u003e\u003e {\n\t\t\t\tBox::new (self.clone ())\n\t\t\t}\n\t\t}\n\t\tlet vars = \u0026 [ $($solver.get_var (stringify! ($arg))),* ];\n\t\tlet cnstr = Box::new (MyConstraint);\n\t\t$solver.add_constraint (vars, cnstr);\n\t} )* };\n}\n\n#[ macro_export ]\nmacro_rules! make_solver {\n\t(\n\t\tvalue_type = $val_type:ty;\n\t\tvariables { $( $($modif:ident)* ($($var:ident),*) = $vals:expr; )* }\n\t\tconstraints { $($rest:tt)* }\n\t) =\u003e {\n\t\t{\n\t\t\tlet mut solver = Solver::new ();\n\t\t\t#[ allow (dead_code) ]\n\t\t\tstruct Vars {\n\t\t\t\t$($( $var: SolverVar, )*)*\n\t\t\t}\n\t\t\t$(\n\t\t\t\t$( let $var = solver.declare (Rc::from (stringify! ($var)), $vals); )*\n\t\t\t\tmake_solver! (@unique solver ($($modif)*) ($($var),*));\n\t\t\t)*\n\t\t\tsolver_constrain! {\n\t\t\t\tsolver = solver;\n\t\t\t\tvalue_type = $val_type;\n\t\t\t\t$($rest)*\n\t\t\t}\n\t\t\t(solver, Vars { $($($var,)*)* })\n\t\t}\n\t};\n\t( @unique $solver:ident () ($($var:ident),*) ) =\u003e {\n\t};\n\t( @unique $solver:ident (unique) ($($var:ident),*) ) =\u003e {\n\t\t{\n\t\t\tlet mut vars = Vec::new ();\n\t\t\tfor var in [ $($var),* ] {\n\t\t\t\tvars.push (var);\n\t\t\t\tif 1 \u003c vars.len () {\n\t\t\t\t\t$solver.constrain (\u0026 vars, |vals| {\n\t\t\t\t\t\tlet last = vals [vals.len () - 1];\n\t\t\t\t\t\tfor \u0026 other in \u0026 vals [ .. vals.len () - 1] {\n\t\t\t\t\t\t\tif last == other { return false }\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrue\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[57945,56848,55064,56256,57440,53296,55664,53888,54472,57432,52704,56840,54480,53287,56248,55656,53880,55072],"length":1,"stats":{"Line":9},"fn_name":"declare\u003cu8, alloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[58656,58624],"length":1,"stats":{"Line":1},"fn_name":"constrain\u003cu8, aoc_2021_day_08::logic::solver::{impl#0}::build::{closure_env#7}\u003e"},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[86208,87264,85664,86608,87168,85824,86800,86960,86400,86016],"length":1,"stats":{"Line":10},"fn_name":"check"},{"line":304,"address":[87175,86816,86225,87280,86033,85841,85680,86417,86625,86977],"length":1,"stats":{"Line":10},"fn_name":null},{"line":306,"address":[86256,86846,86064,87211,86448,85872,85710,86656,87008,87310],"length":1,"stats":{"Line":10},"fn_name":null},{"line":310,"address":[86592,86192,86784,87248,86000,87408,86384,87152,85808,86944],"length":1,"stats":{"Line":10},"fn_name":"clone_box"},{"line":353,"address":[158208],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":354,"address":[51993,52095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":355,"address":[52011,52079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":356,"address":[52075],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":87,"coverable":138},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"2199943210\",\n\t\"3987894921\",\n\t\"9856789892\",\n\t\"8767896789\",\n\t\"9899965678\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"15\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1134\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[51268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[58074],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[58095,58133,58242,58185,58308,58412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[51300],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[58474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[58495,58642,58812,58533,58708,58585],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid = grid_parse ]\n}\n\nfn grid_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cGrid\u003e {\n\tGrid::parse_with_fn (parser, default, |parser| {\n\t\tif ! matches! (parser.peek (), Some ('0' ..= '9')) { return Err (parser.err ()) }\n\t\tOk (parser.next ().unwrap ().to_digit (10).unwrap ().pan_u8 ())\n\t})\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[54624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[48857,49474],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[85964,85845],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[85880,85853,85952],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","lib.rs"],"content":"//! Advent of Code 2021: Day 9: Smoke Basin\n//!\n//! [https://adventofcode.com/2021/day/9](https://adventofcode.com/2021/day/9)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Smoke Basin\";\n\tyear = 2021;\n\tday = 9;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[42657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[43025],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet mut sum: u32 = 0;\n\t'OUTER: for (pos, height) in input.grid.iter () {\n\t\tfor next_pos in pos.adjacent_4 () {\n\t\t\tif let Some (next_height) = input.grid.get (next_pos) {\n\t\t\t\tif next_height \u003c= height { continue 'OUTER }\n\t\t\t}\n\t\t}\n\t\tsum += height.pan_u32 () + 1;\n\t}\n\tOk (sum)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet offsets: Vec \u003c_\u003e =\n\t\tPos::ZERO.adjacent_4 ().into_iter ()\n\t\t\t.map (|pos| input.grid.offset (pos))\n\t\t\t.try_collect () ?;\n\tlet mut basin_sizes: Vec \u003cu32\u003e = Vec::new ();\n\tlet mut seen: Vec \u003cbool\u003e = iter::repeat (false).take (input.grid.len ()).collect ();\n\tfor cur in input.grid.cursors () {\n\t\tif seen [cur.index ()] { continue }\n\t\tseen [cur.index ()] = true;\n\t\tif cur.get (\u0026 input.grid) == 9 { continue }\n\t\tlet mut todo: VecDeque \u003c_\u003e = VecDeque::new ();\n\t\ttodo.push_back (cur);\n\t\tlet mut basin_size = 1_u32;\n\t\twhile let Some (cur) = todo.pop_front () {\n\t\t\tfor \u0026 offset in offsets.iter () {\n\t\t\t\tlet adj_cur = ok_or! (chk! (cur + offset), continue);\n\t\t\t\tif seen [adj_cur.index ()] { continue }\n\t\t\t\tseen [adj_cur.index ()] = true;\n\t\t\t\tif adj_cur.get (\u0026 input.grid) == 9 { continue }\n\t\t\t\ttodo.push_back (adj_cur);\n\t\t\t\tbasin_size += 1;\n\t\t\t}\n\t\t}\n\t\tbasin_sizes.push (basin_size);\n\t}\n\tbasin_sizes.sort_unstable ();\n\tOk (\n\t\tbasin_sizes.into_iter ().rev ()\n\t\t\t.take (3)\n\t\t\t.try_fold (1_u32, |prod, val| chk! (prod * val)) ?\n\t)\n}\n","traces":[{"line":6,"address":[86032,86784],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[86290,86249,86091],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[86769,86327,86428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[86430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[86542,86659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[86576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[89050,86800],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[87145,86823,86975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[96320,96341,96514],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":26,"address":[87252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[87378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[87403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[87485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[87984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[72551,72871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[88109],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[88142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[88228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[88325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[88666,88436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[96544,96736,96704],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"}],"covered":20,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Grid = GridBuf \u003cVec \u003cu8\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosRowCol \u003cCoord\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"[({(\u003c(())[]\u003e[[{[]{\u003c()\u003c\u003e\u003e\",\n\t\"[(()[\u003c\u003e])]({[\u003c{\u003c\u003c[]\u003e\u003e(\",\n\t\"{([(\u003c{}[\u003c\u003e[]}\u003e{[]{[(\u003c()\u003e\",\n\t\"(((({\u003c\u003e}\u003c{\u003c{\u003c\u003e}{[]{[]{}\",\n\t\"[[\u003c[([]))\u003c([[{}[[()]]]\",\n\t\"[{[{({}]{}}([{[{{{}}([]\",\n\t\"{\u003c[[]]\u003e}\u003c{[{[{[]{()[[[]\",\n\t\"[\u003c(\u003c(\u003c(\u003c{}))\u003e\u003c([]([]()\",\n\t\"\u003c{([([[(\u003c\u003e()){}]\u003e(\u003c\u003c{{\",\n\t\"\u003c{([{{}}[\u003c[[[\u003c\u003e{}]]]\u003e[]]\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"26397\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"288957\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[35252,35248],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":20,"address":[39658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[39892,39717,39996,39826,39769,39679],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[35280,35284],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[40058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[40079,40169,40226,40117,40292,40396],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","input.rs"],"content":"use super::*;\n\nuse model::Token;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub lines: Vec \u003cInputLine\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { lines, params } = [ params, @lines lines ]\n}\n\nwrapper_deref_mut! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputLine {\n\t\tpub tokens: Vec \u003cToken\u003e,\n\t}\n}\n\nstruct_parser_display! {\n\tInputLine { tokens } = [ @collect tokens ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[32486,32939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[26211],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","lib.rs"],"content":"//! Advent of Code 2021: Day 10: Syntax Scoring\n//!\n//! [https://adventofcode.com/2021/day/10](https://adventofcode.com/2021/day/10)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Syntax Scoring\";\n\tyear = 2021;\n\tday = 10;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[28072],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Delim;\nuse model::Mode;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tinput.lines.iter ()\n\t\t.map (|line| {\n\t\t\tlet mut stack: Vec \u003cDelim\u003e = Vec::new ();\n\t\t\tline.iter ()\n\t\t\t\t.map (move |token| match token.mode () {\n\t\t\t\t\tMode::Open =\u003e { stack.push (token.delim ()); Ok (0) },\n\t\t\t\t\tMode::Close =\u003e {\n\t\t\t\t\t\tlet stack_delim = stack.pop ()\n\t\t\t\t\t\t\t.ok_or (\"Too many closing delimiters\") ?;\n\t\t\t\t\t\tOk::\u003c_, GenError\u003e (\n\t\t\t\t\t\t\tif stack_delim != token.delim () {\n\t\t\t\t\t\t\t\ttoken.delim ().mismatched_points ()\n\t\t\t\t\t\t\t} else { 0 }\n\t\t\t\t\t\t)\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\t.try_fold (0, |sum, item| {\n\t\t\t\t\tlet item = item ?;\n\t\t\t\t\tOk::\u003c_, GenError\u003e (chk! (sum + item) ?)\n\t\t\t\t})\n\t\t})\n\t\t.try_fold (0, |sum, item| {\n\t\t\tlet item = item ?;\n\t\t\tOk::\u003c_, GenError\u003e (chk! (sum + item) ?)\n\t\t})\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut scores: Vec \u003cu64\u003e =\n\t\tinput.lines.iter ()\n\t\t\t.filter_map (|line| {\n\t\t\t\tlet mut stack: Vec \u003cDelim\u003e = Vec::new ();\n\t\t\t\tfor token in line.iter () {\n\t\t\t\t\tmatch token.mode () {\n\t\t\t\t\t\tMode::Open =\u003e stack.push (token.delim ()),\n\t\t\t\t\t\tMode::Close =\u003e {\n\t\t\t\t\t\t\tlet expect = some_or! (\n\t\t\t\t\t\t\t\tstack.pop (),\n\t\t\t\t\t\t\t\treturn Some (Err::\u003c_, GenError\u003e (\"Too many closing delimters\".into ())));\n\t\t\t\t\t\t\tif token.delim () != expect { return None }\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSome (\n\t\t\t\t\tstack.into_iter ().rev ()\n\t\t\t\t\t\t.map (Delim::not_closed_points)\n\t\t\t\t\t\t.try_fold (0, |total, value| Ok (chk! (value + total * 5) ?))\n\t\t\t\t)\n\t\t\t})\n\t\t\t.try_collect () ?;\n\tif scores.is_empty () { return Err (\"No solution found\".into ()) }\n\tscores.sort_unstable ();\n\tOk (scores [(scores.len () - 1) / 2])\n}\n","traces":[{"line":7,"address":[59520],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[27722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[52711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[52470],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[56346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[56234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[56369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[56283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[56400],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":25,"address":[28631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[56487,56524,57440,57408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[56560],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":30,"address":[56573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[52608,52645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[59600,59917],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":36,"address":[59662,59779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[57259,56720],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":40,"address":[56820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[56841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[56910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[56897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[57129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[56940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[57096],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[57024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[40612,40656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[59797,59701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[59706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[59729,59752,59844],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":23,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","model.rs"],"content":"use super::*;\n\nuse Delim::{ Round, Square, Curly, Angle };\nuse Mode::{ Open, Close };\nuse Token::{\n\tRoundOpen, RoundClose, SquareOpen, SquareClose,\n\tCurlyOpen, CurlyClose, AngleOpen, AngleClose,\n};\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Token {\n\t\tRoundOpen = \"(\",\n\t\tRoundClose = \")\",\n\t\tSquareOpen = \"[\",\n\t\tSquareClose = \"]\",\n\t\tCurlyOpen = \"{\",\n\t\tCurlyClose = \"}\",\n\t\tAngleOpen = \"\u003c\",\n\t\tAngleClose = \"\u003e\",\n\t}\n}\n\nimpl Token {\n\n\t#[ must_use ]\n\tpub const fn delim (self) -\u003e Delim {\n\t\tmatch self {\n\t\t\tRoundOpen | RoundClose =\u003e Round,\n\t\t\tSquareOpen | SquareClose =\u003e Square,\n\t\t\tCurlyOpen | CurlyClose =\u003e Curly,\n\t\t\tAngleOpen | AngleClose =\u003e Angle,\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub const fn mode (self) -\u003e Mode {\n\t\tmatch self {\n\t\t\tRoundOpen | SquareOpen | CurlyOpen | AngleOpen =\u003e Open,\n\t\t\tRoundClose | SquareClose | CurlyClose | AngleClose =\u003e Close,\n\t\t}\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Delim { Round, Square, Curly, Angle }\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Mode { Open, Close }\n\nimpl Delim {\n\n\t#[ must_use ]\n\tpub const fn mismatched_points (self) -\u003e u64 {\n\t\tmatch self {\n\t\t\tSelf::Round =\u003e 3,\n\t\t\tSelf::Square =\u003e 57,\n\t\t\tSelf::Curly =\u003e 1197,\n\t\t\tSelf::Angle =\u003e 25137,\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub const fn not_closed_points (self) -\u003e u64 {\n\t\tmatch self {\n\t\t\tSelf::Round =\u003e 1,\n\t\t\tSelf::Square =\u003e 2,\n\t\t\tSelf::Curly =\u003e 3,\n\t\t\tSelf::Angle =\u003e 4,\n\t\t}\n\t}\n\n}\n","traces":[{"line":27,"address":[26896],"length":1,"stats":{"Line":0},"fn_name":"delim"},{"line":28,"address":[26896],"length":1,"stats":{"Line":3},"fn_name":"delim"},{"line":37,"address":[26928],"length":1,"stats":{"Line":0},"fn_name":"mode"},{"line":38,"address":[26930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[26944],"length":1,"stats":{"Line":0},"fn_name":"mismatched_points"},{"line":56,"address":[26944],"length":1,"stats":{"Line":1},"fn_name":"mismatched_points"},{"line":65,"address":[26960],"length":1,"stats":{"Line":0},"fn_name":"not_closed_points"},{"line":66,"address":[26960],"length":1,"stats":{"Line":1},"fn_name":"not_closed_points"}],"covered":4,"coverable":8},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"5483143223\",\n\t\"2745854711\",\n\t\"5264556173\",\n\t\"6141336146\",\n\t\"6357385478\",\n\t\"4167524645\",\n\t\"2176841721\",\n\t\"6882881134\",\n\t\"4846848554\",\n\t\"5283751526\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1656\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"195\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[38628],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[46650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[46884,46709,46671,46761,46818,46988],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[38596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[47050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[47161,47284,47071,47388,47109,47218],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid = grid_parse ]\n}\n\nfn grid_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cGrid\u003e {\n\tGrid::parse_with_fn (parser, default, |parser| {\n\t\tif ! matches! (parser.peek (), Some ('0' ..= '9')) { return Err (parser.err ()) }\n\t\tOk (parser.next ().unwrap ().to_digit (10).unwrap ().pan_u8 ())\n\t})\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[46624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[38018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[64780,64661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[64669,64696,64768],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","lib.rs"],"content":"//! Advent of Code 2021: Day 11: Dumbo Octopus\n//!\n//! [https://adventofcode.com/2021/day/11](https://adventofcode.com/2021/day/11)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Dumbo Octopus\";\n\tyear = 2021;\n\tday = 11;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":20,"address":[57239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[57591],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Grid;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tOk (\n\t\tstep_iter (input.grid.clone ())\n\t\t\t.take (100)\n\t\t\t.sum ()\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tcheck_input (input) ?;\n\tlet num_octopodes = input.grid.len ().pan_u32 ();\n\tlet mut iter = step_iter (input.grid.clone ());\n\tlet mut num_iters = 0;\n\tloop {\n\t\tif num_iters == 500 {\n\t\t\treturn Err (\"Giving up after 500 iterations\".into ());\n\t\t}\n\t\tnum_iters += 1;\n\t\tlet num_flashes = iter.next ().unwrap ();\n\t\tif num_flashes == num_octopodes { return Ok (num_iters) }\n\t}\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.grid.size ().x \u003c 2 || input.grid.size ().y \u003c 2 {\n\t\treturn Err (\"Grid must be at least 22\".into ());\n\t}\n\tif 100 \u003c input.grid.size ().x || 100 \u003c input.grid.size ().y {\n\t\treturn Err (\"Grid must be at most 5050\".into ());\n\t}\n\tOk (())\n}\n\nfn step_iter (grid: Grid) -\u003e impl Iterator \u003cItem = u32\u003e {\n\tlet offsets: [GridOffset \u003cPos, 2\u003e; 8] =\n\t\tPos::ZERO.adjacent_8 ().into_iter ()\n\t\t\t.map (|pos| grid.offset (pos).unwrap ())\n\t\t\t.array ();\n\titer::repeat (()).scan (grid, move |grid, _| {\n\t\tlet mut num_flashes: u32 = 0;\n\t\tlet mut flashed: GridBuf \u003cVec \u003cbool\u003e, Pos, 2\u003e = GridBuf::new_range (grid.start (), grid.end ()).unwrap ();\n\t\tlet mut todo: Vec \u003cGridCursor \u003cPos, 2\u003e\u003e = Vec::new ();\n\t\t* grid = grid.map (|cur| {\n\t\t\tlet energy = cur.get (\u0026 * grid);\n\t\t\tif energy \u003c 9 { return energy + 1 }\n\t\t\tflashed.set_index (cur.index (), true);\n\t\t\ttodo.push (cur);\n\t\t\tnum_flashes += 1;\n\t\t\t0\n\t\t});\n\t\twhile let Some (cur) = todo.pop () {\n\t\t\tfor adj_off in offsets {\n\t\t\t\tlet adj_cur = ok_or! (chk! (cur + adj_off), continue);\n\t\t\t\tlet adj_energy = adj_cur.get (\u0026 * grid);\n\t\t\t\tif adj_cur.get (\u0026 flashed) { continue }\n\t\t\t\tif adj_energy \u003c 9 {\n\t\t\t\t\tgrid.set_index (adj_cur.index (), adj_energy + 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tflashed.set_index (adj_cur.index (), true);\n\t\t\t\ttodo.push (adj_cur);\n\t\t\t\tnum_flashes += 1;\n\t\t\t\tgrid.set_index (adj_cur.index (), 0);\n\t\t\t}\n\t\t}\n\t\tSome (num_flashes)\n\t})\n}\n","traces":[{"line":7,"address":[64848],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[64936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[66002,65344],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[65435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[65840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[65893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[65859],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[65871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[66016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[65371,66021,64872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[64898,66047,65397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[65384,66034,64885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[64912,66061,65411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[65971,66096,66308,65333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[65596,65002,66112,65667,65073,66168],"length":1,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[69314,69501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[65078,66173,65680],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[42873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[42881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[43195,44060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[41795],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[41854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[41878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[41901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[41982,41958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[43304,43290],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[43322,44101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[44168,43511,44216,44160,44208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[43676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[43685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[43691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[43816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[43855],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":33},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","model.rs"],"content":"use super::*;\n\npub type Coord = i8;\npub type Grid = GridBuf \u003cVec \u003cVal\u003e, Pos, 2\u003e;\npub type Pos = aoc_pos::PosYX \u003cCoord\u003e;\npub type Val = u8;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"start-A\",\n\t\"start-b\",\n\t\"A-c\",\n\t\"A-b\",\n\t\"b-d\",\n\t\"A-end\",\n\t\"b-end\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"dc-end\",\n\t\"HN-start\",\n\t\"start-kj\",\n\t\"dc-start\",\n\t\"dc-HN\",\n\t\"LN-dc\",\n\t\"HN-end\",\n\t\"kj-sa\",\n\t\"kj-HN\",\n\t\"kj-dc\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"fs-end\",\n\t\"he-DX\",\n\t\"fs-he\",\n\t\"start-DX\",\n\t\"pj-DX\",\n\t\"end-zg\",\n\t\"zg-sl\",\n\t\"zg-pj\",\n\t\"pj-he\",\n\t\"RW-he\",\n\t\"fs-DX\",\n\t\"pj-RW\",\n\t\"zg-RW\",\n\t\"start-pj\",\n\t\"he-WI\",\n\t\"zg-he\",\n\t\"pj-fs\",\n\t\"start-RW\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"10\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"19\", puzzle.part_one (EXAMPLE_1));\n\tassert_eq_ok! (\"226\", puzzle.part_one (EXAMPLE_2));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"36\", puzzle.part_two (EXAMPLE_0));\n\tassert_eq_ok! (\"103\", puzzle.part_two (EXAMPLE_1));\n\tassert_eq_ok! (\"3509\", puzzle.part_two (EXAMPLE_2));\n}\n","traces":[{"line":50,"address":[31184,31188],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":51,"address":[45137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[45158,46072,45200,45565,45256,45631],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[45760,45316,46034,45375,45278,45699],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[45825,45993,45397,45500,45886,45441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[31220,31216],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":59,"address":[46145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[46573,47080,46264,46166,46208,46639],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[46286,46324,46707,47042,46383,46768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[46508,46833,46405,46449,46894,47001],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":10,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub cnxns: Vec \u003cInputConnection \u003c'inp\u003e\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { cnxns, params } = [ params, @lines cnxns ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputConnection \u003c'inp\u003e {\n\tpub cave_0: InpStr \u003c'inp\u003e,\n\tpub cave_1: InpStr \u003c'inp\u003e,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInputConnection \u003c'inp\u003e { cave_0, cave_1 } = [\n\t\t@str cave_0 = (|ch| { ch.is_ascii_alphabetic () }, 1 .. ),\n\t\t\"-\",\n\t\t@str cave_1 = (|ch| { ch.is_ascii_alphabetic () }, 1 .. ),\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":11,"address":[31348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[31662],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","lib.rs"],"content":"//! Advent of Code 2021: Day 12: Passage Pathing\n//!\n//! [https://adventofcode.com/2021/day/12](https://adventofcode.com/2021/day/12)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Passage Pathing\";\n\tyear = 2021;\n\tday = 12;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":19,"address":[32280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[32600],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::CaveId;\nuse model::Caves;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet caves = Caves::build (input) ?;\n\tOk (calc_result (\u0026 caves, (), |_, route, next_cave| {\n\t\tif caves [next_cave].small \u0026\u0026 route.contains (\u0026 next_cave) { return false }\n\t\ttrue\n\t}))\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet caves = Caves::build (input) ?;\n\tlet dupe_indexes: Option \u003c(usize, usize)\u003e = None;\n\tOk (calc_result (\u0026 caves, dupe_indexes, |dupe_indexes, route, next_cave| {\n\t\tif let Some ((dupe_idx_0, dupe_idx_1)) = * dupe_indexes {\n\t\t\tif dupe_idx_1 + 1 \u003e route.len ()\n\t\t\t\t\t|| route [dupe_idx_0] != route [dupe_idx_1] {\n\t\t\t\t* dupe_indexes = None;\n\t\t\t}\n\t\t}\n\t\tif caves [next_cave].small {\n\t\t\tif next_cave == caves.start ().id { return false }\n\t\t\tif let Some (prev_pos) = route.iter ()\n\t\t\t\t\t.position (|\u0026 some_cave| some_cave == next_cave) {\n\t\t\t\tif dupe_indexes.is_some () { return false }\n\t\t\t\t* dupe_indexes = Some ((prev_pos, route.len ()));\n\t\t\t}\n\t\t}\n\t\ttrue\n\t}))\n}\n\nfn calc_result \u003c\n\tState,\n\tCheckFn: Fn (\u0026 mut State, \u0026 [CaveId], CaveId) -\u003e bool,\n\u003e (\n\tcaves: \u0026 Caves,\n\tstate: State,\n\tcheck_fn: CheckFn,\n) -\u003e u64 {\n\tlet mut state = state;\n\tlet mut cache: HashMap \u003cCacheKey, u64\u003e = HashMap::new ();\n\tlet mut route: Vec \u003cCaveId\u003e = vec! [ caves.start ().id ];\n\tcalc_recurse (caves, \u0026 mut state, \u0026 check_fn, \u0026 mut cache, \u0026 mut route)\n}\n\nfn calc_recurse \u003c\n\tState,\n\tCheckFn: Fn (\u0026 mut State, \u0026 [CaveId], CaveId) -\u003e bool,\n\u003e (\n\tcaves: \u0026 Caves,\n\tstate: \u0026 mut State,\n\tcheck_fn: \u0026 CheckFn,\n\tcache: \u0026 mut HashMap \u003cCacheKey, u64\u003e,\n\troute: \u0026 mut Vec \u003cCaveId\u003e,\n) -\u003e u64 {\n\tlet this_cave = route.last ().unwrap ().to_owned ();\n\tif this_cave == caves.end ().id { return 1 }\n\tlet cache_key = make_cache_key (caves, route, this_cave);\n\tif let Some (\u0026 cached_val) = cache.get (\u0026 cache_key) { return cached_val }\n\tlet mut num_routes: u64 = 0;\n\tfor \u0026 next_cave in \u0026 caves [this_cave].cnxns {\n\t\tif ! check_fn (state, route, next_cave) { continue }\n\t\troute.push (next_cave);\n\t\tnum_routes += calc_recurse (caves, state, check_fn, cache, route);\n\t\troute.pop ();\n\t}\n\tcache.insert (cache_key, num_routes);\n\tnum_routes\n}\n\ntype CacheKey = (u64, CaveId, CaveId);\n\nfn make_cache_key (caves: \u0026 Caves, route: \u0026 [CaveId], this_cave: CaveId) -\u003e CacheKey {\n\tlet mut route_bits = 0_u64;\n\tlet mut dupe = 0;\n\tfor \u0026 cave in route {\n\t\tif ! caves [cave].small { continue }\n\t\tlet bit = 1 \u003c\u003c cave;\n\t\tif route_bits \u0026 bit == 0 {\n\t\t\troute_bits |= bit;\n\t\t} else {\n\t\t\tdupe = cave;\n\t\t}\n\t}\n\t(route_bits, dupe, this_cave)\n}\n","traces":[{"line":7,"address":[26576,26706],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[26612,26660,26589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[26631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[50515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[26864,26720],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[26733,26756,26818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[48432],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":19,"address":[48455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[48465,48514,48855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[48871,48487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[48516],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[48528,48614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[48647],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[48746,48657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[48720,48912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[48767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[48773],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[48928,49783,49376,49355],"length":1,"stats":{"Line":2},"fn_name":"calc_result\u003ccore::option::Option\u003c(usize, usize)\u003e, aoc_2021_day_12::logic::part_two::{closure_env#0}\u003e"},{"line":45,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[49755,49565,49136,49327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[49792,50848],"length":1,"stats":{"Line":2},"fn_name":"calc_recurse\u003c(), aoc_2021_day_12::logic::part_one::{closure_env#0}\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[50967,49914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[51195,50206,50190,51211],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[26880],"length":1,"stats":{"Line":1},"fn_name":"make_cache_key"},{"line":81,"address":[26907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[27061],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[27076,27200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[27094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[27143],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":36,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","model.rs"],"content":"use super::*;\n\nuse input::Input;\n\npub type CaveId = u8;\n\npub struct Caves \u003c'inp\u003e {\n\tpub caves: Vec \u003cCave \u003c'inp\u003e\u003e,\n}\n\nimpl \u003c'inp\u003e Index \u003cCaveId\u003e for Caves \u003c'inp\u003e {\n\ttype Output = Cave \u003c'inp\u003e;\n\tfn index (\u0026 self, idx: CaveId) -\u003e \u0026 '_ Cave \u003c'inp\u003e {\n\t\t\u0026 self.caves [idx.pan_usize ()]\n\t}\n}\n\nimpl \u003c'inp\u003e Caves \u003c'inp\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn start (\u0026 self) -\u003e \u0026 Cave \u003c'inp\u003e {\n\t\t\u0026 self.caves [0]\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn end (\u0026 self) -\u003e \u0026 Cave \u003c'inp\u003e {\n\t\t\u0026 self.caves [1]\n\t}\n\n\tpub fn build (input: \u0026 Input \u003c'inp\u003e) -\u003e GenResult \u003cSelf\u003e {\n\t\tif 100 \u003c input.cnxns.len () {\n\t\t\treturn Err (\"Max 100 connections\".into ());\n\t\t}\n\t\tfn cave_id_or_insert \u003c'inp\u003e (caves: \u0026 mut Vec \u003cCave \u003c'inp\u003e\u003e, name: \u0026 InpStr \u003c'inp\u003e) -\u003e CaveId {\n\t\t\tcaves.iter ()\n\t\t\t\t.position (|cave| \u0026 cave.name == name)\n\t\t\t\t.unwrap_or_else (|| {\n\t\t\t\t\tlet idx = caves.len ();\n\t\t\t\t\tcaves.push (Cave::new (name.clone (), idx.pan_u8 ()));\n\t\t\t\t\tidx\n\t\t\t\t})\n\t\t\t\t.pan_u8 ()\n\t\t}\n\t\tlet mut caves = vec! [\n\t\t\tCave::new (InpStr::borrow (\"start\"), 0),\n\t\t\tCave::new (InpStr::borrow (\"end\"), 1),\n\t\t];\n\t\tfor cnxn in input.cnxns.iter () {\n\t\t\tlet id_0 = cave_id_or_insert (\u0026 mut caves, \u0026 cnxn.cave_0);\n\t\t\tlet id_1 = cave_id_or_insert (\u0026 mut caves, \u0026 cnxn.cave_1);\n\t\t\tif 25 \u003c caves.len () {\n\t\t\t\treturn Err (\"Max 25 caves\".into ());\n\t\t\t}\n\t\t\tcaves [id_0.pan_usize ()].cnxns.push (id_1);\n\t\t\tcaves [id_1.pan_usize ()].cnxns.push (id_0);\n\t\t}\n\t\tfor cave in \u0026 caves {\n\t\t\tif cave.small { continue }\n\t\t\tfor \u0026 cnxn in \u0026 cave.cnxns {\n\t\t\t\tif ! caves [cnxn.pan_usize ()].small {\n\t\t\t\t\treturn Err (\"Large caves can only be connected to small caves\".into ());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tOk (Self { caves })\n\t}\n\n}\n\npub struct Cave \u003c'inp\u003e {\n\tpub name: InpStr \u003c'inp\u003e,\n\tpub cnxns: Vec \u003cCaveId\u003e,\n\tpub small: bool,\n\tpub id: CaveId,\n}\n\nimpl \u003c'inp\u003e Cave \u003c'inp\u003e {\n\tfn new (name: InpStr \u003c'inp\u003e, id: CaveId) -\u003e Self {\n\t\tlet cnxns = Vec::new ();\n\t\tlet small = name.chars ().next ().unwrap ().is_ascii_lowercase ();\n\t\tSelf { name, cnxns, small, id }\n\t}\n}\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[27360],"length":1,"stats":{"Line":0},"fn_name":"start"},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[27424],"length":1,"stats":{"Line":0},"fn_name":"end"},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[27528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[27534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[28704],"length":1,"stats":{"Line":2},"fn_name":"cave_id_or_insert"},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[35936],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":39,"address":[36000,36290],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[36264,36126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[27726,28636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[27663],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[27716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[27894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":22,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"6,10\",\n\t\"0,14\",\n\t\"9,10\",\n\t\"0,3\",\n\t\"10,4\",\n\t\"4,11\",\n\t\"6,0\",\n\t\"6,12\",\n\t\"4,1\",\n\t\"0,13\",\n\t\"10,12\",\n\t\"3,4\",\n\t\"3,0\",\n\t\"8,4\",\n\t\"1,10\",\n\t\"2,14\",\n\t\"8,10\",\n\t\"9,0\",\n\t\"\",\n\t\"fold along y=7\",\n\t\"fold along x=5\",\n];\n\n#[ test ]\nfn part_one ()  {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"17\", puzzle.part_one (EXAMPLE));\n}\n","traces":[{"line":30,"address":[54247,53856],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":31,"address":[53866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[54204,54100,53977,54034,53887,53925],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","input.rs"],"content":"use super::*;\n\nuse model::Fold;\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub dots: Vec \u003cPos\u003e,\n\tpub folds: Vec \u003cFold\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { dots, folds, params } = [\n\t\tparams,\n\t\t@lines dots { Pos { y, x } = [ x, \",\", y ] }, \"\\n\",\n\t\t\"\\n\",\n\t\t@lines folds,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":14,"address":[72180],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","lib.rs"],"content":"//! Advent of Code 2021: Day 13: Transparent Origami\n//!\n//! [https://adventofcode.com/2021/day/13](https://adventofcode.com/2021/day/13)\n//!\n//! # Input\n//!\n//! First, a number of lines containing 2d points in `x,y` format, with `x` increasing to the right\n//! and `y` increasing downwards. Then, after a blank line, a number of lines containing folds in\n//! the form `fold along a=v` where `a` is the axis, `x` or `y`, and `v` is the point on the axis.\n//!\n//! # Part one\n//!\n//! Fold instructions merge points from after the fold to before it, in a mirror fashion. Apply the\n//! first fold only, then count how many unique points remain.\n//!\n//! # Part two\n//!\n//! Apply all the folds in order, then read the result as a series of capital letters.\n//!\n//! # Algorithm\n//!\n//! This is fairly simple. We simply apply the folds as described. To read the text we use the\n//! [`aoc_ocr`] library.\n\nuse aoc_common::*;\nuse aoc_ocr as ocr;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod tool;\n\npuzzle_info! {\n\tname = \"Transparent Origami\";\n\tyear = 2021;\n\tday = 13;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = tool::run; ),\n\t];\n}\n","traces":[{"line":40,"address":[57548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[57956],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::Axis;\nuse model::Fold;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet dots = fold_once (\u0026 input.folds [0], input.dots.iter ().copied ());\n\tOk (dots.len ().pan_u32 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tlet dots = fold_multi (\u0026 input.folds, input.dots.iter ().copied ());\n\tlet result = ocr::read_dots (dots.iter ().map (|pos| (pos.y, pos.x))) ?;\n\tOk (result)\n}\n\n#[ must_use ]\npub fn fold_multi (folds: \u0026 [Fold], dots: impl IntoIterator \u003cItem = Pos\u003e) -\u003e HashSet \u003cPos\u003e {\n\tfolds.iter ().fold (dots.into_iter ().collect (), |dots, fold| fold_once (fold, dots))\n}\n\n#[ must_use ]\npub fn fold_once (fold: \u0026 Fold, dots: impl IntoIterator \u003cItem = Pos\u003e) -\u003e HashSet \u003cPos\u003e {\n\tdots.into_iter ()\n\t\t.map (|mut dot| {\n\t\t\tmatch fold.axis {\n\t\t\t\tAxis::X =\u003e if dot.x \u003e fold.val { dot.x = fold.val - (dot.x - fold.val) },\n\t\t\t\tAxis::Y =\u003e if dot.y \u003e fold.val { dot.y = fold.val - (dot.y - fold.val) },\n\t\t\t}\n\t\t\tdot\n\t\t})\n\t\t.collect ()\n}\n","traces":[{"line":10,"address":[100521,100272],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[100347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[100409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[100544,100868],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":16,"address":[100615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[100702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[84752],"length":1,"stats":{"Line":0},"fn_name":"fold_multi\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003caoc_pos::dim_2::yx::PosYX\u003ci64\u003e\u003e\u003e\u003e"},{"line":23,"address":[85497,85312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[85520],"length":1,"stats":{"Line":1},"fn_name":"fold_once\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003caoc_pos::dim_2::yx::PosYX\u003ci64\u003e\u003e\u003e\u003e"},{"line":29,"address":[85616,85760],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003caoc_pos::dim_2::yx::PosYX\u003ci64\u003e\u003e\u003e\u003e"},{"line":30,"address":[78427],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[50150,50382,50206,50326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[50174,50350,50302,50126],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","model.rs"],"content":"use super::*;\n\npub type Coord = i64;\npub type Axis = pos::AxisXY;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\n#[ derive (Clone, Debug) ]\npub struct Fold {\n\tpub axis: Axis,\n\tpub val: Coord,\n}\n\nstruct_parser_display! {\n\tFold { axis, val } = [\n\t\t\"fold along \",\n\t\taxis { type = Axis; Axis::X = [ \"x\" ], Axis::Y = [ \"y\" ] },\n\t\t\"=\",\n\t\tval,\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","tool.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::Pos;\n\n#[ derive (clap::Parser) ]\npub struct RunArgs {\n\n\t#[ clap (long, value_parser, default_value = \"inputs/day-13\") ]\n\tinput: String,\n\n}\n\n#[ allow (clippy::print_stdout) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tlet dots = logic::fold_multi (\u0026 input.folds, input.dots.iter ().copied ());\n\tprint! (\"{}\", ocr::DrawDots (dots.iter ().map (|\u0026 Pos { y, x }| (y, x))));\n\tOk (())\n}\n","traces":[{"line":17,"address":[42864,43731],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":18,"address":[42945,43520,42876],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[43020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[43132,43558,43061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[43236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[43293,43431,43281],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-14","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"NNCB\",\n\t\"\",\n\t\"CH -\u003e B\",\n\t\"HH -\u003e N\",\n\t\"CB -\u003e H\",\n\t\"NH -\u003e C\",\n\t\"HB -\u003e C\",\n\t\"HC -\u003e B\",\n\t\"HN -\u003e C\",\n\t\"NN -\u003e C\",\n\t\"BH -\u003e H\",\n\t\"NC -\u003e B\",\n\t\"NB -\u003e B\",\n\t\"BN -\u003e B\",\n\t\"BB -\u003e N\",\n\t\"BC -\u003e B\",\n\t\"CC -\u003e N\",\n\t\"CN -\u003e C\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"1588\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2188189693529\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":27,"address":[42944,42948],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[64986],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[65220,65154,65007,65045,65324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[42980,42976],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":34,"address":[65386],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[65407,65620,65554,65497,65724,65445],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-14","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input \u003c'inp\u003e {\n\tpub template: InpStr \u003c'inp\u003e,\n\tpub rules: Vec \u003c((char, char), char)\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tinput_lifetime = 'inp;\n\tInput \u003c'inp\u003e { template, rules, params } = [\n\t\tparams,\n\t\t@str template = (|ch| { ch.is_ascii_uppercase () }, 1 .. ), \"\\n\",\n\t\t\"\\n\",\n\t\t@lines rules {\n\t\t\ttype = ((char, char), char);\n\t\t\t((left, right), insert) = [ left, right, \" -\u003e \", insert ],\n\t\t},\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[66106],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-14","lib.rs"],"content":"//! Advent of Code 2021: Day 14: Extended Polymerization\n//!\n//! [https://adventofcode.com/2021/day/14](https://adventofcode.com/2021/day/14)\n//!\n//! # Input\n//!\n//! The first line is a string consisting of upper-case letters. After a blank line, there is a\n//! list of rules for inserting extra characters between a specific pair of letters, each on its\n//! own line, for example `AB -\u003e C` means to insert `C` between `A` and `B`.\n//!\n//! # Part one\n//!\n//! Apply the rules ten times. Find the most common letter and the least common letter in the\n//! result, and find the difference.\n//!\n//! # Part two\n//!\n//! Same as part one, but repeat the process forty times.\n//!\n//! # Algorithm\n//!\n//! Instead of tracking the entire string, we simply track adjacent pairs of letters. When\n//! inserting characters, we add the sum to the two new pairs created between the left character\n//! and the newly inserted, and the newly inserted and the right.\n//!\n//! At the end, we convert to a character count by counting only the second of each pair. We also\n//! have to count the first character, since it is not the second in pair.\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Extended Polymerization\";\n\tyear = 2021;\n\tday = 14;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-14","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, 10)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tcalc_result (input, 40)\n}\n\npub fn calc_result (input: \u0026 Input, loops: u32) -\u003e GenResult \u003cu64\u003e {\n\tlet rules = get_rules (input) ?;\n\tlet mut pair_counts =\n\t\tinput.template.chars ()\n\t\t\t.tuple_windows ()\n\t\t\t.map (|(left, right)| ((left, right), 1))\n\t\t\t.into_grouping_map ()\n\t\t\t.sum ();\n\tfor _ in 0 .. loops {\n\t\tpair_counts = pair_counts.into_iter ()\n\t\t\t.flat_map (|((left, right), num)| {\n\t\t\t\tlet insert = rules [\u0026 (left, right)];\n\t\t\t\t[ ((left, insert), num), ((insert, right), num) ]\n\t\t\t})\n\t\t\t.into_grouping_map ()\n\t\t\t.sum ();\n\t}\n\tlet char_counts = pair_counts.iter ()\n\t\t.map (|(\u0026 (_, right), \u0026 num)| (right, num))\n\t\t.chain (iter::once ((input.template.chars ().next ().unwrap (), 1)))\n\t\t.into_grouping_map ()\n\t\t.sum ();\n\tlet most = char_counts.values ().max ().unwrap ();\n\tlet least = char_counts.values ().min ().unwrap ();\n\tOk (most - least)\n}\n\npub fn get_rules (input: \u0026 Input) -\u003e GenResult \u003cHashMap \u003c(char, char), char\u003e\u003e {\n\tlet rules: HashMap \u003c(char, char), char\u003e =\n\t\tinput.rules.iter ().copied ().collect ();\n\tlet chars: HashSet \u003cchar\u003e =\n\t\titer::empty ()\n\t\t\t.chain (input.template.chars ())\n\t\t\t.chain (input.rules.iter ().map (|\u0026 (_, ch)| ch))\n\t\t\t.collect ();\n\tif let Some ((left, right)) =\n\t\tchars.iter ().copied ()\n\t\t\t.cartesian_product (chars.iter ().copied ())\n\t\t\t.find (|\u0026 (left, right)| ! rules.contains_key (\u0026 (left, right))) {\n\t\treturn Err (format! (\"No rules for chars '{left}' and '{right}'\").into ());\n\t}\n\tOk (rules)\n}\n","traces":[{"line":7,"address":[57968],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":8,"address":[31626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[58000],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":12,"address":[32026],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[59872,58032],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":16,"address":[58306,58065,58157],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[58412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[42451,42448],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":23,"address":[58444],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[58653,58680],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[42480,42496],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":26,"address":[42507,42664],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[42667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[58926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[42752,42039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[58779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[59239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[59559],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[59584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[59888,61014],"length":1,"stats":{"Line":2},"fn_name":"get_rules"},{"line":48,"address":[42768],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":50,"address":[60485,60615],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[42789,42926,42784],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":54,"address":[60628,60756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[60492],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":19,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"1163751742\", \"1381373672\", \"2136511328\", \"3694931569\", \"7463417111\",\n\t\"1319128137\", \"1359912421\", \"3125421639\", \"1293138521\", \"2311944581\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"40\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"315\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[46900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[66506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[66674,66844,66527,66565,66740,66617],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[47284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[66906],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[67017,67074,66965,66927,67140,67244],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","input.rs"],"content":"use super::*;\n\nuse model::Risks;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub risks: Risks,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { risks, params } = [ params, risks = risks_parse ]\n}\n\nfn risks_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cRisks\u003e {\n\tRisks::parse_with_fn (parser, || 1, |parser| {\n\t\tif ! matches! (parser.peek (), Some ('1' ..= '9')) { return Err (parser.err ()) }\n\t\tOk (parser.next ().unwrap ().to_digit (10).unwrap ().pan_u8 ())\n\t})\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":15,"address":[66480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[46530],"length":1,"stats":{"Line":4},"fn_name":null},{"line":17,"address":[55429,55548],"length":1,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[55464,55536,55437],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":3,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","lib.rs"],"content":"//! Advent of Code 2021: Day 15: Chiton\n//!\n//! [https://adventofcode.com/2021/day/15](https://adventofcode.com/2021/day/15)\n//!\n//! # Input\n//!\n//! A grid of single-digit cost values, in the range `1` to `9`.\n//!\n//! # Part one\n//!\n//! Calculate the lower cost to get from the top left point to the bottom right. The cost is\n//! applied on entering a square, so the top left cost is irrelevant.\n//!\n//! # Part two\n//!\n//! Same as part one, except the grid is replicated five times down and to the right, for a total\n//! of twenty five times. Each time the grid is replicated in those directions, the cost of each\n//! point is increased by one. A value of `9` becomes `1`.\n//!\n//! # Algorithm\n//!\n//! This is a relatively simple path finder. We use [`PrioritySearch`](search::PrioritySearch) to\n//! prioritise the routes with the lowest risk, and keep a cache of the best ones so far to each\n//! point so we can short-circuit appropriately.\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\nuse aoc_search as search;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Chiton\";\n\tyear = 2021;\n\tday = 15;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":42,"address":[64033],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::Cursor;\nuse model::Grid;\nuse model::Pos;\nuse model::Offset;\nuse model::Risks;\nuse search::PrioritySearch;\nuse search::PrioritySearchAdder;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\tcalc_result (\u0026 input.risks)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu16\u003e {\n\n\t// replicate the grid five times right and down\n\n\tlet y_range = input.risks.first_key ().y ..= input.risks.last_key ().y;\n\tlet x_range = input.risks.first_key ().x ..= input.risks.last_key ().x;\n\n\tlet y_iter = (0 .. 5).flat_map (|y_rep| y_range.clone ().map (move |y| (y_rep, y)));\n\tlet x_iter = (0 .. 5).flat_map (|x_rep| x_range.clone ().map (move |x| (x_rep, x)));\n\n\tlet risks = Grid::wrap_size (\n\t\ty_iter.cartesian_product (x_iter)\n\t\t\t.map (|((y_rep, y), (x_rep, x))| {\n\t\t\t\tlet orig_risk = input.risks.get (Pos { y, x }).unwrap ();\n\t\t\t\t(orig_risk + y_rep + x_rep - 1) % 9 + 1\n\t\t\t})\n\t\t\t.collect (),\n\t\tinput.risks.size () * 5);\n\n\t// apply the algorithm\n\n\tcalc_result (\u0026 risks)\n\n}\n\nfn calc_result (risks: \u0026 Risks) -\u003e GenResult \u003cu16\u003e {\n\n\tif risks.size ().y \u003c 2 || risks.size ().x \u003c 2 {\n\t\treturn Err (\"Minimum grid size is 22\".into ());\n\t}\n\n\t// prepare offsets for efficient grid operations\n\n\tlet offsets: [Offset; 4] =\n\t\tPos::ZERO.adjacent_4 ().into_iter ()\n\t\t\t.map (|pos| risks.offset (pos).unwrap ())\n\t\t\t.array ();\n\n\t// set up priority search, with a function that tries to walk in four directions\n\n\tlet mut search = PrioritySearch::with_grid_size (\n\t    risks.size (),\n\t\t|cur: Cursor, path_risk, mut adder: PrioritySearchAdder \u003cCursor, u16, _\u003e| {\n\t\t\tfor \u0026 adj_off in offsets.iter () {\n\t\t\t    let adj_cur = ok_or! (chk! (cur + adj_off), continue);\n\t\t\t\tlet adj_risk = adj_cur.get (risks);\n\t\t\t\tlet adj_path_risk = path_risk + adj_risk.pan_u16 ();\n\t\t\t\tadder.add (adj_cur, adj_path_risk);\n\t\t\t}\n\t\t\t(cur.pos (), path_risk)\n\t\t},\n\t);\n\n\t// add the starting position with a cost of zero\n\n\tsearch.push (risks.cursor (risks.first_key ()).unwrap (), 0);\n\n\t// apply the search and return the first result which reaches the target\n\n\tOk (\n\t\tsearch\n\t\t\t.filter (|\u0026 (pos, _)| pos == risks.last_key ())\n\t\t\t.map (|(_, score)| score)\n\t\t\t.next ()\n\t\t\t.unwrap ()\n\t)\n\n}\n","traces":[{"line":14,"address":[55616],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":15,"address":[63649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[56547,55632],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[55778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[55908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[86656,86642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[86688,86610],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[86239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[86268,86302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[56518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[56312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[56560,57781],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":45,"address":[56585],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[57291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[56656,56612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[37434,37249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[56664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[88208],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":61,"address":[88235,88304,88810],"length":1,"stats":{"Line":6},"fn_name":null},{"line":62,"address":[88319,89088,89024,89032,89096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[88438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[88906,88542],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[56786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[57538,57441],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[57506],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":20,"coverable":25},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Cursor = GridCursor \u003cPos, 2\u003e;\npub type Grid \u003cVal\u003e = GridBuf \u003cVec \u003cVal\u003e, Pos, 2\u003e;\npub type Offset = GridOffset \u003cPos, 2\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\npub type Risks = Grid \u003cVal\u003e;\npub type Val = u8;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [\"D2FE28\"]));\n\tassert_eq_ok! (\"9\", puzzle.part_one (\u0026 [\"38006F45291200\"]));\n\tassert_eq_ok! (\"14\", puzzle.part_one (\u0026 [\"EE00D40C823060\"]));\n\tassert_eq_ok! (\"16\", puzzle.part_one (\u0026 [\"8A004A801A8002F478\"]));\n\tassert_eq_ok! (\"12\", puzzle.part_one (\u0026 [\"620080001611562C8802118E34\"]));\n\tassert_eq_ok! (\"23\", puzzle.part_one (\u0026 [\"C0015000016115A2E0802F182340\"]));\n\tassert_eq_ok! (\"31\", puzzle.part_one (\u0026 [\"A0016C880162017C3686B18A3D4780\"]));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [\"C200B40A82\"]));\n\tassert_eq_ok! (\"54\", puzzle.part_two (\u0026 [\"04005AC33890\"]));\n\tassert_eq_ok! (\"7\", puzzle.part_two (\u0026 [\"880086C3E88112\"]));\n\tassert_eq_ok! (\"9\", puzzle.part_two (\u0026 [\"CE00C43D881120\"]));\n\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [\"D8005AC2A8F0\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [\"F600BC2D8F\"]));\n\tassert_eq_ok! (\"0\", puzzle.part_two (\u0026 [\"9C005AC2F8F0\"]));\n\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [\"9C0141080250320F1802104A08\"]));\n}\n","traces":[{"line":6,"address":[34772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":7,"address":[27809],"length":1,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[29927,27872,27830,28737,27928,28803],"length":1,"stats":{"Line":3},"fn_name":null},{"line":9,"address":[28047,27988,27950,28871,28932,29889],"length":1,"stats":{"Line":3},"fn_name":null},{"line":10,"address":[29848,28172,28069,29000,29061,28113],"length":1,"stats":{"Line":3},"fn_name":null},{"line":11,"address":[28238,29807,28297,28194,29129,29190],"length":1,"stats":{"Line":3},"fn_name":null},{"line":12,"address":[29258,29319,29766,28319,28422,28363],"length":1,"stats":{"Line":3},"fn_name":null},{"line":13,"address":[29725,28547,28488,29448,28444,29387],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[29574,28672,28569,28613,29513,29684],"length":1,"stats":{"Line":3},"fn_name":null},{"line":18,"address":[29984,32372],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":19,"address":[30001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[32329,31011,31074,30064,30022,30117],"length":1,"stats":{"Line":3},"fn_name":null},{"line":21,"address":[31200,32293,30175,30137,31140,30228],"length":1,"stats":{"Line":3},"fn_name":null},{"line":22,"address":[30248,30348,31326,30292,32254,31266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[30368,32215,30412,31392,30468,31452],"length":1,"stats":{"Line":3},"fn_name":null},{"line":24,"address":[32176,30532,30588,31518,30488,31578],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[30708,32137,30652,30608,31704,31644],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[31770,31830,30828,30772,30728,32098],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[30892,30948,31953,30848,31893,32059],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":19,"coverable":19},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub data: Vec \u003cu8\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { data, params } = [ params, @collect data = (hex_byte_parse, hex_byte_display) ]\n}\n\nfn hex_byte_parse (parser: \u0026 mut Parser) -\u003e ParseResult \u003cu8\u003e {\n\tlet rest = parser.take_rest_while (|ch| ch.is_ascii_hexdigit (), 2 ..= 2) ?;\n\tOk (u8::from_str_radix (\u0026 rest, 16).unwrap ())\n}\n\nfn hex_byte_display (byte: \u0026 u8, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\twrite! (formatter, \"{byte:02X}\")\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[33075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[32624,32878],"length":1,"stats":{"Line":2},"fn_name":"hex_byte_parse"},{"line":14,"address":[32896,32654,32931],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[32770,32785],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","lib.rs"],"content":"//! Advent of Code 2021: Day 15: Packet Decoder\n//!\n//! [https://adventofcode.com/2021/day/16](https://adventofcode.com/2021/day/16)\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Packet Decoder\";\n\tyear = 2021;\n\tday = 16;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":17,"address":[52248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[52568],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::BitIter;\nuse model::Packet;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut input_iter = BitIter::new (\u0026 input.data);\n\tlet packet = Packet::decode (\u0026 mut input_iter).ok_or (\"Failed to decode packet\") ?;\n\tOk (packet.version_sum ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut input_iter = BitIter::new (\u0026 input.data);\n\tlet packet = Packet::decode (\u0026 mut input_iter).ok_or (\"Failed to decode packet\") ?;\n\tOk (packet_eval (\u0026 packet).ok_or (\"Failed to evaluate packet\") ?)\n}\n\nfn packet_eval (packet: \u0026 Packet) -\u003e Option \u003cu64\u003e {\n\tlet child_vals = || packet.children.iter ().map (packet_eval);\n\tlet child_at = |pos| child_vals ().nth (pos) ?;\n\tmatch packet.packet_type {\n\t\t0 =\u003e child_vals ().try_fold (0, |sum, item| {\n\t\t\tlet item = item ?;\n\t\t\tchk! (sum + item).ok ()\n\t\t}),\n\t\t1 =\u003e child_vals ().try_fold (1, |prod, item| {\n\t\t\tlet item = item ?;\n\t\t\tchk! (prod * item).ok ()\n\t\t}),\n\t\t2 =\u003e child_vals ().try_fold (u64::MAX, |min, item| {\n\t\t\tSome (cmp::min (min, item ?))\n\t\t}),\n\t\t3 =\u003e child_vals ().try_fold (u64::MIN, |max, item| {\n\t\t\tSome (cmp::max (max, item ?))\n\t\t}),\n\t\t4 =\u003e Some (packet.value),\n\t\t5 =\u003e {\n\t\t\tif packet.children.len () != 2 { return None }\n\t\t\tSome (u64::from (child_at (0) \u003e child_at (1)))\n\t\t},\n\t\t6 =\u003e {\n\t\t\tif packet.children.len () != 2 { return None }\n\t\t\tSome (u64::from (child_at (0) \u003c child_at (1)))\n\t\t},\n\t\t7 =\u003e {\n\t\t\tif packet.children.len () != 2 { return None }\n\t\t\tSome (u64::from (child_at (0) == child_at (1)))\n\t\t},\n\t\t_ =\u003e panic! (),\n\t}\n}\n","traces":[{"line":9,"address":[45120,45381],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[45131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[45243,45330,45176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[45283],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[45392,45692],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":16,"address":[45403],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[45448,45515,45608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[45572,45555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[45712],"length":1,"stats":{"Line":1},"fn_name":"packet_eval"},{"line":22,"address":[36116,36112,36180,36149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[36160,36177,36378],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":24,"address":[45726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[36416],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":26,"address":[36419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[38144,38176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[36464],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":30,"address":[23903,21839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[38240,38208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[36512],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":34,"address":[23743,22293],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[36560],"length":1,"stats":{"Line":0},"fn_name":"{closure#5}"},{"line":37,"address":[21989,23791],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[46182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[46360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[46518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[46678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[47808],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":19,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","model.rs"],"content":"use super::*;\n\npub use bit_iter::BitIter;\npub use packet::Packet;\n\nmod bit_iter {\n\n\tuse super::*;\n\n\tpub struct BitIter \u003c'dat\u003e {\n\t\tdata: \u0026 'dat [u8],\n\t\tval: u8,\n\t\tval_bits: u8,\n\t\tposition: usize,\n\t}\n\n\timpl \u003c'dat\u003e BitIter \u003c'dat\u003e {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn new (data: \u0026 'dat [u8]) -\u003e BitIter \u003c'dat\u003e {\n\t\t\tBitIter {\n\t\t\t\tdata,\n\t\t\t\tval: 0,\n\t\t\t\tval_bits: 0,\n\t\t\t\tposition: 0,\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn position (\u0026 self) -\u003e usize {\n\t\t\tself.position\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn next_uint (\u0026 mut self, bits: u8) -\u003e Option \u003cu64\u003e {\n\t\t\tif 64 \u003c bits { panic! (); }\n\t\t\tlet mut val = 0;\n\t\t\tfor _ in 0 .. bits {\n\t\t\t\tlet next_bit = some_or! (self.next_bit (), return None);\n\t\t\t\tval = val \u003c\u003c 1_i32 | u64::from (next_bit);\n\t\t\t}\n\t\t\tSome (val)\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn next_bit (\u0026 mut self) -\u003e Option \u003cbool\u003e {\n\t\t\tif ! self.has_next () { return None }\n\t\t\tself.position += 1;\n\t\t\tif self.val_bits == 0 {\n\t\t\t\tself.val = self.data [0];\n\t\t\t\tself.val_bits = 8;\n\t\t\t\tself.data = \u0026 self.data [1 .. ];\n\t\t\t}\n\t\t\tlet result = self.val \u0026 0x80 != 0;\n\t\t\tself.val \u003c\u003c= 1_u32;\n\t\t\tself.val_bits -= 1;\n\t\t\tSome (result)\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn has_next (\u0026 mut self) -\u003e bool {\n\t\t\t0 \u003c self.val_bits || ! self.data.is_empty ()\n\t\t}\n\n\t}\n\n}\n\nmod packet {\n\n\tuse super::*;\n\n\t#[ allow (dead_code) ]\n\t#[ derive (Debug) ]\n\tpub struct Packet {\n\t\tpub version: u64,\n\t\tpub packet_type: u64,\n\t\tpub value: u64,\n\t\tpub children: Vec \u003cPacket\u003e,\n\t}\n\n\timpl Packet {\n\n\t\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t\tpub fn decode (iter: \u0026 mut BitIter \u003c'_\u003e) -\u003e Option \u003cSelf\u003e {\n\t\t\tif ! iter.has_next () { return None }\n\t\t\tlet version = iter.next_uint (3) ?;\n\t\t\tlet packet_type = iter.next_uint (3) ?;\n\t\t\tlet mut value = 0;\n\t\t\tlet mut children = Vec::new ();\n\t\t\tif packet_type == 4 {\n\t\t\t\tlet mut bits = 0_i32;\n\t\t\t\tloop {\n\t\t\t\t\tlet is_last = ! iter.next_bit () ?;\n\t\t\t\t\tif bits + 4_i32 \u003e 64_i32 { return None }\n\t\t\t\t\tvalue = value \u003c\u003c 4_i32 | iter.next_uint (4) ?;\n\t\t\t\t\tbits += 4_i32;\n\t\t\t\t\tif is_last { break }\n\t\t\t\t}\n\t\t\t} else if ! iter.next_bit () ? {\n\t\t\t\tlet child_bits = iter.next_uint (15) ?;\n\t\t\t\tlet end_position = iter.position () + child_bits.pan_usize ();\n\t\t\t\twhile iter.position () \u003c end_position {\n\t\t\t\t\tchildren.push (Self::decode (iter) ?);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet num_children = iter.next_uint (11) ?;\n\t\t\t\tfor _ in 0 .. num_children {\n\t\t\t\t\tchildren.push (Self::decode (iter) ?);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSome (Self { version, packet_type, value, children })\n\t\t}\n\n\t\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t\t#[ must_use ]\n\t\tpub fn version_sum (\u0026 self) -\u003e u64 {\n\t\t\tself.version + self.children.iter ()\n\t\t\t\t.map (Self::version_sum)\n\t\t\t\t.sum::\u003cu64\u003e ()\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[41488],"length":1,"stats":{"Line":0},"fn_name":"position"},{"line":33,"address":[37190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[41504],"length":1,"stats":{"Line":1},"fn_name":"next_uint"},{"line":38,"address":[41611,41515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[41530,41585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[41552],"length":1,"stats":{"Line":14},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[41648],"length":1,"stats":{"Line":2},"fn_name":"next_bit"},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[41700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[41724],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[36608,38038],"length":1,"stats":{"Line":2},"fn_name":"decode"},{"line":88,"address":[36653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[36733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[36811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[36863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[36925,37104,36912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[36931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[37093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[37108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[37119,37129,37164],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[37188,37172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[37249,37934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[37530,37268],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[37301,37379],"length":1,"stats":{"Line":3},"fn_name":null},{"line":109,"address":[37561,37545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[37577],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[37647,37725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[37885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[38048],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[21568,21608,21658,24041,24066,23998],"length":1,"stats":{"Line":8},"fn_name":null}],"covered":38,"coverable":43},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"target area: x=20..30, y=-10..-5\" ];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"45\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn test_example () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"112\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":8,"address":[27476],"length":1,"stats":{"Line":2},"fn_name":null},{"line":9,"address":[40618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[40852,40677,40729,40639,40786,40956],"length":1,"stats":{"Line":3},"fn_name":null},{"line":14,"address":[27652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[41018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[41356,41077,41039,41129,41186,41252],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","input.rs"],"content":"use super::*;\n\nuse model::Coord;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub target_x_start: Coord,\n\tpub target_x_end: Coord,\n\tpub target_y_start: Coord,\n\tpub target_y_end: Coord,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { target_x_start, target_x_end, target_y_start, target_y_end, params } = [\n\t\tparams,\n\t\t\"target area: \",\n\t\t\"x=\", target_x_start, \"..\", target_x_end, \", \",\n\t\t\"y=\", target_y_start, \"..\", target_y_end,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","lib.rs"],"content":"//! Advent of Code 2021: Day 17: Trick Shot\n//!\n//! [https://adventofcode.com/2021/day/17](https://adventofcode.com/2021/day/17)\n\nuse aoc_common::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Trick Shot\";\n\tyear = 2021;\n\tday = 17;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[25256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[25512],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cCoord\u003e {\n\tlet results = find_solutions (input) ?;\n\tOk (\n\t\tresults.into_iter ()\n\t\t\t.map (|(_, height)| height)\n\t\t\t.max ()\n\t\t\t.ok_or (\"No solution found\") ?\n\t)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu32\u003e {\n\tlet results = find_solutions (input) ?;\n\tOk (results.len ().pan_u32 ())\n}\n\nfn find_solutions (input: \u0026 Input) -\u003e GenResult \u003cVec \u003c(Pos, Coord)\u003e\u003e {\n\tlet mut results: Vec \u003c(Pos, Coord)\u003e = Vec::new ();\n\tfor x_velocity in 1 ..= input.target_x_end {\n\t\tfor y_velocity in input.target_y_start ..= -2 * input.target_y_end {\n\t\t\tlet velocity = Pos { x: x_velocity, y: y_velocity };\n\t\t\tif let Some (max_height) = simulate (input, velocity) ? {\n\t\t\t\tresults.push ((velocity, max_height));\n\t\t\t}\n\t\t}\n\t}\n\tOk (results)\n}\n\nfn simulate (input: \u0026 Input, velocity: Pos) -\u003e GenResult \u003cOption \u003cCoord\u003e\u003e {\n\tlet mut position = Pos { x: 0, y: 0 };\n\tlet mut velocity = velocity;\n\tlet mut max_height = 0;\n\twhile ! ((velocity.x == 0 \u0026\u0026 position.x \u003c input.target_x_start)\n\t\t\t|| (input.target_x_end \u003c position.x)\n\t\t\t|| (velocity.y \u003c= 0 \u0026\u0026 position.y \u003c input.target_y_start)) {\n\t\tif (input.target_x_start ..= input.target_x_end).contains (\u0026 position.x)\n\t\t\t\t\u0026\u0026 (input.target_y_start ..= input.target_y_end).contains (\u0026 position.y) {\n\t\t\treturn Ok (Some (max_height));\n\t\t}\n\t\tchk! (position.x += velocity.x) ?;\n\t\tif velocity.x \u003e 0 { chk! (velocity.x -= 1) ?; }\n\t\tchk! (position.y += velocity.y) ?;\n\t\tchk! (velocity.y -= 1) ?;\n\t\tif position.y \u003e max_height { max_height = position.y; }\n\t}\n\tOk (None)\n}\n","traces":[{"line":9,"address":[34896],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[34915,34937,35180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[35237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[31168,31175],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":19,"address":[35296,35463],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":20,"address":[35332,35309,35417],"length":1,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[35397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[36135,35472],"length":1,"stats":{"Line":2},"fn_name":"find_solutions"},{"line":26,"address":[35523,35684],"length":1,"stats":{"Line":4},"fn_name":null},{"line":27,"address":[35868,36083,35570,35711],"length":1,"stats":{"Line":6},"fn_name":null},{"line":29,"address":[35876,35911,35955],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[36034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[36144],"length":1,"stats":{"Line":2},"fn_name":"simulate"},{"line":41,"address":[36419,36172,36256,36262],"length":1,"stats":{"Line":8},"fn_name":null},{"line":42,"address":[36251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[36258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[36273,36279],"length":1,"stats":{"Line":4},"fn_name":null},{"line":46,"address":[36494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[31184],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":49,"address":[22219],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[31232],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":51,"address":[22171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[36408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[36188],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":23,"coverable":24},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","model.rs"],"content":"use super::*;\n\npub type Coord = i16;\npub type Pos = pos::PosXY \u003cCoord\u003e;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]\",\n\t\"[[[5,[2,8]],4],[5,[[9,9],0]]]\",\n\t\"[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]\",\n\t\"[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]\",\n\t\"[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]\",\n\t\"[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]\",\n\t\"[[[[5,4],[7,7]],8],[[8,3],8]]\",\n\t\"[[9,3],[[9,9],[6,[4,9]]]]\",\n\t\"[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]\",\n\t\"[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"4140\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3993\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":19,"address":[55732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[77466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[77525,77577,77634,77700,77804,77487],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[55796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[77866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[78204,77925,77977,78100,77887,78034],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub nums: Vec \u003cTokens\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { nums, params } = [ params, @lines nums ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct Tokens {\n\tpub tokens: Vec \u003cToken\u003e,\n}\n\nstruct_parser_display! {\n\tTokens { tokens } = [ @collect tokens ]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Token {\n\tOpen,\n\tClose,\n\tComma,\n\tValue (u8),\n}\n\nenum_parser_display! {\n\tToken,\n\tOpen = [ \"[\" ],\n\tClose = [ \"]\" ],\n\tComma = [ \",\" ],\n\tValue (val) = [ val = 0 ..= 9 ],\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[55179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[54995],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","lib.rs"],"content":"//! Advent of Code 2021: Day 18: Snailfish\n//!\n//! [https://adventofcode.com/2021/day/18](https://adventofcode.com/2021/day/18)\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Snailfish\";\n\tyear = 2021;\n\tday = 18;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":17,"address":[52232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[52552],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","logic.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Input;\nuse model::Number;\nuse model::Val;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tif input.nums.is_empty () {\n\t\treturn Err (\"Must provide at least one number\".into ());\n\t}\n\tlet nums: Vec \u003cNumber\u003e =\n\t\tinput.nums.iter ()\n\t\t\t.map (Number::try_from)\n\t\t\t.try_collect () ?;\n\tlet sum = Number::sum (nums.into_iter ());\n\tOk (sum.unwrap ().magnitude ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cVal\u003e {\n\tlet nums: Vec \u003cNumber\u003e =\n\t\tinput.nums.iter ()\n\t\t\t.map (Number::try_from)\n\t\t\t.try_collect () ?;\n\tlet mut best: Val = Val::MIN;\n\tfor i in 0 .. nums.len () {\n\t\tfor j in 0 .. nums.len () {\n\t\t\tif i == j { continue }\n\t\t\tlet value = Number::add (nums [i].clone (), nums [j].clone ()).magnitude ();\n\t\t\tif value \u003e best { best = value; }\n\t\t}\n\t}\n\tOk (best)\n}\n","traces":[{"line":9,"address":[49808,50424],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[49833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[49982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[50031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[50217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[50432,51734],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":22,"address":[50588,51437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[50645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[50732],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[50782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[51692,51627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[51317],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[51336],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":13},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","model.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse super::*;\n\nuse input::Token;\nuse input::Tokens;\n\nuse digit::Digit;\npub use error::ParseError;\npub use number::Number;\n\npub type Val = u16;\n\nmod digit {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Eq, PartialEq) ]\n\tpub struct Digit {\n\t\tdepth: u8,\n\t\tvalue: u8,\n\t}\n\n\timpl Digit {\n\t\tpub const fn new (depth: u8, value: u8) -\u003e Self {\n\t\t\tSelf { depth, value }\n\t\t}\n\t\tpub const fn depth (self) -\u003e u8 { self.depth }\n\t\tpub const fn value (self) -\u003e u8 { self.value }\n\t}\n\n\timpl Debug for Digit {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter,\n\t\t\t\t\"Digit {{ depth: {depth}, value: {value} }}\",\n\t\t\t\tdepth = self.depth (),\n\t\t\t\tvalue = self.value ())\n\t\t}\n\t}\n\n}\n\nmod error {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum ParseError {\n\t\tToken,\n\t\tMismatch,\n\t\tNumber,\n\t\tUnexpectedEnd,\n\t\tUnexpectedOpen,\n\t\tUnexpectedClose,\n\t\tUnexpectedComma,\n\t\tUnexpectedValue,\n\t}\n\n\timpl Display for ParseError {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet msg = match * self {\n\t\t\t\tSelf::Token =\u003e \"Error parsing token\",\n\t\t\t\tSelf::Mismatch =\u003e \"Square brackets are not matched\",\n\t\t\t\tSelf::Number =\u003e \"Number does not conform to rules\",\n\t\t\t\tSelf::UnexpectedEnd =\u003e \"Unexpected end of tokens\",\n\t\t\t\tSelf::UnexpectedOpen =\u003e \"Unexpected open bracket\",\n\t\t\t\tSelf::UnexpectedClose =\u003e \"Unexpected close bracket\",\n\t\t\t\tSelf::UnexpectedComma =\u003e \"Unexpected comma\",\n\t\t\t\tSelf::UnexpectedValue =\u003e \"Unexpected value\",\n\t\t\t};\n\t\t\twrite! (formatter, \"Error parsing Snailfish number: {msg}\")\n\t\t}\n\t}\n\n\timpl Error for ParseError {\n\t}\n\n}\n\nmod number {\n\n\tuse super::*;\n\n\ttype DigitsVec = ArrayVec \u003cDigit, 31\u003e;\n\n\t#[ derive (Clone, Eq, PartialEq) ]\n\tpub struct Number {\n\t\tdigits: DigitsVec,\n\t}\n\n\timpl Number {\n\n\t\t#[ must_use ]\n\t\tpub fn magnitude (\u0026 self) -\u003e Val {\n\t\t\tlet mut idx: usize = 0;\n\t\t\tlet result = self.magnitude_real (\u0026 mut idx, 0);\n\t\t\tdebug_assert_eq! (idx, self.digits.len ());\n\t\t\tresult\n\t\t}\n\n\t\tfn magnitude_real (\u0026 self, idx: \u0026 mut usize, depth: u8) -\u003e Val {\n\t\t\tlet digit = self.digits [* idx];\n\t\t\tdebug_assert! (depth \u003c= digit.depth ());\n\t\t\tif digit.depth () == depth {\n\t\t\t\t* idx += 1;\n\t\t\t\treturn Val::from_u8 (digit.value ()).unwrap ();\n\t\t\t}\n\t\t\tlet left = self.magnitude_real (idx, depth + 1);\n\t\t\tlet right = self.magnitude_real (idx, depth + 1);\n\t\t\tleft * 3 + right * 2\n\t\t}\n\n\t\tpub fn sum \u003cIter\u003e (iter: Iter) -\u003e Option \u003cSelf\u003e\n\t\t\t\twhere Iter: IntoIterator \u003cItem = Self\u003e {\n\t\t\titer.into_iter ().reduce (Self::add)\n\t\t}\n\n\t\t#[ allow (clippy::should_implement_trait) ]\n\t\t#[ must_use ]\n\t\tpub fn add (left: Self, right: Self) -\u003e Self {\n\t\t\tSelf::pair (left, right).reduce ()\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn pair (left: Self, right: Self) -\u003e Self {\n\t\t\tlet digits = iter::empty ()\n\t\t\t\t.chain (left.digits.iter ()\n\t\t\t\t\t.map (|digit| Digit::new (digit.depth () + 1, digit.value ())))\n\t\t\t\t.chain (right.digits.iter ()\n\t\t\t\t\t.map (|digit| Digit::new (digit.depth () + 1, digit.value ())))\n\t\t\t\t.collect ();\n\t\t\tSelf { digits }\n\t\t}\n\n\t\t#[ must_use ]\n\t\tpub fn reduce (self) -\u003e Self {\n\n\t\t\t// short circuit if no action is necessary\n\n\t\t\tif self.digits.iter ().all (|digit| digit.depth () \u003c 5 \u0026\u0026 digit.value () \u003c 10) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\t// set up state machine to switch between explode and split, and track range to work\n\t\t\t// on\n\n\t\t\tenum State { Explode, Split }\n\t\t\tlet mut state = State::Explode;\n\t\t\tlet mut start = 0;\n\t\t\tlet mut end = self.digits.len ();\n\t\t\tlet mut left = DigitsVec::new ();\n\t\t\tlet mut right: DigitsVec = self.digits.into_iter ().rev ().collect ();\n\n\t\t\t// loop until there is no more work\n\n\t\t\t'OUTER: loop {\n\t\t\t\tmatch state {\n\t\t\t\t\tState::Explode =\u003e {\n\n\t\t\t\t\t\t// explode until `end`\n\n\t\t\t\t\t\twhile left.len () \u003c end \u0026\u0026 ! right.is_empty () {\n\t\t\t\t\t\t\tlet digit = right.pop ().unwrap ();\n\n\t\t\t\t\t\t\t// if depth is less than five just copy this digit and continue\n\n\t\t\t\t\t\t\tif digit.depth () \u003c 5 {\n\t\t\t\t\t\t\t\tif digit.value () \u003c 10 \u0026\u0026 start == left.len () { start += 1; }\n\t\t\t\t\t\t\t\tleft.push (digit);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// explode this digit: first add the number to the left\n\n\t\t\t\t\t\t\tif ! left.is_empty () {\n\t\t\t\t\t\t\t\tlet prev = left.pop ().unwrap ();\n\t\t\t\t\t\t\t\tif left.len () \u003c start { start = left.len (); }\n\t\t\t\t\t\t\t\tlet value = prev.value () + digit.value ();\n\t\t\t\t\t\t\t\tif value \u003c 10 \u0026\u0026 start == left.len () { start += 1; }\n\t\t\t\t\t\t\t\tleft.push (Digit::new (prev.depth (), value));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// then add the zero in the middle\n\n\t\t\t\t\t\t\tleft.push (Digit::new (digit.depth () - 1, 0));\n\n\t\t\t\t\t\t\t// and finally add the number on the right\n\n\t\t\t\t\t\t\tlet digit = right.pop ().unwrap ();\n\t\t\t\t\t\t\tif ! right.is_empty () {\n\t\t\t\t\t\t\t\tlet next = right.pop ().unwrap ();\n\t\t\t\t\t\t\t\tlet value = next.value () + digit.value ();\n\t\t\t\t\t\t\t\tright.push (Digit::new (next.depth (), value));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tend -= 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// once complete, we switch over to split, starting from the first number\n\t\t\t\t\t\t// which is large enough to be split\n\n\t\t\t\t\t\tstate = State::Split;\n\t\t\t\t\t\twhile start \u003c left.len () { right.push (left.pop ().unwrap ()); }\n\n\t\t\t\t\t},\n\t\t\t\t\tState::Split =\u003e {\n\n\t\t\t\t\t\t// split as much as we can\n\n\t\t\t\t\t\twhile ! right.is_empty () {\n\t\t\t\t\t\t\tlet digit = right.pop ().unwrap ();\n\n\t\t\t\t\t\t\t// digits less than ten can be copied over\n\n\t\t\t\t\t\t\tif digit.value () \u003c 10 {\n\t\t\t\t\t\t\t\tleft.push (digit);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split this digit, add to `right` because they may need exploding or\n\t\t\t\t\t\t\t// splitting again\n\n\t\t\t\t\t\t\tright.push (Digit::new (digit.depth () + 1, (digit.value () + 1) / 2));\n\t\t\t\t\t\t\tright.push (Digit::new (digit.depth () + 1, digit.value () / 2));\n\n\t\t\t\t\t\t\t// if we increased the depth past four then switch back to exploding,\n\t\t\t\t\t\t\t// but only for the pair we just added\n\n\t\t\t\t\t\t\tif digit.depth () == 4 {\n\t\t\t\t\t\t\t\tstate = State::Explode;\n\t\t\t\t\t\t\t\tstart = left.len ();\n\t\t\t\t\t\t\t\tend = left.len () + 2;\n\t\t\t\t\t\t\t\tcontinue 'OUTER;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if splitting reaches the end, then we are done\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `right` should be empty, return new digits in `left`\n\n\t\t\tdebug_assert! (right.is_empty ());\n\t\t\tSelf { digits: left }\n\n\t\t}\n\n\t}\n\n\timpl TryFrom \u003c\u0026 Tokens\u003e for Number {\n\t\ttype Error = ParseError;\n\t\tfn try_from (tokens: \u0026 Tokens) -\u003e Result \u003cSelf, ParseError\u003e {\n\t\t\tfn take_one (\n\t\t\t\tdigits: \u0026 mut DigitsVec,\n\t\t\t\ttokens: \u0026 mut SliceIter \u003cToken\u003e,\n\t\t\t\tdepth: u8,\n\t\t\t) -\u003e Result \u003c(), ParseError\u003e {\n\t\t\t\tif 5 \u003c depth { return Err (ParseError::UnexpectedOpen) }\n\t\t\t\tmatch * tokens.next ().ok_or (ParseError::UnexpectedEnd) ? {\n\t\t\t\t\tToken::Open =\u003e (),\n\t\t\t\t\tToken::Close =\u003e return Err (ParseError::UnexpectedClose),\n\t\t\t\t\tToken::Comma =\u003e return Err (ParseError::UnexpectedComma),\n\t\t\t\t\tToken::Value (value) =\u003e {\n\t\t\t\t\t\tdigits.push (Digit::new (depth, value));\n\t\t\t\t\t\treturn Ok (());\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\ttake_one (digits, tokens, depth + 1) ?;\n\t\t\t\tmatch * tokens.next ().ok_or (ParseError::UnexpectedEnd) ? {\n\t\t\t\t\tToken::Open =\u003e return Err (ParseError::UnexpectedOpen),\n\t\t\t\t\tToken::Close =\u003e return Err (ParseError::UnexpectedClose),\n\t\t\t\t\tToken::Comma =\u003e (),\n\t\t\t\t\tToken::Value (_) =\u003e return Err (ParseError::UnexpectedValue),\n\t\t\t\t}\n\t\t\t\ttake_one (digits, tokens, depth + 1) ?;\n\t\t\t\tmatch * tokens.next ().ok_or (ParseError::UnexpectedEnd) ? {\n\t\t\t\t\tToken::Open =\u003e return Err (ParseError::UnexpectedOpen),\n\t\t\t\t\tToken::Close =\u003e (),\n\t\t\t\t\tToken::Comma =\u003e return Err (ParseError::UnexpectedComma),\n\t\t\t\t\tToken::Value (_) =\u003e return Err (ParseError::UnexpectedValue),\n\t\t\t\t}\n\t\t\t\tOk (())\n\t\t\t}\n\t\t\tlet mut digits = DigitsVec::new ();\n\t\t\ttake_one (\u0026 mut digits, \u0026 mut tokens.tokens.iter (), 0) ?;\n\t\t\tOk (Self { digits })\n\t\t}\n\t}\n\n\timpl FromStr for Number {\n\t\ttype Err = ParseError;\n\t\tfn from_str (src: \u0026 str) -\u003e Result \u003cSelf, ParseError\u003e {\n\t\t\tlet tokens = Tokens::parse_from_str (src)\n\t\t\t\t.map_err (|_err| ParseError::Token) ?;\n\t\t\tSelf::try_from (\u0026 tokens)\n\t\t}\n\t}\n\n\timpl Display for Number {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfn display_part (\n\t\t\t\tformatter: \u0026 mut fmt::Formatter,\n\t\t\t\tdigits: \u0026 [Digit],\n\t\t\t\tidx: \u0026 mut usize,\n\t\t\t\tdepth: u8,\n\t\t\t) -\u003e fmt::Result {\n\t\t\t\tlet digit = digits [* idx];\n\t\t\t\tdebug_assert! (depth \u003c= digit.depth ());\n\t\t\t\tif digit.depth () == depth {\n\t\t\t\t\t* idx += 1;\n\t\t\t\t\treturn Display::fmt (\u0026 digit.value (), formatter);\n\t\t\t\t}\n\t\t\t\tformatter.write_char ('[') ?;\n\t\t\t\tdisplay_part (formatter, digits, idx, depth + 1) ?;\n\t\t\t\tformatter.write_char (',') ?;\n\t\t\t\tdisplay_part (formatter, digits, idx, depth + 1) ?;\n\t\t\t\tformatter.write_char (']') ?;\n\t\t\t\tOk (())\n\t\t\t}\n\t\t\tdisplay_part (formatter, \u0026 self.digits, \u0026 mut 0, 0)\n\t\t}\n\t}\n\n\timpl Debug for Number {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"Snaifish {{ digits: {:?} }}\", self.digits) ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn test_reduce () {\n\t\t\tassert_eq! (\n\t\t\t\tfish (\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\"),\n\t\t\t\tfish (\"[[[[[4,3],4],4],[7,[[8,4],9]]],[1,1]]\").reduce ());\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_add () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (\n\t\t\t\tfish (\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\"),\n\t\t\t\tNumber::add (\n\t\t\t\t\tfish (\"[[[[4,3],4],4],[7,[[8,4],9]]]\"),\n\t\t\t\t\tfish (\"[1,1]\"),\n\t\t\t\t),\n\t\t\t);\n\t\t\tOk (())\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_sum () {\n\t\t\tassert_eq! (None, Number::sum ([]));\n\t\t\tassert_eq! (\n\t\t\t\tSome (fish (\"[[[[1,1],[2,2]],[3,3]],[4,4]]\")),\n\t\t\t\tNumber::sum (fishes ([\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"])));\n\t\t\tassert_eq! (\n\t\t\t\tSome (fish (\"[[[[3,0],[5,3]],[4,4]],[5,5]]\")),\n\t\t\t\tNumber::sum (fishes ([\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"])));\n\t\t\tassert_eq! (\n\t\t\t\tSome (fish (\"[[[[5,0],[7,4]],[5,5]],[6,6]]\")),\n\t\t\t\tNumber::sum (fishes ([\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\"])));\n\t\t\tassert_eq! (\n\t\t\t\tSome (fish (\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\")),\n\t\t\t\tNumber::sum (fishes ([\n\t\t\t\t\t\"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\",\n\t\t\t\t\t\"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\",\n\t\t\t\t\t\"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\",\n\t\t\t\t\t\"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\",\n\t\t\t\t\t\"[7,[5,[[3,8],[1,4]]]]\",\n\t\t\t\t\t\"[[2,[2,2]],[8,[8,1]]]\",\n\t\t\t\t\t\"[2,9]\",\n\t\t\t\t\t\"[1,[[[9,3],9],[[9,0],[0,7]]]]\",\n\t\t\t\t\t\"[[[5,[7,4]],7],1]\",\n\t\t\t\t\t\"[[[[4,2],2],6],[8,7]]\",\n\t\t\t\t])));\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_magnitude () {\n\t\t\tassert_eq! (143, fish (\"[[1,2],[[3,4],5]]\").magnitude ());\n\t\t\tassert_eq! (1384, fish (\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\").magnitude ());\n\t\t\tassert_eq! (445, fish (\"[[[[1,1],[2,2]],[3,3]],[4,4]]\").magnitude ());\n\t\t\tassert_eq! (791, fish (\"[[[[3,0],[5,3]],[4,4]],[5,5]]\").magnitude ());\n\t\t\tassert_eq! (1137, fish (\"[[[[5,0],[7,4]],[5,5]],[6,6]]\").magnitude ());\n\t\t\tassert_eq! (3488, fish (\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\").magnitude ());\n\t\t}\n\n\t\tfn fish (src: \u0026 str) -\u003e Number {\n\t\t\tNumber::from_str (src).unwrap ()\n\t\t}\n\n\t\tfn fishes (items: impl IntoIterator \u003cItem = \u0026 'static str\u003e) -\u003e Vec \u003cNumber\u003e {\n\t\t\titems.into_iter ()\n\t\t\t\t.map (fish)\n\t\t\t\t.collect ()\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":25,"address":[39936],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":28,"address":[39954,39952],"length":1,"stats":{"Line":0},"fn_name":"depth"},{"line":29,"address":[39970,39968],"length":1,"stats":{"Line":0},"fn_name":"value"},{"line":33,"address":[39984],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":34,"address":[40010,40044,40121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[40003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[40031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[63312],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":61,"address":[63320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[63339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[63357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[63375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[63393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[63402],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[63420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[63438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[63447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[63541,63471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[40176],"length":1,"stats":{"Line":0},"fn_name":"magnitude"},{"line":95,"address":[40184],"length":1,"stats":{"Line":8},"fn_name":null},{"line":96,"address":[40195],"length":1,"stats":{"Line":8},"fn_name":null},{"line":97,"address":[40221,40204],"length":1,"stats":{"Line":8},"fn_name":null},{"line":101,"address":[40272],"length":1,"stats":{"Line":2},"fn_name":"magnitude_real"},{"line":102,"address":[40287,40459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[40299,40576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[40309],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[40474,40311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[40358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[40490,40388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[40411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[40506,40430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[81360],"length":1,"stats":{"Line":0},"fn_name":"sum\u003calloc::vec::into_iter::IntoIter\u003caoc_2021_day_18::model::number::Number, alloc::alloc::Global\u003e\u003e"},{"line":115,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":120,"address":[40608],"length":1,"stats":{"Line":0},"fn_name":"add"},{"line":121,"address":[40621],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[40973,40768],"length":1,"stats":{"Line":1},"fn_name":"pair"},{"line":128,"address":[38809,38348,38310,38885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[38390,38969,39045,38428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[42984,40992],"length":1,"stats":{"Line":2},"fn_name":"reduce"},{"line":140,"address":[30852],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[41093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[41332],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[41346,41471,41383],"length":1,"stats":{"Line":6},"fn_name":null},{"line":167,"address":[41424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[41430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[41488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[41551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[41516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[41545,41561],"length":1,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[41590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[41687],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[41713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[41757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[42004,42110],"length":1,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[41782,41836],"length":1,"stats":{"Line":4},"fn_name":null},{"line":215,"address":[41879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[41883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[41935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[41963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[41980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[30668],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[43200],"length":1,"stats":{"Line":2},"fn_name":"take_one"},{"line":263,"address":[43217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[43268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[43394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":273,"address":[43292,43519],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[43358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":280,"address":[43442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":281,"address":[43497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[30306,30471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[30344],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[43600,44158],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":298,"address":[44057,43792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[44047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[44176],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":331,"address":[44254,44183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[55876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[81851,82000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[81817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[55764],"length":1,"stats":{"Line":2},"fn_name":null},{"line":350,"address":[82817,82619,82905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[55844],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[85208,82993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[85312,83403,85384,85014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":364,"address":[83100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":366,"address":[83876,85299,85366,85064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":367,"address":[83556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[84321,85286,85348,85114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[84013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[84882,85161,85330,85273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[84458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":389,"address":[55700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[85584,86551,87112],"length":1,"stats":{"Line":1},"fn_name":null},{"line":391,"address":[85751,86640,87097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":392,"address":[87082,85918,86729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[86085,86818,87067],"length":1,"stats":{"Line":1},"fn_name":null},{"line":394,"address":[86252,86904,87052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":395,"address":[86419,86987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[81456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[53505,54305,54477,53889,53697],"length":1,"stats":{"Line":19},"fn_name":null}],"covered":75,"coverable":100},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\"--- scanner 0 ---\",\n\t\"404,-588,-901\", \"528,-643,409\", \"-838,591,734\", \"390,-675,-793\", \"-537,-823,-458\",\n\t\"-485,-357,347\", \"-345,-311,381\", \"-661,-816,-575\", \"-876,649,763\", \"-618,-824,-621\",\n\t\"553,345,-567\", \"474,580,667\", \"-447,-329,318\", \"-584,868,-557\", \"544,-627,-890\",\n\t\"564,392,-477\", \"455,729,728\", \"-892,524,684\", \"-689,845,-530\", \"423,-701,434\",\n\t\"7,-33,-71\", \"630,319,-379\", \"443,580,662\", \"-789,900,-551\", \"459,-707,401\",\n\t\"\",\n\t\"--- scanner 1 ---\",\n\t\"686,422,578\", \"605,423,415\", \"515,917,-361\", \"-336,658,858\", \"95,138,22\", \"-476,619,847\",\n\t\"-340,-569,-846\", \"567,-361,727\", \"-460,603,-452\", \"669,-402,600\", \"729,430,532\",\n\t\"-500,-761,534\", \"-322,571,750\", \"-466,-666,-811\", \"-429,-592,574\", \"-355,545,-477\",\n\t\"703,-491,-529\", \"-328,-685,520\", \"413,935,-424\", \"-391,539,-444\", \"586,-435,557\",\n\t\"-364,-763,-893\", \"807,-499,-711\", \"755,-354,-619\", \"553,889,-390\",\n\t\"\",\n\t\"--- scanner 2 ---\",\n\t\"649,640,665\", \"682,-795,504\", \"-784,533,-524\", \"-644,584,-595\", \"-588,-843,648\",\n\t\"-30,6,44\", \"-674,560,763\", \"500,723,-460\", \"609,671,-379\", \"-555,-800,653\",\n\t\"-675,-892,-343\", \"697,-426,-610\", \"578,704,681\", \"493,664,-388\", \"-671,-858,530\",\n\t\"-667,343,800\", \"571,-461,-707\", \"-138,-166,112\", \"-889,563,-600\", \"646,-828,498\",\n\t\"640,759,510\", \"-630,509,768\", \"-681,-892,-333\", \"673,-379,-804\", \"-742,-814,-386\",\n\t\"577,-820,562\",\n\t\"\",\n\t\"--- scanner 3 ---\",\n\t\"-589,542,597\", \"605,-692,669\", \"-500,565,-823\", \"-660,373,557\", \"-458,-679,-417\",\n\t\"-488,449,543\", \"-626,468,-788\", \"338,-750,-386\", \"528,-832,-391\", \"562,-778,733\",\n\t\"-938,-730,414\", \"543,643,-506\", \"-524,371,-870\", \"407,773,750\", \"-104,29,83\",\n\t\"378,-903,-323\", \"-778,-728,485\", \"426,699,580\", \"-438,-605,-362\", \"-469,-447,-387\",\n\t\"509,732,623\", \"647,635,-688\", \"-868,-804,481\", \"614,-800,639\", \"595,780,-596\",\n\t\"\",\n\t\"--- scanner 4 ---\",\n\t\"727,592,562\", \"-293,-554,779\", \"441,611,-461\", \"-714,465,-776\", \"-743,427,-804\",\n\t\"-660,-479,-426\", \"832,-632,460\", \"927,-485,-438\", \"408,393,-506\", \"466,436,-512\",\n\t\"110,16,151\", \"-258,-428,682\", \"-393,719,612\", \"-211,-452,876\", \"808,-476,-593\",\n\t\"-575,615,604\", \"-485,667,467\", \"-680,325,-822\", \"-627,-443,-432\", \"872,-547,-609\",\n\t\"833,512,582\", \"807,604,487\", \"839,-516,451\", \"891,-625,532\", \"-652,-548,-490\",\n\t\"30,-46,-14\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"79\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3621\", puzzle.part_two (EXAMPLE));\n}\n\n","traces":[{"line":45,"address":[54816,54820],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":46,"address":[63258],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[63426,63279,63492,63317,63596,63369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[54852,54848],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":52,"address":[63658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[63996,63769,63717,63826,63679,63892],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","input.rs"],"content":"use super::*;\n\nuse model::Pos;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub scanners: Vec \u003cInputScanner\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { scanners, params } = [ params, @delim \"\\n\\n\" scanners ]\n}\n\n#[ derive (Clone, Debug) ]\npub struct InputScanner {\n\tpub id: u16,\n\tpub beacons: Vec \u003cPos\u003e,\n}\n\nstruct_parser_display! {\n\tInputScanner { id, beacons } = [\n\t\t\"--- scanner \", id, \" ---\\n\",\n\t\t@lines beacons { Pos { x, y, z } = [ x, \",\", y, \",\", z ] },\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":12,"address":[81851,81254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[153455],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","lib.rs"],"content":"//! Advent of Code 2021: Day 19: Beacon Scanner\n//!\n//! [https://adventofcode.com/2021/day/19](https://adventofcode.com/2021/day/19)\n//!\n//! # Algorithm\n//!\n//! This algorithm uses bloom filters to allow it to scale better. For each scanner we generate a\n//! set of bits which have bits set according to the arrangement of the beacons they contain. If\n//! there are two beacons with a specific offset between them, then a number of bits are guaranteed\n//! to be set. Once we have this information for every scanner, we can prioritise the slower\n//! matching process to pairs of scanners which share a large number of bits.\n//!\n//! Generating these hashes for each scanner is slow, so there is some further optimisation going\n//! on as well. Firstly, we have to rotate scanners so that they will match. Instead of rotating\n//! each scanner in every direction, we rotate scanners which we have placed in one set of\n//! directions and the ones we haven't placed in another. We choose a set of directions in each\n//! case to guarntee a match. Specifically we rotate placed scanners around the Z axis only, giving\n//! four hashes for each scanner. We rotate unplaced scanners to move its Z axis into one of the\n//! six other positions. since almost all scanners will first be unplaced and later placed, this\n//! means we do a total of ten hashes for each scanner, instead of the twenty four we would have to\n//! with a more nave algorithm.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_bithash::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod rotation;\n\nconst SCANNER_HASH_TOTAL_BITS: usize = 4096; // bits per hash (multiple of 64)\nconst SCANNER_HASH_ENTRY_BITS: usize = 3;    // bits per entry (pair of scanners)\n\npuzzle_info! {\n\tname = \"Beacon Scanner\";\n\tyear = 2021;\n\tday = 19;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":43,"address":[153992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[154312],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::OriginalScanner;\nuse model::PlacedScanner;\nuse model::Pos;\nuse model::ScannerHash;\nuse model::ScannerHasher;\nuse model::ScannerMatch;\nuse model::UnplacedScanner;\nuse rotation::Rotation;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcheck_input (input) ?;\n\tlet (_, beacons) = calc_result (input) ?;\n\tOk (beacons.len ().pan_i64 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcheck_input (input) ?;\n\tlet (scanners, _) = calc_result (input) ?;\n\tlet scanners: Vec \u003cPos\u003e = scanners.into_iter ().collect ();\n\tOk (\n\t\tscanners.iter ()\n\t\t\t.combinations (2)\n\t\t\t.map (|scanners| {\n\t\t\t\tlet (pos_0, pos_1) = (scanners [0], scanners [1]);\n\t\t\t\tCoord::abs_diff (pos_0.x, pos_1.x)\n\t\t\t\t\t+ Coord::abs_diff (pos_0.y, pos_1.y)\n\t\t\t\t\t+ Coord::abs_diff (pos_0.z, pos_1.z)\n\t\t\t})\n\t\t\t.max ()\n\t\t\t.unwrap ()\n\t\t\t.pan_i64 ()\n\t)\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tif input.scanners.len () \u003c 2 {\n\t\treturn Err (\"Must provide at least two scanners\".into ());\n\t}\n\tfor scanner in \u0026 input.scanners {\n\t\tif 40 \u003c scanner.beacons.len () {\n\t\t\treturn Err (\"Max forty beacons per scanner\".into ());\n\t\t}\n\t}\n\tOk (())\n}\n\nfn calc_result (input: \u0026 Input) -\u003e GenResult \u003c(HashSet \u003cPos\u003e, HashSet \u003cPos\u003e)\u003e {\n\tlet mut arranger = ScannerArranger::new ();\n\tif ! arranger.init (input) ? { Err (\"Failed to arrange scanners\") ? }\n\tarranger.run () ?;\n\tOk ((arranger.scanner_positions, arranger.beacon_positions))\n}\n\n#[ derive (Default) ]\nstruct ScannerArranger {\n\thash_builder: RandomHasher,\n\toriginal_scanners: Vec \u003cRc \u003cOriginalScanner\u003e\u003e,\n\tunplaced_scanners: Vec \u003cRc \u003cUnplacedScanner\u003e\u003e,\n\tscanner_matches: BinaryHeap \u003cScannerMatch\u003e,\n\tscanner_positions: HashSet \u003cPos\u003e,\n\tbeacon_positions: HashSet \u003cPos\u003e,\n}\n\nimpl ScannerArranger {\n\n\tfn new () -\u003e Self { default () }\n\n\tfn init (\u0026 mut self, input: \u0026 Input) -\u003e NumResult \u003cbool\u003e {\n\t\tself.original_scanners.extend (\n\t\t\tinput.scanners.iter ().map (|scanner|\n\t\t\t\tRc::new (OriginalScanner {\n\t\t\t\t\tbeacons: scanner.beacons.iter ().copied ().sorted ().collect (),\n\t\t\t\t\tmatched: Cell::new (false),\n\t\t\t\t})));\n\t\tif self.original_scanners.is_empty () { return Ok (false) }\n\t\tself.unplaced_scanners = self.original_scanners.iter ()\n\t\t\t.map (|scanner| Ok (Rc::new (UnplacedScanner {\n\t\t\t\toriginal: Rc::clone (scanner),\n\t\t\t\thashes: self.calc_scanner_hashes (\u0026 scanner.beacons, UNPLACED_ROTATIONS) ?,\n\t\t\t})))\n\t\t\t.try_collect () ?;\n\t\tOk (true)\n\t}\n\n\tfn run (\u0026 mut self) -\u003e GenResult \u003c()\u003e {\n\t\tself.place_scanner (\n\t\t\t\u0026 Rc::clone (\u0026 self.unplaced_scanners [0]),\n\t\t\tRotation::None,\n\t\t\tPos::ZERO) ?;\n\t\tlet mut scanner_matches_buffer = Vec::new ();\n\t\tlet mut num_failures = 0_u32;\n\t\t'OUTER: loop {\n\t\t\tif self.unplaced_scanners.is_empty () { break }\n\t\t\tself.scanner_matches.extend (scanner_matches_buffer.drain ( .. ));\n\t\t\twhile let Some (scanner_match) = self.scanner_matches.pop () {\n\t\t\t\tif self.unplaced_scanners.is_empty () { break 'OUTER }\n\t\t\t\tif scanner_match.unplaced.original.matched.get () { continue }\n\t\t\t\tif self.process_match (\u0026 scanner_match) ? { continue 'OUTER }\n\t\t\t\tnum_failures += 1;\n\t\t\t\tif num_failures == 10 {\n\t\t\t\t\treturn Err (\"Giving after ten failed placements\".into ());\n\t\t\t\t}\n\t\t\t\tscanner_matches_buffer.push (scanner_match);\n\t\t\t}\n\t\t\tself.unplaced_scanners.retain (|scanner| ! scanner.original.matched.get ());\n\t\t}\n\t\tOk (())\n\t}\n\n\tfn process_match (\u0026 mut self, scanner_match: \u0026 ScannerMatch) -\u003e GenResult \u003cbool\u003e {\n\t\tlet placed = Rc::clone (\u0026 scanner_match.placed);\n\t\tlet unplaced = Rc::clone (\u0026 scanner_match.unplaced);\n\t\tlet rotate = Rotation::combine (\n\t\t\tscanner_match.placed_rotate.rev (),\n\t\t\tscanner_match.unplaced_rotate);\n\t\tlet offset = match Self::find_offset (\u0026 placed, \u0026 unplaced, rotate) ? {\n\t\t\tSome (value) =\u003e value,\n\t\t\tNone =\u003e { return Ok (false) },\n\t\t};\n\t\tself.place_scanner (\u0026 unplaced, rotate, offset) ?;\n\t\tOk (true)\n\t}\n\n\tfn find_offset (\n\t\tplaced: \u0026 PlacedScanner,\n\t\tunplaced: \u0026 UnplacedScanner,\n\t\trotate: Rotation,\n\t) -\u003e NumResult \u003cOption \u003cPos\u003e\u003e {\n\t\tlet mut offsets_temp: Vec \u003c_\u003e =\n\t\t\tunplaced.original.beacons.iter ().copied ()\n\t\t\t\t.map (|beacon| rotate.apply (beacon))\n\t\t\t\t.cartesian_product (placed.beacons.iter ().copied ())\n\t\t\t\t.map (|(unplaced_beacon, placed_beacon)| chk! (placed_beacon - unplaced_beacon))\n\t\t\t\t.try_collect () ?;\n\t\toffsets_temp.sort ();\n\t\tlet offsets_grouped = offsets_temp.into_iter ()\n\t\t\t.group_by (|\u0026 offset| offset);\n\t\tOk (\n\t\t\toffsets_grouped.into_iter ()\n\t\t\t\t.map (|(offset, iter)| (offset, iter.count ()))\n\t\t\t\t.filter (|\u0026 (_, count)| count \u003e= 12)\n\t\t\t\t.map (|(offset, _)| offset)\n\t\t\t\t.next ()\n\t\t)\n\t}\n\n\tfn place_scanner (\n\t\t\u0026 mut self,\n\t\tscanner: \u0026 Rc \u003cUnplacedScanner\u003e,\n\t\trotate: Rotation,\n\t\toffset: Pos,\n\t) -\u003e GenResult \u003c()\u003e {\n\t\tlet beacons = scanner.original.beacons.iter ().copied ()\n\t\t\t.map (|beacon| rotate.apply (beacon) + offset)\n\t\t\t.sorted ()\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet hashes = self.calc_scanner_hashes (\u0026 beacons, PLACED_ROTATIONS) ?;\n\t\tlet scanner = Rc::new (PlacedScanner {\n\t\t\toriginal: Rc::clone (\u0026 scanner.original),\n\t\t\tbeacons,\n\t\t\thashes,\n\t\t});\n\t\tscanner.original.matched.set (true);\n\t\tif ! self.scanner_positions.insert (offset) {\n\t\t\treturn Err (format! (\"Duplicated scanner position: {offset:?}\").into ());\n\t\t}\n\t\tself.beacon_positions.extend (scanner.beacons.iter ().copied ());\n\t\tself.add_scanner_matches (\u0026 scanner);\n\t\tOk (())\n\t}\n\n\tfn add_scanner_matches (\u0026 mut self, placed: \u0026 Rc \u003cPlacedScanner\u003e) {\n\t\tfor unplaced in self.unplaced_scanners.iter () {\n\t\t\tif unplaced.original.matched.get () { continue }\n\t\t\tfor (unplaced_rotate_idx, unplaced_rotate)\n\t\t\t\t\tin UNPLACED_ROTATIONS.iter ().copied ().enumerate () {\n\t\t\t\tlet unplaced_hash = unplaced.hashes [unplaced_rotate_idx];\n\t\t\t\tfor (placed_rotate_idx, placed_rotate)\n\t\t\t\t\t\tin PLACED_ROTATIONS.iter ().copied ().enumerate () {\n\t\t\t\t\tlet placed_hash = placed.hashes [placed_rotate_idx];\n\t\t\t\t\tself.scanner_matches.push (ScannerMatch {\n\t\t\t\t\t\tplaced: Rc::clone (placed),\n\t\t\t\t\t\tunplaced: Rc::clone (unplaced),\n\t\t\t\t\t\tpriority: (placed_hash \u0026 unplaced_hash).bits ().pan_u32 (),\n\t\t\t\t\t\tplaced_rotate,\n\t\t\t\t\t\tunplaced_rotate,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfn calc_scanner_hashes \u003cconst LEN: usize\u003e (\n\t\t\u0026 self,\n\t\tbeacons: \u0026 [Pos],\n\t\trotates: \u0026 [Rotation; LEN],\n\t) -\u003e NumResult \u003c[ScannerHash; LEN]\u003e {\n\t\tlet mut hashers =\n\t\t\t[0_i32; LEN].map (|_| ScannerHasher::new_with_hasher (self.hash_builder.clone ()));\n\t\tfor offset in beacons.iter ().copied ().enumerate ()\n\t\t\t.flat_map (|(beacon_0_idx, beacon_0)| beacons.iter ().copied ()\n\t\t\t\t.skip (beacon_0_idx + 1)\n\t\t\t\t.map (move |beacon_1| chk! (beacon_1 - beacon_0))) {\n\t\t\tlet offset = offset ?;\n\t\t\tfor idx in 0 .. rotates.len () {\n\t\t\t\tlet offset = rotates [idx].apply (offset);\n\t\t\t\thashers [idx].update (cmp::max (offset, - offset));\n\t\t\t}\n\t\t}\n\t\tOk (hashers.map (|hasher| hasher.finish ()))\n\t}\n\n}\n\nconst PLACED_ROTATIONS: \u0026 [Rotation; 4] = \u0026 [\n\tRotation::None, Rotation::Clockwise,\n\tRotation::UpsideDown, Rotation::CounterClockwise,\n];\n\nconst UNPLACED_ROTATIONS: \u0026 [Rotation; 6] = \u0026 [\n\tRotation::None, Rotation::Up, Rotation::Right,\n\tRotation::Around, Rotation::Down, Rotation::Left,\n];\n","traces":[{"line":14,"address":[125216,125937],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":15,"address":[125348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[125899,125407,125537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[125833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[125952,127195],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":21,"address":[126085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[126128,126258,127111],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[126993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[117313,117072],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":28,"address":[117138,117106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[117142,117186,117214,117234],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[117145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[117191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[127216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[125243,125979,127228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[125249,125985,127234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[126043,127291,125306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[126050,127313,125313],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[127323,125324,126061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[127770,127360],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":53,"address":[127404,127391],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[127452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[127521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[127792],"length":1,"stats":{"Line":2},"fn_name":"init"},{"line":73,"address":[127811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[117328],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":76,"address":[117369],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[127861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[127987,128048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[117900,117568],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":82,"address":[117620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[117649,117625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[128080,129158],"length":1,"stats":{"Line":2},"fn_name":"run"},{"line":90,"address":[128169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[128159],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[129107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[128882,128412],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[128560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[128611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[128630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[128951,128656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[128718,129037],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[128727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[128974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[128737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[117934,117920],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":114,"address":[129168,129708],"length":1,"stats":{"Line":2},"fn_name":"process_match"},{"line":115,"address":[129221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[129257],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[129262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[129295,129365],"length":1,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[129352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[129374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[129505],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[129728,130678],"length":1,"stats":{"Line":2},"fn_name":"find_offset"},{"line":133,"address":[130096,130545],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[80129,64777],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[65871,72879],"length":1,"stats":{"Line":6},"fn_name":null},{"line":140,"address":[130147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[116496],"length":1,"stats":{"Line":0},"fn_name":"call_mut\u003c\u0026aoc_pos::PosXYZ\u003ci16\u003e, aoc_pos::PosXYZ\u003ci16\u003e, aoc_2021_day_19::logic::{impl#0}::find_offset::{closure_env#2}\u003e"},{"line":143,"address":[130423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[49975,49920,49953],"length":1,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[50005],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[131728,130688],"length":1,"stats":{"Line":2},"fn_name":"place_scanner"},{"line":157,"address":[130812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[73704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[130879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[131132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[131169,131145],"length":1,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[131267,131177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[131516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[131744,132775],"length":1,"stats":{"Line":2},"fn_name":"add_scanner_matches"},{"line":177,"address":[131810,131911],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[131883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[132047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[132058,132082,132706],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[132187],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[132196,132656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[132556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[132291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[132333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[132338,132497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":197,"address":[119104,118160],"length":1,"stats":{"Line":4},"fn_name":"calc_scanner_hashes\u003c6\u003e"},{"line":202,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":8},"fn_name":null}],"covered":81,"coverable":94},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","model.rs"],"content":"use super::*;\n\nuse rotation::Rotation;\n\npub const SCANNER_HASH_TOTAL_U64S: usize = SCANNER_HASH_TOTAL_BITS / 64;\n\npub type Coord = i16;\npub type Pos = pos::PosXYZ \u003cCoord\u003e;\npub type ScannerHash = BitHash \u003cSCANNER_HASH_TOTAL_U64S\u003e;\npub type ScannerHasher = BitHasher \u003cRandomHasher, SCANNER_HASH_TOTAL_U64S, SCANNER_HASH_ENTRY_BITS\u003e;\n\npub (crate) struct OriginalScanner {\n\tpub beacons: Vec \u003cPos\u003e,\n\tpub matched: Cell \u003cbool\u003e,\n}\n\npub (crate) struct UnplacedScanner {\n\tpub original: Rc \u003cOriginalScanner\u003e,\n\tpub hashes: [ScannerHash; 6],\n}\n\npub (crate) struct PlacedScanner {\n\tpub original: Rc \u003cOriginalScanner\u003e,\n\tpub hashes: [ScannerHash; 4],\n\tpub beacons: Vec \u003cPos\u003e,\n}\n\n#[ derive (Clone) ]\npub (crate) struct ScannerMatch {\n\tpub placed: Rc \u003cPlacedScanner\u003e,\n\tpub unplaced: Rc \u003cUnplacedScanner\u003e,\n\tpub priority: u32,\n\tpub placed_rotate: Rotation,\n\tpub unplaced_rotate: Rotation,\n}\n\nimpl PartialEq for ScannerMatch {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.priority == other.priority\n\t}\n}\n\nimpl Eq for ScannerMatch {}\n\nimpl PartialOrd for ScannerMatch {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003ccmp::Ordering\u003e {\n\t\tu32::partial_cmp (\u0026 self.priority, \u0026 other.priority)\n\t}\n}\n\nimpl Ord for ScannerMatch {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e cmp::Ordering {\n\t\tu32::cmp (\u0026 self.priority, \u0026 other.priority)\n\t}\n}\n","traces":[{"line":46,"address":[84640],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":47,"address":[59191,59979,60167,57131,59012],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":1,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","rotation.rs"],"content":"use super::*;\nuse model::Pos;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub enum Rotation {\n\tNone, Clockwise, CounterClockwise, UpsideDown,\n\tUp, ClockwiseUp, CounterClockwiseUp, UpsideDownUp,\n\tDown, ClockwiseDown, CounterClockwiseDown, UpsideDownDown,\n\tLeft, ClockwiseLeft, CounterClockwiseLeft, UpsideDownLeft,\n\tRight, ClockwiseRight, CounterClockwiseRight, UpsideDownRight,\n\tAround, ClockwiseAround, CounterClockwiseAround, UpsideDownAround,\n}\n\n#[ allow (dead_code) ]\nimpl Rotation {\n\n\tpub const ALL: \u0026 'static [Self; 24] = \u0026 [\n\t\tSelf::None, Self::Clockwise,\n\t\tSelf::CounterClockwise, Self::UpsideDown,\n\t\tSelf::Up, Self::ClockwiseUp,\n\t\tSelf::CounterClockwiseUp, Self::UpsideDownUp,\n\t\tSelf::Down, Self::ClockwiseDown,\n\t\tSelf::CounterClockwiseDown, Self::UpsideDownDown,\n\t\tSelf::Left, Self::ClockwiseLeft,\n\t\tSelf::CounterClockwiseLeft, Self::UpsideDownLeft,\n\t\tSelf::Right, Self::ClockwiseRight,\n\t\tSelf::CounterClockwiseRight, Self::UpsideDownRight,\n\t\tSelf::Around, Self::ClockwiseAround,\n\t\tSelf::CounterClockwiseAround, Self::UpsideDownAround,\n\t];\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn idx (self) -\u003e usize {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e 0,\n\t\t\tSelf::Clockwise =\u003e 1,\n\t\t\tSelf::CounterClockwise =\u003e 2,\n\t\t\tSelf::UpsideDown =\u003e 3,\n\t\t\tSelf::Up =\u003e 4,\n\t\t\tSelf::ClockwiseUp =\u003e 5,\n\t\t\tSelf::CounterClockwiseUp =\u003e 6,\n\t\t\tSelf::UpsideDownUp =\u003e 7,\n\t\t\tSelf::Down =\u003e 8,\n\t\t\tSelf::ClockwiseDown =\u003e 9,\n\t\t\tSelf::CounterClockwiseDown =\u003e 10,\n\t\t\tSelf::UpsideDownDown =\u003e 11,\n\t\t\tSelf::Left =\u003e 12,\n\t\t\tSelf::ClockwiseLeft =\u003e 13,\n\t\t\tSelf::CounterClockwiseLeft =\u003e 14,\n\t\t\tSelf::UpsideDownLeft =\u003e 15,\n\t\t\tSelf::Right =\u003e 16,\n\t\t\tSelf::ClockwiseRight =\u003e 17,\n\t\t\tSelf::CounterClockwiseRight =\u003e 18,\n\t\t\tSelf::UpsideDownRight =\u003e 19,\n\t\t\tSelf::Around =\u003e 20,\n\t\t\tSelf::ClockwiseAround =\u003e 21,\n\t\t\tSelf::CounterClockwiseAround =\u003e 22,\n\t\t\tSelf::UpsideDownAround =\u003e 23,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn apply (self, pos: Pos) -\u003e Pos {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e Pos { x: pos.x, y: pos.y, z: pos.z },\n\t\t\tSelf::Clockwise =\u003e Pos { x: - pos.y, y: pos.x, z: pos.z },\n\t\t\tSelf::CounterClockwise =\u003e Pos { x: pos.y, y: - pos.x, z: pos.z },\n\t\t\tSelf::UpsideDown =\u003e Pos { x: - pos.x, y: - pos.y, z: pos.z },\n\t\t\tSelf::Up =\u003e Pos { x: pos.x, y: - pos.z, z: pos.y },\n\t\t\tSelf::ClockwiseUp =\u003e Pos { x: pos.z, y: pos.x, z: pos.y },\n\t\t\tSelf::CounterClockwiseUp =\u003e Pos { x: - pos.z, y: - pos.x, z: pos.y },\n\t\t\tSelf::UpsideDownUp =\u003e Pos { x: - pos.x, y: pos.z, z: pos.y },\n\t\t\tSelf::Down =\u003e Pos { x: pos.x, y: pos.z, z: - pos.y },\n\t\t\tSelf::ClockwiseDown =\u003e Pos { x: - pos.z, y: pos.x, z: - pos.y },\n\t\t\tSelf::CounterClockwiseDown =\u003e Pos { x: pos.z, y: - pos.x, z: - pos.y },\n\t\t\tSelf::UpsideDownDown =\u003e Pos { x: - pos.x, y: - pos.z, z: - pos.y },\n\t\t\tSelf::Left =\u003e Pos { x: pos.z, y: pos.y, z: - pos.x },\n\t\t\tSelf::ClockwiseLeft =\u003e Pos { x: - pos.y, y: pos.z, z: - pos.x },\n\t\t\tSelf::CounterClockwiseLeft =\u003e Pos { x: pos.y, y: - pos.z, z: - pos.x },\n\t\t\tSelf::UpsideDownLeft =\u003e Pos { x: - pos.z, y: - pos.y, z: - pos.x },\n\t\t\tSelf::Right =\u003e Pos { x: - pos.z, y: pos.y, z: pos.x },\n\t\t\tSelf::ClockwiseRight =\u003e Pos { x: - pos.y, y: - pos.z, z: pos.x },\n\t\t\tSelf::CounterClockwiseRight =\u003e Pos { x: pos.y, y: pos.z, z: pos.x },\n\t\t\tSelf::UpsideDownRight =\u003e Pos { x: pos.z, y: - pos.y, z: pos.x },\n\t\t\tSelf::Around =\u003e Pos { x: - pos.x, y: pos.y, z: - pos.z },\n\t\t\tSelf::ClockwiseAround =\u003e Pos { x: - pos.y, y: - pos.x, z: - pos.z },\n\t\t\tSelf::CounterClockwiseAround =\u003e Pos { x: pos.y, y: pos.x, z: - pos.z },\n\t\t\tSelf::UpsideDownAround =\u003e Pos { x: pos.x, y: - pos.y, z: - pos.z },\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn left (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e Self::Left,\n\t\t\tSelf::Clockwise =\u003e Self::ClockwiseUp,\n\t\t\tSelf::CounterClockwise =\u003e Self::CounterClockwiseDown,\n\t\t\tSelf::UpsideDown =\u003e Self::UpsideDownRight,\n\t\t\tSelf::Up =\u003e Self::CounterClockwiseLeft,\n\t\t\tSelf::ClockwiseUp =\u003e Self::CounterClockwiseAround,\n\t\t\tSelf::CounterClockwiseUp =\u003e Self::CounterClockwise,\n\t\t\tSelf::UpsideDownUp =\u003e Self::CounterClockwiseRight,\n\t\t\tSelf::Down =\u003e Self::ClockwiseLeft,\n\t\t\tSelf::ClockwiseDown =\u003e Self::Clockwise,\n\t\t\tSelf::CounterClockwiseDown =\u003e Self::ClockwiseAround,\n\t\t\tSelf::UpsideDownDown =\u003e Self::ClockwiseRight,\n\t\t\tSelf::Left =\u003e Self::Around,\n\t\t\tSelf::ClockwiseLeft =\u003e Self::UpsideDownUp,\n\t\t\tSelf::CounterClockwiseLeft =\u003e Self::UpsideDownDown,\n\t\t\tSelf::UpsideDownLeft =\u003e Self::UpsideDown,\n\t\t\tSelf::Right =\u003e Self::None,\n\t\t\tSelf::ClockwiseRight =\u003e Self::Up,\n\t\t\tSelf::CounterClockwiseRight =\u003e Self::Down,\n\t\t\tSelf::UpsideDownRight =\u003e Self::UpsideDownAround,\n\t\t\tSelf::Around =\u003e Self::Right,\n\t\t\tSelf::ClockwiseAround =\u003e Self::CounterClockwiseUp,\n\t\t\tSelf::CounterClockwiseAround =\u003e Self::ClockwiseDown,\n\t\t\tSelf::UpsideDownAround =\u003e Self::UpsideDownLeft,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn around (self) -\u003e Self {\n\t\tself.left ().left ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn right (self) -\u003e Self {\n\t\tself.left ().left ().left ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn clockwise (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e Self::Clockwise,\n\t\t\tSelf::Clockwise =\u003e Self::UpsideDown,\n\t\t\tSelf::CounterClockwise =\u003e Self::None,\n\t\t\tSelf::UpsideDown =\u003e Self::CounterClockwise,\n\t\t\tSelf::Up =\u003e Self::ClockwiseUp,\n\t\t\tSelf::ClockwiseUp =\u003e Self::UpsideDownUp,\n\t\t\tSelf::CounterClockwiseUp =\u003e Self::Up,\n\t\t\tSelf::UpsideDownUp =\u003e Self::CounterClockwiseUp,\n\t\t\tSelf::Down =\u003e Self::ClockwiseDown,\n\t\t\tSelf::ClockwiseDown =\u003e Self::UpsideDownDown,\n\t\t\tSelf::CounterClockwiseDown =\u003e Self::Down,\n\t\t\tSelf::UpsideDownDown =\u003e Self::CounterClockwiseDown,\n\t\t\tSelf::Left =\u003e Self::ClockwiseLeft,\n\t\t\tSelf::ClockwiseLeft =\u003e Self::UpsideDownLeft,\n\t\t\tSelf::CounterClockwiseLeft =\u003e Self::Left,\n\t\t\tSelf::UpsideDownLeft =\u003e Self::CounterClockwiseLeft,\n\t\t\tSelf::Right =\u003e Self::ClockwiseRight,\n\t\t\tSelf::ClockwiseRight =\u003e Self::UpsideDownRight,\n\t\t\tSelf::CounterClockwiseRight =\u003e Self::Right,\n\t\t\tSelf::UpsideDownRight =\u003e Self::CounterClockwiseRight,\n\t\t\tSelf::Around =\u003e Self::ClockwiseAround,\n\t\t\tSelf::ClockwiseAround =\u003e Self::UpsideDownAround,\n\t\t\tSelf::CounterClockwiseAround =\u003e Self::Around,\n\t\t\tSelf::UpsideDownAround =\u003e Self::CounterClockwiseAround,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn upside_down (self) -\u003e Self {\n\t\tself.clockwise ().clockwise ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn counter_clockwise (self) -\u003e Self {\n\t\tself.clockwise ().clockwise ().clockwise ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn up (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e Self::Up,\n\t\t\tSelf::Clockwise =\u003e Self::ClockwiseRight,\n\t\t\tSelf::CounterClockwise =\u003e Self::CounterClockwiseLeft,\n\t\t\tSelf::UpsideDown =\u003e Self::UpsideDownDown,\n\t\t\tSelf::Up =\u003e Self::UpsideDownAround,\n\t\t\tSelf::ClockwiseUp =\u003e Self::UpsideDownRight,\n\t\t\tSelf::CounterClockwiseUp =\u003e Self::UpsideDownLeft,\n\t\t\tSelf::UpsideDownUp =\u003e Self::UpsideDown,\n\t\t\tSelf::Down =\u003e Self::None,\n\t\t\tSelf::ClockwiseDown =\u003e Self::Right,\n\t\t\tSelf::CounterClockwiseDown =\u003e Self::Left,\n\t\t\tSelf::UpsideDownDown =\u003e Self::Around,\n\t\t\tSelf::Left =\u003e Self::ClockwiseUp,\n\t\t\tSelf::ClockwiseLeft =\u003e Self::Clockwise,\n\t\t\tSelf::CounterClockwiseLeft =\u003e Self::CounterClockwiseAround,\n\t\t\tSelf::UpsideDownLeft =\u003e Self::ClockwiseDown,\n\t\t\tSelf::Right =\u003e Self::CounterClockwiseUp,\n\t\t\tSelf::ClockwiseRight =\u003e Self::ClockwiseAround,\n\t\t\tSelf::CounterClockwiseRight =\u003e Self::CounterClockwise,\n\t\t\tSelf::UpsideDownRight =\u003e Self::CounterClockwiseDown,\n\t\t\tSelf::Around =\u003e Self::UpsideDownUp,\n\t\t\tSelf::ClockwiseAround =\u003e Self::ClockwiseLeft,\n\t\t\tSelf::CounterClockwiseAround =\u003e Self::CounterClockwiseRight,\n\t\t\tSelf::UpsideDownAround =\u003e Self::Down,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn flip (self) -\u003e Self {\n\t\tself.up ().up ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn down (self) -\u003e Self {\n\t\tself.up ().up ().up ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn rev (self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e Self::None,\n\t\t\tSelf::Clockwise =\u003e Self::CounterClockwise,\n\t\t\tSelf::CounterClockwise =\u003e Self::Clockwise,\n\t\t\tSelf::UpsideDown =\u003e Self::UpsideDown,\n\t\t\tSelf::Up =\u003e Self::Down,\n\t\t\tSelf::ClockwiseUp =\u003e Self::CounterClockwiseRight,\n\t\t\tSelf::CounterClockwiseUp =\u003e Self::ClockwiseLeft,\n\t\t\tSelf::UpsideDownUp =\u003e Self::UpsideDownUp,\n\t\t\tSelf::Down =\u003e Self::Up,\n\t\t\tSelf::ClockwiseDown =\u003e Self::CounterClockwiseLeft,\n\t\t\tSelf::CounterClockwiseDown =\u003e Self::ClockwiseRight,\n\t\t\tSelf::UpsideDownDown =\u003e Self::UpsideDownDown,\n\t\t\tSelf::Left =\u003e Self::Right,\n\t\t\tSelf::ClockwiseLeft =\u003e Self::CounterClockwiseUp,\n\t\t\tSelf::CounterClockwiseLeft =\u003e Self::ClockwiseDown,\n\t\t\tSelf::UpsideDownLeft =\u003e Self::UpsideDownLeft,\n\t\t\tSelf::Right =\u003e Self::Left,\n\t\t\tSelf::ClockwiseRight =\u003e Self::CounterClockwiseDown,\n\t\t\tSelf::CounterClockwiseRight =\u003e Self::ClockwiseUp,\n\t\t\tSelf::UpsideDownRight =\u003e Self::UpsideDownRight,\n\t\t\tSelf::Around =\u003e Self::Around,\n\t\t\tSelf::ClockwiseAround =\u003e Self::ClockwiseAround,\n\t\t\tSelf::CounterClockwiseAround =\u003e Self::CounterClockwiseAround,\n\t\t\tSelf::UpsideDownAround =\u003e Self::UpsideDownAround,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn combine (self, other: Self) -\u003e Self {\n\t\tmatch self {\n\t\t\tSelf::None =\u003e other,\n\t\t\tSelf::Clockwise =\u003e other.clockwise (),\n\t\t\tSelf::CounterClockwise =\u003e other.counter_clockwise (),\n\t\t\tSelf::UpsideDown =\u003e other.upside_down (),\n\t\t\tSelf::Up =\u003e other.up (),\n\t\t\tSelf::ClockwiseUp =\u003e other.up ().clockwise (),\n\t\t\tSelf::CounterClockwiseUp =\u003e other.up ().counter_clockwise (),\n\t\t\tSelf::UpsideDownUp =\u003e other.up ().upside_down (),\n\t\t\tSelf::Down =\u003e other.down (),\n\t\t\tSelf::ClockwiseDown =\u003e other.down ().clockwise (),\n\t\t\tSelf::CounterClockwiseDown =\u003e other.down ().counter_clockwise (),\n\t\t\tSelf::UpsideDownDown =\u003e other.down ().upside_down (),\n\t\t\tSelf::Left =\u003e other.left (),\n\t\t\tSelf::ClockwiseLeft =\u003e other.left ().clockwise (),\n\t\t\tSelf::CounterClockwiseLeft =\u003e other.left ().counter_clockwise (),\n\t\t\tSelf::UpsideDownLeft =\u003e other.left ().upside_down (),\n\t\t\tSelf::Right =\u003e other.right (),\n\t\t\tSelf::ClockwiseRight =\u003e other.right ().clockwise (),\n\t\t\tSelf::CounterClockwiseRight =\u003e other.right ().counter_clockwise (),\n\t\t\tSelf::UpsideDownRight =\u003e other.right ().upside_down (),\n\t\t\tSelf::Around =\u003e other.around (),\n\t\t\tSelf::ClockwiseAround =\u003e other.around ().clockwise (),\n\t\t\tSelf::CounterClockwiseAround =\u003e other.around ().counter_clockwise (),\n\t\t\tSelf::UpsideDownAround =\u003e other.around ().upside_down (),\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse aoc_common::*;\n\tuse super::*;\n\n\t#[ test ]\n\tfn test_rotation () {\n\t\tlet base = Pos { x: 1, y: 2, z: 3 };\n\t\tlet mut seen: HashSet \u003cPos\u003e = HashSet::new ();\n\t\tlet mut seen_left: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tlet mut seen_up: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tlet mut seen_clockwise: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tfn right_handed (pos: Pos) -\u003e bool {\n\t\t\tlet sign = match (pos.x.abs (), pos.y.abs (), pos.z.abs ()) {\n\t\t\t\t(1, 2, 3) | (2, 3, 1) | (3, 1, 2) =\u003e 1,\n\t\t\t\t(3, 2, 1) | (2, 1, 3) | (1, 3, 2) =\u003e -1,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t} * pos.x.signum () * pos.y.signum () * pos.z.signum ();\n\t\t\t0 \u003c sign\n\t\t}\n\t\tfor rotate in Rotation::ALL.iter ().copied () {\n\t\t\tlet result = rotate.apply (base);\n\t\t\tassert! (right_handed (result));\n\t\t\tassert! (! seen.contains (\u0026 result), \"Duplicated rotation {:?}\", result);\n\t\t\tseen.insert (result);\n\t\t\tlet rotate_left = rotate.left ();\n\t\t\tassert! (! seen_left.contains (\u0026 rotate_left),\n\t\t\t\t\"Duplicated rotation left {rotate_left:?}\");\n\t\t\tseen_left.insert (rotate_left);\n\t\t\tlet rotate_up = rotate.up ();\n\t\t\tassert! (! seen_up.contains (\u0026 rotate_up), \"Duplicated rotation up {rotate_up:?}\");\n\t\t\tseen_up.insert (rotate_up);\n\t\t\tlet rotate_clockwise = rotate.clockwise ();\n\t\t\tassert! (! seen_clockwise.contains (\u0026 rotate_clockwise),\n\t\t\t\t\"Duplicated rotation clockwise {rotate_clockwise:?}\");\n\t\t\tseen_clockwise.insert (rotate_clockwise);\n\t\t\tlet rotate_four_lefts = rotate.left ().left ().left ().left ();\n\t\t\tassert_eq! (rotate, rotate_four_lefts,\n\t\t\t\t\"Four lefts from {rotate:?} arrives at {rotate_four_lefts:?}\");\n\t\t\tlet rotate_four_ups = rotate.up ().up ().up ().up ();\n\t\t\tassert_eq! (rotate, rotate_four_ups,\n\t\t\t\t\"Four ups from {rotate:?} arrives at {rotate_four_ups:?}\");\n\t\t\tlet rotate_four_clockwises = rotate.clockwise ().clockwise ().clockwise ().clockwise ();\n\t\t\tassert_eq! (rotate, rotate_four_clockwises,\n\t\t\t\t\"Four clockwises from {rotate:?} arrives at {rotate_four_clockwises:?}\");\n\t\t\tassert_eq! (rotate, rotate.up ().right ().down ().counter_clockwise ());\n\t\t\tassert_eq! (rotate, rotate.flip ().around ().upside_down ());\n\t\t\tlet rotate_two_revs = rotate.rev ().rev ();\n\t\t\tassert_eq! (rotate, rotate_two_revs,\n\t\t\t\t\"Two reverses of {rotate:?} arrives at {rotate_two_revs:?}\");\n\t\t\tlet pos_forward_rev = rotate.rev ().apply (rotate.apply (base));\n\t\t\tassert_eq! (base, pos_forward_rev,\n\t\t\t\t\"Applying forward and reverse to {rotate:?} arrives at {pos_forward_rev:?}\");\n\t\t\tfor other in Rotation::ALL.iter ().copied () {\n\t\t\t\tlet pos_apply_twice = other.apply (rotate.apply (base));\n\t\t\t\tlet pos_combine = other.combine (rotate).apply (base);\n\t\t\t\tassert_eq! (pos_apply_twice, pos_combine,\n\t\t\t\t\t\"Applying {rotate:?} then {other:?} gives {pos_apply_twice:?} but combining \\\n\t\t\t\t\tthen applying gives {pos_combine:?}\");\n\t\t\t\tfor other_base in Rotation::ALL.iter ().copied ().map (|rot| rot.apply (base)) {\n\t\t\t\t\tif other.apply (other_base) != result { continue }\n\t\t\t\t\tassert_eq! (other.rev ().combine (rotate).apply (base), other_base);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[45776,49310],"length":1,"stats":{"Line":2},"fn_name":"test_rotation"},{"line":295,"address":[45793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[49328],"length":1,"stats":{"Line":1},"fn_name":"right_handed"},{"line":301,"address":[49603,49654,49625,49471,49572,49684,49410],"length":1,"stats":{"Line":6},"fn_name":null},{"line":304,"address":[49535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[49676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":308,"address":[46414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[46446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[46485,48568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[46519,48522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":[46527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":313,"address":[46571,46555],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[49136,46690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":[46741,46725],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[46860,49093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[46911,46895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[49050,47030],"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":[47098,47065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[47105,48701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[47138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[48912,47145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[47178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":[47185,48799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[47232,47191,49007],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[47278,48889,47271],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[47295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[48603,47302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[47308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[48409,47410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[47468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[47503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[47558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":[48257,47670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[47781,47750,47730],"length":1,"stats":{"Line":3},"fn_name":null},{"line":348,"address":[47837,47816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":349,"address":[48206,47870,47975],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":73,"coverable":230},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\"..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###..\\\n\t.####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..\\\n\t#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.....\\\n\t..#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.#\\\n\t##.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##.\\\n\t.####..#...#.#.#...##..#.#..###..#####........#..####......#..#\",\n\t\"\",\n\t\"#..#.\",\n\t\"#....\",\n\t\"##..#\",\n\t\"..#..\",\n\t\"..###\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"35\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"3351\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":21,"address":[51312,51316],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":22,"address":[109242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[109301,109410,109353,109580,109476,109263],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[51344,51348],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[109642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[109663,109701,109810,109876,109980],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","input.rs"],"content":"use super::*;\n\nuse model::Algorithm;\nuse model::Pixels;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub algorithm: Algorithm,\n\tpub pixels: Pixels,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { algorithm, pixels, params } = [\n\t\tparams,\n\t\t@array algorithm, \"\\n\",\n\t\t\"\\n\",\n\t\tpixels,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t\tpub num_times_one: u32 = (\"NUM_TIMES_ONE\", 2, 1_u32 .. ),\n\t\tpub num_times_two: u32 = (\"NUM_TIMES_TWO\", 50, 1_u32 .. ),\n\t}\n}\n","traces":[{"line":14,"address":[116174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[116867],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[116871],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","lib.rs"],"content":"//! Advent of Code 2021: Day 20: Trench Map\n//!\n//! [https://adventofcode.com/2021/day/20](https://adventofcode.com/2021/day/20)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod tool;\n\npuzzle_info! {\n\tname = \"Trench Map\";\n\tyear = 2021;\n\tday = 20;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = tool::run; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Algorithm;\nuse model::Image;\nuse model::Pixel;\nuse model::Pixels;\nuse model::Pos;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcalc_result (input, input.params.num_times_one)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcalc_result (input, input.params.num_times_two)\n}\n\npub fn calc_result (input: \u0026 Input, loops: u32) -\u003e GenResult \u003ci64\u003e {\n\tlet image = Image::new_from (input.pixels.clone (), Pixel::Dark);\n\tOk (\n\t\timage_iter (input.algorithm, image)\n\t\t\t.nth (loops.pan_usize ())\n\t\t\t.unwrap ()\n\t\t\t.num_pixels ().pan_i64 ()\n\t)\n}\n\npub struct ImageIter {\n\talgorithm: Algorithm,\n\timage: Rc \u003cImage\u003e,\n\tfirst: bool,\n}\n\n#[ allow (clippy::large_types_passed_by_value) ]\npub fn image_iter \u003cIntoImage: Into \u003cRc \u003cImage\u003e\u003e\u003e (\n\talgorithm: Algorithm,\n\timage: IntoImage,\n) -\u003e ImageIter {\n\tlet image = image.into ();\n\tImageIter { algorithm, image, first: true }\n}\n\nimpl Iterator for ImageIter {\n\ttype Item = Rc \u003cImage\u003e;\n\tfn next (\u0026 mut self) -\u003e Option \u003cRc \u003cImage\u003e\u003e {\n\t\tif self.first {\n\t\t\tself.first = false;\n\t\t} else {\n\t\t\tself.image = Rc::new (calc_next (\u0026 self.algorithm, \u0026 self.image));\n\t\t}\n\t\tSome (Rc::clone (\u0026 self.image))\n\t}\n}\n\n#[ must_use ]\npub fn calc_next (algorithm: \u0026 Algorithm, image: \u0026 Image) -\u003e Image {\n\tlet (origin, peak) = image.range ();\n\tlet new_pixels = (origin.y - 1 .. peak.y + 1)\n\t\t.flat_map (|y| (origin.x - 3 .. peak.x + 1)\n\t\t\t.map (move |x| [\n\t\t\t\timage.get (Pos { y: y - 1, x: x + 1 }),\n\t\t\t\timage.get (Pos { y, x: x + 1 }),\n\t\t\t\timage.get (Pos { y: y + 1, x: x + 1 }),\n\t\t\t])\n\t\t\t.scan ([Pixel::Dark; 9], |state, next| {\n\t\t\t\t* state = [\n\t\t\t\t\tstate [1], state [2], next [0],\n\t\t\t\t\tstate [4], state [5], next [1],\n\t\t\t\t\tstate [7], state [8], next [2],\n\t\t\t\t];\n\t\t\t\tSome (* state)\n\t\t\t})\n\t\t\t.skip (2)\n\t\t\t.map (|bits| {\n\t\t\t\tlet algorithm_idx = bits.into_iter ()\n\t\t\t\t\t.fold (0, |val, bit| (val \u003c\u003c 1_i32) | usize::from (bit));\n\t\t\t\talgorithm [algorithm_idx]\n\t\t\t}))\n\t\t.collect ();\n\tlet new_size = image.size () + Pos::new (2, 2);\n\tlet new_pixels = Pixels::wrap_size (new_pixels, new_size);\n\tlet new_default = algorithm [if image.default () == Pixel::Light { 0x1ff } else { 0 }];\n\tImage::new_from (new_pixels, new_default)\n}\n","traces":[{"line":10,"address":[96832],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":11,"address":[51933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[96864],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":15,"address":[52445],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[96896,97625],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":21,"address":[96940,97292],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[114976],"length":1,"stats":{"Line":0},"fn_name":"image_iter\u003caoc_2021_day_20::model::Image\u003e"},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[97648],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":46,"address":[97660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[97669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[97681,97828,97697,97893],"length":1,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[97936,98427],"length":1,"stats":{"Line":2},"fn_name":"calc_next"},{"line":57,"address":[97958],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[97994,98265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[60325,60436],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[60351],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[113214,113394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[113437,113277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[46235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[106984,107369,107463],"length":1,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[107352,107451,106972],"length":1,"stats":{"Line":6},"fn_name":null},{"line":68,"address":[60785],"length":1,"stats":{"Line":6},"fn_name":null},{"line":69,"address":[60789],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[94524],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[46249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[113633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[63371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[113758,113788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[98088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[98224,98240],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":27,"coverable":31},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","model.rs"],"content":"use super::*;\n\npub type Algorithm = [Pixel; 512];\npub type Pixels = GridBuf \u003cVec \u003cPixel\u003e, Pos, 2\u003e;\npub type Pos = pos::PosYX \u003ci16\u003e;\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Pixel {\n\t\t#[ default ]\n\t\tDark = \".\",\n\t\tLight = \"#\",\n\t}\n}\n\nimpl From \u003cPixel\u003e for usize {\n\tfn from (pixel: Pixel) -\u003e Self {\n\t\tmatch pixel {\n\t\t\tPixel::Dark =\u003e 0,\n\t\t\tPixel::Light =\u003e 1,\n\t\t}\n\t}\n}\n\n#[ derive (Debug) ]\npub struct Image {\n\tpixels: Pixels,\n\tdefault: Pixel,\n}\n\nimpl Image {\n\n\t#[ must_use ]\n\tpub const fn new_from (pixels: Pixels, default: Pixel) -\u003e Self {\n\t\tSelf { pixels, default }\n\t}\n\n\t#[ must_use ]\n\tpub fn num_pixels (\u0026 self) -\u003e usize {\n\t\tself.pixels.values ().filter (|\u0026 val| val != self.default).count ()\n\t}\n\n\t#[ must_use ]\n\tpub fn size (\u0026 self) -\u003e Pos {\n\t\tself.pixels.size ()\n\t}\n\n\t#[ must_use ]\n\tpub const fn default (\u0026 self) -\u003e Pixel {\n\t\tself.default\n\t}\n\n\t#[ must_use ]\n\tpub fn get (\u0026 self, pos: Pos) -\u003e Pixel {\n\t\tself.pixels.get (pos).unwrap_or (self.default)\n\t}\n\n\t#[ must_use ]\n\tpub fn range (\u0026 self) -\u003e (Pos, Pos) {\n\t\t(self.pixels.first_key (), self.pixels.last_key () + Pos { y: 1, x: 1 })\n\t}\n\n}\n\nimpl Display for Image {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tDisplay::fmt (\u0026 self.pixels, formatter)\n\t}\n}\n","traces":[{"line":8,"address":[125217],"length":1,"stats":{"Line":6},"fn_name":null},{"line":17,"address":[106048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[106064],"length":1,"stats":{"Line":0},"fn_name":"new_from"},{"line":39,"address":[106096],"length":1,"stats":{"Line":0},"fn_name":"num_pixels"},{"line":40,"address":[94192,94204],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":44,"address":[106256],"length":1,"stats":{"Line":0},"fn_name":"size"},{"line":49,"address":[106272],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":50,"address":[98236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[106288],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":55,"address":[106292],"length":1,"stats":{"Line":8},"fn_name":null},{"line":59,"address":[106336],"length":1,"stats":{"Line":2},"fn_name":"range"},{"line":67,"address":[98970],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","tool.rs"],"content":"use super::*;\n\nuse std::path::PathBuf;\n\nuse input::Input;\nuse model::Image;\nuse model::Pixel;\n\n#[ derive (Debug, clap::Parser) ]\npub struct RunArgs {\n\n\t/// File to read algorithm and initial image from\n\t#[ clap (long, from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n\n\t/// Print the image after each step\n\t#[ clap (long) ]\n\tverbose: bool,\n\n\t/// Number of times to apply the algorithm\n\t#[ clap (long, value_parser, default_value_t = 2) ]\n\tloops: usize,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tlet start_image = Image::new_from (input.pixels, Pixel::Dark);\n\tlet end_image = logic::image_iter (input.algorithm, start_image)\n\t\t.enumerate ()\n\t\t.inspect (|\u0026 (ref steps, ref image)| if args.verbose {\n\t\t\tprintln! (\n\t\t\t\t\"\\nAfter {steps} steps: {num_pixels} pixels {pixel}\\n{image}\",\n\t\t\t\tnum_pixels = image.num_pixels (),\n\t\t\t\tpixel = match image.default () { Pixel::Dark =\u003e \"light\", Pixel::Light =\u003e \"dark\" });\n\t\t},\n\t).map (|(_, image)| image).nth (args.loops).unwrap ();\n\tprintln! (\"Result: {}\", end_image.num_pixels ());\n\tOk (())\n}\n","traces":[{"line":28,"address":[108823,107616],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":29,"address":[107644,108289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[107747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[107840,107785,108390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[108159,108142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[108082,108832,108847],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":36,"address":[109033,109183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[108974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[108979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[108452,108559],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-21","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\"Player 1 starting position: 4\",\n\t\"Player 2 starting position: 8\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"739785\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"444356092776315\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":11,"address":[39216,39607],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":12,"address":[39226],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[39460,39394,39247,39337,39285,39564],"length":1,"stats":{"Line":3},"fn_name":null},{"line":17,"address":[39616,40007],"length":1,"stats":{"Line":2},"fn_name":"part_two"},{"line":18,"address":[39626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[39860,39794,39685,39737,39964,39647],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-21","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub player_1: u8,\n\tpub player_2: u8,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { player_1, player_2, params } = [\n\t\tparams,\n\t\t\"Player 1 starting position: \", player_1 = 1 ..= 10, \"\\n\",\n\t\t\"Player 2 starting position: \", player_2 = 1 ..= 10,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-21","lib.rs"],"content":"//! Advent of Code 2021: Day 21: Dirac Dice\n//!\n//! [https://adventofcode.com/2021/day/21](https://adventofcode.com/2021/day/21)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\n\npuzzle_info! {\n\tname = \"Dirac Dice\";\n\tyear = 2021;\n\tday = 21;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":18,"address":[36248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[36507],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-21","logic.rs"],"content":"use super::*;\n\nuse input::Input;\n\nconst DIRAC_FREQS: [(u8, u128); 7] = [(3, 1), (4, 3), (5, 6), (6, 7), (7, 6), (8, 3), (9, 1)];\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cu64\u003e {\n\tlet mut die_state: u16 = 0;\n\tlet mut die_count: u64 = 0;\n\tlet mut die_roll = || {\n\t\tlet roll = die_state + 1;\n\t\tdie_state = (die_state + 1) % 100;\n\t\tdie_count += 1;\n\t\troll\n\t};\n\tstruct Player { score: u16, pos: u8 }\n\tlet mut players = [\n\t\tPlayer { score: 0, pos: input.player_1 - 1 },\n\t\tPlayer { score: 0, pos: input.player_2 - 1 },\n\t];\n\tlet winner = 'OUTER: loop {\n\t\tfor (player_idx, player) in players.iter_mut ().enumerate () {\n\t\t\tlet roll = iter::from_fn (|| Some (die_roll ())).take (3).sum::\u003cu16\u003e ();\n\t\t\tplayer.pos = ((player.pos.pan_u16 () + roll.pan_u16 ()) % 10).pan_u8 ();\n\t\t\tplayer.score += player.pos.pan_u16 () + 1;\n\t\t\tif player.score \u003e= 1000 { break 'OUTER player_idx }\n\t\t}\n\t};\n\tlet loser = (winner + 1) % 2;\n\tOk (die_count * players [loser].score.pan_u64 ())\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cu128\u003e {\n\n\t// array indexed by game state to track the number of \"universes\" in which each occurs\n\n\tlet mut games: Vec \u003cu128\u003e = iter::repeat (0_u128).take (1 \u003c\u003c 19).collect ();\n\n\t// seed the state with the single starting game in one universe\n\n\tlet start_game = Game::start (input);\n\tgames [start_game.idx ()] = 1;\n\n\t// `num_wins` is used to track universes where each player wins\n\n\tlet mut num_wins = [0_u128; 2];\n\n\t// iterate over game states adding future game states which branch from each\n\n\tfor this_game_idx in start_game.idx () .. games.len () {\n\t\tlet this_times = games [this_game_idx];\n\t\tif this_times == 0 { continue }\n\t\tlet this_game = Game::from_idx (this_game_idx);\n\t\tfor (new_game, new_player, freq) in this_game.iter_next () {\n\t\t\tif 21 \u003c= new_player.score {\n\t\t\t\tnum_wins [this_game.turn.pan_usize ()] += this_times * freq;\n\t\t\t} else {\n\t\t\t\tgames [new_game.idx ()] += this_times * freq;\n\t\t\t}\n\t\t}\n\t}\n\n\t// return the higher of the two numbers of winning universes\n\n\tOk (num_wins.iter ().copied ().max ().unwrap ())\n\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\nstruct Player {\n\tscore: u8,\n\tpos: u8,\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, PartialEq) ]\nstruct Game {\n\tplayers: [Player; 2],\n\tturn: u8,\n}\n\nimpl Game {\n\n\tconst fn start (input: \u0026 Input) -\u003e Self {\n\t\tSelf {\n\t\t\tplayers: [\n\t\t\t\tPlayer { score: 0, pos: input.player_1 },\n\t\t\t\tPlayer { score: 0, pos: input.player_2 },\n\t\t\t],\n\t\t\tturn: 0,\n\t\t}\n\t}\n\n\tfn idx (self) -\u003e usize {\n\t\tself.players [0].score.qck_usize () \u003c\u003c 14_u32\n\t\t\t| self.players [1].score.qck_usize () \u003c\u003c 9_u32\n\t\t\t| self.players [0].pos.qck_usize () \u003c\u003c 5_u32\n\t\t\t| self.players [1].pos.qck_usize () \u003c\u003c 1_u32\n\t\t\t| self.turn.qck_usize ()\n\t}\n\n\tfn from_idx (idx: usize) -\u003e Self {\n\t\tSelf {\n\t\t\tplayers: [\n\t\t\t\tPlayer {\n\t\t\t\t\tscore: (idx \u003e\u003e 14_u32).qck_u8 () \u0026 0x1f,\n\t\t\t\t\tpos: (idx \u003e\u003e 5_u32).qck_u8 () \u0026 0xf,\n\t\t\t\t},\n\t\t\t\tPlayer {\n\t\t\t\t\tscore: (idx \u003e\u003e 9_u32).qck_u8 () \u0026 0x1f,\n\t\t\t\t\tpos: (idx \u003e\u003e 1_u32).qck_u8 () \u0026 0xf,\n\t\t\t\t},\n\t\t\t],\n\t\t\tturn: idx.qck_u8 () \u0026 0x1,\n\t\t}\n\t}\n\n\tfn iter_next (self) -\u003e impl Iterator \u003cItem = (Self, Player, u128)\u003e {\n\t\tDIRAC_FREQS.into_iter ().map (move |(roll_val, roll_freq)| {\n\t\t\tlet mut new_game = self;\n\t\t\tlet new_player = \u0026 mut new_game.players [self.turn.pan_usize ()];\n\t\t\tnew_player.pos += roll_val;\n\t\t\tif 10 \u003c new_player.pos { new_player.pos -= 10; }\n\t\t\tnew_player.score += new_player.pos;\n\t\t\tlet new_player = * new_player;\n\t\t\tnew_game.turn ^= 1;\n\t\t\tdebug_assert! (new_game \u003c self);\n\t\t\t(new_game, new_player, roll_freq)\n\t\t})\n\t}\n\n}\n\nimpl Ord for Game {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tOrdering::Equal\n\t\t\t.then (self.players [0].score.cmp (\u0026 other.players [0].score))\n\t\t\t.then (self.players [1].score.cmp (\u0026 other.players [1].score))\n\t\t\t.then (self.players [0].pos.cmp (\u0026 other.players [0].pos))\n\t\t\t.then (self.players [1].pos.cmp (\u0026 other.players [1].pos))\n\t\t\t.then (self.turn.cmp (\u0026 other.turn))\n\t\t\t.reverse ()\n\t}\n}\n\nimpl PartialOrd for Game {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tSome (self.cmp (other))\n\t}\n}\n","traces":[{"line":7,"address":[29168],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":8,"address":[29182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[29189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[29203],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[40173,40116],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[37833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[40152,40189],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[29247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[30046,29218],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[29229,30062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[29437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[40112,40167,40113],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":24,"address":[29761,29971,29673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[29987,29801],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[29827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[29851,30078,29865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[29860,29925,30094],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[31365,30128],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":42,"address":[30221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[30238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[30256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[30361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[30371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[30424,30666,31340],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[30746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[30819,31225,30760],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[30963,30864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[31088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[30379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[40224],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":119,"address":[40249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[40320,40262,40561],"length":1,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[40330,40584],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[40343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[40600,40363],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[40377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[40627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[40506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[31376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[31488],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"}],"covered":37,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"on x=10..12,y=10..12,z=10..12\",\n\t\"on x=11..13,y=11..13,z=11..13\",\n\t\"off x=9..11,y=9..11,z=9..11\",\n\t\"on x=10..10,y=10..10,z=10..10\",\n];\n\nconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\"on x=-20..26,y=-36..17,z=-47..7\",\n\t\"on x=-20..33,y=-21..23,z=-26..28\",\n\t\"on x=-22..28,y=-29..23,z=-38..16\",\n\t\"on x=-46..7,y=-6..46,z=-50..-1\",\n\t\"on x=-49..1,y=-3..46,z=-24..28\",\n\t\"on x=2..47,y=-22..22,z=-23..27\",\n\t\"on x=-27..23,y=-28..26,z=-21..29\",\n\t\"on x=-39..5,y=-6..47,z=-3..44\",\n\t\"on x=-30..21,y=-8..43,z=-13..34\",\n\t\"on x=-22..26,y=-27..20,z=-29..19\",\n\t\"off x=-48..-32,y=26..41,z=-47..-37\",\n\t\"on x=-12..35,y=6..50,z=-50..-2\",\n\t\"off x=-48..-32,y=-32..-16,z=-15..-5\",\n\t\"on x=-18..26,y=-33..15,z=-7..46\",\n\t\"off x=-40..-22,y=-38..-28,z=23..41\",\n\t\"on x=-16..35,y=-41..10,z=-47..6\",\n\t\"off x=-32..-23,y=11..30,z=-14..3\",\n\t\"on x=-49..-5,y=-3..45,z=-29..18\",\n\t\"off x=18..30,y=-20..-8,z=-3..13\",\n\t\"on x=-41..9,y=-7..43,z=-33..15\",\n\t\"on x=-54112..-39298,y=-85059..-49293,z=-27449..7877\",\n\t\"on x=967..23432,y=45373..81175,z=27513..53682\",\n];\n\nconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\"on x=-5..47,y=-31..22,z=-19..33\",\n\t\"on x=-44..5,y=-27..21,z=-14..35\",\n\t\"on x=-49..-1,y=-11..42,z=-10..38\",\n\t\"on x=-20..34,y=-40..6,z=-44..1\",\n\t\"off x=26..39,y=40..50,z=-2..11\",\n\t\"on x=-41..5,y=-41..6,z=-36..8\",\n\t\"off x=-43..-33,y=-45..-28,z=7..25\",\n\t\"on x=-33..15,y=-32..19,z=-34..11\",\n\t\"off x=35..47,y=-46..-34,z=-11..5\",\n\t\"on x=-14..36,y=-6..44,z=-16..29\",\n\t\"on x=-57795..-6158,y=29564..72030,z=20435..90618\",\n\t\"on x=36731..105352,y=-21140..28532,z=16094..90401\",\n\t\"on x=30999..107136,y=-53464..15513,z=8553..71215\",\n\t\"on x=13528..83982,y=-99403..-27377,z=-24141..23996\",\n\t\"on x=-72682..-12347,y=18159..111354,z=7391..80950\",\n\t\"on x=-1060..80757,y=-65301..-20884,z=-103788..-16709\",\n\t\"on x=-83015..-9461,y=-72160..-8347,z=-81239..-26856\",\n\t\"on x=-52752..22273,y=-49450..9096,z=54442..119054\",\n\t\"on x=-29982..40483,y=-108474..-28371,z=-24328..38471\",\n\t\"on x=-4958..62750,y=40422..118853,z=-7672..65583\",\n\t\"on x=55694..108686,y=-43367..46958,z=-26781..48729\",\n\t\"on x=-98497..-18186,y=-63569..3412,z=1232..88485\",\n\t\"on x=-726..56291,y=-62629..13224,z=18033..85226\",\n\t\"on x=-110886..-34664,y=-81338..-8658,z=8914..63723\",\n\t\"on x=-55829..24974,y=-16897..54165,z=-121762..-28058\",\n\t\"on x=-65152..-11147,y=22489..91432,z=-58782..1780\",\n\t\"on x=-120100..-32970,y=-46592..27473,z=-11695..61039\",\n\t\"on x=-18631..37533,y=-124565..-50804,z=-35667..28308\",\n\t\"on x=-57817..18248,y=49321..117703,z=5745..55881\",\n\t\"on x=14781..98692,y=-1341..70827,z=15753..70151\",\n\t\"on x=-34419..55919,y=-19626..40991,z=39015..114138\",\n\t\"on x=-60785..11593,y=-56135..2999,z=-95368..-26915\",\n\t\"on x=-32178..58085,y=17647..101866,z=-91405..-8878\",\n\t\"on x=-53655..12091,y=50097..105568,z=-75335..-4862\",\n\t\"on x=-111166..-40997,y=-71714..2688,z=5609..50954\",\n\t\"on x=-16602..70118,y=-98693..-44401,z=5197..76897\",\n\t\"on x=16383..101554,y=4615..83635,z=-44907..18747\",\n\t\"off x=-95822..-15171,y=-19987..48940,z=10804..104439\",\n\t\"on x=-89813..-14614,y=16069..88491,z=-3297..45228\",\n\t\"on x=41075..99376,y=-20427..49978,z=-52012..13762\",\n\t\"on x=-21330..50085,y=-17944..62733,z=-112280..-30197\",\n\t\"on x=-16478..35915,y=36008..118594,z=-7885..47086\",\n\t\"off x=-98156..-27851,y=-49952..43171,z=-99005..-8456\",\n\t\"off x=2032..69770,y=-71013..4824,z=7471..94418\",\n\t\"on x=43670..120875,y=-42068..12382,z=-24787..38892\",\n\t\"off x=37514..111226,y=-45862..25743,z=-16714..54663\",\n\t\"off x=25699..97951,y=-30668..59918,z=-15349..69697\",\n\t\"off x=-44271..17935,y=-9516..60759,z=49131..112598\",\n\t\"on x=-61695..-5813,y=40978..94975,z=8655..80240\",\n\t\"off x=-101086..-9439,y=-7088..67543,z=33935..83858\",\n\t\"off x=18020..114017,y=-48931..32606,z=21474..89843\",\n\t\"off x=-77139..10506,y=-89994..-18797,z=-80..59318\",\n\t\"off x=8476..79288,y=-75520..11602,z=-96624..-24783\",\n\t\"on x=-47488..-1262,y=24338..100707,z=16292..72967\",\n\t\"off x=-84341..13987,y=2429..92914,z=-90671..-1318\",\n\t\"off x=-37810..49457,y=-71013..-7894,z=-105357..-13188\",\n\t\"off x=-27365..46395,y=31009..98017,z=15428..76570\",\n\t\"off x=-70369..-16548,y=22648..78696,z=-1892..86821\",\n\t\"on x=-53470..21291,y=-120233..-33476,z=-44150..38147\",\n\t\"off x=-93533..-4276,y=-16170..68771,z=-104985..-24507\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"39\", puzzle.part_one (EXAMPLE_0));\n\tassert_eq_ok! (\"590784\", puzzle.part_one (EXAMPLE_1));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"2758514936282235\", puzzle.part_two (EXAMPLE_2));\n}\n","traces":[{"line":101,"address":[53728,53760,54430,53732],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":102,"address":[53777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[53839,54064,53798,54127,54386,53892],"length":1,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[54190,54350,54250,54002,53949,53912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[54452,54480,54448,54871],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":109,"address":[54490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[54828,54549,54601,54724,54658,54511],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":7,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","input.rs"],"content":"use super::*;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub steps: Vec \u003cInputStep\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { steps, params } = [ params, @lines steps ]\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct InputStep {\n\tpub state: bool,\n\tpub cube: InputCube,\n}\n\nstruct_parser_display! {\n\tInputStep { state, cube } = [\n\t\tstate {\n\t\t\t//state if (* state == true) = [ \"on\", @parse state { true } ],\n\t\t\t//state if (* state == false) = [ \"off\", @parse state { false } ],\n\t\t\ttrue = [ \"on\" ],\n\t\t\tfalse = [ \"off\" ],\n\t\t}, \" \",\n\t\tcube,\n\t]\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub struct InputCube {\n\tpub x0: i32, pub x1: i32,\n\tpub y0: i32, pub y1: i32,\n\tpub z0: i32, pub z1: i32,\n}\n\nstruct_parser_display! {\n\tInputCube { x0, x1, y0, y1, z0, z1 } = [\n\t\t\"x=\", x0, \"..\", x1, \",\",\n\t\t\"y=\", y0, \"..\", y1, \",\",\n\t\t\"z=\", z0, \"..\", z1,\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":10,"address":[32374,32891],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","lib.rs"],"content":"//! Advent of Code 2021: Day 22: Reactor Reboot\n//!\n//! [https://adventofcode.com/2021/day/22](https://adventofcode.com/2021/day/22)\n//!\n//! This uses a slightly unintuitive algorithm to count up the activated locations. Instead of\n//! splitting up cubes to ensure they never intersect, we simply add them all together, then keep\n//! track of where they overlapped. Every time we overlap we track the overlapping section as well,\n//! but we add it up as the negative. If we overlap a negative we add it again as a positive.\n//!\n//! To make part two quicker, we split the referenced area up into a 101010 grid and calculate\n//! the value for each section individually. This drastically cuts down on the number of\n//! intersections we need to make.\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Reactor Reboot\";\n\tyear = 2021;\n\tday = 22;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n}\n","traces":[{"line":28,"address":[70200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[70520],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":2,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Cube;\nuse model::Step;\n\nconst BOUND_50: Cube = Cube { x0: -50, y0: -50, z0: -50, x1: 51, y1: 51, z1: 51 };\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tlet steps: Vec \u003cStep\u003e = input.steps.iter ().copied ().map (Step::from).collect ();\n\tlet steps = bound_steps (\u0026 steps, BOUND_50);\n\tcalc_result (\u0026 steps)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tlet steps: Vec \u003cStep\u003e = input.steps.iter ().copied ().map (Step::from).collect ();\n\tcalc_result_with_splits (\u0026 steps, 10)\n}\n\nfn calc_result_with_splits (steps: \u0026 [Step], num_splits: i32) -\u003e GenResult \u003ci64\u003e {\n\tlet bound = steps.iter ().copied ().fold (Cube::ZERO, |bound, step| Cube {\n\t\tx0: cmp::min (bound.x0, step.cube.x0),\n\t\tx1: cmp::max (bound.x1, step.cube.x1),\n\t\ty0: cmp::min (bound.y0, step.cube.y0),\n\t\ty1: cmp::max (bound.y1, step.cube.y1),\n\t\tz0: cmp::min (bound.z0, step.cube.z0),\n\t\tz1: cmp::max (bound.z1, step.cube.z1),\n\t});\n\tlet x_bounds: Vec \u003c_\u003e = (0_i32 .. num_splits)\n\t\t.map (|idx| Ok (Cube {\n\t\t\tx0: chk! (bound.x0 + (bound.x1 - bound.x0) * idx / num_splits) ?,\n\t\t\tx1: chk! (bound.x0 + (bound.x1 - bound.x0) * (idx + 1_i32) / num_splits) ?,\n\t\t\t.. bound\n\t\t}))\n\t\t.try_collect::\u003c_, _, Overflow\u003e () ?;\n\tlet y_bounds: Vec \u003c_\u003e = (0_i32 .. num_splits)\n\t\t.map (|idx| Ok (Cube {\n\t\t\ty0: chk! (bound.y0 + (bound.y1 - bound.y0) * idx / num_splits) ?,\n\t\t\ty1: chk! (bound.y0 + (bound.y1 - bound.y0) * (idx + 1_i32) / num_splits) ?,\n\t\t\t.. bound\n\t\t}))\n\t\t.try_collect::\u003c_, _, Overflow\u003e () ?;\n\tlet z_bounds: Vec \u003c_\u003e = (0_i32 .. num_splits)\n\t\t.map (|idx| Ok (Cube {\n\t\t\tz0: chk! (bound.z0 + (bound.z1 - bound.z0) * idx / num_splits) ?,\n\t\t\tz1: chk! (bound.z0 + (bound.z1 - bound.z0) * (idx + 1_i32) / num_splits) ?,\n\t\t\t.. bound\n\t\t}))\n\t\t.try_collect::\u003c_, _, Overflow\u003e () ?;\n\tlet mut total = 0;\n\tfor x_bound in x_bounds.iter ().copied () {\n\t\tlet steps = bound_steps (steps, x_bound);\n\t\tfor y_bound in y_bounds.iter ().copied () {\n\t\t\tlet steps = bound_steps (\u0026 steps, y_bound);\n\t\t\tfor z_bound in z_bounds.iter ().copied () {\n\t\t\t\tlet steps = bound_steps (\u0026 steps, z_bound);\n\t\t\t\ttotal += calc_result (\u0026 steps) ?;\n\t\t\t}\n\t\t}\n\t}\n\tOk (total)\n}\n\nfn calc_result (steps: \u0026 [Step]) -\u003e GenResult \u003ci64\u003e {\n\tlet mut core: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\tlet mut buffer: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\tfor step in steps.iter () {\n\t\tif step.state {\n\t\t\tbuffer.push ((step.cube, true));\n\t\t}\n\t\tfor \u0026 (core_cube, core_state) in core.iter () {\n\t\t\tif let Some (intersect) = core_cube.intersect (step.cube) {\n\t\t\t\tbuffer.push ((intersect, ! core_state));\n\t\t\t}\n\t\t}\n\t\tcore.append (\u0026 mut buffer);\n\t\tif 100_000 \u003c core.len () {\n\t\t\treturn Err (\"Giving up because of too many cubes to track\".into ());\n\t\t}\n\t}\n\tOk (\n\t\tcore.iter ()\n\t\t\t.map (|\u0026 (cube, state)| cube.volume () * if state { 1 } else { -1 })\n\t\t\t.sum::\u003ci64\u003e ()\n\t)\n}\n\nfn bound_steps (steps: \u0026 [Step], bound: Cube) -\u003e Vec \u003cStep\u003e {\n\tsteps.iter ().copied ().filter_map (\n\t\t|mut step| step.cube.intersect (bound).map (|cube| { step.cube = cube; step }),\n\t).collect ()\n}\n","traces":[{"line":9,"address":[36416,36681],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":11,"address":[36500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[36597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":15,"address":[36704,36845],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":17,"address":[36785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[36864,38946],"length":1,"stats":{"Line":1},"fn_name":"calc_result_with_splits"},{"line":21,"address":[35582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[35490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[35504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[35526],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[27512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[27525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[27538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[36964,37150,37353],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[27600,27851],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":31,"address":[28827,28912,28928,28960,28992,27624,28752,28905,29120,29056,27779,28976,28760,27698],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[29379,29136,29179,29404,29456,29616,29328,29488,29423,27837,29146,29376,29211,29472,29440,29552,27793,29344,29288],"length":1,"stats":{"Line":7},"fn_name":"{closure#1}"},{"line":36,"address":[37445,37183,37612],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[28188,27936],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":38,"address":[30000,28035,29792,29785,29632,27960,29840,29707,29856,28116,29872,29640,29808,29936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[30059,30432,28174,30026,30368,30259,30016,30320,30303,30336,30168,30352,30496,28130,30256,30091,30224,30284,30208],"length":1,"stats":{"Line":7},"fn_name":"{closure#1}"},{"line":43,"address":[37696,37478,38668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[28524,28272],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":45,"address":[30720,30752,30816,28296,30512,30520,30688,28371,30587,28452,30665,30736,30880,30672],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[31104,31200,31232,31312,31248,31183,28510,31088,30896,31136,31164,30939,30971,28466,30906,31048,31216,31139,31376],"length":1,"stats":{"Line":7},"fn_name":"{closure#1}"},{"line":52,"address":[37856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[38092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[38328],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[38583,38791,38430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[38751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[39897,38960],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":67,"address":[39062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[39077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[39084],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[39371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[39387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[39669],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[39682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[28613,28608],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":90,"address":[28704,28707,27374,27310],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":38,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","model.rs"],"content":"use super::*;\n\nuse input::InputCube;\nuse input::InputStep;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Step {\n\tpub state: bool,\n\tpub cube: Cube,\n}\n\nimpl From \u003cInputStep\u003e for Step {\n\tfn from (step: InputStep) -\u003e Self {\n\t\tSelf {\n\t\t\tstate: step.state,\n\t\t\tcube: step.cube.into (),\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub struct Cube {\n\tpub x0: i32, pub x1: i32,\n\tpub y0: i32, pub y1: i32,\n\tpub z0: i32, pub z1: i32,\n}\n\nimpl From \u003cInputCube\u003e for Cube {\n\tfn from (cube: InputCube) -\u003e Self {\n\t\tSelf {\n\t\t\tx0: cube.x0, x1: cube.x1 + 1,\n\t\t\ty0: cube.y0, y1: cube.y1 + 1,\n\t\t\tz0: cube.z0, z1: cube.z1 + 1,\n\t\t}\n\t}\n}\n\nimpl Cube {\n\n\t#[ must_use ]\n\tpub const fn overlaps (self, other: Self) -\u003e bool {\n\t\tself.x0 \u003c other.x1 \u0026\u0026 other.x0 \u003c self.x1\n\t\t\t\u0026\u0026 self.y0 \u003c other.y1 \u0026\u0026 other.y0 \u003c self.y1\n\t\t\t\u0026\u0026 self.z0 \u003c other.z1 \u0026\u0026 other.z0 \u003c self.z1\n\t}\n\n\t#[ must_use ]\n\tpub fn intersect (self, other: Self) -\u003e Option \u003cSelf\u003e {\n\t\tself.overlaps (other).then_some (Self {\n\t\t\tx0: cmp::max (self.x0, other.x0),\n\t\t\tx1: cmp::min (self.x1, other.x1),\n\t\t\ty0: cmp::max (self.y0, other.y0),\n\t\t\ty1: cmp::min (self.y1, other.y1),\n\t\t\tz0: cmp::max (self.z0, other.z0),\n\t\t\tz1: cmp::min (self.z1, other.z1),\n\t\t} )\n\t}\n\n\t#[ must_use ]\n\tpub fn volume (self) -\u003e i64 {\n\t\t(self.x1.pan_i64 () - self.x0.pan_i64 ())\n\t\t\t* (self.y1.pan_i64 () - self.y0.pan_i64 ())\n\t\t\t* (self.z1.pan_i64 () - self.z0.pan_i64 ())\n\t}\n\n\tpub const ZERO: Self = Self { x0: 0, x1: 0, y0: 0, y1: 0, z0: 0, z1: 0 };\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct Pos { pub z: i32, pub y: i32, pub x: i32 }\n","traces":[{"line":13,"address":[64032],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":16,"address":[64033,64040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[64160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[74616,74564],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[74571,74632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[74648,74578],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[64320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[64361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[64288],"length":1,"stats":{"Line":1},"fn_name":"intersect"},{"line":49,"address":[64311,64357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[64371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[64384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[64405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[64418],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[64432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[64444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[64544],"length":1,"stats":{"Line":1},"fn_name":"volume"},{"line":61,"address":[64558,64786,64904,64928,64627,64662],"length":1,"stats":{"Line":5},"fn_name":null},{"line":62,"address":[64734,64671,64953,64777],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[64796,64969,64859,64899],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":18,"coverable":20},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\"#############\",\n\t\"#...........#\",\n\t\"###B#C#B#D###\",\n\t\"  #A#D#C#A#\",\n\t\"  #########\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"12521\", puzzle.part_one (EXAMPLE));\n}\n\n#[ test ]\nfn part_two () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"44169\", puzzle.part_two (EXAMPLE));\n}\n","traces":[{"line":14,"address":[69428,69424],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":15,"address":[112730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[112751,112898,112964,113068,112841,112789],"length":1,"stats":{"Line":3},"fn_name":null},{"line":20,"address":[69456,69460],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":21,"address":[113130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[113189,113151,113241,113298,113468,113364],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","input.rs"],"content":"use super::*;\n\nuse model::Amph;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub amphs: [[Amph; 2]; 4],\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput {\n\t\tamphs: [ [ a0, a1 ], [ b0, b1 ], [ c0, c1 ], [ d0, d1 ] ],\n\t\tparams,\n\t} = [\n\t\tparams,\n\t\t\"#############\\n\",\n\t\t\"#...........#\\n\",\n\t\t\"###\", a0, \"#\", b0, \"#\", c0, \"#\", d0, \"###\\n\",\n\t\t\"  #\", a1, \"#\", b1, \"#\", c1, \"#\", d1, \"#\\n\",\n\t\t\"  #########\",\n\t]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[{"line":13,"address":[129810],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","lib.rs"],"content":"//! Advent of Code 2021: Day 23: Amphipod\n//!\n//! [https://adventofcode.com/2021/day/23](https://adventofcode.com/2021/day/23)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\nuse aoc_search as search;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\npub mod tools;\n\npuzzle_info! {\n\tname = \"Amphipod\";\n\tyear = 2021;\n\tday = 23;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"run\"; method = tools::run; ),\n\t\t( name = \"internals\"; method = tools::internals; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Amph::{ self, Amber, Bronze, Copper, Desert };\nuse model::Place;\nuse model::State;\nuse model::StateCompact;\nuse search::PrioritySearch;\nuse search::PrioritySearchAdder;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcheck_input (input) ?;\n\tlet state = State::new_part_one (input);\n\tcalc_result (state)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tcheck_input (input) ?;\n\tlet state = State::new_part_two (input);\n\tcalc_result (state)\n}\n\npub fn calc_result (initial_state: State) -\u003e GenResult \u003ci64\u003e {\n\tOk (\n\t\titerator (initial_state)\n\t\t\t.filter (|\u0026 (ref state_compact, _)| state_compact.is_finished ())\n\t\t\t.map (|(_, score)| score)\n\t\t\t.next ()\n\t\t\t.ok_or (\"Failed to find solution\") ?\n\t)\n}\n\npub fn iterator (initial_state: State) -\u003e impl Iterator \u003cItem = (StateCompact, i64)\u003e {\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|state: StateCompact, score: i64, mut adder: PrioritySearchAdder \u003c'_, _, _, _\u003e| {\n\t\t\tfor (next_state, next_cost) in calc_next_states (state) {\n\t\t\t\tlet next_score = score + next_cost;\n\t\t\t\tadder.add (next_state, next_score);\n\t\t\t}\n\t\t\t(state, score)\n\t\t},\n\t);\n\tsearch.push (initial_state.compact (), 0);\n\tsearch\n}\n\n#[ must_use ]\npub fn calc_next_states (state_compact: StateCompact) -\u003e ArrayVec \u003c(StateCompact, i64), 28\u003e {\n\tlet state = state_compact.expand ();\n\n\tlet out_cost = |room| state.room_size () - state.room (room).len () + 1;\n\tlet in_cost = |room| state.room_size () - state.room (room).len ();\n\tlet hall_cost = |room: Amph, hall: Place|\n\t\tusize::abs_diff (2 + room.idx () * 2, hall.idx ());\n\n\tlet next_moves = calc_next_moves (\u0026 state);\n\tif next_moves.is_empty () { return ArrayVec::new () }\n\n\tlet blocking = (state.hall () [3], state.hall () [5], state.hall () [7]);\n\tlet sections = [\n\t\t! matches! (blocking,\n\t\t\t(Some (Copper | Desert), _, _) |\n\t\t\t(_, Some (Bronze | Copper | Desert), _) |\n\t\t\t(_, _, Some (Desert))),\n\t\t! matches! (blocking,\n\t\t\t(Some (Amber), _, _) |\n\t\t\t(_, Some (Copper | Desert), _) |\n\t\t\t(_, _, Some (Desert))),\n\t\t! matches! (blocking,\n\t\t\t(Some (Amber), _, _) |\n\t\t\t(_, Some (Amber | Bronze), _) |\n\t\t\t(_, _, Some (Desert))),\n\t\t! matches! (blocking,\n\t\t\t(Some (Amber), _, _) |\n\t\t\t(_, Some (Amber | Bronze), _) |\n\t\t\t(_, _, Some (Amber | Bronze | Copper))),\n\t];\n\n\tlet mut next_states = ArrayVec::new ();\n\tfor next_move in next_moves.iter ().copied () {\n\t\tmatch next_move {\n\t\t\tMove::Between (amph, from_room, to_room) =\u003e {\n\t\t\t\tif ! sections [from_room.idx ()] || ! sections [to_room.idx ()] { continue }\n\t\t\t\tlet cost = amph.cost () * (out_cost (from_room) + in_cost (to_room)\n\t\t\t\t\t+ usize::abs_diff (from_room.idx (), to_room.idx ()) * 2).pan_i64 ();\n\t\t\t\tlet next_state = state.move_between (from_room, to_room);\n\t\t\t\treturn iter::once ((next_state.compact (), cost)).collect ();\n\t\t\t},\n\t\t\tMove::In (amph, from_hall, to_room) =\u003e {\n\t\t\t\tif ! sections [to_room.idx ()] { continue }\n\t\t\t\tlet cost = amph.cost () * (in_cost (to_room) + hall_cost (to_room, from_hall)).pan_i64 ();\n\t\t\t\tlet next_state = state.move_in (from_hall, to_room);\n\t\t\t\treturn iter::once ((next_state.compact (), cost)).collect ();\n\t\t\t},\n\t\t\tMove::Out (..) =\u003e (),\n\t\t}\n\t}\n\tfor next_move in next_moves.iter ().copied () {\n\t\tif let Move::Out (amph, from_room, to_hall) = next_move {\n\t\t\tif ! sections [from_room.idx ()] { continue }\n\t\t\tlet cost = amph.cost () * (out_cost (from_room)\n\t\t\t\t+ hall_cost (from_room, to_hall)).pan_i64 ();\n\t\t\tlet next_state = state.move_out (from_room, to_hall);\n\t\t\tnext_states.push ((next_state.compact (), cost));\n\t\t}\n\t}\n\n\tnext_states\n\n}\n\n#[ derive (Clone, Copy) ]\npub enum Move {\n\tOut (Amph, Amph, Place),\n\tIn (Amph, Place, Amph),\n\tBetween (Amph, Amph, Amph),\n}\n\n#[ must_use ]\npub fn calc_next_moves (state: \u0026 State) -\u003e ArrayVec \u003cMove, 28\u003e {\n\tlet mut result = ArrayVec::new ();\n\tlet path_clear = |from: Place, to: Place|\n\t\tstate.hall ().iter ().enumerate ()\n\t\t\t.skip (cmp::min (to.idx (), from.idx ()))\n\t\t\t.take (usize::abs_diff (from.idx (), to.idx ()) + 1)\n\t\t\t.map (|(idx, amph)| (Place::for_idx (idx), amph))\n\t\t\t.filter (|\u0026 (hall, _)| hall != from)\n\t\t\t.all (|(_, amph)| amph.is_none ());\n\tlet room_entrance = |room: Amph| Place::for_idx (2 + room.idx () * 2);\n\tfor (idx, amph) in state.hall ().iter ().enumerate ()\n\t\t\t.filter_map (|(idx, amph)| amph.map (|amph| (idx, amph))) {\n\t\tlet to_room = amph;\n\t\tlet hall = Place::for_idx (idx);\n\t\tif ! state.room_is_happy (to_room) { continue }\n\t\tif ! path_clear (hall, room_entrance (to_room)) { continue }\n\t\tresult.clear ();\n\t\tresult.push (Move::In (amph, hall, to_room));\n\t\treturn result;\n\t}\n\tfor (from_room, amphs) in [\n\t\t(Amber, state.room (Amber)),\n\t\t(Bronze, state.room (Bronze)),\n\t\t(Copper, state.room (Copper)),\n\t\t(Desert, state.room (Desert)),\n\t] {\n\t\tif let Some (\u0026 amph) = amphs.last () {\n\t\t\tlet to_room = amph;\n\t\t\tif state.room_is_happy (from_room) { continue }\n\t\t\tif state.room_is_happy (to_room) {\n\t\t\t\tif ! path_clear (room_entrance (from_room), room_entrance (to_room)) { continue }\n\t\t\t\tresult.clear ();\n\t\t\t\tresult.push (Move::Between (amph, from_room, to_room));\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tfor hall in\n\t\t\t\titer::successors (\n\t\t\t\t\t\tSome (room_entrance (from_room)),\n\t\t\t\t\t\t|prev_hall| (prev_hall.idx () \u003e 0).then (||\n\t\t\t\t\t\t\tPlace::for_idx (prev_hall.idx () - 1)))\n\t\t\t\t\t.take_while (|\u0026 hall| state.get (hall).is_none ())\n\t\t\t\t\t.chain (\n\t\t\t\t\t\titer::successors (\n\t\t\t\t\t\t\t\tSome (room_entrance (from_room)),\n\t\t\t\t\t\t\t\t|prev_hall| (prev_hall.idx () + 1 \u003c 11).then_some (\n\t\t\t\t\t\t\t\t\tPlace::for_idx (prev_hall.idx () + 1)))\n\t\t\t\t\t\t\t.take_while (|\u0026 hall| state.get (hall).is_none ()))\n\t\t\t\t\t.filter (|hall| ! hall.entrance ()) {\n\t\t\t\tif ! path_clear (room_entrance (from_room), hall) { continue }\n\t\t\t\tresult.push (Move::Out (amph, from_room, hall));\n\t\t\t}\n\t\t}\n\t}\n\tresult\n}\n\nfn check_input (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\tlet (num_amber, num_bronze, num_copper, num_desert) =\n\t\tinput.amphs.iter ().flatten ()\n\t\t\t.fold ((0_u32, 0_u32, 0_u32, 0_u32), |(amber, bronze, copper, desert), \u0026 amph|\n\t\t\t\tmatch amph {\n\t\t\t\t\tAmber =\u003e (amber + 1, bronze, copper, desert),\n\t\t\t\t\tBronze =\u003e (amber, bronze + 1, copper, desert),\n\t\t\t\t\tCopper =\u003e (amber, bronze, copper + 1, desert),\n\t\t\t\t\tDesert =\u003e (amber, bronze, copper, desert + 1),\n\t\t\t\t});\n\tif num_amber != 2 || num_bronze != 2 || num_copper != 2 || num_desert != 2 {\n\t\treturn Err (\"Must have exactly two each of amber, bronze, copper, desert\".into ());\n\t}\n\tOk (())\n}\n","traces":[{"line":11,"address":[115152],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":12,"address":[115251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[70017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":[70022],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[115360],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":18,"address":[70330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[115496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[70390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[115744,115568],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":25,"address":[115662,115581],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[67022],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[116206,115760],"length":1,"stats":{"Line":2},"fn_name":"iterator"},{"line":35,"address":[116224,116754],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":36,"address":[116405,116257,116739],"length":1,"stats":{"Line":4},"fn_name":null},{"line":37,"address":[116416,116623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[115917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[116768,119122],"length":1,"stats":{"Line":2},"fn_name":"calc_next_states"},{"line":49,"address":[116795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[117415,117815],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[117907,118162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[117439,117923],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[116811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[116829],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[116839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[117018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[116879,116923],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[116895,116955],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[117010,116994],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[117014,117007],"length":1,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[117152],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[117165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[117193,117183],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[118215,118171,118290],"length":1,"stats":{"Line":6},"fn_name":null},{"line":85,"address":[118206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[118311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[118327],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[117088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[117095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[118036,117958],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[118047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[118074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[117280,117342],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[117346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[117356],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[117538,117470],"length":1,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[117556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[117576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[117759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[120658,119136],"length":1,"stats":{"Line":2},"fn_name":"calc_next_moves"},{"line":122,"address":[119169,120672],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":123,"address":[120692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[120699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[120769,120733,120989],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[108972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[102531],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[121120,120976,121130],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":129,"address":[119861,119829,120170,119334,119811],"length":1,"stats":{"Line":9},"fn_name":null},{"line":130,"address":[119265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[67123,62832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[119293],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[119303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[119339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[119431,119385],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[119708,119511,120625],"length":1,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[119745],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[119763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[119791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[119834],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[120405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[120160,119883],"length":1,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[67690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[67873,67702],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[67749],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[67553,67354,67397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[67373,67569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[67425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[120178],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[120199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[120303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[121472],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[114414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[114433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[114454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[114474],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[114495,114517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[115403,121511,115195],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[115435,121546,115227],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":84,"coverable":87},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","model.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Amph::{ Amber, Bronze, Copper, Desert };\nuse model::Place::{ Hall, Room };\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct State {\n\troom_size: usize,\n\thall: ArrayVec \u003cOption \u003cAmph\u003e, 11\u003e,\n\tamber: ArrayVec \u003cAmph, 4\u003e,\n\tbronze: ArrayVec \u003cAmph, 4\u003e,\n\tcopper: ArrayVec \u003cAmph, 4\u003e,\n\tdesert: ArrayVec \u003cAmph, 4\u003e,\n}\n\nimpl State {\n\n\t#[ must_use ]\n\tpub fn new_part_one (input: \u0026 Input) -\u003e Self {\n\t\tSelf {\n\t\t\troom_size: 2,\n\t\t\thall: array_vec! [None; 11],\n\t\t\tamber: array_vec! [ input.amphs [0] [1], input.amphs [0] [0] ],\n\t\t\tbronze: array_vec! [ input.amphs [1] [1], input.amphs [1] [0] ],\n\t\t\tcopper: array_vec! [ input.amphs [2] [1], input.amphs [2] [0] ],\n\t\t\tdesert: array_vec! [ input.amphs [3] [1], input.amphs [3] [0] ],\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn new_part_two (input: \u0026 Input) -\u003e Self {\n\t\tSelf {\n\t\t\troom_size: 4,\n\t\t\thall: array_vec! [None; 11],\n\t\t\tamber: array_vec! [ input.amphs [0] [1], Desert, Desert, input.amphs [0] [0] ],\n\t\t\tbronze: array_vec! [ input.amphs [1] [1], Bronze, Copper, input.amphs [1] [0] ],\n\t\t\tcopper: array_vec! [ input.amphs [2] [1], Amber, Bronze, input.amphs [2] [0] ],\n\t\t\tdesert: array_vec! [ input.amphs [3] [1], Copper, Amber, input.amphs [3] [0] ],\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn from_array (room_size: usize, places: [Option \u003cAmph\u003e; 27]) -\u003e Self {\n\t\tlet mut state = Self {\n\t\t\troom_size,\n\t\t\thall: ArrayVec::new (),\n\t\t\tamber: ArrayVec::new (),\n\t\t\tbronze: ArrayVec::new (),\n\t\t\tcopper: ArrayVec::new (),\n\t\t\tdesert: ArrayVec::new (),\n\t\t};\n\t\tstate.hall = places [0 .. 11].iter ().copied ().collect ();\n\t\tfor room in Amph::VARIANTS.iter ().copied () {\n\t\t\tstate.room_mut (room).extend (\n\t\t\t\tplaces [11 + room.idx () * 4 .. ].iter ().copied ().take (room_size).rev ()\n\t\t\t\t\t.while_some ());\n\t\t}\n\t\tstate\n\t}\n\n\t#[ must_use ]\n\tpub fn as_array (\u0026 self) -\u003e [Option \u003cAmph\u003e; 27] {\n\t\tlet mut result = [None; 27];\n\t\tfor (result, \u0026 hall) in result.iter_mut ().zip (\u0026 self.hall) {\n\t\t\t* result = hall;\n\t\t}\n\t\tfor (idx, amph) in self.amber.iter ().copied ().enumerate () {\n\t\t\tresult [11 + self.room_size - idx - 1] = Some (amph);\n\t\t}\n\t\tfor (idx, amph) in self.bronze.iter ().copied ().enumerate () {\n\t\t\tresult [15 + self.room_size - idx - 1] = Some (amph);\n\t\t}\n\t\tfor (idx, amph) in self.copper.iter ().copied ().enumerate () {\n\t\t\tresult [19 + self.room_size - idx - 1] = Some (amph);\n\t\t}\n\t\tfor (idx, amph) in self.desert.iter ().copied ().enumerate () {\n\t\t\tresult [23 + self.room_size - idx - 1] = Some (amph);\n\t\t}\n\t\tresult\n\t}\n\n\t#[ must_use ]\n\tpub const fn room_size (\u0026 self) -\u003e usize {\n\t\tself.room_size\n\t}\n\n\t#[ must_use ]\n\tpub fn get (\u0026 self, place: Place) -\u003e Option \u003cAmph\u003e {\n\t\tmatch place {\n\t\t\tHall (id) =\u003e self.hall [id.pan_usize ()],\n\t\t\tRoom (Amber, depth) =\u003e\n\t\t\t\tself.amber.get (self.room_size - depth.pan_usize () - 1).copied (),\n\t\t\tRoom (Bronze, depth) =\u003e\n\t\t\t\tself.bronze.get (self.room_size - depth.pan_usize () - 1).copied (),\n\t\t\tRoom (Copper, depth) =\u003e\n\t\t\t\tself.copper.get (self.room_size - depth.pan_usize () - 1).copied (),\n\t\t\tRoom (Desert, depth) =\u003e\n\t\t\t\tself.desert.get (self.room_size - depth.pan_usize () - 1).copied (),\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn hall (\u0026 self) -\u003e \u0026 [Option \u003cAmph\u003e] {\n\t\t\u0026 self.hall\n\t}\n\n\t#[ must_use ]\n\tpub fn room (\u0026 self, amph: Amph) -\u003e \u0026 [Amph] {\n\t\tmatch amph {\n\t\t\tAmber =\u003e \u0026 self.amber,\n\t\t\tBronze =\u003e \u0026 self.bronze,\n\t\t\tCopper =\u003e \u0026 self.copper,\n\t\t\tDesert =\u003e \u0026 self.desert,\n\t\t}\n\t}\n\n\tfn room_mut (\u0026 mut self, amph: Amph) -\u003e \u0026 mut ArrayVec \u003cAmph, 4\u003e {\n\t\tmatch amph {\n\t\t\tAmber =\u003e \u0026 mut self.amber,\n\t\t\tBronze =\u003e \u0026 mut self.bronze,\n\t\t\tCopper =\u003e \u0026 mut self.copper,\n\t\t\tDesert =\u003e \u0026 mut self.desert,\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn is_finished (\u0026 self) -\u003e bool {\n\t\tself.hall.iter ().all (Option::is_none)\n\t\t\t\u0026\u0026 self.amber.iter ().all (|\u0026 amph| amph == Amber)\n\t\t\t\u0026\u0026 self.bronze.iter ().all (|\u0026 amph| amph == Bronze)\n\t\t\t\u0026\u0026 self.copper.iter ().all (|\u0026 amph| amph == Copper)\n\t\t\t\u0026\u0026 self.desert.iter ().all (|\u0026 amph| amph == Desert)\n\t}\n\n\t#[ must_use ]\n\tpub fn room_is_happy (\u0026 self, room: Amph) -\u003e bool {\n\t\tself.room (room).iter ().copied ().all (|amph| amph == room)\n\t}\n\n\t#[ must_use ]\n\tpub fn move_out (\u0026 self, room: Amph, hall: Place) -\u003e Self {\n\t\tlet mut state = self.clone ();\n\t\tlet amph = state.room_mut (room).pop ().unwrap ();\n\t\tassert! (state.get (hall).is_none ());\n\t\tstate.hall [hall.idx ()] = Some (amph);\n\t\tstate\n\t}\n\n\t#[ must_use ]\n\tpub fn move_in (\u0026 self, hall: Place, room: Amph) -\u003e Self {\n\t\tlet mut state = self.clone ();\n\t\tlet amph = state.hall [hall.idx ()].take ().unwrap ();\n\t\tstate.room_mut (room).push (amph);\n\t\tstate\n\t}\n\n\t#[ must_use ]\n\tpub fn move_between (\u0026 self, from: Amph, to: Amph) -\u003e Self {\n\t\tlet mut state = self.clone ();\n\t\tlet amph = state.room_mut (from).pop ().unwrap ();\n\t\tlet to = match to {\n\t\t\tAmber =\u003e \u0026 mut state.amber,\n\t\t\tBronze =\u003e \u0026 mut state.bronze,\n\t\t\tCopper =\u003e \u0026 mut state.copper,\n\t\t\tDesert =\u003e \u0026 mut state.desert,\n\t\t};\n\t\tassert! (to.len () \u003c self.room_size);\n\t\tto.push (amph);\n\t\tstate\n\t}\n\n\t#[ must_use ]\n\tpub fn pretty_line (\u0026 self, line: usize) -\u003e String {\n\t\tlet print_amph = |amph: Option \u003cAmph\u003e| amph.map_or (' ', Amph::letter);\n\t\tif line == 0 {\n\t\t\t\"\".to_owned ()\n\t\t} else if line == 1 {\n\t\t\tformat! (\"{}\",\n\t\t\t\tself.hall.iter ().copied ().map (print_amph).collect::\u003cString\u003e ())\n\t\t} else if line == 2 {\n\t\t\tformat! (\"{}{}{}{}\",\n\t\t\t\tprint_amph (self.get (Room (Amber, 0))),\n\t\t\t\tprint_amph (self.get (Room (Bronze, 0))),\n\t\t\t\tprint_amph (self.get (Room (Copper, 0))),\n\t\t\t\tprint_amph (self.get (Room (Desert, 0))))\n\t\t} else if line \u003c self.room_size.pan_usize () + 2 {\n\t\t\tlet depth = (line - 2).pan_u8 ();\n\t\t\tformat! (\"  {}{}{}{}\",\n\t\t\t\tprint_amph (self.get (Room (Amber, depth))),\n\t\t\t\tprint_amph (self.get (Room (Bronze, depth))),\n\t\t\t\tprint_amph (self.get (Room (Copper, depth))),\n\t\t\t\tprint_amph (self.get (Room (Desert, depth))))\n\t\t} else if line == self.room_size.pan_usize () + 2 {\n\t\t\t\"  \".to_owned ()\n\t\t} else {\n\t\t\tpanic! ();\n\t\t}\n\t}\n\n\t#[ allow (clippy::print_stdout) ]\n\tpub fn print (\u0026 self) {\n\t\tfor line in 0 .. self.room_size.pan_usize () + 3 {\n\t\t\tprintln! (\"{}\", self.pretty_line (line));\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn compact (\u0026 self) -\u003e StateCompact {\n\t\tlet mut place_bits: u64 = 0;\n\t\tlet mut amph_bits: u64 = 0;\n\t\tfor amph in self.as_array () {\n\t\t\tplace_bits \u003c\u003c= 1_u64;\n\t\t\tif let Some (amph) = amph {\n\t\t\t\tplace_bits |= 1;\n\t\t\t\tamph_bits \u003c\u003c= 2_i32;\n\t\t\t\tamph_bits |= match amph {\n\t\t\t\t\tAmber =\u003e 0,\n\t\t\t\t\tBronze =\u003e 1,\n\t\t\t\t\tCopper =\u003e 2,\n\t\t\t\t\tDesert =\u003e 3,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert! (64 - place_bits.leading_zeros () \u003c= 27);\n\t\tassert! (64 - amph_bits.leading_zeros () \u003c= 32);\n\t\tlet data = ((self.room_size.pan_u64 ()) \u003c\u003c 59_i32) | (place_bits \u003c\u003c 32_i32) | amph_bits;\n\t\tStateCompact { data }\n\t}\n\n}\n\nimpl Display for State {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor amph in self.hall.iter ().copied () {\n\t\t\twrite! (formatter, \"{}\", amph.map_or ('.', Amph::letter)) ?;\n\t\t}\n\t\tfor room in [\u0026 self.amber, \u0026 self.bronze, \u0026 self.copper, \u0026 self.desert] {\n\t\t\twrite! (formatter, \"/\") ?;\n\t\t\tfor amph in iter::repeat (None).take (self.room_size - room.len ())\n\t\t\t\t\t.chain (room.iter ().copied ().rev ().map (Some)) {\n\t\t\t\twrite! (formatter, \"{}\", amph.map_or ('.', Amph::letter)) ?;\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl FromStr for State {\n\n\ttype Err = ();\n\n\tfn from_str (input: \u0026 str) -\u003e Result \u003cSelf, ()\u003e {\n\t\tlet num_chars = input.chars ().count ();\n\t\tif ! [23, 27, 31].contains (\u0026 num_chars) { return Err (()) }\n\t\tlet room_size = (num_chars - 11) / 5;\n\t\tlet mut places = [None; 27];\n\t\tlet mut place_idx = 0;\n\t\tfor (char_idx, letter) in input.chars ().enumerate () {\n\t\t\tif 11 \u003c= char_idx \u0026\u0026 (char_idx - 11) % (room_size + 1) == 0 {\n\t\t\t\tif letter != '/' { return Err (()) }\n\t\t\t\tif 11 \u003c char_idx { place_idx += 4 - room_size; }\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tplaces [place_idx] = match Amph::from_letter (letter) {\n\t\t\t\tSome (amph) =\u003e amph,\n\t\t\t\tNone =\u003e return Err (()),\n\t\t\t};\n\t\t\tplace_idx += 1;\n\t\t}\n\t\tOk (Self::from_array (room_size, places))\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct StateCompact {\n\tdata: u64,\n}\n\nimpl StateCompact {\n\n\t#[ must_use ]\n\tpub fn expand (self) -\u003e State {\n\t\tlet mut present_bits = (self.data \u0026 0x_07ff_ffff_0000_0000) \u003e\u003e 32_i32;\n\t\tlet mut amph_bits = self.data \u0026 0x_0000_0000_ffff_ffff;\n\t\tlet mut places = [None; 27];\n\t\tfor place_idx in (0 .. 27).rev () {\n\t\t\tif present_bits \u0026 1 != 0 {\n\t\t\t\tmatch amph_bits \u0026 0x3 {\n\t\t\t\t\t0 =\u003e places [place_idx] = Some (Amber),\n\t\t\t\t\t1 =\u003e places [place_idx] = Some (Bronze),\n\t\t\t\t\t2 =\u003e places [place_idx] = Some (Copper),\n\t\t\t\t\t3 =\u003e places [place_idx] = Some (Desert),\n\t\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t\t}\n\t\t\t\tamph_bits \u003e\u003e= 2_i32;\n\t\t\t}\n\t\t\tpresent_bits \u003e\u003e= 1_i32;\n\t\t}\n\t\tlet room_size = (self.data \u003e\u003e 59_i32).pan_usize ();\n\t\tState::from_array (room_size, places)\n\t}\n\n\t#[ must_use ]\n\tpub fn is_finished (self) -\u003e bool {\n\t\tlet mut present_bits = (self.data \u0026 0x_07ff_ffff_0000_0000) \u003e\u003e 32_i32;\n\t\tif present_bits \u0026 0x_07ff_0000 != 0 { return false }\n\t\tlet mut amph_bits = self.data \u0026 0x_0000_0000_ffff_ffff;\n\t\tfor idx in (0 .. 4).rev () {\n\t\t\tfor _ in 0_i32 .. 4_i32 {\n\t\t\t\tif present_bits \u0026 1 != 0 {\n\t\t\t\t\tif amph_bits \u0026 0x3 != idx { return false }\n\t\t\t\t\tamph_bits \u003e\u003e= 2_i32;\n\t\t\t\t}\n\t\t\t\tpresent_bits \u003e\u003e= 1_i32;\n\t\t\t}\n\t\t}\n\t\ttrue\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub enum Place {\n\tHall (u8),\n\tRoom (Amph, u8),\n}\n\nimpl Place {\n\n\t#[ must_use ]\n\tpub fn idx (self) -\u003e usize {\n\t\tmatch self {\n\t\t\tHall (id) =\u003e id.pan_usize (),\n\t\t\tRoom (Amber, depth) =\u003e 11 + depth.pan_usize (),\n\t\t\tRoom (Bronze, depth) =\u003e 15 + depth.pan_usize (),\n\t\t\tRoom (Copper, depth) =\u003e 19 + depth.pan_usize (),\n\t\t\tRoom (Desert, depth) =\u003e 23 + depth.pan_usize (),\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn for_idx (idx: usize) -\u003e Self {\n\t\tmatch idx {\n\t\t\t0 ..= 10 =\u003e Hall (idx.pan_u8 ()),\n\t\t\t11 ..= 14 =\u003e Room (Amber, idx.pan_u8 () - 11),\n\t\t\t15 ..= 18 =\u003e Room (Bronze, idx.pan_u8 () - 15),\n\t\t\t19 ..= 22 =\u003e Room (Copper, idx.pan_u8 () - 19),\n\t\t\t23 ..= 26 =\u003e Room (Desert, idx.pan_u8 () - 23),\n\t\t\t_ =\u003e panic! (\"Invalid index: {}\", idx),\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub fn entrance (self) -\u003e bool {\n\t\t[2, 4, 6, 8].contains (\u0026 self.idx ())\n\t}\n\n}\n\nparse_display_enum! {\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Amph { Amber = \"A\", Bronze = \"B\", Copper = \"C\", Desert = \"D\" }\n}\n\nimpl Amph {\n\n\t#[ allow (clippy::option_option) ]\n\t#[ must_use ]\n\tpub const fn from_letter (letter: char) -\u003e Option \u003cOption \u003cSelf\u003e\u003e {\n\t\tmatch letter {\n\t\t\t'A' =\u003e Some (Some (Amber)),\n\t\t\t'B' =\u003e Some (Some (Bronze)),\n\t\t\t'C' =\u003e Some (Some (Copper)),\n\t\t\t'D' =\u003e Some (Some (Desert)),\n\t\t\t'.' =\u003e Some (None),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n\t#[ must_use ]\n\tpub const fn cost (self) -\u003e i64 {\n\t\tSelf::COSTS [self.idx ()]\n\t}\n\n\t#[ must_use ]\n\tpub const fn letter (self) -\u003e char {\n\t\tSelf::LETTERS [self.idx ()]\n\t}\n\n\tconst COSTS: \u0026 'static [i64; 4] = \u0026 [1, 10, 100, 1000];\n\tconst LETTERS: \u0026 'static [char; 4] = \u0026 ['A', 'B', 'C', 'D'];\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn test_state_finished () {\n\t\tassert! (State::from_str (\".........../AA/BB/CC/DD\").unwrap ().is_finished ());\n\t\tassert! (! State::from_str (\"A........../.A/BB/CC/DD\").unwrap ().is_finished ());\n\t}\n\n}\n","traces":[{"line":20,"address":[142592],"length":1,"stats":{"Line":1},"fn_name":"new_part_one"},{"line":24,"address":[142709,142669,142694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[142739,142755,142714],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[142760,142785,142801],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[142847,142831,142806],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[143659,142928],"length":1,"stats":{"Line":1},"fn_name":"new_part_two"},{"line":36,"address":[143611,143005,143037,143072],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[143586,143082,143114,143151],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[143561,143229,143193,143161],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[143536,143239,143307,143271],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[143680,144056],"length":1,"stats":{"Line":2},"fn_name":"from_array"},{"line":53,"address":[143806],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[143890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[144064],"length":1,"stats":{"Line":2},"fn_name":"as_array"},{"line":64,"address":[144081],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[144137,144124,144156],"length":1,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[144143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[144247],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[144841,144252,144747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[144391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[144396,144763,144866],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[144535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[144891,144540,144798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[144675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[144916,144814,144680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[144976],"length":1,"stats":{"Line":0},"fn_name":"room_size"},{"line":85,"address":[117720,117213],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[144992],"length":1,"stats":{"Line":2},"fn_name":"get"},{"line":90,"address":[145005,145088],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[145067,145490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[145511,145114,145169],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[145212,145267,145527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[145310,145365,145543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[145456,145559,145401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[145600],"length":1,"stats":{"Line":0},"fn_name":"hall"},{"line":109,"address":[145616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[117364,117863,117218],"length":1,"stats":{"Line":8},"fn_name":null},{"line":111,"address":[117238,117741,117884],"length":1,"stats":{"Line":5},"fn_name":null},{"line":112,"address":[117808,117894,118154],"length":1,"stats":{"Line":6},"fn_name":null},{"line":113,"address":[118140,117780],"length":1,"stats":{"Line":5},"fn_name":null},{"line":114,"address":[117794,118147],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[146659,146887,146325],"length":1,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[146345,146907,146679],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[146697,146925,146366],"length":1,"stats":{"Line":5},"fn_name":null},{"line":122,"address":[146685,146913,146352],"length":1,"stats":{"Line":5},"fn_name":null},{"line":123,"address":[146691,146919,146359],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[145696],"length":1,"stats":{"Line":1},"fn_name":"is_finished"},{"line":129,"address":[145947,146011,145787,145867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[59216,59222],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":131,"address":[59238,59232],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":132,"address":[59254,59248],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":133,"address":[59270,59264],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":137,"address":[146096],"length":1,"stats":{"Line":2},"fn_name":"room_is_happy"},{"line":138,"address":[125200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[146593,146304],"length":1,"stats":{"Line":2},"fn_name":"move_out"},{"line":143,"address":[146320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[146416,146429],"length":1,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[146436,146466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[146851,146608],"length":1,"stats":{"Line":2},"fn_name":"move_in"},{"line":152,"address":[146623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[146739,146632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[147199,146864],"length":1,"stats":{"Line":2},"fn_name":"move_between"},{"line":160,"address":[146882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[146972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[146992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[147010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[146998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[147004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[147016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[148782,147216],"length":1,"stats":{"Line":0},"fn_name":"pretty_line"},{"line":175,"address":[59296,59350],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":176,"address":[147239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[147462,147368,148747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[147808,147894,148070,147988],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[147799,147285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[147885,147824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[147979,147908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[148000,148061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[147525,148642,147473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[148658,147540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[148174,148446,148362,148262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[148165,147608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[148190,148252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[148353,148281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[148374,148436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[147664,147716,148685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[148712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[148800,149267],"length":1,"stats":{"Line":2},"fn_name":"compact"},{"line":212,"address":[148934,148822,149252],"length":1,"stats":{"Line":4},"fn_name":null},{"line":214,"address":[148951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[149190,149147,149008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[149050,149163,149217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[149063,149118],"length":1,"stats":{"Line":4},"fn_name":null},{"line":253,"address":[149280],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":255,"address":[149430],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[149949,149436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[149469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[149503,149728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[149751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[149796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[149801,149965],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[149848,149926],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[149862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[149591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[150016],"length":1,"stats":{"Line":2},"fn_name":"expand"},{"line":285,"address":[150110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[150107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[150038],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[150165,150055],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[150175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[150180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[150195,150366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[150144,150357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[150211,150375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[150224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[150158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[150162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[150242],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[150301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[150416],"length":1,"stats":{"Line":2},"fn_name":"is_finished"},{"line":308,"address":[150426],"length":1,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[150434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[150683,150583,150727,150558,150516,150496,150456,150537,150708,150608,150476,150658,150746,150633,150436,150765],"length":1,"stats":{"Line":17},"fn_name":null},{"line":313,"address":[150443,150503,150590,150665,150753,150734,150544,150615,150565,150640,150463,150715,150483,150523,150690],"length":1,"stats":{"Line":15},"fn_name":null},{"line":314,"address":[150679,150742,150472,150554,150492,150512,150629,150579,150452,150533,150654,150704,150761,150604,150723],"length":1,"stats":{"Line":15},"fn_name":null},{"line":333,"address":[150784],"length":1,"stats":{"Line":2},"fn_name":"idx"},{"line":334,"address":[150849,150790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[150923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[151004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[151085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[151159,151167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[151200],"length":1,"stats":{"Line":2},"fn_name":"for_idx"},{"line":346,"address":[151208],"length":1,"stats":{"Line":2},"fn_name":null},{"line":347,"address":[151339,151592,151278],"length":1,"stats":{"Line":4},"fn_name":null},{"line":348,"address":[151608,151354,151415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[151624,151432,151493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[151503,151568,151640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[151670,151735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[151760],"length":1,"stats":{"Line":0},"fn_name":"entrance"},{"line":357,"address":[114681,114569],"length":1,"stats":{"Line":4},"fn_name":null},{"line":363,"address":[104864,102561],"length":1,"stats":{"Line":8},"fn_name":null},{"line":372,"address":[149775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[151856],"length":1,"stats":{"Line":0},"fn_name":"cost"},{"line":384,"address":[151860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[151872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[59340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[56000,56004],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":404,"address":[100476,100360,100154,100074,99992],"length":1,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[100162,100244,100324,100426],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":106,"coverable":149},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","tools.rs"],"content":"use super::*;\n\nuse std::path::PathBuf;\n\nuse input::Input;\nuse model::State;\nuse model::StateCompact;\nuse search::PrioritySearch;\nuse search::PrioritySearchAdder;\n\n#[ derive (Debug, clap::Parser) ]\n#[ allow (clippy::struct_excessive_bools) ]\npub struct RunArgs {\n\n\t#[ clap (from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n\n\t#[ clap (long) ]\n\tverbose: bool,\n\n\t#[ clap (long) ]\n\tdead_ends: bool,\n\n\t#[ clap (long) ]\n\tpart_1: bool,\n\n\t#[ clap (long) ]\n\tpart_2: bool,\n\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\npub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\tlet mut args = args;\n\tif ! (args.part_1 || args.part_2) { args.part_1 = true; args.part_2 = true; }\n\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\tlet input_lines: Vec \u003c_\u003e = input_string.trim ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tif args.part_1 {\n\t\trun_part (\u0026 args, State::new_part_one (\u0026 input)) ?;\n\t}\n\tif args.part_2 {\n\t\trun_part (\u0026 args, State::new_part_two (\u0026 input)) ?;\n\t}\n\tOk (())\n}\n\n#[ allow (clippy::print_stdout) ]\npub fn run_part (args: \u0026 RunArgs, initial_state: State) -\u003e GenResult \u003c()\u003e {\n\tlet mut num_loops = 0_i32;\n\tlet mut last_cost = -1_i64;\n\tlet mut prev_states: HashMap \u003cStateCompact, StateCompact\u003e = HashMap::new ();\n\tlet mut search = PrioritySearch::with_hash_map (\n\t\t|state_compact, score, mut adder: PrioritySearchAdder \u003c_, _, _\u003e| {\n\t\t\tlet next_states_compact = logic::calc_next_states (state_compact);\n\t\t\tfor (next_state_compact, next_cost) in next_states_compact.iter ().copied () {\n\t\t\t\tlet next_score = score + next_cost;\n\t\t\t\tadder.add (next_state_compact, next_score);\n\t\t\t}\n\t\t\t(state_compact, score, next_states_compact)\n\t\t},\n\t);\n\tsearch.push (initial_state.compact (), 0);\n\tlet final_cost = loop {\n\t\tlet (state_compact, cost, next_states_compact) = match search.next () {\n\t\t\tSome (val) =\u003e val,\n\t\t\tNone =\u003e break None,\n\t\t};\n\t\tnum_loops += 1_i32;\n\t\tlet state = state_compact.expand ();\n\t\tif state.is_finished () {\n\t\t\tbreak Some ((state_compact, cost));\n\t\t}\n\t\tif args.verbose {\n\t\t\tlet next_states: Vec \u003c_\u003e =\n\t\t\t\tnext_states_compact.iter ().copied ()\n\t\t\t\t\t.map (|(state_compact, cost)| (state_compact.expand (), cost))\n\t\t\t\t\t.sorted_by_key (|\u0026 (_, cost)| cost)\n\t\t\t\t\t.collect ();\n\t\t\tif cost != last_cost {\n\t\t\t\tprintln! ();\n\t\t\t\tprintln! (\"Evaluating states with cost: {}\", cost);\n\t\t\t\tprintln! (\"Number of iterations: {}\", num_loops);\n\t\t\t\tprintln! (\"Size of backlog: {}\", search.len ());\n\t\t\t}\n\t\t\tprintln! ();\n\t\t\tif next_states.is_empty () \u0026\u0026 args.dead_ends {\n\t\t\t\tlet all_states =\n\t\t\t\t\titer::successors (\n\t\t\t\t\t\t\tSome (state_compact),\n\t\t\t\t\t\t\t|state| prev_states.get (state).copied ())\n\t\t\t\t\t\t.map (StateCompact::expand)\n\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\t\t\tprintln! (\"    Dead end:\");\n\t\t\t\tfor chunk in all_states.chunks (11) {\n\t\t\t\t\tfor line in 0 .. state.room_size () + 3 {\n\t\t\t\t\t\tprint! (\"    \");\n\t\t\t\t\t\tfor (idx, state) in chunk.iter ().enumerate () {\n\t\t\t\t\t\t\tif idx \u003e 0 { print! (\" \"); }\n\t\t\t\t\t\t\tprint! (\"{:13}\", state.pretty_line (line));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprint! (\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprint_next_states (\u0026 state, \u0026 next_states, 100);\n\t\t\t}\n\t\t}\n\t\tfor (next_state_compact, _) in next_states_compact {\n\t\t\tprev_states.insert (next_state_compact, state_compact);\n\t\t}\n\t\tlast_cost = cost;\n\t};\n\tlet (final_state_compact, final_cost) =\n\t\tfinal_cost.ok_or (\"Failed to find a solution\") ?;\n\tlet final_state = final_state_compact.expand ();\n\tlet mut all_states =\n\t\titer::successors (\n\t\t\t\tSome (final_state_compact),\n\t\t\t\t|state| prev_states.get (state).copied ())\n\t\t\t.map (StateCompact::expand)\n\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\tall_states.reverse ();\n\tif args.verbose {\n\t\tprintln! ();\n\t\tprintln! (\" Found solution \");\n\t}\n\tprintln! ();\n\tprintln! (\"Solved with cost: {}\", final_cost);\n\tprintln! (\"Number of steps in solution: {}\", all_states.len () - 1);\n\tprintln! (\"Number of iterations: {}\", num_loops);\n\tprintln! (\"Total states generated: {}\", prev_states.len ());\n\tprintln! ();\n\tfor chunk in all_states.chunks (11) {\n\t\tfor line in 0 .. final_state.room_size () + 3 {\n\t\t\tfor (idx, state) in chunk.iter ().enumerate () {\n\t\t\t\tif idx \u003e 0 { print! (\" \"); }\n\t\t\t\tprint! (\"{:13}\", state.pretty_line (line));\n\t\t\t}\n\t\t\tprint! (\"\\n\");\n\t\t}\n\t}\n\tif args.verbose { println! (); }\n\tOk (())\n}\n\n#[ allow (clippy::print_stdout) ]\nfn print_next_states (\n\tcur_state: \u0026 State,\n\tnext_states: \u0026 [(State, i64)],\n\tterm_lines: u32,\n) {\n\tlet chunk_size = (term_lines - 16) / 14;\n\tif next_states.is_empty () {\n\t\tprintln! (\"{:^13}\", \"START\");\n\t\tfor line in 0 .. cur_state.room_size () + 3 {\n\t\t\tprint! (\"{:13}\", cur_state.pretty_line (line));\n\t\t\tif line == (cur_state.room_size () + 3) / 2 {\n\t\t\t\tprint! (\"   (dead end)\");\n\t\t\t}\n\t\t\tprint! (\"\\n\");\n\t\t}\n\t\treturn;\n\t}\n\tfor (chunk_idx, chunk) in next_states.chunks (chunk_size.pan_usize ()).enumerate () {\n\t\tprint! (\"{:^13}  \", if chunk_idx == 0 { \"START\" } else { \"\" });\n\t\tfor \u0026 (_, ref cost) in chunk.iter () {\n\t\t\tprint! (\" {:^13}\", cost);\n\t\t}\n\t\tprint! (\"\\n\");\n\t\tfor line in 0 .. (cur_state.room_size ().pan_usize () + 3) {\n\t\t\tprint! (\"{:13}  \", if chunk_idx == 0 { cur_state.pretty_line (line) } else { String::new () });\n\t\t\tfor \u0026 (ref next_state, _) in chunk.iter () {\n\t\t\t\tprint! (\" {:13}\", next_state.pretty_line (line));\n\t\t\t}\n\t\t\tprint! (\"\\n\");\n\t\t}\n\t}\n}\n\n#[ derive (Debug, clap::Parser) ]\npub struct InternalsArgs;\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn internals (_args: InternalsArgs) -\u003e GenResult \u003c()\u003e {\n\tprintln! (\"Data structures:\");\n\tfn show_struct \u003cType\u003e () {\n\t\tlet name = std::any::type_name::\u003cType\u003e ();\n\t\tlet size = mem::size_of::\u003cType\u003e ();\n\t\tlet align = mem::align_of::\u003cType\u003e ();\n\t\tprintln! (\" - {} {} bytes (align = {})\", name, size, align);\n\t}\n\tshow_struct::\u003clogic::Move\u003e ();\n\tshow_struct::\u003cmodel::Amph\u003e ();\n\tshow_struct::\u003cmodel::Place\u003e ();\n\tshow_struct::\u003cmodel::State\u003e ();\n\tshow_struct::\u003cmodel::StateCompact\u003e ();\n\tOk (())\n}\n","traces":[{"line":33,"address":[77280,77825],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":34,"address":[77290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[77307],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[77335,77529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[77417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[77484,77581,77452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[77586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[77603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[77658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[77675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[83273,77840],"length":1,"stats":{"Line":0},"fn_name":"run_part"},{"line":50,"address":[77870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[54490,54176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":55,"address":[54210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[54315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[54438,54323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[54381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[78192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[78439,78385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[78423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[78474,82794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[78495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[78511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[78535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[78567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[54512,54528],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":78,"address":[54592],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":80,"address":[78632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[78712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[78726,78814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[78913,78828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[78935,79031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[79111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[79134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[62927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[79286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[79392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[79600,82764,79429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[79697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[79795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[79875,79804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[79889,83109,80019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[79570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[80091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[80231,80122,83130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[80443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[80459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[54944,54784,54789],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":124,"address":[80611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[80700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[80780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[80860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[80957,80874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[81077,80968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[81088,81171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[81284,81185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[81364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[81472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[81506,81680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[81795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[81875,81804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[81889,82019,83060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[81650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[82502,82422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[83296,85316],"length":1,"stats":{"Line":0},"fn_name":"print_next_states"},{"line":153,"address":[85105,83342,83318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[83333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[84578,84664],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[85132,84678,84817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[84933,85268,84838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[84956,85078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[85017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[84811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[83585,83548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[83740,83618,84213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[83784,83810,83921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[83895,83819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[83982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[85046,84187,84045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[84351,84256,85284,84219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[84397,84549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[84512,84422,85300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[84178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[85328],"length":1,"stats":{"Line":0},"fn_name":"internals"},{"line":187,"address":[85401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":90},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","input.rs"],"content":"use super::*;\n\nuse machine::Instr;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub instrs: Vec \u003cInstr\u003e,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { instrs, params } = [ params, @lines instrs ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","lib.rs"],"content":"//! Advent of Code 2021: Day 24: Arithmetic Logic Unit\n//!\n//! [https://adventofcode.com/2021/day/24](https://adventofcode.com/2021/day/24)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n#![ allow (dead_code) ]\n\nuse aoc_common::*;\n\npub mod input;\npub mod logic;\npub mod machine;\npub mod model;\npub mod quick;\npub mod solver;\npub mod tool;\n\npuzzle_info! {\n\tname = \"Arithmetic Logic Unit\";\n\tyear = 2021;\n\tday = 24;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n\tpart_two = |input| logic::part_two (\u0026 input);\n\tcommands = [\n\t\t( name = \"all\"; method = tool::all; ),\n\t\t( name = \"machine\"; method = tool::machine; ),\n\t\t( name = \"solver\"; method = tool::solver; ),\n\t];\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse machine::Instr;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\u0026 input.instrs, true)\n}\n\npub fn part_two (input: \u0026 Input) -\u003e GenResult \u003cString\u003e {\n\tcalc_result (\u0026 input.instrs, false)\n}\n\npub fn calc_result (prog: \u0026 [Instr], reverse: bool) -\u003e GenResult \u003cString\u003e {\n\tlet steps = quick::steps_for (prog) ?;\n\tlet result = quick::iterator (\u0026 steps, reverse).next ().ok_or (\"No solution found\") ?;\n\tOk (model::input_to_str (result))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","machine.rs"],"content":"use super::*;\n\n#[ must_use ]\npub fn machine_input (input: [u8; 14]) -\u003e [i64; 14] {\n\tlet mut result = [0; 14];\n\tfor idx in 0 .. 14 { result [idx] = input [idx].pan_i64 (); }\n\tresult\n}\n\n#[ derive (Clone, Debug, Default, Eq, Hash, PartialEq) ]\npub struct Machine {\n\tpub regs: MachineRegs,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum MachineError {\n\tNoMoreInput,\n\tDivideByZero,\n\tNegativeModulo,\n}\n\nimpl Machine {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new () -\u003e Self {\n\t\tSelf { regs: default () }\n\t}\n\n\tpub fn step (\u0026 mut self, prog: \u0026 [Instr], input: \u0026 [i64]) -\u003e Result \u003cbool, MachineError\u003e {\n\t\tlet instr = match prog.get (self.regs.pc) {\n\t\t\tSome (\u0026 instr) =\u003e instr,\n\t\t\tNone =\u003e return Ok (true),\n\t\t};\n\t\tmatch instr {\n\t\t\tInstr::Inp (dest) =\u003e {\n\t\t\t\tlet val = match input.get (self.regs.ic) {\n\t\t\t\t\tSome (\u0026 val) =\u003e val,\n\t\t\t\t\tNone =\u003e return Err (MachineError::NoMoreInput),\n\t\t\t\t};\n\t\t\t\tself.regs.ic += 1;\n\t\t\t\tself.regs.store (dest, val);\n\t\t\t},\n\t\t\tInstr::Add (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val + src_val);\n\t\t\t},\n\t\t\tInstr::Mul (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val * src_val);\n\t\t\t},\n\t\t\tInstr::Div (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tif src_val == 0 { Err (MachineError::DivideByZero) ? }\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val / src_val);\n\t\t\t},\n\t\t\tInstr::Mod (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tif src_val == 0 { Err (MachineError::DivideByZero) ? }\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val % src_val);\n\t\t\t},\n\t\t\tInstr::Eql (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, i64::from (dst_val == src_val));\n\t\t\t},\n\t\t}\n\t\tself.regs.pc += 1;\n\t\tOk (false)\n\t}\n\n\t#[ allow (dead_code) ]\n\tfn execute (\u0026 mut self, prog: \u0026 [Instr], input: \u0026 [i64]) -\u003e Result \u003c(), MachineError\u003e {\n\t\tloop {\n\t\t\tmatch self.step (prog, input) {\n\t\t\t\tOk (true) =\u003e break,\n\t\t\t\tOk (false) =\u003e continue,\n\t\t\t\tErr (err) =\u003e Err (err) ?,\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, PartialEq) ]\npub struct MachineRegs {\n\tpub w: i64,\n\tpub x: i64,\n\tpub y: i64,\n\tpub z: i64,\n\tpub pc: usize,\n\tpub ic: usize,\n}\n\nimpl MachineRegs {\n\tfn store (\u0026 mut self, reg: Reg, val: i64) {\n\t\tmatch reg {\n\t\t\tReg::W =\u003e self.w = val,\n\t\t\tReg::X =\u003e self.x = val,\n\t\t\tReg::Y =\u003e self.y = val,\n\t\t\tReg::Z =\u003e self.z = val,\n\t\t}\n\t}\n\tconst fn retrieve (\u0026 self, reg: Reg) -\u003e i64 {\n\t\tmatch reg {\n\t\t\tReg::W =\u003e self.w,\n\t\t\tReg::X =\u003e self.x,\n\t\t\tReg::Y =\u003e self.y,\n\t\t\tReg::Z =\u003e self.z,\n\t\t}\n\t}\n\tconst fn retrieve_or_int (\u0026 self, reg_or_int: RegOrInt) -\u003e i64 {\n\t\tmatch reg_or_int {\n\t\t\tRegOrInt::W =\u003e self.w,\n\t\t\tRegOrInt::X =\u003e self.x,\n\t\t\tRegOrInt::Y =\u003e self.y,\n\t\t\tRegOrInt::Z =\u003e self.z,\n\t\t\tRegOrInt::Int (val) =\u003e val,\n\t\t}\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Instr {\n\t\tInp (dst: Reg) = [ \"inp \", dst ],\n\t\tAdd (dst: Reg, src: RegOrInt) = [ \"add \", dst, \" \", src ],\n\t\tMul (dst: Reg, src: RegOrInt) = [ \"mul \", dst, \" \", src ],\n\t\tDiv (dst: Reg, src: RegOrInt) = [ \"div \", dst, \" \", src ],\n\t\tMod (dst: Reg, src: RegOrInt) = [ \"mod \", dst, \" \", src ],\n\t\tEql (dst: Reg, src: RegOrInt) = [ \"eql \", dst, \" \", src ],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Reg {\n\t\tW = [ \"w\" ],\n\t\tX = [ \"x\" ],\n\t\tY = [ \"y\" ],\n\t\tZ = [ \"z\" ],\n\t}\n}\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum RegOrInt {\n\t\tW = [ \"w\" ],\n\t\tX = [ \"x\" ],\n\t\tY = [ \"y\" ],\n\t\tZ = [ \"z\" ],\n\t\tInt (val: i64) = [ val ],\n\t}\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","model.rs"],"content":"use super::*;\n\npub type Input = [u8; 14];\n\n#[ inline ]\n#[ must_use ]\npub fn input_from_str (input_str: \u0026 str) -\u003e Input {\n\tinput_str.chars ()\n\t\t.map (|letter| letter.to_digit (10).unwrap ().pan_u8 ())\n\t\t.array ()\n}\n\n#[ inline ]\n#[ must_use ]\npub fn input_to_str (input: Input) -\u003e String {\n\tinput.into_iter ()\n\t\t.map (|val| char::from_digit (val.pan_u32 (), 10).unwrap ())\n\t\t.collect ()\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","quick.rs"],"content":"//! Quick algorithm found by reverse engineering the input programme.\n//!\n//! # Quick start\n//!\n//! Call [`iterator`] to create an iterator over the valid solutions:\n//!\n//! ```\n//! # use aoc_2021_day_24::*;\n//! # let steps = [quick::Step { random: false, check: 0, increment: 0 }; 14];\n//! for solution in quick::iterator (\u0026 steps, true) {\n//!   println! (\"{:?}\", solution);\n//! }\n//! ```\n//!\n//! # Description\n//!\n//! Looking carefully at the provided programme, it seems to be the same 18 instructions repeated,\n//! once for every input character. There are only three that vary. Here's the template:\n//!\n//! ```text\n//!  1  inp w\n//!  2  mul x 0\n//!  3  add x z\n//!  4  mod x 26\n//!  5  div z (1 or 26)\n//!  6  add x (-16 to 13)\n//!  7  eql x w\n//!  8  eql x 0\n//!  9  mul y 0\n//! 10  add y 25\n//! 11  mul y x\n//! 12  add y 1\n//! 13  mul z y\n//! 14  mul y 0\n//! 15  mul y w\n//! 16  add y (3 to 15)\n//! 17  mul y x\n//! 18  add z y\n//! ```\n//!\n//! So, the registers seem to be used as follows:\n//!\n//!\n//! * `w` --- The current input value. This is loaded in the first instruction and not modified\n//! again.\n//! * `x` --- Temporary value, the value from the previous step is discarded. This is set to `0` if\n//! the input value matches a calculation based on `z` and a parameter which varies for each step,\n//! or to `1` otherwise.\n//! * `y` --- Another temporary value, this is used to calculate values based on `x`, `w` and a\n//! parameter, and then used to update `z`. The value is carefully calculated to not update `z` if\n//! `x` is set to `0`, by setting it to `1` for a multiply or `0` for an add.\n//! * `z` --- An accumulator, which is kept between steps. This starts off at `0` and gets\n//! conditionally multiplied by 26, divided by 26, and added to.\n//!\n//! We can compile the differences in each step into a table of parameters. Since a divide by one\n//! is an identity operation, we reduce the first difference into a boolean, tracking whether we\n//! will divide of not. We will name the other two parameters `check` and `increment`, based on\n//! how they are used. So using the programme I was given as an example, we end up with the\n//! following:\n//!\n//! | Parameter   | 1    | 2    | 3    | 4    | 5    | 6     | 7    | 8     | 9     | 10   | 11   | 12   | 13   | 14    |\n//! |-------------|:----:|:----:|:----:|:----:|:----:|:-----:|:----:|:-----:|:-----:|:----:|:----:|:----:|:----:|:-----:|\n//! | `divide`    |      |      |      |      |      | yes   |      | yes   | yes   |      | yes  | yes  | yes  | yes   |\n//! | `check`     | `10` | `12` | `10` | `12` | `11` | `-16` | `10` | `-11` | `-13` | `13` | `-8` | `-1` | `-4` | `-14` |\n//! | `increment` | `12` | `7`  | `8`  | `8`  | `15` | `12`  | `8`  | `13`  | `3`   | `13` | `3`  | `9`  | `4`  | `13`  |\n//!\n//! And we can descibe the algorithm for each step as code. Here we use `acc` to refer to the\n//! shared state stored in register `z`, and we expect the parameters for each step to be passed in\n//! a struct:\n//!\n//! ```\n//! struct StepParams {\n//!     divide: bool,\n//!     check: i64,\n//!     increment: i64,\n//! }\n//! fn apply_step (params: \u0026 StepParams, acc: \u0026 mut i64, input: i64) {\n//!     if input == * acc % 26 + params.check { // instructions 2-4,6-8\n//!         if params.divide { * acc /= 26; }   // instruction 5\n//!     } else {\n//!         if ! params.divide { * acc *= 26; } // instructions 9-13\n//!         * acc += input + params.increment;  // instructions 14-18\n//!     }\n//! }\n//! ```\n//!\n//! We can either divide `acc` by 26, multiply it by 26 and add something, or just add something.\n//! Furthermore, in seven of our fourteen steps we always multiply, so to get this value down to\n//! zero we are going to have to make sure we divide on all seven of the other steps. The extra\n//! addition from increment will have to be removed as a rounding error from the division - this\n//! presumably is intended to reduce the total number of valid inputs.\n//!\n//! Since we are deciding whether to divide based on a value derived from `acc` and `check`, we\n//! can simply calculate the correct value based on the previous digits. This reduces our problem\n//! from searching 9 (twenty-three trillion) combinations, down to only 9 (five million).\n//! What's more, we will often be able to shortcut the search if there is no matching next digit.\n//!\n//! This leads to the algorithm implemented here. The steps are encoded in the [`Step`] struct,\n//! and the `steps_for` function reads an input programme and identifies the correct parameters\n//! for each step. I inverted the `divide` parameter around and called it [`random`][Step::random]\n//! - this indicates that we should choose a random value for this input value, or in practice try\n//! all possible values. The `iterator` function returns an iterator over all of the valid inputs,\n//! actually 14 nested iterators plus a final call to `map` at the end to check the final sum, and\n//! to convert to match the function signature.\n//!\n//! The actual algorithm is implemented in the [`NextNumIter`] struct. This is an iterator\n//! adapter, which takes an iterator over partial solutions and provides the possible answers with\n//! the next digit included. If this is a `random` step, then this expands every `n`-digit entry\n//! into nine `n+1`-digit entries, one for each valid digit. Otherwise, it will either provide a\n//! single entry with the appropriate next digit, or no entries if the correct next digit is not\n//! in the valid range.\n//!\n//! # Performance\n//!\n//! This shows the time for finding the answers for the puzzle, and for finding all valid codes,\n//! plus the peak memory usage, for each build version.\n//!\n//! | Version | Puzzle    | All        | Memory   |\n//! |:-------:|:---------:|:----------:|:--------:|\n//! | Debug   | 0.56 secs | 2.23 secs  | 2.88 MiB |\n//! | Release | 0.10 secs | 0.39 secs  | 2.20 MiB |\n\nuse super::*;\nuse machine::Instr;\nuse machine::Reg;\nuse machine::RegOrInt;\nuse model::Input;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Step {\n\tpub random: bool,\n\tpub check: i64,\n\tpub increment: i64,\n}\n\nimpl Step {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn new (random: bool, check: i64, increment: i64) -\u003e Self {\n\t\tSelf { random, check, increment }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn solve (self, progress: i64) -\u003e Option \u003cu8\u003e {\n\t\tlet next = progress % 26 + self.check;\n\t\t(1 ..= 9).contains (\u0026 next).then (|| next.pan_u8 ())\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn incr (self, progress: i64, next: u8) -\u003e i64 {\n\t\tif self.random {\n\t\t\tprogress * 26 + next.pan_i64 () + self.increment\n\t\t} else {\n\t\t\tprogress / 26\n\t\t}\n\t}\n\n}\n\npub fn steps_for (prog: \u0026 [Instr]) -\u003e GenResult \u003c[Step; 14]\u003e {\n\tif prog.len () != 14 * 18 { Err (\"Programme is not the right length\") ? }\n\tOk (prog.chunks (18).enumerate ().map (|(chunk_idx, chunk)| {\n\t\tlet err = |line_idx|\n\t\t\tformat! (\"Unable to generate quick steps for programme at line {}\",\n\t\t\t\tchunk_idx * 18 + line_idx + 1).into ();\n\t\tlet expect = |line_idx, val| -\u003e GenResult \u003c()\u003e {\n\t\t\tif chunk [line_idx] == val { Ok (()) } else { Err (err (line_idx)) ? }\n\t\t};\n\t\texpect (0, Instr::Inp (Reg::W)) ?;\n\t\texpect (1, Instr::Mul (Reg::X, RegOrInt::Int (0))) ?;\n\t\texpect (2, Instr::Add (Reg::X, RegOrInt::Z)) ?;\n\t\texpect (3, Instr::Mod (Reg::X, RegOrInt::Int (26))) ?;\n\t\tlet random = if let Instr::Div (Reg::Z, RegOrInt::Int (val)) = chunk [4] {\n\t\t\tif val == 26 { false } else if val == 1 { true } else { return Err (err (4)); }\n\t\t} else { Err (err (4)) ? };\n\t\tlet check = if let Instr::Add (Reg::X, RegOrInt::Int (check)) = chunk [5] {\n\t\t\tcheck\n\t\t} else { Err (err (5)) ? };\n\t\texpect (6, Instr::Eql (Reg::X, RegOrInt::W)) ?;\n\t\texpect (7, Instr::Eql (Reg::X, RegOrInt::Int (0))) ?;\n\t\texpect (8, Instr::Mul (Reg::Y, RegOrInt::Int (0))) ?;\n\t\texpect (9, Instr::Add (Reg::Y, RegOrInt::Int (25))) ?;\n\t\texpect (10, Instr::Mul (Reg::Y, RegOrInt::X)) ?;\n\t\texpect (11, Instr::Add (Reg::Y, RegOrInt::Int (1))) ?;\n\t\texpect (12, Instr::Mul (Reg::Z, RegOrInt::Y)) ?;\n\t\texpect (13, Instr::Mul (Reg::Y, RegOrInt::Int (0))) ?;\n\t\texpect (14, Instr::Add (Reg::Y, RegOrInt::W)) ?;\n\t\tlet increment = if let Instr::Add (Reg::Y, RegOrInt::Int (increment)) = chunk [15] {\n\t\t\tincrement\n\t\t} else { Err (err (15)) ? };\n\t\texpect (16, Instr::Mul (Reg::Y, RegOrInt::X)) ?;\n\t\texpect (17, Instr::Add (Reg::Z, RegOrInt::Y)) ?;\n\t\tOk (Step { random, check, increment })\n\t}).collect::\u003cGenResult \u003cVec \u003cStep\u003e\u003e\u003e () ?.try_into ().unwrap ())\n}\n\npub fn iterator (steps: \u0026 [Step; 14], reverse: bool) -\u003e impl Iterator \u003cItem = Input\u003e + '_ {\n\tNextNumIter::new (steps, reverse).nest ().nest ().nest ().nest ().nest ().nest ().nest ().nest ()\n\t\t.nest ().nest ().nest ().nest ().nest ().filter_map (|(nums, progress)| {\n\t\t\t(progress == 0).then_some ({\n\t\t\t\tlet mut answer = [0; 14];\n\t\t\t\tfor idx in 0 .. 14 { answer [idx] = nums [idx] }\n\t\t\t\tanswer\n\t\t\t})\n\t\t})\n}\n\ntype TempAnswer = (ArrayVec \u003cu8, 14\u003e, i64);\n\npub enum NextNumIter \u003c'stp, Nested\u003e {\n\tOuter {\n\t\tsteps: \u0026 'stp [Step; 14],\n\t\tnested: Nested,\n\t\treverse: bool,\n\t},\n\tInner {\n\t\tsteps: \u0026 'stp [Step; 14],\n\t\tnested: Nested,\n\t\treverse: bool,\n\t\tnums: ArrayVec \u003cu8, 14\u003e,\n\t\tprogress: i64,\n\t\tnext_iter: ops::RangeInclusive \u003cu8\u003e,\n\t},\n\tPoison,\n}\n\nimpl \u003c'stp\u003e NextNumIter \u003c'stp, std::option::IntoIter \u003cTempAnswer\u003e\u003e {\n\tfn new (\n\t\tsteps: \u0026 'stp [Step; 14],\n\t\treverse: bool,\n\t) -\u003e NextNumIter \u003c'stp, std::option::IntoIter \u003cTempAnswer\u003e\u003e {\n\t\tlet a: TempAnswer = (ArrayVec::new (), 0);\n\t\tNextNumIter::Outer { steps, nested: Some (a).into_iter (), reverse }\n\t}\n}\n\nimpl \u003c'stp, Nested: Iterator \u003cItem = TempAnswer\u003e\u003e NextNumIter \u003c'stp, Nested\u003e {\n\tfn nest (self) -\u003e NextNumIter \u003c'stp, Self\u003e {\n\t\tmatch \u0026 self {\n\t\t\t\u0026 NextNumIter::Outer { steps, reverse, .. } =\u003e\n\t\t\t\tNextNumIter::Outer { steps, nested: self, reverse },\n\t\t\t\u0026 NextNumIter::Inner { .. } | \u0026 NextNumIter::Poison =\u003e panic! (),\n\t\t}\n\t}\n}\n\nimpl \u003c'stp, Nested: Iterator \u003cItem = TempAnswer\u003e\u003e Iterator for NextNumIter \u003c'stp, Nested\u003e {\n\ttype Item = TempAnswer;\n\t#[ allow (clippy::reversed_empty_ranges) ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cTempAnswer\u003e {\n\t\tloop { match mem::replace (self, NextNumIter::Poison) {\n\t\t\tNextNumIter::Outer { steps, mut nested, reverse } =\u003e match nested.next () {\n\t\t\t\tSome ((nums, progress)) =\u003e {\n\t\t\t\t\tlet step = steps [nums.len ()];\n\t\t\t\t\tlet next_iter = if step.random {\n\t\t\t\t\t\t1 ..= 9\n\t\t\t\t\t} else if let Some (next) = step.solve (progress) {\n\t\t\t\t\t\tnext ..= next\n\t\t\t\t\t} else {\n\t\t\t\t\t\t10 ..= 9\n\t\t\t\t\t};\n\t\t\t\t\t* self = NextNumIter::Inner { steps, nested, reverse, nums, progress, next_iter };\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tNone =\u003e {\n\t\t\t\t\treturn None;\n\t\t\t\t},\n\t\t\t},\n\t\t\tNextNumIter::Inner { steps, nested, reverse, nums, progress, mut next_iter } =\u003e {\n\t\t\t\tif let Some (next) = if reverse { next_iter.next_back () } else { next_iter.next () } {\n\t\t\t\t\tlet step = steps [nums.len ()];\n\t\t\t\t\tlet mut new_nums = nums.clone ();\n\t\t\t\t\tnew_nums.push (next);\n\t\t\t\t\tlet new_progress = step.incr (progress, next);\n\t\t\t\t\t* self = NextNumIter::Inner { steps, nested, reverse, nums, progress, next_iter };\n\t\t\t\t\treturn Some ((new_nums, new_progress));\n\t\t\t\t}\n\t\t\t\t* self = NextNumIter::Outer { steps, nested, reverse };\n\t\t\t\tcontinue;\n\t\t\t},\n\t\t\tNextNumIter::Poison =\u003e panic! (),\n\t\t} }\n\t}\n}\n","traces":[{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":39},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","solver.rs"],"content":"use super::*;\n\nuse machine::Instr;\nuse machine::MachineError;\nuse machine::Reg;\nuse machine::RegOrInt;\n\n#[ derive (Clone) ]\npub struct Solver {\n\tinner: Rc \u003cSolverInner\u003e,\n\tinner_weak: RcWeak \u003cSolverInner\u003e,\n}\n\nstruct SolverInner {\n\tstate: RefCell \u003cSolverState\u003e,\n}\n\nstruct SolverState {\n\tsymbols: HashMap \u003cRc \u003cstr\u003e, Symbol\u003e,\n\tsymbols_ordered: Vec \u003cSymbol\u003e,\n}\n\n#[ derive (Clone) ]\npub struct Symbol {\n\tinner: Rc \u003cSymbolInner\u003e,\n}\n\nstruct SymbolInner {\n\tsolver_inner: RcWeak \u003cSolverInner\u003e,\n\tname: Rc \u003cstr\u003e,\n\toriginal_value: Option \u003cSymVal\u003e,\n\toriginal_depth: usize,\n\toriginal_len: usize,\n\toriginal_children: ArrayVec \u003cSymbol, 2\u003e,\n\tstate: RefCell \u003cSymbolState\u003e,\n}\n\n#[ derive (Debug) ]\nstruct SymbolState {\n\tvalue: SymVal,\n\tdepth: usize,\n\tlen: usize,\n}\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub enum SymVal {\n\tSymbol (Symbol),\n\tInput (usize),\n\tAdd (Symbol, Symbol),\n\tMultiply (Symbol, Symbol),\n\tDivide (Symbol, Symbol),\n\tModulo (Symbol, Symbol),\n\tIsEqual (Symbol, Symbol),\n\tIsUnequal (Symbol, Symbol),\n\tValue (i64),\n\tError (MachineError),\n}\n\nimpl Solver {\n\n\t#[ allow (clippy::too_many_lines) ]\n\t#[ must_use ]\n\tpub fn from_prog (input: \u0026 [Instr]) -\u003e (Self, Vec \u003c(Rc \u003cstr\u003e, Symbol)\u003e) {\n\t\tstruct Context {\n\t\t\tnamer: VerNamer,\n\t\t\tsolver: Solver,\n\t\t\tliteral_name: Rc \u003cstr\u003e,\n\t\t\treg_w_name: Rc \u003cstr\u003e,\n\t\t\treg_x_name: Rc \u003cstr\u003e,\n\t\t\treg_y_name: Rc \u003cstr\u003e,\n\t\t\treg_z_name: Rc \u003cstr\u003e,\n\t\t\treg_w: Symbol,\n\t\t\treg_x: Symbol,\n\t\t\treg_y: Symbol,\n\t\t\treg_z: Symbol,\n\t\t}\n\t\timpl Context {\n\t\t\tfn get (\u0026 self, reg: Reg) -\u003e Symbol {\n\t\t\t\tmatch reg {\n\t\t\t\t\tReg::W =\u003e self.reg_w.clone (),\n\t\t\t\t\tReg::X =\u003e self.reg_x.clone (),\n\t\t\t\t\tReg::Y =\u003e self.reg_y.clone (),\n\t\t\t\t\tReg::Z =\u003e self.reg_z.clone (),\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn get_val (\u0026 mut self, reg_or_int: RegOrInt) -\u003e Symbol {\n\t\t\t\tmatch reg_or_int {\n\t\t\t\t\tRegOrInt::W =\u003e self.reg_w.clone (),\n\t\t\t\t\tRegOrInt::X =\u003e self.reg_x.clone (),\n\t\t\t\t\tRegOrInt::Y =\u003e self.reg_y.clone (),\n\t\t\t\t\tRegOrInt::Z =\u003e self.reg_z.clone (),\n\t\t\t\t\tRegOrInt::Int (value) =\u003e self.lit (value),\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn set (\u0026 mut self, reg: Reg, value: SymVal) {\n\t\t\t\tlet (reg_name, reg) = match reg {\n\t\t\t\t\tReg::W =\u003e (\u0026 self.reg_w_name, \u0026 mut self.reg_w),\n\t\t\t\t\tReg::X =\u003e (\u0026 self.reg_x_name, \u0026 mut self.reg_x),\n\t\t\t\t\tReg::Y =\u003e (\u0026 self.reg_y_name, \u0026 mut self.reg_y),\n\t\t\t\t\tReg::Z =\u003e (\u0026 self.reg_z_name, \u0026 mut self.reg_z),\n\t\t\t\t};\n\t\t\t\tlet symbol_name = self.namer.define (reg_name);\n\t\t\t\tlet symbol = self.solver.define (symbol_name, value);\n\t\t\t\t* reg = symbol;\n\t\t\t}\n\t\t\tfn lit (\u0026 mut self, value: i64) -\u003e Symbol {\n\t\t\t\tlet symbol_name = self.namer.define (\u0026 self.literal_name);\n\t\t\t\tlet symbol_value = SymVal::Value (value);\n\t\t\t\tself.solver.define (symbol_name, symbol_value)\n\t\t\t}\n\t\t}\n\t\tlet mut ctx = {\n\t\t\tlet mut namer = VerNamer::new ();\n\t\t\tlet solver = Self::new ();\n\t\t\tlet literal_name = \"lit\".into ();\n\t\t\tlet reg_w_name: Rc \u003cstr\u003e = \"w\".into ();\n\t\t\tlet reg_x_name: Rc \u003cstr\u003e = \"x\".into ();\n\t\t\tlet reg_y_name: Rc \u003cstr\u003e = \"y\".into ();\n\t\t\tlet reg_z_name: Rc \u003cstr\u003e = \"z\".into ();\n\t\t\tlet reg_w = solver.define (namer.define (\u0026 reg_w_name), SymVal::Value (0));\n\t\t\tlet reg_x = solver.define (namer.define (\u0026 reg_x_name), SymVal::Value (0));\n\t\t\tlet reg_y = solver.define (namer.define (\u0026 reg_y_name), SymVal::Value (0));\n\t\t\tlet reg_z = solver.define (namer.define (\u0026 reg_z_name), SymVal::Value (0));\n\t\t\tContext {\n\t\t\t\tnamer, solver,\n\t\t\t\tliteral_name, reg_w_name, reg_x_name, reg_y_name, reg_z_name,\n\t\t\t\treg_w, reg_x, reg_y, reg_z,\n\t\t\t}\n\t\t};\n\t\tlet mut input_count = 0;\n\t\tfor instr in input.iter ().copied () {\n\t\t\tmatch instr {\n\t\t\t\tInstr::Inp (dest) =\u003e {\n\t\t\t\t\tctx.set (dest, SymVal::Input (input_count));\n\t\t\t\t\tinput_count += 1;\n\t\t\t\t},\n\t\t\t\tInstr::Add (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Add (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Mul (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Multiply (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Div (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Divide (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Mod (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Modulo (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Eql (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::IsEqual (dest_val, src_val));\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\t(ctx.solver, vec! [\n\t\t\t(ctx.reg_w_name, ctx.reg_w),\n\t\t\t(ctx.reg_x_name, ctx.reg_x),\n\t\t\t(ctx.reg_y_name, ctx.reg_y),\n\t\t\t(ctx.reg_z_name, ctx.reg_z),\n\t\t])\n\t}\n\n\t#[ allow (clippy::todo) ]\n\tpub fn eval (\u0026 self, input: \u0026 [\u0026 [i64]], symbol: \u0026 Symbol) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\t\tself.require_own_symbol (\"eval\", symbol);\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tlet mut seen: HashSet \u003cSymbol\u003e = HashSet::new ();\n\t\tseen.insert (symbol.clone ());\n\t\tlet mut todo: Vec \u003cSymbol\u003e = vec! [ symbol.clone () ];\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.children () {\n\t\t\t\tif seen.insert (child.clone ()) {\n\t\t\t\t\ttodo.push (child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet mut values: HashMap \u003cSymbol, Rc \u003c[i64]\u003e\u003e = HashMap::new ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif ! seen.contains (symbol) { continue }\n\t\t\tlet value = symbol.eval (\u0026 |sym| Rc::clone (\u0026 values [sym]), input) ?;\n\t\t\tlet value = Rc::from (value.as_slice ());\n\t\t\tvalues.insert (symbol.clone (), Rc::clone (\u0026 value));\n\t\t}\n\t\ttodo! ();\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new () -\u003e Self {\n\t\tlet inner = Rc::new (SolverInner {\n\t\t\tstate: RefCell::new (SolverState {\n\t\t\t\tsymbols: HashMap::new (),\n\t\t\t\tsymbols_ordered: Vec::new (),\n\t\t\t}),\n\t\t});\n\t\tlet inner_weak = Rc::downgrade (\u0026 inner);\n\t\tSelf { inner, inner_weak }\n\t}\n\n\t#[ must_use ]\n\tpub fn fork (\u0026 self, symbols: \u0026 mut [\u0026 mut Symbol], input: \u0026 [i64]) -\u003e Self {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tlet mut seen: HashSet \u003cSymbol\u003e = symbols.iter ().map (|a| \u0026 ** a).cloned ().collect ();\n\t\tlet mut todo: Vec \u003cSymbol\u003e = seen.iter ().cloned ().collect ();\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.children () {\n\t\t\t\tif seen.insert (child.clone ()) {\n\t\t\t\t\ttodo.push (child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet mut new_solver = Self::new ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif ! seen.contains (symbol) { continue }\n\t\t\tlet new_value = symbol.value ().migrate (\u0026 mut new_solver, input);\n\t\t\tlet _symbol = new_solver.define (Rc::clone (symbol.name ()), new_value);\n\t\t}\n\t\tfor old_symbol in symbols.iter_mut () {\n\t\t\tlet new_symbol = new_solver.get (old_symbol.name ()).unwrap ();\n\t\t\t** old_symbol = new_symbol;\n\t\t}\n\t\tnew_solver\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn get (\u0026 self, name: \u0026 Rc \u003cstr\u003e) -\u003e Option \u003cSymbol\u003e {\n\t\tlet state = self.inner.state.borrow ();\n\t\tstate.symbols.get (name).cloned ()\n\t}\n\n\t#[ must_use ]\n\tpub fn define (\u0026 self, name: Rc \u003cstr\u003e, value: SymVal) -\u003e Symbol {\n\t\tvalue.children ().iter ().for_each (|child| self.require_own_symbol (\"define\", child));\n\t\tlet mut state = self.inner.state.borrow_mut ();\n\t\tif state.symbols.contains_key (\u0026 name) { panic! () }\n\t\tlet mut value = value;\n\t\tlet mut depth = value.depth ();\n\t\tlet mut len = value.len ();\n\t\tlet mut original_value = None;\n\t\tlet original_depth = value.original_depth ();\n\t\tlet original_len = value.original_len ();\n\t\tlet original_children = value.children ();\n\t\tif let Some (simplified_value) = value.simplify () {\n\t\t\toriginal_value = Some (value);\n\t\t\tvalue = simplified_value;\n\t\t\tdepth = value.depth ();\n\t\t\tlen = value.len ();\n\t\t}\n\t\tlet symbol = Symbol {\n\t\t\tinner: Rc::new (SymbolInner {\n\t\t\t\tsolver_inner: Rc::downgrade (\u0026 self.inner),\n\t\t\t\tname: Rc::clone (\u0026 name),\n\t\t\t\toriginal_value,\n\t\t\t\toriginal_depth,\n\t\t\t\toriginal_len,\n\t\t\t\toriginal_children,\n\t\t\t\tstate: RefCell::new (SymbolState {\n\t\t\t\t\tvalue,\n\t\t\t\t\tdepth,\n\t\t\t\t\tlen,\n\t\t\t\t}),\n\t\t\t}),\n\t\t};\n\t\tstate.symbols.insert (name, symbol.clone ());\n\t\tstate.symbols_ordered.push (symbol.clone ());\n\t\tsymbol\n\t}\n\n\tpub fn dump (\u0026 self, depth: usize, show_original: bool) {\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tlet state = self.inner.state.borrow ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tsymbol.dump (options, show_original, None);\n\t\t}\n\t}\n\n\tfn require_own_symbol (\u0026 self, fn_name: \u0026 str, symbol: \u0026 Symbol) {\n\t\tassert! (\n\t\t\tRcWeak::ptr_eq (\u0026 self.inner_weak, \u0026 symbol.inner.solver_inner),\n\t\t\t\"Tried to call Solver::{} on solver at {:p} with a symbol from solver at {:p}\",\n\t\t\tfn_name,\n\t\t\tRc::as_ptr (\u0026 self.inner),\n\t\t\tRcWeak::as_ptr (\u0026 symbol.inner.solver_inner));\n\t}\n\n\tpub fn dump_symbol (\u0026 self, depth: usize, show_original: bool, symbol: \u0026 Symbol) {\n\t\tself.require_own_symbol (\"dump_symbol\", symbol);\n\t\tlet state = self.inner.state.borrow ();\n\t\tlet counts = symbol.use_counts ();\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tlet count = match counts.get (symbol) {\n\t\t\t\tSome (\u0026 count) =\u003e count,\n\t\t\t\tNone =\u003e continue,\n\t\t\t};\n\t\t\tsymbol.dump (options, show_original, Some (count));\n\t\t}\n\t}\n\n\tpub fn dump_symbol_auto (\u0026 self, symbol: \u0026 Symbol) {\n\t\tself.require_own_symbol (\"dump_symbol_auto\", symbol);\n\t\tlet state = self.inner.state.borrow ();\n\t\tlet counts = symbol.use_counts ();\n\t\tlet break_symbols: HashSet \u003cSymbol\u003e =\n\t\t\tcounts.iter ()\n\t\t\t\t.filter_map (|(symbol, \u0026 count)| (count \u003e 1).then_some (symbol))\n\t\t\t\t.cloned ()\n\t\t\t\t.collect ();\n\t\tlet options = FormatExpandOptions::BreakSymbols (\u0026 break_symbols);\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif counts.get (symbol).map_or (true, |count| * count == 1) { continue }\n\t\t\tsymbol.dump (options, true, None);\n\t\t}\n\t}\n\n}\n\nimpl Symbol {\n\n\tpub fn eval (\n\t\t\u0026 self,\n\t\tlookup: \u0026 dyn Fn (\u0026 Self) -\u003e Rc \u003c[i64]\u003e, input: \u0026 [\u0026 [i64]],\n\t) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.eval (lookup, input)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn name (\u0026 self) -\u003e \u0026 Rc \u003cstr\u003e {\n\t\t\u0026 self.inner.name\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn value (\u0026 self) -\u003e SymVal {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.clone ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn children (\u0026 self) -\u003e ArrayVec \u003cSelf, 2\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.children ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn original_children (\u0026 self) -\u003e ArrayVec \u003cSelf, 2\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_children.clone ()\n\t}\n\n\t#[ allow (clippy::print_stdout) ]\n\tfn dump (\n\t\t\u0026 self,\n\t\toptions: FormatExpandOptions,\n\t\tshow_original: bool,\n\t\tuse_count: Option \u003cusize\u003e,\n\t) {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tprint! (\"{}\", inner.name);\n\t\tif let Some (use_count) = use_count {\n\t\t\tprint! (\" ({})\", use_count);\n\t\t}\n\t\tmatch options {\n\t\t\tFormatExpandOptions::Depth (depth) =\u003e {\n\t\t\t\tif show_original {\n\t\t\t\t\tif let Some (original_value) = inner.original_value.as_ref () {\n\t\t\t\t\t\tprint! (\"  {}\", original_value.expand (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprint! (\"  {}\", state.value);\n\t\t\t\tprint! (\"  {}\", state.value.expand (depth));\n\t\t\t},\n\t\t\tFormatExpandOptions::BreakSymbols (_) =\u003e\n\t\t\t\tprint! (\"  {}\", FormatExpand::SymVal (options, false, \u0026 state.value)),\n\t\t}\n\t\tprint! (\"\\n\");\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn depth (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.depth\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.len\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.len () == 0\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn original_depth (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_depth\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn original_len (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_len\n\t}\n\n\tfn fmt_expand (\n\t\t\u0026 self,\n\t\tformatter: \u0026 mut fmt::Formatter,\n\t\toptions: FormatExpandOptions,\n\t\twrap: bool,\n\t) -\u003e fmt::Result {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tmatch options {\n\t\t\tFormatExpandOptions::Depth (depth) =\u003e {\n\t\t\t\tif depth \u003e 0 {\n\t\t\t\t\tlet options = FormatExpandOptions::Depth (depth - 1);\n\t\t\t\t\twrite! (formatter, \"C{}\", FormatExpand::SymVal (options, wrap, \u0026 state.value)) ?;\n\t\t\t\t} else {\n\t\t\t\t\twrite! (formatter, \"D{}\", inner.name) ?;\n\t\t\t\t}\n\t\t\t},\n\t\t\tFormatExpandOptions::BreakSymbols (break_symbols) =\u003e {\n\t\t\t\tif break_symbols.contains (self) {\n\t\t\t\t\twrite! (formatter, \"A{}\", inner.name) ?;\n\t\t\t\t} else {\n\t\t\t\t\tlet value = inner.original_value.clone ().unwrap_or_else (|| state.value.clone ()).simplified ();\n\t\t\t\t\twrite! (formatter, \"B{}\", FormatExpand::SymVal (options, wrap, \u0026 value)) ?;\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\tOk (())\n\t}\n\n\tfn use_counts (\u0026 self) -\u003e HashMap \u003cSelf, usize\u003e {\n\t\tlet mut counts: HashMap \u003cSelf, usize\u003e = HashMap::new ();\n\t\tcounts.insert (self.clone (), 0);\n\t\tlet mut todo: Vec \u003cSelf\u003e = Vec::new ();\n\t\ttodo.push (self.clone ());\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.original_children () {\n\t\t\t\tlet child_count = counts.entry (child.clone ()).or_insert (0);\n\t\t\t\tif * child_count == 0 {\n\t\t\t\t\ttodo.push (child.clone ());\n\t\t\t\t}\n\t\t\t\t* child_count += 1;\n\t\t\t}\n\t\t}\n\t\tcounts\n\t}\n\n}\n\nimpl fmt::Debug for Symbol {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet inner = self.inner.as_ref ();\n\t\twrite! (formatter, \"Symbol {:?}\", inner.name) ?;\n\t\tOk (())\n\t}\n}\n\nimpl fmt::Display for Symbol {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"{}\",\n\t\t\tFormatExpand::Symbol (\n\t\t\t\tFormatExpandOptions::Depth (formatter.precision ().unwrap_or (0)),\n\t\t\t\tfalse,\n\t\t\t\tself)) ?;\n\t\tOk (())\n\t}\n}\n\nimpl Eq for Symbol {}\n\nimpl Hash for Symbol {\n\tfn hash \u003cHasher: hash::Hasher\u003e (\u0026 self, state: \u0026 mut Hasher) {\n\t\tself.inner.name.hash (state);\n\t}\n}\n\nimpl Ord for Symbol {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tself.inner.name.cmp (\u0026 other.inner.name)\n\t}\n}\n\nimpl PartialEq for Symbol {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool { self.inner.name == other.inner.name }\n}\n\nimpl cmp::PartialOrd for Symbol {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tself.inner.name.partial_cmp (\u0026 other.inner.name)\n\t}\n}\n\nimpl SymVal {\n\n\tfn eval (\n\t\t\u0026 self,\n\t\tlookup: \u0026 dyn Fn (\u0026 Symbol) -\u003e Rc \u003c[i64]\u003e,\n\t\tinput: \u0026 [\u0026 [i64]],\n\t) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\n\t\tfn combine \u003cCombine: Fn (i64, i64) -\u003e i64\u003e (\n\t\t\tleft: \u0026 Rc \u003c[i64]\u003e,\n\t\t\tright: \u0026 Rc \u003c[i64]\u003e,\n\t\t\tcombine: Combine,\n\t\t) -\u003e Vec \u003ci64\u003e {\n\t\t\tlet mut results = HashSet::new ();\n\t\t\tfor left in left.iter ().copied () { for right in right.iter ().copied () {\n\t\t\t\tresults.insert (combine (left, right));\n\t\t\t} }\n\t\t\tlet mut results: Vec \u003ci64\u003e = results.into_iter ().collect ();\n\t\t\tresults.sort_unstable ();\n\t\t\tresults\n\t\t}\n\n\t\tOk (match * self {\n\t\t\tSelf::Symbol (ref arg) =\u003e\n\t\t\t\tlookup (arg).to_vec (),\n\t\t\tSelf::Input (ref arg) =\u003e\n\t\t\t\tinput.get (* arg).copied ().ok_or (MachineError::NoMoreInput) ?.to_vec (),\n\t\t\tSelf::Add (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| a + b),\n\t\t\tSelf::Multiply (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| a * b),\n\t\t\tSelf::Divide (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| a / b),\n\t\t\tSelf::Modulo (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| a % b),\n\t\t\tSelf::IsEqual (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| i64::from (a == b)),\n\t\t\tSelf::IsUnequal (ref left, ref right) =\u003e\n\t\t\t\tcombine (\u0026 lookup (left), \u0026 lookup (right), |a, b| i64::from (a != b)),\n\t\t\tSelf::Value (ref arg) =\u003e\n\t\t\t\tvec! [ * arg ],\n\t\t\tSelf::Error (ref arg) =\u003e\n\t\t\t\tErr (* arg) ?,\n\t\t})\n\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn depth (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ()\n\t\t\t.map (Symbol::depth)\n\t\t\t.max ()\n\t\t\t.unwrap_or (0) + 1\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().fold (1, |len, child| len + child.len ())\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.children ().iter ().next ().is_some ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn original_depth (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ()\n\t\t\t.map (Symbol::original_depth)\n\t\t\t.max ()\n\t\t\t.unwrap_or (0) + 1\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn original_len (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().fold (1, |len, child| len + child.original_len ())\n\t}\n\n\t#[ must_use ]\n\tpub fn children (\u0026 self) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\tfn make \u003cconst CAP: usize\u003e (arg: [\u0026 Symbol; CAP]) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\t\targ.into_iter ().cloned ().collect ()\n\t\t}\n\t\tmatch * self {\n\t\t\tSelf::Symbol (ref arg) =\u003e make ([ arg ]),\n\t\t\tSelf::Input (_) =\u003e make ([ ]),\n\t\t\tSelf::Add (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::Multiply (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::Divide (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::Modulo (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::IsEqual (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::IsUnequal (ref left, ref right) =\u003e make ([ left, right ]),\n\t\t\tSelf::Value (_) =\u003e make ([ ]),\n\t\t\tSelf::Error (_) =\u003e make ([ ]),\n\t\t}\n\t}\n\tfn fmt_expand (\n\t\t\u0026 self,\n\t\tformatter: \u0026 mut fmt::Formatter,\n\t\toptions: FormatExpandOptions,\n\t\twrap: bool,\n\t) -\u003e fmt::Result {\n\t\tlet expand = |symbol, wrap| FormatExpand::Symbol (options, wrap, symbol);\n\t\tlet (open, close) = if wrap { (\"(\", \")\") } else { (\"\", \"\") };\n\t\tmatch * self {\n\t\t\tSelf::Symbol (ref other_symbol) =\u003e\n\t\t\t\twrite! (formatter, \"{}\", expand (other_symbol, wrap)) ?,\n\t\t\tSelf::Input (ref index) =\u003e\n\t\t\t\twrite! (formatter, \"input [{}]\", index) ?,\n\t\t\tSelf::Add (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} + {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::Multiply (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::Divide (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::Modulo (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} mod {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::IsEqual (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} = {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::IsUnequal (ref left, ref right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSelf::Value (ref value) =\u003e\n\t\t\t\twrite! (formatter, \"{}\", value) ?,\n\t\t\tSelf::Error (ref arg) =\u003e\n\t\t\t\twrite! (formatter, \"{:?}\", arg) ?,\n\t\t}\n\t\tOk (())\n\t}\n\tconst fn expand (\u0026 self, depth: usize) -\u003e FormatExpand {\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tFormatExpand::SymVal (options, false, self)\n\t}\n\tfn simplified (\u0026 self) -\u003e Self {\n\t\tself.simplify ().unwrap_or_else (|| self.clone ())\n\t}\n\tfn simplify (\u0026 self) -\u003e Option \u003cSelf\u003e {\n\t\tlet mut value = self;\n\t\tlet mut result = None;\n\t\twhile let Some (temp) = value.simplify_real () {\n\t\t\tresult = Some (temp);\n\t\t\tvalue = result.as_ref ().unwrap ();\n\t\t}\n\t\tresult\n\t}\n\t#[ allow (clippy::todo) ]\n\tfn simplify_real (\u0026 self) -\u003e Option \u003cSelf\u003e {\n\t\tmatch * self {\n\t\t\tSelf::Input (_) =\u003e None,\n\t\t\tSelf::Add (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (ref left_val), \u0026 Self::Value (ref right_val)) =\u003e\n\t\t\t\t\t\tSome (Self::Value (left_val + right_val)),\n\t\t\t\t\t(_, \u0026 Self::Value (0)) =\u003e Some (left_symval),\n\t\t\t\t\t(\u0026 Self::Value (0), _) =\u003e Some (right_symval),\n\t\t\t\t\t(_, _) if left_symval == right_symval =\u003e todo! (),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::Multiply (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (left_val), \u0026 Self::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (Self::Value (left_val * right_val)),\n\t\t\t\t\t(_, \u0026 Self::Value (0)) =\u003e Some (Self::Value (0)),\n\t\t\t\t\t(\u0026 Self::Value (0), _) =\u003e Some (Self::Value (0)),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::Divide (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (left_val), \u0026 Self::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (Self::Value (left_val / right_val)),\n\t\t\t\t\t(_, \u0026 Self::Value (1)) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Value (0)) =\u003e\n\t\t\t\t\t\tSome (Self::Error (MachineError::DivideByZero)),\n\t\t\t\t\t(\u0026 Self::Value (0), _) =\u003e Some (Self::Value (0)),\n\t\t\t\t\t(_, _) if left_symval == right_symval =\u003e todo! (),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t}\n\t\t\tSelf::Modulo (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (left_val), \u0026 Self::Value (right_val)) =\u003e {\n\t\t\t\t\t\tif left_val \u003e= 0 \u0026\u0026 right_val \u003e 0 {\n\t\t\t\t\t\t\tSome (Self::Value (left_val % right_val))\n\t\t\t\t\t\t} else if right_val == 0 {\n\t\t\t\t\t\t\tSome (Self::Error (MachineError::DivideByZero))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSome (Self::Error (MachineError::NegativeModulo))\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(_, \u0026 Self::Value (0)) =\u003e\n\t\t\t\t\t\tSome (Self::Error (MachineError::DivideByZero)),\n\t\t\t\t\t(_, \u0026 Self::Value (right_val)) if right_val \u003c 0 =\u003e\n\t\t\t\t\t\tSome (Self::Error (MachineError::NegativeModulo)),\n\t\t\t\t\t(\u0026 Self::Value (left_val), _) if left_val \u003c 0 =\u003e\n\t\t\t\t\t\tSome (Self::Error (MachineError::NegativeModulo)),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::IsEqual (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::IsEqual (ref inner_left_sym, ref inner_right_sym), \u0026 Self::Value (0)) =\u003e\n\t\t\t\t\t\tSome (Self::IsUnequal (inner_left_sym.clone (), inner_right_sym.clone ())),\n\t\t\t\t\t(\u0026 Self::Value (0), \u0026 Self::IsEqual (ref inner_left_sym, ref inner_right_sym)) =\u003e\n\t\t\t\t\t\tSome (Self::IsUnequal (inner_left_sym.clone (), inner_right_sym.clone ())),\n\t\t\t\t\t(\u0026 Self::IsEqual (_, _), \u0026 Self::Value (1)) =\u003e Some (left_symval),\n\t\t\t\t\t(\u0026 Self::Value (1), \u0026 Self::IsEqual (_, _)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (left_val), \u0026 Self::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (Self::Value (i64::from (left_val == right_val))),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::IsUnequal (ref left_sym, ref right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(\u0026 Self::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, \u0026 Self::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 Self::Value (ref left_val), \u0026 Self::Value (ref right_val)) =\u003e\n\t\t\t\t\t\tSome (Self::Value (i64::from (left_val != right_val))),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSelf::Value (_) =\u003e None,\n\t\t\tSelf::Symbol (_) | Self::Error (_) =\u003e todo! (\"SymVal::{:?}\", self),\n\t\t}\n\t}\n\tfn migrate (\u0026 self, solver: \u0026 mut Solver, input: \u0026 [i64]) -\u003e Self {\n\t\tlet dup = |arg: Symbol| solver.get (arg.name ()).unwrap ();\n\t\tmatch self.clone () {\n\t\t\tSelf::Symbol (arg) =\u003e Self::Symbol (dup (arg)),\n\t\t\tSelf::Input (arg) =\u003e\n\t\t\t\tif let Some (\u0026 val) = input.get (arg) {\n\t\t\t\t\tSelf::Value (val)\n\t\t\t\t} else {\n\t\t\t\t\tSelf::Input (arg)\n\t\t\t\t},\n\t\t\tSelf::Add (left, right) =\u003e Self::Add (dup (left), dup (right)),\n\t\t\tSelf::Multiply (left, right) =\u003e Self::Multiply (dup (left), dup (right)),\n\t\t\tSelf::Divide (left, right) =\u003e Self::Divide (dup (left), dup (right)),\n\t\t\tSelf::Modulo (left, right) =\u003e Self::Modulo (dup (left), dup (right)),\n\t\t\tSelf::IsEqual (left, right) =\u003e Self::IsEqual (dup (left), dup (right)),\n\t\t\tSelf::IsUnequal (left, right) =\u003e Self::IsUnequal (dup (left), dup (right)),\n\t\t\tSelf::Value (arg) =\u003e Self::Value (arg),\n\t\t\tSelf::Error (arg) =\u003e Self::Error (arg),\n\t\t}\n\t}\n}\n\nimpl fmt::Display for SymVal {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet options = FormatExpandOptions::Depth (formatter.precision ().unwrap_or (0));\n\t\twrite! (formatter, \"{}\",\n\t\t\tFormatExpand::SymVal (options, false, self)) ?;\n\t\tOk (())\n\t}\n}\n\nenum FormatExpand \u003c'dat\u003e {\n\tSymbol (FormatExpandOptions \u003c'dat\u003e, bool, \u0026 'dat Symbol),\n\tSymVal (FormatExpandOptions \u003c'dat\u003e, bool, \u0026 'dat SymVal),\n}\n\nimpl \u003c'dat\u003e fmt::Display for FormatExpand \u003c'dat\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tFormatExpand::Symbol (options, wrap, symbol) =\u003e\n\t\t\t\tsymbol.fmt_expand (formatter, options, wrap),\n\t\t\tFormatExpand::SymVal (options, wrap, symbol_value) =\u003e\n\t\t\t\tsymbol_value.fmt_expand (formatter, options, wrap),\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy) ]\nenum FormatExpandOptions \u003c'dat\u003e {\n\tDepth (usize),\n\tBreakSymbols (\u0026 'dat HashSet \u003cSymbol\u003e),\n}\n\nstruct VerNamer {\n\tentries: HashMap \u003cRc \u003cstr\u003e, VerNamerEntry\u003e,\n}\n\nstruct VerNamerEntry {\n\tbase_name: Rc \u003cstr\u003e,\n\tlatest_name: Rc \u003cstr\u003e,\n\tlatest_rev: usize,\n}\n\nimpl VerNamer {\n\n\tfn new () -\u003e Self {\n\t\tSelf {\n\t\t\tentries: HashMap::new (),\n\t\t}\n\t}\n\n\tfn define (\u0026 mut self, base_name: \u0026 Rc \u003cstr\u003e) -\u003e Rc \u003cstr\u003e {\n\t\tlet entry =\n\t\t\tself.entries.entry (Rc::clone (base_name))\n\t\t\t\t.and_modify (|entry| entry.latest_rev += 1)\n\t\t\t\t.or_insert (VerNamerEntry {\n\t\t\t\t\tbase_name: Rc::clone (base_name),\n\t\t\t\t\tlatest_name: Rc::clone (base_name),\n\t\t\t\t\tlatest_rev: 0,\n\t\t\t\t});\n\t\tentry.latest_name = format! (\"{}{}\", entry.base_name, entry.latest_rev).into ();\n\t\tRc::clone (\u0026 entry.latest_name)\n\t}\n\n}\n","traces":[{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[10000],"length":1,"stats":{"Line":0},"fn_name":"children"},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[10010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[10029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[10105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[10166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[10227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[10288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[10349],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[10407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":820,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":79},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","tool.rs"],"content":"use super::*;\n\nuse std::path::PathBuf;\n\nuse input::Input;\nuse machine::Machine;\nuse machine::MachineRegs;\nuse solver::Solver;\n\n#[ derive (clap::Parser) ]\npub struct AllArgs {\n\t#[ clap (long, from_global, value_parser = PathBuf) ]\n\tinput: PathBuf,\n}\n\n#[ allow (clippy::print_stdout) ]\npub fn all (args: AllArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input_string = fs::read_to_string (args.input) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tlet steps = quick::steps_for (\u0026 input.instrs) ?;\n\tquick::iterator (\u0026 steps, false).for_each (\n\t\t|input| println! (\"{}\", model::input_to_str (input)),\n\t);\n\tOk (())\n}\n\n#[ derive (clap::Parser) ]\npub struct MachineArgs { inputs: Vec \u003cString\u003e }\n\n#[ allow (clippy::needless_pass_by_value) ]\n#[ allow (clippy::print_stdout) ]\npub fn machine (args: MachineArgs) -\u003e GenResult \u003c()\u003e {\n\tfn dump_regs (regs: \u0026 MachineRegs) -\u003e String {\n\t\tformat! (\"{:2}  {:10}  {:2}  {:10}\", regs.w, regs.x, regs.y, regs.z)\n\t}\n\tlet mut machines: Vec \u003c(Machine, [i64; 14])\u003e = args.inputs.iter ().map (\n\t\t|input_str| (\n\t\t\tMachine::new (),\n\t\t\tmachine::machine_input (model::input_from_str (input_str)),\n\t\t),\n\t).collect ();\n\tlet input = get_input () ?;\n\tlet prog = \u0026 input.instrs;\n\tlet mut done = false;\n\twhile ! done {\n\t\tif machines [0].0.regs.pc % 18 == 0 {\n\t\t\tprinter (\u0026 machines,\n\t\t\t\t|| print! (\"+-- {:2} ---------+\", machines [0].0.regs.pc / 18),\n\t\t\t\t|_| print! (\"--------------------------------+\"));\n\t\t}\n\t\tprinter (\u0026 machines,\n\t\t\t|| print! (\"| {:2}  {:9} |\", machines [0].0.regs.pc % 18 + 1,\n\t\t\t\tprog.get (machines [0].0.regs.pc)\n\t\t\t\t\t.map_or_else (|| \"(end)\".to_owned (), |instr| format! (\"{}\", instr))),\n\t\t\t|machine| print! (\" {:30} |\", dump_regs (\u0026 machine.regs)));\n\t\tfor \u0026 mut (ref mut machine, ref mut input) in machines.iter_mut () {\n\t\t\tif machine.step (prog, input).map_err (|err| format! (\"{:?}\", err)) ? {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t}\n\tprinter (\u0026 machines,\n\t\t|| print! (\"+---------------+\"),\n\t\t|_| print! (\"--------------------------------+\"));\n\tprinter (\u0026 machines,\n\t\t|| print! (\"|               |\"),\n\t\t|machine| print! (\" {:30} |\", format! (\"Result: {}\", machine.regs.z)));\n\tprinter (\u0026 machines,\n\t\t|| print! (\"+---------------+\"),\n\t\t|_| print! (\"--------------------------------+\"));\n\treturn Ok (());\n\tfn printer \u003c\n\t\tBeforeFn: Fn (),\n\t\tEachFn: Fn (\u0026 Machine),\n\t\u003e (machines: \u0026 [(Machine, [i64; 14])], before_fn: BeforeFn, each_fn: EachFn) {\n\t\tbefore_fn ();\n\t\tfor \u0026 (ref machine, _) in machines.iter () {\n\t\t\teach_fn (machine);\n\t\t}\n\t\tprint! (\"\\n\");\n\t}\n}\n\n#[ derive (clap::Parser) ]\npub struct SolverArgs {\n\targs: Vec \u003cString\u003e,\n}\n\n#[ allow (clippy::needless_pass_by_value) ]\npub fn solver (args: SolverArgs) -\u003e GenResult \u003c()\u003e {\n\tlet input = get_input () ?;\n\tlet (solver, regs) = Solver::from_prog (\u0026 input.instrs);\n\tlet reg_z =\n\t\tregs.into_iter ()\n\t\t\t.filter (|\u0026 (ref name, _)| name.as_ref () == \"z\")\n\t\t\t.map (|(_, reg)| reg)\n\t\t\t.next ()\n\t\t\t.unwrap ();\n\tmatch args.args [0].as_str () {\n\t\t\"solver-full\" =\u003e {\n\t\t\tsolver.dump (3, true);\n\t\t},\n\t\t\"solver-z\" =\u003e {\n\t\t\tsolver.dump_symbol (3, true, \u0026 reg_z);\n\t\t},\n\t\t\"solver-z-auto\" =\u003e {\n\t\t\tsolver.dump_symbol_auto (\u0026 reg_z);\n\t\t},\n\t\t_ =\u003e panic! (),\n\t}\n\tOk (())\n}\n\nfn get_input () -\u003e GenResult \u003cInput\u003e {\n\tlet input_string = fs::read_to_string (\"inputs/day-24\") ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\tlet input = Input::parse_from_lines (\u0026 input_lines) ?;\n\tOk (input)\n}\n","traces":[{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","examples.rs"],"content":"#![ cfg (test) ]\n\nuse super::*;\n\nconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\"v...\u003e\u003e.vv\u003e\",\n\t\".vv\u003e\u003e.vv..\",\n\t\"\u003e\u003e.\u003ev\u003e...v\",\n\t\"\u003e\u003ev\u003e\u003e.\u003e.v.\",\n\t\"v\u003ev.vv.v..\",\n\t\"\u003e.\u003e\u003e..v...\",\n\t\".vv..\u003e.\u003ev.\",\n\t\"v.v..\u003e\u003ev.v\",\n\t\"....v..v.\u003e\",\n];\n\n#[ test ]\nfn part_one () {\n\tlet puzzle = puzzle_metadata ();\n\tassert_eq_ok! (\"58\", puzzle.part_one (EXAMPLE_0));\n}\n","traces":[{"line":18,"address":[32224,32615],"length":1,"stats":{"Line":2},"fn_name":"part_one"},{"line":19,"address":[32234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[32468,32572,32402,32345,32255,32293],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":3,"coverable":3},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","input.rs"],"content":"use super::*;\n\nuse model::Grid;\n\n#[ derive (Clone, Debug) ]\npub struct Input {\n\tpub grid: Grid,\n\tpub params: InputParams,\n}\n\nstruct_parser_display! {\n\tInput { grid, params } = [ params, grid ]\n}\n\ninput_params! {\n\t#[ derive (Clone, Debug) ]\n\tpub struct InputParams {\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","lib.rs"],"content":"//! Advent of Code 2021: Day 25: Sea Cucumber\n//!\n//! [https://adventofcode.com/2021/day/25](https://adventofcode.com/2021/day/25)\n\n#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_bitvec::prelude::*;\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\nuse aoc_pos as pos;\n\nmod examples;\npub mod input;\npub mod logic;\npub mod model;\n\npuzzle_info! {\n\tname = \"Sea Cucumber\";\n\tyear = 2021;\n\tday = 25;\n\tparse = |lines| input::Input::parse_from_lines (lines);\n\tpart_one = |input| logic::part_one (\u0026 input);\n}\n","traces":[{"line":22,"address":[68543],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","logic.rs"],"content":"use super::*;\n\nuse input::Input;\nuse model::Grid;\nuse model::GridInner;\nuse model::Pos;\nuse model::Region;\n\npub fn part_one (input: \u0026 Input) -\u003e GenResult \u003ci64\u003e {\n\tif 160 \u003c input.grid.size ().y || 160 \u003c input.grid.size ().x {\n\t\treturn Err (\"Maximum grid size is 160160\".into ());\n\t}\n\tlet mut count = 0;\n\tlet mut prev_grid = input.grid.clone ();\n\tloop {\n\t\tif count == 500 { return Err (\"Giving up after 500 iterations\".into ()) }\n\t\tlet next_grid = move_both (\u0026 prev_grid);\n\t\tcount += 1;\n\t\tif prev_grid == next_grid { break }\n\t\tprev_grid = next_grid;\n\t}\n\tOk (count)\n}\n\nfn move_both (grid: \u0026 Grid) -\u003e Grid {\n\tlet size = grid.size ();\n\tlet iter_row = |y| iter::empty ()\n\t\t.chain (iter::once (grid.get (Pos { y, x: size.x - 1 }).unwrap ()))\n\t\t.chain (grid.values ()\n\t\t\t.skip (size.x.pan_usize () * y.pan_usize ())\n\t\t\t.take (size.x.pan_usize ()))\n\t\t.chain (iter::once (grid.get (Pos { y, x: 0 }).unwrap ()))\n\t\t.collect::\u003cVec \u003cRegion\u003e\u003e ();\n\tlet data =\n\t\titer::once (iter_row (size.y - 1))\n\t\t\t.chain ((0 .. size.y).map (iter_row))\n\t\t\t.chain (iter::once (iter_row (0)))\n\t\t\t.scan ((Rc::new (Vec::new ()), Rc::new (Vec::new ())),\n\t\t\t\tmove |rows, row| {\n\t\t\t\t\tlet row_0 = Rc::clone (\u0026 rows.0);\n\t\t\t\t\tlet row_1 = Rc::clone (\u0026 rows.1);\n\t\t\t\t\tlet row_2 = Rc::new (row);\n\t\t\t\t\t* rows = (Rc::clone (\u0026 row_1), Rc::clone (\u0026 row_2));\n\t\t\t\t\tif row_0.len () == 0 || row_1.len () == 0 {\n\t\t\t\t\t\treturn Some (Either::Left (iter::empty ()));\n\t\t\t\t\t}\n\t\t\t\t\tSome (Either::Right (\n\t\t\t\t\t\t(0 .. size.x.pan_usize ()).map (move |idx|\n\t\t\t\t\t\t\tcalc_one_region (\n\t\t\t\t\t\t\t\trow_0 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t\trow_1 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t\trow_2 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t))\n\t\t\t\t})\n\t\t\t.flatten ()\n\t\t\t.collect::\u003cGridInner\u003e ();\n\tGrid::wrap_size (data, size)\n}\n\nconst fn calc_one_region (\n\tabove: [Region; 3],\n\tlevel: [Region; 3],\n\tbelow: [Region; 3],\n) -\u003e Region {\n\tuse Region::{ Empty as X, East as E, South as S };\n\t#[ allow (clippy::unnested_or_patterns) ]\n\tmatch (above, level, below) {\n\t\t([_, _, _], [E, X, _], [_, _, _]) =\u003e E,\n\t\t([_, S, _], [_, E, X], [_, _, _])\n\t\t\t| ([_, S, _], [_, X, _], [_, _, _])\n\t\t\t| ([_, _, _], [_, S, _], [E, X, _]) =\u003e S,\n\t\t([_, _, _], [_, E, X], [_, _, _])\n\t\t\t| ([_, _, _], [_, S, _], [_, E, X])\n\t\t\t| ([_, _, _], [_, S, _], [_, X, _]) =\u003e X,\n\t\t([_, _, _], [_, h, _], [_, _, _]) =\u003e h,\n\t}\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tuse model::Region::{ East, South };\n\n\tfn test_sequence \u003cStepFn: Fn (\u0026 Grid) -\u003e Grid\u003e (\n\t\tstep_fn: StepFn,\n\t\tlines: \u0026 [\u0026 [\u0026 str]],\n\t) -\u003e GenResult \u003c()\u003e {\n\t\tlet input = Input::parse_from_lines (lines [0]) ?;\n\t\tlet mut grid = input.grid.clone ();\n\t\tlet count = |grid: \u0026 Grid, region|\n\t\t\tgrid.values ()\n\t\t\t\t.filter (|\u0026 other_region| region == other_region)\n\t\t\t\t.count ();\n\t\tlet num_east = count (\u0026 grid, East);\n\t\tlet num_south = count (\u0026 grid, South);\n\t\tfor expect_lines in lines.iter ().skip (1) {\n\t\t\tlet expect_input = Input::parse_from_lines (expect_lines) ?;\n\t\t\tgrid = step_fn (\u0026 grid);\n\t\t\tassert_eq! (expect_input.grid, grid);\n\t\t\tassert_eq! (num_east, count (\u0026 grid, East));\n\t\t\tassert_eq! (num_south, count (\u0026 grid, South));\n\t\t}\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn test_complex () -\u003e GenResult \u003c()\u003e {\n\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\u0026 [ \"v...\u003e\u003e.vv\u003e\", \".vv\u003e\u003e.vv..\", \"\u003e\u003e.\u003ev\u003e...v\", \"\u003e\u003ev\u003e\u003e.\u003e.v.\", \"v\u003ev.vv.v..\",\n\t\t\t\t\"\u003e.\u003e\u003e..v...\", \".vv..\u003e.\u003ev.\", \"v.v..\u003e\u003ev.v\", \"....v..v.\u003e\" ],\n\t\t\t\u0026 [ \"....\u003e.\u003ev.\u003e\", \"v.v\u003e.\u003ev.v.\", \"\u003ev\u003e\u003e..\u003ev..\", \"\u003e\u003ev\u003ev\u003e.\u003e.v\", \".\u003ev.v...v.\",\n\t\t\t\t\"v\u003e\u003e.\u003evvv..\", \"..v...\u003e\u003e..\", \"vv...\u003e\u003evv.\", \"\u003e.v.v..v.v\" ],\n\t\t])\n\t}\n\n\t#[ test ]\n\tfn test_east () -\u003e GenResult \u003c()\u003e {\n\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\u0026 [\"...\u003e\u003e\u003e\u003e\u003e...\"], \u0026 [\"...\u003e\u003e\u003e\u003e.\u003e..\"], \u0026 [\"...\u003e\u003e\u003e.\u003e.\u003e.\"], \u0026 [\"...\u003e\u003e.\u003e.\u003e.\u003e\"],\n\t\t])\n\t}\n\n\t#[ test ]\n\tfn test_both () -\u003e GenResult \u003c()\u003e {\n\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\u0026 [\"..........\", \".\u003ev....v..\", \".......\u003e..\", \"..........\"],\n\t\t\t\u0026 [\"..........\", \".\u003e........\", \"..v....v\u003e.\", \"..........\"],\n\t\t\t\u0026 [\"..........\", \"..\u003e.......\", \".........\u003e\", \"..v....v..\"],\n\t\t])\n\t}\n\n}\n","traces":[{"line":9,"address":[40048,40593],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":10,"address":[40072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[40434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[40377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[40160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[40296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":20,"address":[40304,40515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[40496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[40608,41577],"length":1,"stats":{"Line":1},"fn_name":"move_both"},{"line":26,"address":[40630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[83520],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":28,"address":[83536,83885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[83901,83714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[83786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[40690,41383,40661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[40698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[41493,40739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[40937,41518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[41037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[84052],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[84092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[84200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[84233,84546,84285,84521],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[84292],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[84405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[84368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[84656],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":50,"address":[84670,85115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[41600],"length":1,"stats":{"Line":0},"fn_name":"calc_one_region"},{"line":69,"address":[85097,84972],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[79863,78288],"length":1,"stats":{"Line":1},"fn_name":"test_sequence\u003cfn(\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2021_day_25::model::Region, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003cu16\u003e, 2\u003e) -\u003e aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2021_day_25::model::Region, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003cu16\u003e, 2\u003e\u003e"},{"line":92,"address":[79625,78371,78305,79477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[41744],"length":1,"stats":{"Line":1},"fn_name":"test_complex"},{"line":112,"address":[41744],"length":1,"stats":{"Line":1},"fn_name":"test_complex"},{"line":121,"address":[41776],"length":1,"stats":{"Line":1},"fn_name":"test_east"},{"line":122,"address":[41776],"length":1,"stats":{"Line":1},"fn_name":"test_east"},{"line":128,"address":[41808],"length":1,"stats":{"Line":1},"fn_name":"test_both"},{"line":129,"address":[41808],"length":1,"stats":{"Line":1},"fn_name":"test_both"}],"covered":44,"coverable":51},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","model.rs"],"content":"use super::*;\n\npub type Coord = u16;\npub type Grid = GridBuf \u003cGridInner, Pos, 2\u003e;\npub type GridInner = Vec \u003cRegion\u003e;\npub type Pos = pos::PosYX \u003cCoord\u003e;\n\nenum_decl_parser_display! {\n\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Region {\n\t\t#[ default ]\n\t\tEmpty = [ \".\" ],\n\t\tEast = [ \"\u003e\" ],\n\t\tSouth = [ \"v\" ],\n\t}\n}\n\nimpl BitVecNative for Region {\n\tconst BITS: u32 = 2;\n\tfn encode (self) -\u003e usize {\n\t\tmatch self {\n\t\t\tSelf::Empty =\u003e 0x0,\n\t\t\tSelf::East =\u003e 0x1,\n\t\t\tSelf::South =\u003e 0x2,\n\t\t}\n\t}\n\tfn decode (encoded: usize) -\u003e Self {\n\t\tmatch encoded {\n\t\t\t0 =\u003e Self::Empty,\n\t\t\t1 =\u003e Self::East,\n\t\t\t2 =\u003e Self::South,\n\t\t\t_ =\u003e panic! (\"Invalid encoded value for Region: {:#x}\", encoded),\n\t\t}\n\t}\n}\n","traces":[{"line":9,"address":[30848,30034,29886,30025,30099],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}\u003c(\u0026aoc_2021_day_25::model::Region, \u0026aoc_2021_day_25::model::Region), core::slice::cmp::{impl#4}::equal::{closure_env#0}\u003caoc_2021_day_25::model::Region, aoc_2021_day_25::model::Region\u003e\u003e"}],"covered":1,"coverable":1},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","src","lib.rs"],"content":"#![ allow (clippy::missing_inline_in_public_items) ]\n\nuse aoc_common::*;\n\npub use aoc_2021_day_01 as day_01;\npub use aoc_2021_day_02 as day_02;\npub use aoc_2021_day_03 as day_03;\npub use aoc_2021_day_04 as day_04;\npub use aoc_2021_day_05 as day_05;\npub use aoc_2021_day_06 as day_06;\npub use aoc_2021_day_07 as day_07;\npub use aoc_2021_day_08 as day_08;\npub use aoc_2021_day_09 as day_09;\npub use aoc_2021_day_10 as day_10;\npub use aoc_2021_day_11 as day_11;\npub use aoc_2021_day_12 as day_12;\npub use aoc_2021_day_13 as day_13;\npub use aoc_2021_day_14 as day_14;\npub use aoc_2021_day_15 as day_15;\npub use aoc_2021_day_16 as day_16;\npub use aoc_2021_day_17 as day_17;\npub use aoc_2021_day_18 as day_18;\npub use aoc_2021_day_19 as day_19;\npub use aoc_2021_day_20 as day_20;\npub use aoc_2021_day_21 as day_21;\npub use aoc_2021_day_22 as day_22;\npub use aoc_2021_day_23 as day_23;\npub use aoc_2021_day_24 as day_24;\npub use aoc_2021_day_25 as day_25;\n\n#[ must_use ]\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","args","args.rs"],"content":"pub trait ArgsParse {\n\tfn parse \u003cIter\u003e (iter: Iter) -\u003e Result \u003cSelf, ArgsParseError\u003e\n\t\twhere Iter: IntoIterator \u003cItem = OsString\u003e;\n}\n\npub enum ArgsParseError {\n\tUnexpected (OsString),\n\tMissingValue (OsString),\n\tInvalid (OsString, OsString, String),\n}\n\nimpl Display for ArgsParseError {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Unexpected (ref arg) =\u003e\n\t\t\t\twrite! (\"Unexpected argument {}\", arg.display ()),\n\t\t\tSelf::MissingValue (ref arg) =\u003e\n\t\t\t\twrite! (\"Missing value for {}\", arg.display ()),\n\t\t\tSelf::Invalid (ref arg, ref val, ref msg) =\u003e\n\t\t\t\twrite! (\"Invalid value for {}: {}: {}\", arg.display (), val.display (), msg),\n\t\t}\n\t}\n}\n\nimpl Error for ArgsParseError {\n}\n\n/*\nbasic requirements:\n\n- handle basic commands \"(none)\", \"part-1\" and \"part-2\"\n- args for those commands \"--input\" and \"--repeat\"\n- extension commands for puzzles\n- args for those extension commands\n*/\n\n#[ macro_export ]\nmacro_rules! args_decl {\n\t(\n\t\t$( #[ $($attr:tt)* ] )*\n\t\t$vis:vis struct $name:ident { $(\n\t\t\t$mem_vis:vis $mem_name:ident: $mem_type:ty\n\t\t),* $(,)? }\n\t) =\u003e {\n\n\t\t$( #[ $($attr)* ] )*\n\t\t$vis struct $name { $(\n\t\t\t$mem_vis $mem_name: $mem_type,\n\t\t)* }\n\n\t\timpl ArgsParse for $name {\n\n\t\t\tconst ARGS_DEF: \u0026 [(\u0026 str, \u0026 str)] = \u0026 [ $(\n\t\t\t\t(stringify! ($mem_name), stringify! ($mem_type)),\n\t\t\t)* ];\n\n\t\t\t$( if stringify! ($mem_type == \"bool\") {\n\t\t\t\t$mem_name = Some (false);\n\t\t\t} )*\n\n\t\t\tfor \u0026 (arg_name, arg_type) in ARGS_DEF {\n\t\t\t\t// TODO\n\t\t\t}\n\n\t\t\tfn parse \u003cIter\u003e (iter: Iter) -\u003e Result \u003cSelf, ArgsParseError\u003e\n\t\t\t\t\twhere Iter: IntoIterator \u003cItem = OsString\u003e {\n\t\t\t\t$( let mut $mem_name: Option \u003c$mem_type\u003e = None; )*\n\t\t\t\ttodo! ();\n\t\t\t\tOk (Self { $(\n\t\t\t\t\t$mem_name: $mem_name.ok_or (ArgsParseError::MissingValue (stringify! ($mem_name))) ?,\n\t\t\t\t)* })\n\t\t\t}\n\n\t\t}\n\n\t};\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","bithash","bithash.rs"],"content":"//! Bloom filter\n\nuse std::fmt::{ self, Display };\nuse std::hash::{ BuildHasher, Hash, Hasher };\nuse std::ops::{ BitAnd, Not };\n\nuse aoc_nums as nums;\nuse nums::IntConv;\n\n/// State for building a [`BitHash`] iteratively\n///\npub struct BitHasher \u003cBldHsh: BuildHasher, const LEN: usize, const BITS: usize\u003e {\n\n\t/// Current hash value\n\t///\n\tdata: [u64; LEN],\n\n\t/// Build hasher state\n\t///\n\thash_builder: BldHsh,\n\n}\n\nimpl \u003cBldHsh: BuildHasher, const LEN: usize, const BITS: usize\u003e BitHasher \u003cBldHsh, LEN, BITS\u003e {\n\n\t/// Construct a [`BitHasher`] with the provided [`BuildHasher`]\n\t///\n\t#[ inline ]\n\tpub const fn new_with_hasher (hash_builder: BldHsh) -\u003e Self {\n\t\tSelf { data: [0; LEN], hash_builder }\n\t}\n\n\t/// Update the hash value with a new item\n\t///\n\t#[ inline ]\n\tpub fn update \u003cVal: Hash\u003e (\u0026 mut self, val: Val) -\u003e \u0026 mut Self {\n\t\tlet mut hasher = self.hash_builder.build_hasher ();\n\t\tval.hash (\u0026 mut hasher);\n\t\tlet mut hash = hasher.finish ();\n\t\tfor _ in 0 .. BITS {\n\t\t\tlet bit = 1 \u003c\u003c (hash \u0026 0x3f);\n\t\t\thash \u003e\u003e= 6_u32;\n\t\t\tlet idx = (hash % LEN.to_u64 ().unwrap ()).to_usize ().unwrap ();\n\t\t\thash /= LEN.to_u64 ().unwrap ();\n\t\t\tself.data [idx] |= bit;\n\t\t}\n\t\tself\n\t}\n\n\t/// Stop hashing and return the hash value\n\t///\n\t#[ inline ]\n\tpub const fn finish (\u0026 self) -\u003e BitHash \u003cLEN\u003e {\n\t\tBitHash { data: self.data }\n\t}\n\n}\n\n/// A bit hash value\n///\n#[ derive (Clone, Copy) ]\npub struct BitHash \u003cconst LEN: usize\u003e {\n\n\t/// The hash value\n\t///\n\tdata: [u64; LEN],\n\n}\n\nimpl \u003cconst LEN: usize\u003e BitHash \u003cLEN\u003e {\n\n\t/// A zero hash value, with no items added\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn zero () -\u003e Self {\n\t\tSelf { data: [0; LEN] }\n\t}\n\n\t/// The number of one bits in the hash value\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn bits (\u0026 self) -\u003e usize {\n\t\tlet mut sum = 0;\n\t\tfor idx in 0 .. LEN { sum += self.data [idx].count_ones ().to_usize ().unwrap (); }\n\t\tsum\n\t}\n\n\t/// Map the hash to an equivalent hash of a smaller size\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn reduce \u003cconst OTHER_LEN: usize\u003e (\u0026 self) -\u003e BitHash \u003cOTHER_LEN\u003e {\n\t\tif LEN \u003c OTHER_LEN { panic! () }\n\t\tlet mut data = [0; OTHER_LEN];\n\t\tfor idx in 0 .. LEN { data [idx % OTHER_LEN] |= self.data [idx]; }\n\t\tBitHash { data }\n\t}\n\n\t/// Return true is this hash has no one bits\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_zero (\u0026 self) -\u003e bool {\n\t\tfor idx in 0 .. LEN { if self.data [idx] != 0 { return false } }\n\t\ttrue\n\t}\n\n}\n\nimpl \u003cconst LEN: usize\u003e Display for BitHash \u003cLEN\u003e {\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor idx in 0 .. LEN {\n\t\t\twrite! (formatter, \"{:064b}\", self.data [idx]) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl \u003cconst LEN: usize\u003e BitAnd for BitHash \u003cLEN\u003e {\n\n\ttype Output = Self;\n\n\t#[ inline ]\n\tfn bitand (mut self, other: Self) -\u003e Self {\n\t\tfor idx in 0 .. LEN { self.data [idx] \u0026= other.data [idx]; }\n\t\tself\n\t}\n\n}\n\nimpl \u003cconst LEN: usize\u003e Not for BitHash \u003cLEN\u003e {\n\n\ttype Output = Self;\n\n\t#[ inline ]\n\tfn not (mut self) -\u003e Self {\n\t\tfor idx in 0 .. LEN { self.data [idx] = ! self.data [idx]; }\n\t\tself\n\t}\n\n}\n\n/// Extension trait to [`Iterator`] for working with [`BitHash`]\n///\npub trait IteratorBitHash : Iterator {\n\n\t/// Construct a [`BitHash`] with the values from an iterator\n\t///\n\t#[ inline ]\n\tfn bit_hash \u003cBldHsh, const LEN: usize, const BITS: usize\u003e (self, hash_builder: BldHsh) -\u003e BitHash \u003cLEN\u003e\n\t\t\twhere BldHsh: BuildHasher, Self: Sized, Self::Item: Hash {\n\t\tlet mut hasher = BitHasher::\u003cBldHsh, LEN, BITS\u003e::new_with_hasher (hash_builder);\n\t\tfor item in self { hasher.update (\u0026 item); }\n\t\thasher.finish ()\n\t}\n\n}\n\nimpl \u003cSomeIter, SomeItem\u003e IteratorBitHash for SomeIter\n\twhere\n\t\tSomeIter: Iterator \u003cItem = SomeItem\u003e + Sized,\n\t\tSomeItem: Hash {\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","bitvec","bitvec.rs"],"content":"use super::*;\n\n/// Dynamically sized array of items encoded as bits and packed\n///\n#[ derive (Debug, Clone, Eq, PartialEq) ]\npub struct BitVec \u003cItem, Encoding = BitVecEncodingDefault\u003e {\n\n\t/// The number of items stored\n\t///\n\tlen: usize,\n\n\t/// Data for stored items\n\t///\n\twords: Vec \u003cusize\u003e,\n\n\t/// Phantom data to make the type system happy\n\t///\n\tphantom: PhantomData \u003c(Item, Encoding)\u003e,\n\n}\n\nimpl \u003cItem, Encoding\u003e BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\t/// Create a new [`BitVec`] with no items\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new () -\u003e Self {\n\t\tassert! (Encoding::BITS \u003c usize::BITS);\n\t\tassert! (Encoding::MASK == (1 \u003c\u003c Encoding::BITS) - 1);\n\t\tSelf {\n\t\t\twords: Vec::new (),\n\t\t\tlen: 0,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\n\t/// Number of items stored\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn len (\u0026 self) -\u003e usize { self.len }\n\n\t/// True if there are no stored items\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_empty (\u0026 self) -\u003e bool { self.len == 0 }\n\n\t#[ inline ]\n\tpub fn extend (\u0026 mut self, iter: impl IntoIterator \u003cItem = Item\u003e) {\n\t\tlet (_, mut bit_idx) = Self::get_backing_indexes (self.len);\n\t\tlet mut word_val = if 0 \u003c bit_idx { self.words.pop ().unwrap () } else { 0 };\n\t\tfor item in iter {\n\t\t\tlet item_enc = Encoding::encode (item);\n\t\t\tdebug_assert! (item_enc \u0026 ! Encoding::MASK == 0);\n\t\t\tlet mut rem_bits = Encoding::BITS;\n\t\t\twhile 0 \u003c rem_bits {\n\t\t\t\tword_val |= Encoding::item_to_word (item_enc, bit_idx);\n\t\t\t\tif bit_idx + rem_bits \u003c usize::BITS {\n\t\t\t\t\tbit_idx += Encoding::BITS;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\trem_bits -= usize::BITS - bit_idx;\n\t\t\t\tself.words.push (word_val);\n\t\t\t\tword_val = 0;\n\t\t\t\tbit_idx = 0;\n\t\t\t}\n\t\t\tself.len += 1;\n\t\t}\n\t\tif 0 \u003c bit_idx { self.words.push (word_val); }\n\t}\n\n\t/// Add a new item, increases the size by one\n\t///\n\t#[ inline ]\n\tpub fn push (\u0026 mut self, item: Item) {\n\t\tlet item_enc = Encoding::encode (item);\n\t\tself.push_real (item_enc);\n\t}\n\n\t#[ inline ]\n\tfn push_real (\u0026 mut self, item_enc: usize) {\n\t\tdebug_assert! (item_enc \u0026 ! Encoding::MASK == 0);\n\t\tlet mut rem_bits = Encoding::BITS;\n\t\tlet (mut word_idx, mut bit_idx) = Self::get_backing_indexes (self.len);\n\t\twhile 0 \u003c rem_bits {\n\t\t\tif self.words.len () \u003c= word_idx { self.words.push (0); }\n\t\t\tself.words [word_idx] |= Encoding::item_to_word (item_enc, bit_idx);\n\t\t\tif bit_idx + rem_bits \u003c= usize::BITS { break }\n\t\t\trem_bits -= usize::BITS - bit_idx;\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t\tself.len += 1;\n\t}\n\n\t/// Get a specific item given its index\n\t///\n\t#[ inline ]\n\tpub fn get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.get_real (idx).map (Encoding::decode)\n\t}\n\n\t#[ inline ]\n\tfn get_real (\u0026 self, idx: usize) -\u003e Option \u003cusize\u003e {\n\t\tif self.len \u003c idx + 1 { return None }\n\t\tlet mut item_enc = 0;\n\t\tlet mut rem_bits = Encoding::BITS;\n\t\tlet (mut word_idx, mut bit_idx) = Self::get_backing_indexes (idx);\n\t\twhile 0 \u003c rem_bits {\n\t\t\titem_enc |= Encoding::word_to_item (self.words [word_idx], bit_idx);\n\t\t\trem_bits -= cmp::min (rem_bits, usize::BITS - bit_idx);\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t\tSome (item_enc \u0026 Encoding::MASK)\n\t}\n\n\t/// Replace the item at the specified index\n\t///\n\t#[ inline ]\n\tpub fn set (\u0026 mut self, idx: usize, item: Item) {\n\t\tlet item_enc = Encoding::encode (item);\n\t\tself.set_real (idx, item_enc);\n\t}\n\n\t#[ inline ]\n\tfn set_real (\u0026 mut self, idx: usize, item_enc: usize) {\n\t\tassert! (idx \u003c self.len, \"Tried to set {} but len is {}\", idx, self.len);\n\t\tlet (mut word_idx, mut bit_idx) = Self::get_backing_indexes (idx);\n\t\tlet mut rem_bits = Encoding::BITS;\n\t\twhile 0 \u003c rem_bits {\n\t\t\tself.words [word_idx] \u0026= ! Encoding::item_to_word (Encoding::MASK, bit_idx);\n\t\t\tself.words [word_idx] |= Encoding::item_to_word (item_enc, bit_idx);\n\t\t\trem_bits -= cmp::min (rem_bits, usize::BITS - bit_idx);\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t}\n\n\t/// Create an iterator over the stored items\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn iter (\u0026 self) -\u003e BitVecIter \u003cItem, Encoding\u003e {\n\t\tBitVecIter::new (self.words.as_slice (), self.len ())\n\t}\n\n\t#[ inline ]\n\tfn get_backing_indexes (idx: usize) -\u003e (usize, u32) {\n\t\tlet word_idx = idx * Encoding::BITS.qck_usize () / usize::BITS.qck_usize ();\n\t\tlet bit_idx = (idx * Encoding::BITS.qck_usize () % usize::BITS.qck_usize ()).qck_u32 ();\n\t\t(word_idx, bit_idx)\n\t}\n\n}\n\nimpl \u003cItem, Encoding\u003e Default for BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\t#[ inline ]\n\tfn default () -\u003e Self {\n\t\tSelf::new ()\n\t}\n\n}\n\nimpl \u003cItem, Encoding\u003e FromIterator \u003cItem\u003e for BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\t#[ inline ]\n\tfn from_iter \u003cIter: IntoIterator \u003cItem = Item\u003e\u003e (iter: Iter) -\u003e Self {\n\t\tlet mut bitvec = Self::new ();\n\t\t//bitvec.extend (iter);\n\t\tfor item in iter { bitvec.push (item); }\n\t\tbitvec\n\t}\n\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":75},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","bitvec","encode.rs"],"content":"#[ cfg (doc) ]\nuse super::*;\n\n/// Trait for encoding an item as bits for storing in a [`BitVec`]\n///\npub trait BitVecEncoding \u003cItem\u003e {\n\n\t/// Number of bits in each encoded item\n\t///\n\tconst BITS: u32;\n\n\t/// Mask for the bits in an encoded item\n\t///\n\tconst MASK: usize = (1 \u003c\u003c Self::BITS) - 1;\n\n\t/// Encode an item into its representation as bits\n\t///\n\tfn encode (item: Item) -\u003e usize;\n\n\t/// Decode an item from its representation as bits\n\t///\n\tfn decode (bits: usize) -\u003e Item;\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn get_bit_shift (bit_idx: u32) -\u003e u32 {\n\t\tusize::BITS - bit_idx - Self::BITS\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn item_to_word (item_enc: usize, bit_idx: u32) -\u003e usize {\n\t\titem_enc \u003c\u003c Self::get_bit_shift (bit_idx)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn word_to_item (word_val: usize, bit_idx: u32) -\u003e usize {\n\t\tword_val \u003e\u003e Self::get_bit_shift (bit_idx)\n\t}\n\n}\n\n/// Default implementation of [`BitVecEncoding`] for items which implement [`BitVecNative`]\n///\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct BitVecEncodingDefault;\n\nimpl \u003cItem\u003e BitVecEncoding \u003cItem\u003e for BitVecEncodingDefault where Item: BitVecNative {\n\n\tconst BITS: u32 = Item::BITS;\n\n\tconst MASK: usize = (1 \u003c\u003c Item::BITS) - 1;\n\n\t#[ inline ]\n\tfn encode (item: Item) -\u003e usize { Item::encode (item) }\n\n\t#[ inline ]\n\tfn decode (bits: usize) -\u003e Item { Item::decode (bits) }\n\n}\n\n/// Trait for items which know how to encode themselves for storing in a [`BitVec`]\n///\npub trait BitVecNative {\n\n\t/// Number of bits in an encoded item\n\t///\n\tconst BITS: u32;\n\n\t/// Encode an item into its representation as bits\n\t///\n\tfn encode (self) -\u003e usize;\n\n\t/// Decode an item from its representation as bits\n\t///\n\tfn decode (encoded: usize) -\u003e Self;\n\n}\n\nimpl BitVecNative for bool {\n\n\tconst BITS: u32 = 1;\n\n\t#[ inline ]\n\tfn encode (self) -\u003e usize {\n\t\tusize::from (self)\n\t}\n\n\t#[ inline ]\n\tfn decode (encoded: usize) -\u003e Self {\n\t\tencoded != 0\n\t}\n\n}\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","bitvec","iter.rs"],"content":"use super::*;\n\n/// Iterator over the items in a [`BitVec`]\n///\n#[ derive (Clone) ]\npub struct BitVecIter \u003c'dat, Item, Encoding = BitVecEncodingDefault\u003e {\n\n\t/// The remaining packed data\n\t///\n\twords: \u0026 'dat [usize],\n\n\t/// Number of items remaining\n\t///\n\tlen: usize,\n\n\t/// The word currently being unpacked\n\t///\n\tword_val: usize,\n\n\t/// Index of next bit to unpack from current word\n\t///\n\tbit_idx: u32,\n\n\t/// Phantom data to make the type system happy\n\t///\n\tphantom: PhantomData \u003c(Item, Encoding)\u003e,\n\n}\n\nimpl \u003c'dat, Item, Encoding\u003e BitVecIter \u003c'dat, Item, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\t#[ inline ]\n\tpub (crate) fn new (words: \u0026 'dat [usize], len: usize) -\u003e Self {\n\t\tBitVecIter {\n\t\t\twords: if 0 \u003c len { \u0026 words [ 1 .. ] } else { \u0026 [] },\n\t\t\tlen,\n\t\t\tword_val: if 0 \u003c len { words [0] } else { 0 },\n\t\t\tbit_idx: 0,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn next_real (\u0026 mut self) -\u003e Option \u003cusize\u003e {\n\t\tif self.len == 0 { return None }\n\t\tself.len -= 1;\n\t\tlet mut item_enc = 0;\n\t\tlet mut rem_bits = Encoding::BITS;\n\t\twhile 0 \u003c rem_bits {\n\t\t\titem_enc |= Encoding::word_to_item (self.word_val, self.bit_idx);\n\t\t\tif self.bit_idx + rem_bits \u003c usize::BITS {\n\t\t\t\tself.bit_idx += rem_bits;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trem_bits -= usize::BITS - self.bit_idx;\n\t\t\tif 0 \u003c self.len {\n\t\t\t\tself.word_val = self.words [0];\n\t\t\t\tself.words = \u0026 self.words [1 .. ];\n\t\t\t\tself.bit_idx = 0;\n\t\t\t} else {\n\t\t\t\tassert! (rem_bits == 0);\n\t\t\t\tassert! (self.words.is_empty ());\n\t\t\t\tself.word_val = 0;\n\t\t\t\tself.bit_idx = usize::BITS;\n\t\t\t}\n\t\t}\n\t\tSome (item_enc \u0026 Encoding::MASK)\n\t}\n\n\t/*\n\tfn nth_real (\u0026 mut self, num: usize) -\u003e Option \u003cusize\u003e {\n\t\tlet mut adv_bits = Encoding::BITS.qck_usize () * num;\n\t\tlet adv_words =\n\t\t\t(usize::BITS.qck_usize () - self.word_bits.qck_usize () + adv_bits)\n\t\t\t\t/ usize::BITS.qck_usize ();\n\t\tif adv_words \u003e 0 {\n\t\t\tself.word_val = self.words [adv_words - 1];\n\t\t\tself.words = \u0026 self.words [adv_words .. ];\n\t\t\tadv_bits -= (adv_words - 1) * usize::BITS.qck_usize ();\n\t\t\tself.word_bits = usize::BITS;\n\t\t}\n\t\tdebug_assert! (adv_bits \u003c= self.word_bits.pan_usize ());\n\t\tself.word_bits -= adv_bits.qck_u32 ();\n\t\tself.word_val \u003e\u003e= adv_bits;\n\t\tself.len -= num;\n\t\tself.next_real ()\n\t}\n\t*/\n\n}\n\nimpl \u003c'dat, Item, Encoding\u003e Iterator for BitVecIter \u003c'dat, Item, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cItem\u003e {\n\t\tself.next_real ().map (Encoding::decode)\n\t}\n\n\t/*\n\t#[ inline ]\n\tfn nth (\u0026 mut self, num: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.nth_real (num).map (Encoding::decode)\n\t}\n\t*/\n\n\t#[ inline ]\n\tfn count (self) -\u003e usize {\n\t\tself.len\n\t}\n\n}\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","bitvec","lib.rs"],"content":"//! Dynamically sized array of items encoded as bits and packed\n\nuse std::cmp;\nuse std::marker::PhantomData;\n\nuse aoc_nums::IntConv as _;\n\nmod bitvec;\nmod encode;\nmod iter;\n\npub use bitvec::*;\npub use encode::*;\npub use iter::*;\n\npub mod prelude {\n\tpub use super::BitVec;\n\tpub use super::BitVecEncoding;\n\tpub use super::BitVecNative;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","checked","checked.rs"],"content":"#![ allow (clippy::wildcard_enum_match_arm) ]\n\nextern crate proc_macro;\n\nuse proc_macro::Delimiter;\nuse proc_macro::Group;\nuse proc_macro::Ident;\nuse proc_macro::Punct;\nuse proc_macro::Spacing;\nuse proc_macro::Span;\nuse proc_macro::TokenStream;\nuse proc_macro::TokenTree;\nuse proc_macro::token_stream::IntoIter as TokenStreamIter;\nuse std::iter;\nuse std::iter::Peekable;\nuse std::vec::IntoIter as VecIter;\n\ntype TokenIter = Peekable \u003cTokenStreamIter\u003e;\n\n/*\ntop = item arith-assign expr\nitem = non-arithmetic +\nexpr = item | expr arith expr | (expr)\n\nitem -\u003e Ok (item)\nleft.op (right) =\u003e left.and_then (|left| right.and_then (|right| left.checked_op (right)))\n*/\n\n#[proc_macro]\npub fn checked (tokens: TokenStream) -\u003e TokenStream {\n\tlet mut iter = tokens.into_iter ().peekable ();\n\tCheckedTop::parse (\u0026 mut iter).into ()\n}\n\n#[ derive (Debug) ]\nenum CheckedTop {\n\tExpr (CheckedExpr),\n\tAssign (CheckedItem, Punct, Punct, CheckedExpr),\n}\n\nimpl CheckedTop {\n\tfn parse (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tmatch Self::parse_assign (\u0026 mut iter.clone ()) {\n\t\t\tSome (val) =\u003e val,\n\t\t\t_ =\u003e Self::Expr (CheckedExpr::parse (iter)),\n\t\t}\n\t}\n\tfn parse_assign (iter: \u0026 mut TokenIter) -\u003e Option \u003cSelf\u003e {\n\t\tlet left = CheckedItem::parse (iter);\n\t\tlet punct_0 = match iter.next () {\n\t\t\tSome (TokenTree::Punct (punct)) =\u003e punct,\n\t\t\t_ =\u003e panic! (),\n\t\t};\n\t\tif punct_0.spacing () != Spacing::Joint { return None }\n\t\tlet punct_1 = match iter.next () {\n\t\t\tSome (TokenTree::Punct (punct)) =\u003e punct,\n\t\t\t_ =\u003e return None,\n\t\t};\n\t\tif punct_1.as_char () != '=' { return None }\n\t\tSome (Self::Assign (left, punct_0, punct_1, CheckedExpr::parse (iter)))\n\t}\n}\n\nimpl From \u003cCheckedTop\u003e for TokenStream {\n\tfn from (top: CheckedTop) -\u003e Self {\n\t\tmatch top {\n\t\t\tCheckedTop::Expr (expr) =\u003e expr.into (),\n\t\t\tCheckedTop::Assign (left, punct_0, punct_1, right) =\u003e {\n\t\t\t\tlet fn_name = match punct_0.as_char () {\n\t\t\t\t\t'+' =\u003e \"try_add\",\n\t\t\t\t\t'/' =\u003e \"try_div\",\n\t\t\t\t\t'*' =\u003e \"try_mul\",\n\t\t\t\t\t'%' =\u003e \"try_rem\",\n\t\t\t\t\t'-' =\u003e \"try_sub\",\n\t\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t\t};\n\t\t\t\t[\n\t\t\t\t\t// {\n\t\t\t\t\t//   let __val: Result \u003c_, Overflow\u003e =\n\t\t\t\t\t//     $right.and_then (|__right| $left.$fn_name (__right));\n\t\t\t\t\t//   if let Ok (__val) == __val {\n\t\t\t\t\t//     $left $punct_1 __val;\n\t\t\t\t\t//   } else {\n\t\t\t\t\t//     Err (Overflow)\n\t\t\t\t\t//   }\n\t\t\t\t\t// }\n\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Brace, [\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"let\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__val\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new (':', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Result\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new ('\u003c', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"_\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new (',', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Overflow\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new ('\u003e', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new ('=', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::None, right.into ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new ('.', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"and_then\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__right\", Span::mixed_site ())),\n\t\t\t\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::None, (\u0026 left).into ())),\n\t\t\t\t\t\t\tTokenTree::Punct (Punct::new ('.', Spacing::Alone)),\n\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (fn_name, Span::mixed_site ())),\n\t\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__right\", Span::mixed_site ())),\n\t\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new (';', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"if\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"let\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Ok\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__val\", Span::mixed_site ())),\n\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t\tTokenTree::Punct (Punct::new ('=', Spacing::Alone)),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__val\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Brace, iter::empty ()\n\t\t\t\t\t\t\t.chain (left.into_iter ())\n\t\t\t\t\t\t\t.chain ([\n\t\t\t\t\t\t\t\tTokenTree::Punct (punct_1),\n\t\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__val\", Span::mixed_site ())),\n\t\t\t\t\t\t\t\tTokenTree::Punct (Punct::new (';', Spacing::Alone)),\n\t\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Ok\", Span::mixed_site ())),\n\t\t\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis,\n\t\t\t\t\t\t\t\t\t\tSelf::new ())),\n\t\t\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t\t\t].into_iter ())\n\t\t\t\t\t\t\t.collect ())),\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"else\", Span::mixed_site ())),\n\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Brace, [\n\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Err\", Span::mixed_site ())),\n\t\t\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"Overflow\", Span::mixed_site ())),\n\t\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t\t].into_iter ().collect ()))\n\t\t\t\t].into_iter ().collect ()\n\t\t\t},\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Debug) ]\nenum CheckedExpr {\n\tItem (CheckedItem),\n\tAdd (Box \u003cCheckedExpr\u003e, Punct, Box \u003cCheckedExpr\u003e),\n\tDiv (Box \u003cCheckedExpr\u003e, Punct, Box \u003cCheckedExpr\u003e),\n\tMul (Box \u003cCheckedExpr\u003e, Punct, Box \u003cCheckedExpr\u003e),\n\tRem (Box \u003cCheckedExpr\u003e, Punct, Box \u003cCheckedExpr\u003e),\n\tSub (Box \u003cCheckedExpr\u003e, Punct, Box \u003cCheckedExpr\u003e),\n}\n\nimpl CheckedExpr {\n\tfn parse (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tSelf::parse_loose (iter)\n\t}\n\tfn parse_loose (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tlet mut result = Self::parse_tight (iter);\n\t\twhile iter.peek ().is_some () {\n\t\t\tlet punct = match iter.next ().unwrap () {\n\t\t\t\tTokenTree::Punct (punct) =\u003e punct,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t};\n\t\t\tresult = match punct.as_char () {\n\t\t\t\t'+' =\u003e Self::Add (result.into (), punct, Self::parse_tight (iter).into ()),\n\t\t\t\t'-' =\u003e Self::Sub (result.into (), punct, Self::parse_tight (iter).into ()),\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t}\n\t\t}\n\t\tresult\n\t}\n\tfn parse_tight (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tlet mut result = Self::parse_single (iter);\n\t\twhile iter.peek ().is_some () {\n\t\t\tlet punct = match iter.peek ().unwrap () {\n\t\t\t\t\u0026 TokenTree::Punct (ref punct) =\u003e punct,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t};\n\t\t\tlet ctor = match punct.as_char () {\n\t\t\t\t'/' =\u003e Self::Div,\n\t\t\t\t'*' =\u003e Self::Mul,\n\t\t\t\t'%' =\u003e Self::Rem,\n\t\t\t\t_ =\u003e return result,\n\t\t\t};\n\t\t\tlet punct = match iter.next ().unwrap () {\n\t\t\t\tTokenTree::Punct (punct) =\u003e punct,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t};\n\t\t\tresult = ctor (result.into (), punct, Self::parse_single (iter).into ());\n\t\t}\n\t\tresult\n\t}\n\tfn parse_single (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tmatch iter.peek () {\n\t\t\tSome (\u0026 TokenTree::Group (ref group))\n\t\t\t\t\tif group.delimiter () == Delimiter::Parenthesis =\u003e {\n\t\t\t\tlet inner = Self::parse_loose (\u0026 mut group.stream ().into_iter ().peekable ());\n\t\t\t\titer.next ().unwrap ();\n\t\t\t\tinner\n\t\t\t},\n\t\t\tSome (_) =\u003e Self::Item (CheckedItem::parse (iter)),\n\t\t\t_ =\u003e panic! (),\n\t\t}\n\t}\n}\n\nimpl From \u003cBox \u003cCheckedExpr\u003e\u003e for TokenStream {\n\tfn from (expr: Box \u003cCheckedExpr\u003e) -\u003e Self {\n\t\tSelf::from (\u0026 * expr)\n\t}\n}\n\nimpl From \u003c\u0026 Box \u003cCheckedExpr\u003e\u003e for TokenStream {\n\tfn from (expr: \u0026 Box \u003cCheckedExpr\u003e) -\u003e Self {\n\t\tSelf::from (\u0026 ** expr)\n\t}\n}\n\nimpl From \u003cCheckedExpr\u003e for TokenStream {\n\tfn from (expr: CheckedExpr) -\u003e Self {\n\t\tSelf::from (\u0026 expr)\n\t}\n}\n\nimpl From \u003c\u0026 CheckedExpr\u003e for TokenStream {\n\tfn from (expr: \u0026 CheckedExpr) -\u003e Self {\n\t\tlet (fn_name, left, punct, right) = match * expr {\n\t\t\tCheckedExpr::Item (ref item) =\u003e {\n\t\t\t\t// Ok ($item)\n\t\t\t\treturn [\n\t\t\t\t\tTokenTree::Ident (Ident::new (\"Ok\", Span::mixed_site ())),\n\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, item.into ())),\n\t\t\t\t].into_iter ().collect ();\n\t\t\t},\n\t\t\tCheckedExpr::Add (ref left, ref punct, ref right) =\u003e (\"try_add\", left, punct, right),\n\t\t\tCheckedExpr::Div (ref left, ref punct, ref right) =\u003e (\"try_div\", left, punct, right),\n\t\t\tCheckedExpr::Mul (ref left, ref punct, ref right) =\u003e (\"try_mul\", left, punct, right),\n\t\t\tCheckedExpr::Rem (ref left, ref punct, ref right) =\u003e (\"try_rem\", left, punct, right),\n\t\t\tCheckedExpr::Sub (ref left, ref punct, ref right) =\u003e (\"try_sub\", left, punct, right),\n\t\t};\n\t\t[\n\t\t\t// $left.and_then (|__left| $right.and_then (|__right| __left.$fn_name (__right)))\n\t\t\tTokenTree::Group (Group::new (Delimiter::None, left.into ())),\n\t\t\tTokenTree::Punct (Punct::new ('.', Spacing::Alone)),\n\t\t\tTokenTree::Ident (Ident::new (\"and_then\", punct.span ())),\n\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\tTokenTree::Ident (Ident::new (\"__left\", punct.span ())),\n\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\tTokenTree::Group (Group::new (Delimiter::None, right.into ())),\n\t\t\t\tTokenTree::Punct (Punct::new ('.', Spacing::Alone)),\n\t\t\t\tTokenTree::Ident (Ident::new (\"and_then\", punct.span ())),\n\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\t\tTokenTree::Ident (Ident::new (\"__right\", punct.span ())),\n\t\t\t\t\tTokenTree::Punct (Punct::new ('|', Spacing::Alone)),\n\t\t\t\t\tTokenTree::Ident (Ident::new (\"__left\", punct.span ())),\n\t\t\t\t\tTokenTree::Punct (Punct::new ('.', Spacing::Alone)),\n\t\t\t\t\tTokenTree::Ident (Ident::new (fn_name, punct.span ())),\n\t\t\t\t\tTokenTree::Group (Group::new (Delimiter::Parenthesis, [\n\t\t\t\t\t\tTokenTree::Ident (Ident::new (\"__right\", punct.span ())),\n\t\t\t\t\t].into_iter ().collect ())),\n\t\t\t\t].into_iter ().collect ())),\n\t\t\t].into_iter ().collect ())),\n\t\t].into_iter ().collect ()\n\t}\n}\n\n#[ derive (Clone, Debug) ]\nstruct CheckedItem (Vec \u003cTokenTree\u003e);\n\nimpl CheckedItem {\n\tfn parse (iter: \u0026 mut TokenIter) -\u003e Self {\n\t\tlet mut tokens = Vec::new ();\n\t\tlet mut first = true;\n\t\tloop {\n\t\t\tconst ARITH_CHARS: [char; 5] = ['+', '-', '*', '/', '%'];\n\t\t\tmatch iter.peek () {\n\t\t\t\tSome (\u0026 TokenTree::Punct (ref punct))\n\t\t\t\t\t\tif ! first \u0026\u0026 ARITH_CHARS.contains (\u0026 punct.as_char ()) =\u003e {\n\t\t\t\t\tassert! (! tokens.is_empty ());\n\t\t\t\t\treturn Self (tokens);\n\t\t\t\t},\n\t\t\t\tNone =\u003e return Self (tokens),\n\t\t\t\t_ =\u003e tokens.push (iter.next ().unwrap ()),\n\t\t\t}\n\t\t\tfirst = false;\n\t\t}\n\t}\n}\n\nimpl IntoIterator for CheckedItem {\n\ttype Item = TokenTree;\n\ttype IntoIter = VecIter \u003cTokenTree\u003e;\n\tfn into_iter (self) -\u003e VecIter \u003cTokenTree\u003e {\n\t\tlet Self (tokens) = self;\n\t\ttokens.into_iter ()\n\t}\n}\n\nimpl From \u003cCheckedItem\u003e for TokenStream {\n\tfn from (CheckedItem (tokens): CheckedItem) -\u003e Self {\n\t\ttokens.into_iter ().collect ()\n\t}\n}\n\nimpl From \u003c\u0026 CheckedItem\u003e for TokenStream {\n\tfn from (\u0026 CheckedItem (ref tokens): \u0026 CheckedItem) -\u003e Self {\n\t\ttokens.iter ().cloned ().collect ()\n\t}\n}\n\n/*\n#[ macro_export ]\nmacro_rules! checked {\n\t( $left:tt += $right:tt ) =\u003e {\n\t\t(|| { $left = $left.try_add (checked_eval! ($right) ?) ?; Ok::\u003c_, Overflow\u003e (()) }) ()\n\t};\n\t( $left:tt /= $right:tt ) =\u003e {\n\t\t(|| { $left = $left.try_div (checked_eval! ($right) ?) ?; Ok::\u003c_, Overflow\u003e (()) }) ()\n\t};\n\t( $left:tt *= $right:tt ) =\u003e {\n\t\t(|| { $left = $left.try_mul (checked_eval! ($right) ?) ?; Ok::\u003c_, Overflow\u003e (()) }) ()\n\t};\n\t( $left:tt %= $right:tt ) =\u003e {\n\t\t(|| { $left = $left.try_rem (checked_eval! ($right) ?) ?; Ok::\u003c_, Overflow\u003e (()) }) ()\n\t};\n\t( $left:tt -= $right:tt ) =\u003e {\n\t\t(|| { $left = $left.try_sub (checked_eval! ($right) ?) ?; Ok::\u003c_, Overflow\u003e (()) }) ()\n\t};\n\t( $($arg:tt)* ) =\u003e { (|| checked_eval! ($($arg)*)) () };\n}\n\n#[ macro_export ]\nmacro_rules! checked_eval {\n\t( $arg:ident ) =\u003e { Ok::\u003c_, Overflow\u003e ($arg) };\n\t( ( $($args:tt)* ) ) =\u003e { checked_eval! ($($args)*) };\n\t( $left:tt . $right:ident ) =\u003e { Ok::\u003c_, Overflow\u003e (checked_eval! ($left) ?.$right) };\n\t( $left_0:tt + $($right:tt)* ) =\u003e {\n\t\tchecked_eval! ($left_0) ?.try_add (checked_eval! ($($right)*) ?)\n\t};\n\t( $left_0:tt / $($right:tt)* ) =\u003e {\n\t\tchecked_eval! ($left_0) ?.try_div (checked_eval! ($($right)*) ?)\n\t};\n\t( $left_0:tt * $($right:tt)* ) =\u003e {\n\t\tchecked_eval! ($left_0) ?.try_mul (checked_eval! ($($right)*) ?)\n\t};\n\t( $left_0:tt % $($right:tt)* ) =\u003e {\n\t\tchecked_eval! ($left_0) ?.try_rem (checked_eval! ($($right)*) ?)\n\t};\n\t( $left_0:tt - $($right:tt)* ) =\u003e {\n\t\tchecked_eval! ($left_0) ?.try_sub (checked_eval! ($($right)*) ?)\n\t};\n}\n*/\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","buf.rs"],"content":"use super::*;\n\n/// Multi dimensional abstraction over a single dimensional collection\n///\n/// This allows a simple one-dimensional collection to be accessed in a multi-dimensional way. It\n/// wraps a backing collection which implements [`GridStorage`], and takes indexes which implement\n/// [`GridPos`].\n///\n#[ derive (Clone, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct GridBuf \u003cStorage, Pos, const DIMS: usize\u003e\n\t\twhere Pos: GridPos \u003cDIMS\u003e {\n\tstorage: Storage,\n\tstart: Pos,\n\tend: Pos,\n\tsize: Pos,\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorage + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn wrap_range (storage: Storage, start: Pos, end: Pos) -\u003e NumResult \u003cSelf\u003e {\n\t\tassert! (\n\t\t\tstd::iter::zip (start.to_array (), end.to_array ())\n\t\t\t\t.all (|(start, end)| start \u003c end),\n\t\t\t\"Size must be positive in all dimensions: {start:?} to {end:?}\");\n\t\tlet size = Pos::from_array (\n\t\t\tstd::iter::zip (start.to_array (), end.to_array ())\n\t\t\t\t.map (|(start, end)| chk! (end - start))\n\t\t\t\t.try_array () ?);\n\t\tlet expected_len =\n\t\t\tsize.to_array ().into_iter ()\n\t\t\t\t.map (Pos::Coord::pan_usize)\n\t\t\t\t.product::\u003cusize\u003e ();\n\t\tlet actual_len = storage.storage_len ();\n\t\tassert! (expected_len == actual_len,\n\t\t\t\"Expected {} items but was passed {}\", expected_len, actual_len);\n\t\tOk (Self { storage, start, end, size, phantom: PhantomData })\n\t}\n\n\t#[ inline ]\n\tpub fn wrap_size (storage: Storage, size: Pos) -\u003e Self {\n\t\tSelf::wrap_range (storage, Pos::default (), size).unwrap ()\n\t}\n\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorage + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn new_range (start: Pos, end: Pos) -\u003e NumResult \u003cSelf\u003e\n\t\twhere\n\t\t\tStorage: FromIterator \u003cStorage::Item\u003e,\n\t\t\tStorage::Item: Clone + Default {\n\t\tassert! (\n\t\t\tstd::iter::zip (start.to_array (), end.to_array ())\n\t\t\t\t.all (|(start, end)| start \u003c end),\n\t\t\t\"Size must be positive in all dimensions: {start:?} to {end:?}\");\n\t\tlet size = Pos::from_array (\n\t\t\tstd::iter::zip (start.to_array (), end.to_array ())\n\t\t\t\t.map (|(start, end)| chk! (end - start))\n\t\t\t\t.try_array () ?);\n\t\tlet storage =\n\t\t\tstd::iter::repeat (default ())\n\t\t\t\t.take (size.to_array ().into_iter ()\n\t\t\t\t\t.map (Pos::Coord::pan_usize)\n\t\t\t\t\t.product ())\n\t\t\t\t.collect::\u003cStorage\u003e ();\n\t\tOk (Self { storage, start, end, size, phantom: PhantomData })\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new_size (size: Pos) -\u003e Self\n\t\twhere\n\t\t\tStorage: FromIterator \u003cStorage::Item\u003e,\n\t\t\tStorage::Item: Clone + Default {\n\t\tSelf::new_range (Pos::default (), size).unwrap ()\n\t}\n\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorage + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn set_index (\u0026 mut self, idx: usize, item: Storage::Item) {\n\t\tself.storage.storage_set (idx.qck_usize (), item);\n\t}\n\n\t#[ inline ]\n\tpub fn set (\u0026 mut self, pos: Pos, item: Storage::Item) {\n\t\tlet native = pos.to_native (self.start).unwrap ();\n\t\tlet idx = native.native_to_index (self.size).unwrap ();\n\t\tself.storage.storage_set (idx.qck_usize (), item);\n\t}\n\n\t#[ inline ]\n\tpub fn try_set (\u0026 mut self, pos: Pos, item: Storage::Item) -\u003e Option \u003c()\u003e {\n\t\tlet native = pos.to_native (self.start) ?;\n\t\tlet idx = native.native_to_index (self.size) ?;\n\t\tself.storage.storage_set (idx.qck_usize (), item);\n\t\tSome (())\n\t}\n\n\t#[ inline ]\n\tpub fn translate (\u0026 self, offset: Pos) -\u003e NumResult \u003cSelf\u003e {\n\t\tlet offset_arr = offset.to_array ();\n\t\tlet mut start_arr = self.start.to_array ();\n\t\tlet mut end_arr = self.end.to_array ();\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tchk! (start_arr [dim_idx] += offset_arr [dim_idx]) ?;\n\t\t\tchk! (end_arr [dim_idx] += offset_arr [dim_idx]) ?;\n\t\t}\n\t\tlet start = Pos::from_array (start_arr);\n\t\tlet end = Pos::from_array (end_arr);\n\t\tOk (Self {\n\t\t\tstorage: self.storage.clone (),\n\t\t\tstart,\n\t\t\tend,\n\t\t\tsize: self.size,\n\t\t\tphantom: PhantomData,\n\t\t})\n\t}\n\n}\n\nimpl \u003cItem, Pos, const DIMS: usize\u003e GridBuf \u003cVec \u003cItem\u003e, Pos, DIMS\u003e\n\twhere\n\t\tItem: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn reset (\u0026 mut self) {\n\t\tfor item in self.storage.iter_mut () {\n\t\t\t* item = default ();\n\t\t}\n\t}\n\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorageMut + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn get_ref (\u0026 self, pos: Pos) -\u003e Option \u003c\u0026 Storage::Item\u003e {\n\t\tlet native = pos.to_native (self.start) ?;\n\t\tlet idx = native.native_to_index (self.size) ?;\n\t\tself.storage.storage_ref (idx.qck_usize ())\n\t}\n\n\t#[ inline ]\n\tpub fn get_mut (\u0026 mut self, pos: Pos) -\u003e Option \u003c\u0026 mut Storage::Item\u003e {\n\t\tlet native = pos.to_native (self.start) ?;\n\t\tlet idx = native.native_to_index (self.size) ?;\n\t\tself.storage.storage_mut (idx.qck_usize ())\n\t}\n\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e Debug\n\tfor GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.debug_struct (\"GridBuf\")\n\t\t\t.field (\"start\", \u0026 self.start)\n\t\t\t.field (\"end\", \u0026 self.end)\n\t\t\t.field (\"size\", \u0026 self.size)\n\t\t\t.finish ()\n\t}\n\n}\n\nimpl \u003c'grd, Storage, Pos, const DIMS: usize\u003e GridView \u003cPos, DIMS\u003e\n\tfor \u0026 'grd GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tPos: GridPos \u003cDIMS\u003e,\n\t\tStorage: GridStorage {\n\n\ttype Item = Storage::Item;\n\ttype Cursors = GridCursorIter \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn start (self) -\u003e Pos {\n\t\tself.start\n\t}\n\n\t#[ inline ]\n\tfn end (self) -\u003e Pos {\n\t\tself.end\n\t}\n\n\t#[ inline ]\n\tfn size (self) -\u003e Pos {\n\t\tself.size\n\t}\n\n\t#[ inline ]\n\tfn get_trusted (self, _native: Pos, idx: usize) -\u003e Storage::Item {\n\t\tself.storage.storage_get (idx).unwrap ()\n\t}\n\n\t#[ inline ]\n\tfn cursors (self) -\u003e GridCursorIter \u003cPos, DIMS\u003e {\n\t\tGridCursorIter::new_grid (self)\n\t}\n\n}\n\nimpl \u003c'grd, Storage, Pos, const DIMS: usize\u003e GridViewIter \u003cPos, DIMS\u003e\n\tfor \u0026 'grd GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tPos: GridPos \u003cDIMS\u003e,\n\t\tStorage: GridStorage,\n\t\t\u0026 'grd Storage: GridStorageIntoIter \u003cItem = Self::Item\u003e {\n\n\ttype Values = \u003c\u0026 'grd Storage as GridStorageIntoIter\u003e::Iter;\n\n\t#[ inline ]\n\tfn values (self) -\u003e Self::Values {\n\t\t(\u0026 self.storage).storage_iter ()\n\t}\n\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":57,"address":[109632,110484,109648,108944],"length":1,"stats":{"Line":18},"fn_name":"new_range\u003calloc::vec::Vec\u003caoc_2020_day_17::model::Tile, alloc::alloc::Global\u003e, aoc_pos::PosXYZW\u003ci8\u003e, 4\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":31},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":80,"address":[108720,108832],"length":1,"stats":{"Line":0},"fn_name":"new_size\u003calloc::vec::Vec\u003caoc_2020_day_17::model::Tile, alloc::alloc::Global\u003e, aoc_pos::PosXYZW\u003ci8\u003e, 4\u003e"},{"line":84,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":35},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":40,"coverable":85},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","cursor.rs"],"content":"use super::*;\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct GridCursor \u003cPos, const DIMS: usize\u003e {\n\tstart: Pos,\n\tsize: Pos,\n\tnative: Pos,\n\tidx: usize,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GridCursor \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub (crate) fn new_grid (grid: impl GridView \u003cPos, DIMS\u003e, native: Pos, idx: usize) -\u003e Self {\n\t\tSelf { start: grid.start (), size: grid.size (), native, idx }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub (crate) const fn new_size (start: Pos, size: Pos, native: Pos, idx: usize) -\u003e Self {\n\t\tSelf { start, size, native, idx }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn pos (\u0026 self) -\u003e Pos {\n\t\tPos::from_native (self.native, self.start).unwrap ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn native (\u0026 self) -\u003e Pos {\n\t\tself.native\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn index (\u0026 self) -\u003e usize {\n\t\tself.idx\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn get \u003cGrid: GridView \u003cPos, DIMS\u003e\u003e (\u0026 self, grid: Grid) -\u003e Grid::Item {\n\t\tgrid.get_trusted (self.native, self.idx)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn walk (\n\t\tself,\n\t\toffset: GridOffset \u003cPos, DIMS\u003e,\n\t) -\u003e GridCursorWalk \u003cPos, DIMS\u003e {\n\t\tGridCursorWalk { cur: self, offset, done: false }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn compact (self) -\u003e GridCursorCompact \u003cPos, DIMS\u003e {\n\t\tGridCursorCompact { native: self.native, idx: self.idx }\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\npub struct GridCursorCompact \u003cPos, const DIMS: usize\u003e {\n\tnative: Pos,\n\tidx: usize,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GridCursorCompact \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn expand (self, grid: impl GridView \u003cPos, DIMS\u003e) -\u003e GridCursor \u003cPos, DIMS\u003e {\n\t\tGridCursor {\n\t\t\tstart: grid.start (),\n\t\t\tsize: grid.size (),\n\t\t\tnative: self.native,\n\t\t\tidx: self.idx,\n\t\t}\n\t}\n\n}\n\npub struct GridCursorWalk \u003cPos, const DIMS: usize\u003e\n\t\twhere Pos: GridPos \u003cDIMS\u003e {\n\tcur: GridCursor \u003cPos, DIMS\u003e,\n\toffset: GridOffset \u003cPos, DIMS\u003e,\n\tdone: bool,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Iterator\n\tfor GridCursorWalk \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = GridCursor \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tif self.done { return None }\n\t\tlet result = self.cur;\n\t\tif self.cur.try_add_assign (self.offset).is_err () { self.done = true; }\n\t\tSome (result)\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e TryAdd \u003cGridOffset \u003cPos, DIMS\u003e\u003e\n\tfor GridCursor \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Output = Self;\n\n\t#[ inline ]\n\tfn try_add (self, offset: GridOffset \u003cPos, DIMS\u003e) -\u003e NumResult \u003cSelf\u003e {\n\t\tlet size_arr = self.size.to_array ();\n\t\tlet offset_arr = offset.val ().to_array ();\n\t\tlet mut native_arr = self.native.to_array ();\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tlet native_val = chk! (native_arr [dim_idx] + offset_arr [dim_idx]) ?;\n\t\t\tif ! (Pos::Coord::ZERO .. size_arr [dim_idx]).contains (\u0026 native_val) {\n\t\t\t\treturn Err (Overflow);\n\t\t\t}\n\t\t\tnative_arr [dim_idx] = native_val;\n\t\t}\n\t\tlet native = Pos::from_array (native_arr);\n\t\tlet idx = (self.idx.qck_isize () + offset.idx ()).qck_usize ();\n\t\tOk (Self { start: self.start, size: self.size, native, idx })\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e TryAddAssign \u003cGridOffset \u003cPos, DIMS\u003e\u003e\n\tfor GridCursor \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tfn try_add_assign (\u0026 mut self, offset: GridOffset \u003cPos, DIMS\u003e) -\u003e NumResult \u003c()\u003e {\n\t\tlet size_arr = self.size.to_array ();\n\t\tlet offset_arr = offset.val ().to_array ();\n\t\tlet mut native_arr = self.native.to_array ();\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tlet native_val = chk! (native_arr [dim_idx] + offset_arr [dim_idx]) ?;\n\t\t\tif ! (Pos::Coord::ZERO .. size_arr [dim_idx]).contains (\u0026 native_val) {\n\t\t\t\treturn Err (Overflow);\n\t\t\t}\n\t\t\tnative_arr [dim_idx] = native_val;\n\t\t}\n\t\tself.native = Pos::from_array (native_arr);\n\t\tself.idx = (self.idx.qck_isize () + offset.idx ()).qck_usize ();\n\t\tOk (())\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Debug for GridCursor \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.debug_struct (\"GridCursor\")\n\t\t\t.field (\"native\", \u0026 self.native)\n\t\t\t.field (\"idx\", \u0026 self.idx)\n\t\t\t.finish ()\n\t}\n\n}\n\n/*\npub struct GridCursorMut \u003c'sto, Storage, Pos, const DIMS: usize = 2\u003e\n\t\twhere Pos: Copy {\n\tgrid: \u0026 'sto mut GridBuf \u003cStorage, Pos, DIMS\u003e,\n\tpos: [usize; DIMS],\n\tidx: usize,\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003c'grid, Storage, Pos, const DIMS: usize\u003e GridCursorMut \u003c'grid, Storage, Pos, DIMS\u003e\n\twhere\n\t\tPos: GridPos \u003cDIMS\u003e,\n\t\tStorage: GridStorageMut + Clone {\n\n\tpub (crate) fn new (grid: \u0026 'grid mut GridBuf \u003cStorage, Pos, DIMS\u003e, pos: [usize; DIMS], idx: usize) -\u003e Self {\n\t\tSelf { grid, pos, idx, phantom: PhantomData }\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn pos (\u0026 self) -\u003e Pos {\n\t\tPos::from_native (self.pos, self.grid.native_origin ()).unwrap ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn native (\u0026 self) -\u003e [usize; DIMS] {\n\t\tself.pos\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn index (\u0026 self) -\u003e usize {\n\t\tself.idx\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn item (\u0026 mut self) -\u003e \u0026 mut Storage::Item {\n\t\tself.grid.storage.storage_mut (self.idx).unwrap ()\n\t}\n\n\t#[ inline ]\n\tpub fn try_add (self, offset: GridOffset \u003cDIMS\u003e) -\u003e Result \u003cSelf, Self\u003e\n\t\t\twhere Pos: TryAdd \u003cPos, Output = Pos\u003e {\n\t\tlet mut pos = [0; DIMS];\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tlet dim_offset = offset.native () [dim_idx];\n\t\t\tlet dim_val = self.pos [dim_idx];\n\t\t\tpos [dim_idx] = if 0 \u003c= dim_offset {\n\t\t\t\tlet dim_val = dim_val + dim_offset.unsigned_abs ();\n\t\t\t\tif self.grid.size [dim_idx] \u003c= dim_val { return Err (self) }\n\t\t\t\tdim_val\n\t\t\t} else {\n\t\t\t\tif dim_val \u003c dim_offset.unsigned_abs () { return Err (self) }\n\t\t\t\tdim_val - dim_offset.unsigned_abs ()\n\t\t\t};\n\t\t}\n\t\tlet idx = if 0 \u003c= offset.idx () {\n\t\t\tself.idx + offset.idx ().unsigned_abs ()\n\t\t} else {\n\t\t\tself.idx - offset.idx ().unsigned_abs ()\n\t\t};\n\t\tOk (Self {\n\t\t\tgrid: self.grid,\n\t\t\tpos,\n\t\t\tidx,\n\t\t\tphantom: PhantomData,\n\t\t})\n\t}\n\n\t#[ inline ]\n\tpub fn try_add_assign (\u0026 mut self, offset: \u0026 GridOffset \u003cDIMS\u003e) -\u003e Option \u003c()\u003e\n\t\t\twhere Pos: TryAdd \u003cPos, Output = Pos\u003e {\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tlet dim_offset = offset.native () [dim_idx];\n\t\t\tlet dim_val = self.pos [dim_idx];\n\t\t\tself.pos [dim_idx] = if 0 \u003c= dim_offset {\n\t\t\t\tlet dim_val = dim_val + dim_offset.unsigned_abs ();\n\t\t\t\tif self.grid.size [dim_idx] \u003c= dim_val { return None }\n\t\t\t\tdim_val\n\t\t\t} else {\n\t\t\t\tif dim_val \u003c dim_offset.unsigned_abs () { return None }\n\t\t\t\tdim_val - dim_offset.unsigned_abs ()\n\t\t\t};\n\t\t}\n\t\tif 0 \u003c= offset.idx () {\n\t\t\tself.idx += offset.idx ().unsigned_abs ();\n\t\t} else {\n\t\t\tself.idx -= offset.idx ().unsigned_abs ();\n\t\t};\n\t\tSome (())\n\t}\n\n}\n\nimpl \u003c'grid, Storage, Pos, const DIMS: usize\u003e Debug for GridCursorMut \u003c'grid, Storage, Pos, DIMS\u003e\n\twhere Pos: Copy + Debug {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.debug_struct (\"GridCursorMut\")\n\t\t\t.field (\"pos\", \u0026 self.pos)\n\t\t\t.field (\"idx\", \u0026 self.idx)\n\t\t\t.finish ()\n\t}\n\n}\n*/\n\n#[ derive (Clone, Copy, Debug, Default) ]\npub struct GridOffset \u003cPos, const DIMS: usize\u003e\n\t\twhere Pos: GridPos \u003cDIMS\u003e {\n\tpos: Pos,\n\tidx: isize,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GridOffset \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn new (size: Pos, pos: Pos) -\u003e NumResult \u003cSelf\u003e {\n\t\tlet idx = pos.native_to_index (size).ok_or (Overflow) ?;\n\t\tOk (Self { pos, idx })\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn val (\u0026 self) -\u003e Pos {\n\t\tself.pos\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn idx (\u0026 self) -\u003e isize {\n\t\tself.idx\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Neg\n\tfor GridOffset \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e, Pos::Coord: Neg \u003cOutput = Pos::Coord\u003e {\n\n\ttype Output = Self;\n\n\t#[ inline ]\n\tfn neg (self) -\u003e Self {\n\t\tSelf {\n\t\t\tpos: Pos::from_array (self.pos.to_array ().map (|val| - val)),\n\t\t\tidx: - self.idx,\n\t\t}\n\t}\n\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":52,"address":[68976],"length":1,"stats":{"Line":0},"fn_name":"walk\u003caoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e"},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":62},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","display.rs"],"content":"use super::*;\n\nuse aoc_pos::PosGeo;\nuse aoc_pos::PosGeoHexLat;\nuse aoc_pos::PosRowCol;\nuse aoc_pos::PosXY;\nuse aoc_pos::PosYX;\n\npub enum GridPosDisplayType {\n\tDownRight,\n\tRightUp,\n\tUpRight,\n\tUpRightSlant,\n}\n\npub trait GridPosDisplay: GridPos \u003c2\u003e {\n\tfn grid_pos_display_rows_cols (pos: Self) -\u003e (Self::Coord, Self::Coord);\n\tfn grid_pos_display_native (size: Self, row: Self::Coord, col: Self::Coord) -\u003e Self;\n\tfn grid_pos_display_prefix (row: Self::Coord) -\u003e Self::Coord;\n}\n\npub trait GridPosDisplayAuto: GridPos \u003c2\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType;\n}\n\nimpl \u003cPos: GridPosDisplayAuto\u003e GridPosDisplay for Pos {\n\n\t#[ inline ]\n\tfn grid_pos_display_rows_cols (size: Self) -\u003e (Self::Coord, Self::Coord) {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tlet size_arr = size.to_array ();\n\t\tmatch Self::DISPLAY_TYPE {\n\t\t\tDownRight | UpRight | UpRightSlant =\u003e (size_arr [0], size_arr [1]),\n\t\t\tRightUp =\u003e (size_arr [1], size_arr [0]),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn grid_pos_display_native (size: Self, row: Self::Coord, col: Self::Coord) -\u003e Self {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tlet size_arr = size.to_array ();\n\t\tSelf::from_array (match Self::DISPLAY_TYPE {\n\t\t\tDownRight =\u003e [ row, col ],\n\t\t\tRightUp =\u003e [ col, size_arr [1] - row - Self::Coord::ONE ],\n\t\t\tUpRight | UpRightSlant =\u003e [ size_arr [0] - row - Self::Coord::ONE, col ],\n\t\t})\n\t}\n\n\t#[ inline ]\n\tfn grid_pos_display_prefix (row: Self::Coord) -\u003e Self::Coord {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tmatch Self::DISPLAY_TYPE {\n\t\t\tDownRight | RightUp | UpRight =\u003e Self::Coord::ZERO,\n\t\t\tUpRightSlant =\u003e row,\n\t\t}\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPosDisplayAuto for PosGeo \u003cVal\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType = GridPosDisplayType::UpRight;\n}\n\nimpl \u003cVal: Int\u003e GridPosDisplayAuto for PosGeoHexLat \u003cVal\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType = GridPosDisplayType::UpRightSlant;\n}\n\nimpl \u003cVal: Int\u003e GridPosDisplayAuto for PosXY \u003cVal\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType = GridPosDisplayType::RightUp;\n}\n\nimpl \u003cVal: Int\u003e GridPosDisplayAuto for PosYX \u003cVal\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType = GridPosDisplayType::DownRight;\n}\n\nimpl \u003cVal: Int\u003e GridPosDisplayAuto for PosRowCol \u003cVal\u003e {\n\tconst DISPLAY_TYPE: GridPosDisplayType = GridPosDisplayType::DownRight;\n}\n\nimpl \u003cStorage, Pos\u003e GridBuf \u003cStorage, Pos, 2\u003e\n\twhere\n\t\tStorage: GridStorage,\n\t\tStorage::Item: Display,\n\t\tPos: GridPosDisplay {\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn display_with_delim \u003cDelim: Display\u003e (\n\t\t\u0026 self,\n\t\tdelim: Delim,\n\t\tformatter: \u0026 mut fmt::Formatter,\n\t) -\u003e fmt::Result {\n\t\tlet (num_rows, num_cols) = Pos::grid_pos_display_rows_cols (self.size ());\n\t\tfor row in 0 .. num_rows.qck_usize () {\n\t\t\tif 0 \u003c row { formatter.write_char ('\\n') ?; }\n\t\t\tlet row = Pos::Coord::from_usize (row).unwrap ();\n\t\t\tfor _ in 0 .. Pos::grid_pos_display_prefix (row).qck_usize () {\n\t\t\t\tformatter.write_char (' ') ?;\n\t\t\t}\n\t\t\tfor col in 0 .. num_cols.qck_usize () {\n\t\t\t\tif 0 \u003c col { Display::fmt (\u0026 delim, formatter) ?; }\n\t\t\t\tlet col = Pos::Coord::from_usize (col).unwrap ();\n\t\t\t\tlet native = Pos::grid_pos_display_native (self.size (), row, col);\n\t\t\t\tlet item = self.get_native (native).unwrap ();\n\t\t\t\tDisplay::fmt (\u0026 item, formatter) ?;\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\nimpl \u003cStorage, Pos\u003e Display for GridBuf \u003cStorage, Pos, 2\u003e\n\twhere\n\t\tStorage: GridStorage,\n\t\tStorage::Item: Display,\n\t\tPos: GridPosDisplay {\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut first = true;\n\t\tlet (num_rows, num_cols) = Pos::grid_pos_display_rows_cols (self.size ());\n\t\tfor row in 0 .. num_rows.qck_usize () {\n\t\t\tlet row = Pos::Coord::from_usize (row).unwrap ();\n\t\t\tif first { first = false; } else { formatter.write_char ('\\n') ?; }\n\t\t\tfor _ in 0 .. Pos::grid_pos_display_prefix (row).qck_usize () {\n\t\t\t\tformatter.write_char (' ') ?;\n\t\t\t}\n\t\t\tfor col in 0 .. num_cols.qck_usize () {\n\t\t\t\tlet col = Pos::Coord::from_usize (col).unwrap ();\n\t\t\t\tlet native = Pos::grid_pos_display_native (self.size (), row, col);\n\t\t\t\tlet item = self.get_native (native).unwrap ();\n\t\t\t\tDisplay::fmt (\u0026 item, formatter) ?;\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\npub struct GridPrint \u003cGrid, Pos, MapFn, Out\u003e\n\twhere\n\t\tGrid: GridView \u003cPos, 2\u003e,\n\t\tPos: GridPos \u003c2\u003e,\n\t\tMapFn: Fn (\u003cGrid as GridView \u003cPos, 2\u003e\u003e::Item) -\u003e Out,\n\t\tOut: Display {\n\tgrid: Grid,\n\tmap_fn: MapFn,\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003cGrid, Pos, MapFn, Out\u003e Display for GridPrint \u003cGrid, Pos, MapFn, Out\u003e\n\twhere\n\t\tGrid: GridView \u003cPos, 2\u003e,\n\t\tPos: GridPos \u003c2\u003e,\n\t\tMapFn: Fn (\u003cGrid as GridView \u003cPos, 2\u003e\u003e::Item) -\u003e Out,\n\t\tOut: Display {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor row in 0 .. self.grid.size ().to_array () [0].qck_usize () {\n\t\t\tlet row = Pos::Coord::from_usize (row).unwrap ();\n\t\t\tfor col in 0 .. self.grid.size ().to_array () [1].qck_usize () {\n\t\t\t\tlet col = Pos::Coord::from_usize (col).unwrap ();\n\t\t\t\tlet pos = Pos::from_array ([ row, col ]);\n\t\t\t\tlet item = self.grid.get_native (pos).unwrap ();\n\t\t\t\twrite! (formatter, \"{}\", (self.map_fn) (item)) ?;\n\t\t\t}\n\t\t\twrite! (formatter, \"\\n\") ?;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\npub trait GridViewPrint \u003cPos\u003e: GridView \u003cPos, 2\u003e\n\twhere Pos: GridPos \u003c2\u003e {\n\n\t#[ inline ]\n\tfn print \u003cMapFn, Out\u003e (self, map_fn: MapFn) -\u003e GridPrint \u003cSelf, Pos, MapFn, Out\u003e\n\t\twhere\n\t\t\tMapFn: Fn (Self::Item) -\u003e Out, Out: Display,\n\t\t\tSelf: Sized {\n\t\tGridPrint {\n\t\t\tgrid: self,\n\t\t\tmap_fn,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\n}\n\nimpl \u003cGrid, Pos\u003e GridViewPrint \u003cPos\u003e for Grid\n\twhere\n\t\tGrid: GridView \u003cPos, 2\u003e,\n\t\tPos: GridPos \u003c2\u003e {\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":52},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","extend.rs"],"content":"use super::*;\n\npub trait GridViewExtend \u003cPos, const DIMS: usize\u003e: GridView \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tfn extend (self, amts: [(Pos::Coord, Pos::Coord); DIMS]) -\u003e NumResult \u003cGridExtend \u003cSelf, Pos, DIMS\u003e\u003e {\n\t\tlet mut start_arr = self.start ().to_array ();\n\t\tlet mut end_arr = self.end ().to_array ();\n\t\tlet mut size_arr = self.size ().to_array ();\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tchk! (start_arr [dim_idx] -= amts [dim_idx].0) ?;\n\t\t\tchk! (end_arr [dim_idx] += amts [dim_idx].1) ?;\n\t\t\tchk! (size_arr [dim_idx] += amts [dim_idx].0 + amts [dim_idx].1) ?;\n\t\t}\n\t\tlet start = Pos::from_array (start_arr);\n\t\tlet end = Pos::from_array (end_arr);\n\t\tlet size = Pos::from_array (size_arr);\n\t\tlet ranges = array::from_fn (|dim_idx|\n\t\t\t(amts [dim_idx].0, size_arr [dim_idx] - amts [dim_idx].1));\n\t\tlet idx_fix = {\n\t\t\tlet self_size_arr = self.size ().to_array ();\n\t\t\tlet mut mul = 1_usize;\n\t\t\tlet mut sum = 0_usize;\n\t\t\tfor (dim_idx, \u0026 (start, _)) in amts.iter ().enumerate ().rev () {\n\t\t\t\tsum += start.pan_usize () * mul;\n\t\t\t\tmul *= self_size_arr [dim_idx].pan_usize ();\n\t\t\t}\n\t\t\tsum\n\t\t};\n\t\tOk (GridExtend { inner: self, start, end, size, ranges, idx_fix })\n\t}\n\n}\n\nimpl \u003cGrid, Pos, const DIMS: usize\u003e GridViewExtend \u003cPos, DIMS\u003e for Grid\n\twhere\n\t\tGrid: GridView \u003cPos, DIMS\u003e,\n\t\tPos: GridPos \u003cDIMS\u003e {\n}\n\n#[ derive (Clone, Copy) ]\npub struct GridExtend \u003cInner, Pos, const DIMS: usize\u003e\n\twhere\n\t\tInner: GridView \u003cPos, DIMS\u003e,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\tinner: Inner,\n\tstart: Pos,\n\tend: Pos,\n\tsize: Pos,\n\tranges: [(Pos::Coord, Pos::Coord); DIMS],\n\tidx_fix: usize,\n}\n\nimpl \u003c'grd, Inner, Pos, const DIMS: usize\u003e GridView \u003cPos, DIMS\u003e\n\tfor \u0026 'grd GridExtend \u003cInner, Pos, DIMS\u003e\n\twhere\n\t\tInner: GridView \u003cPos, DIMS\u003e,\n\t\tInner::Item: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = Inner::Item;\n\ttype Cursors = GridExtendCursors \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn start (self) -\u003e Pos {\n\t\tself.start\n\t}\n\n\t#[ inline ]\n\tfn end (self) -\u003e Pos {\n\t\tself.end\n\t}\n\n\t#[ inline ]\n\tfn size (self) -\u003e Pos {\n\t\tself.size\n\t}\n\n\t#[ inline ]\n\tfn get_trusted (self, native: Pos, idx: usize) -\u003e Self::Item {\n\t\tlet native_arr = native.to_array ();\n\t\tlet mut inner_native_arr = [Pos::Coord::ZERO; DIMS];\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tlet val = native_arr [dim_idx];\n\t\t\tlet (rng_start, rng_end) = self.ranges [dim_idx];\n\t\t\tif ! (rng_start .. rng_end).contains (\u0026 val) { return default () }\n\t\t\tlet inner_val = val - rng_start;\n\t\t\tinner_native_arr [dim_idx] = inner_val;\n\t\t}\n\t\tlet inner_native = Pos::from_array (inner_native_arr);\n\t\tlet inner_idx = idx - self.idx_fix;\n\t\tself.inner.get_trusted (inner_native, inner_idx)\n\t}\n\n\t#[ inline ]\n\tfn offset (self, pos: Pos) -\u003e NumResult \u003cGridOffset \u003cPos, DIMS\u003e\u003e {\n\t\tGridOffset::new (self.inner.size (), pos)\n\t}\n\n\t#[ inline ]\n\tfn cursor (self, pos: Pos) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tlet native = pos.to_native (self.start) ?;\n\t\tlet (idx, _) = native.to_array ().into_iter ()\n\t\t\t.zip (self.inner.size ().to_array ()).rev ()\n\t\t\t.fold ((Pos::Coord::ZERO, Pos::Coord::ONE),\n\t\t\t\t|(sum, mul), (val, size)| (sum + val * mul, mul * size));\n\t\tSome (GridCursor::new_grid (self, native, idx.qck_usize ()))\n\t}\n\n\t#[ inline ]\n\tfn cursors (self) -\u003e GridExtendCursors \u003cPos, DIMS\u003e\n\t\t\twhere Self: Sized {\n\t\tlet inner_size_arr = self.inner.size ().to_array ();\n\t\tGridExtendCursors {\n\t\t\tstart: self.start (),\n\t\t\tsize: self.size (),\n\t\t\tnative: Pos::from_array ([Pos::Coord::ZERO; DIMS]),\n\t\t\tidx: 0,\n\t\t\tidx_fix: {\n\t\t\t\tlet mut idx_fix = [0; DIMS];\n\t\t\t\tlet mut mul = 1_usize;\n\t\t\t\tlet mut sum = 0_usize;\n\t\t\t\tfor (dim_idx, (\u0026 (rng_start, rng_end), \u0026 size))\n\t\t\t\t\tin self.ranges.iter ()\n\t\t\t\t\t\t.zip (\u0026 self.size.to_array ())\n\t\t\t\t\t\t.enumerate ()\n\t\t\t\t\t\t.rev () {\n\t\t\t\t\tlet val = chk! (size - rng_end + rng_start).unwrap ().pan_usize ();\n\t\t\t\t\tsum += chk! (val * mul).unwrap ();\n\t\t\t\t\tidx_fix [dim_idx] = chk! (sum * mul).unwrap ();\n\t\t\t\t\tmul *= inner_size_arr [dim_idx].pan_usize ();\n\t\t\t\t}\n\t\t\t\tidx_fix\n\t\t\t},\n\t\t\tdone: false,\n\t\t}\n\t}\n\n}\n\nimpl \u003c'grd, Inner, Pos, const DIMS: usize\u003e Debug\n\tfor \u0026 'grd GridExtend \u003cInner, Pos, DIMS\u003e\n\twhere\n\t\tInner: GridView \u003cPos, DIMS\u003e,\n\t\tInner::Item: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.debug_struct (\"GridExtend\")\n\t\t\t.field (\"start\", \u0026 self.start)\n\t\t\t.field (\"end\", \u0026 self.end)\n\t\t\t.field (\"size\", \u0026 self.size)\n\t\t\t.field (\"ranges\", \u0026 self.ranges)\n\t\t\t.field (\"idx_fix\", \u0026 self.idx_fix)\n\t\t\t.finish ()\n\t}\n\n}\n\nimpl \u003c'grd, Inner, Pos, const DIMS: usize\u003e GridViewIter \u003cPos, DIMS\u003e\n\tfor \u0026 'grd GridExtend \u003cInner, Pos, DIMS\u003e\n\twhere\n\t\tInner: GridViewIter \u003cPos, DIMS\u003e,\n\t\tInner::Item: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\ttype Values = GridExtendIter \u003cInner::Values, Pos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn values (self) -\u003e Self::Values {\n\t\tGridExtendIter {\n\t\t\tinner: self.inner.values (),\n\t\t\tnative: Pos::from_array ([Pos::Coord::ZERO; DIMS]),\n\t\t\tsize: self.size,\n\t\t\tranges: self.ranges,\n\t\t\tdone: false,\n\t\t}\n\t}\n\n}\n\n#[ derive (Clone) ]\npub struct GridExtendIter \u003cInner, Pos, const DIMS: usize\u003e\n\t\twhere Pos: GridPos \u003cDIMS\u003e {\n\tinner: Inner,\n\tnative: Pos,\n\tsize: Pos,\n\tranges: [(Pos::Coord, Pos::Coord); DIMS],\n\tdone: bool,\n}\n\nimpl \u003cInner, Pos, const DIMS: usize\u003e Iterator\n\tfor GridExtendIter \u003cInner, Pos, DIMS\u003e\n\twhere\n\t\tInner: Iterator,\n\t\tInner::Item: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = Inner::Item;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cSelf::Item\u003e {\n\t\tif self.done { return None }\n\t\tlet val = {\n\t\t\tif self.native.to_array ().iter ()\n\t\t\t\t\t.zip (\u0026 self.ranges)\n\t\t\t\t\t.all (|(\u0026 val, \u0026 (start, end))| (start .. end).contains (\u0026 val)) {\n\t\t\t\tself.inner.next ().unwrap ()\n\t\t\t} else {\n\t\t\t\tSelf::Item::default ()\n\t\t\t}\n\t\t};\n\t\tlet mut native_arr = self.native.to_array ();\n\t\tfor (dim_idx, (pos, \u0026 size))\n\t\t\tin native_arr.iter_mut ()\n\t\t\t\t.zip (\u0026 self.size.to_array ())\n\t\t\t\t.enumerate ()\n\t\t\t\t.rev () {\n\t\t\t* pos += Pos::Coord::ONE;\n\t\t\tif * pos \u003c size { break }\n\t\t\t* pos = Pos::Coord::ZERO;\n\t\t\tif dim_idx == 0 { self.done = true; }\n\t\t}\n\t\tself.native = Pos::from_array (native_arr);\n\t\tSome (val)\n\t}\n\n}\n\nimpl \u003cInner, Pos, const DIMS: usize\u003e FusedIterator\n\tfor GridExtendIter \u003cInner, Pos, DIMS\u003e\n\twhere\n\t\tInner: Iterator,\n\t\tInner::Item: Default,\n\t\tPos: GridPos \u003cDIMS\u003e {\n}\n\npub struct GridExtendCursors \u003cPos, const DIMS: usize\u003e {\n\tstart: Pos,\n\tsize: Pos,\n\tnative: Pos,\n\tidx: usize,\n\tidx_fix: [usize; DIMS],\n\tdone: bool,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Iterator\n\tfor GridExtendCursors \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = GridCursor \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tif self.done { return None }\n\t\tlet size_arr = self.size.to_array ();\n\t\tlet cur_native = self.native;\n\t\tlet cur_idx = self.idx;\n\t\tlet mut native_arr = cur_native.to_array ();\n\t\tfor dim_idx in (0 .. DIMS).rev () {\n\t\t\tnative_arr [dim_idx] += Pos::Coord::ONE;\n\t\t\tif native_arr [dim_idx] \u003c size_arr [dim_idx] { break }\n\t\t\tnative_arr [dim_idx] = Pos::Coord::ZERO;\n\t\t\tif 0 \u003c dim_idx {\n\t\t\t\tself.idx -= self.idx_fix [dim_idx];\n\t\t\t} else { self.done = true; }\n\t\t}\n\t\tself.native = Pos::from_array (native_arr);\n\t\tself.idx += 1;\n\t\tSome (GridCursor::new_size (self.start, self.size, cur_native, cur_idx))\n\t}\n\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[92416],"length":1,"stats":{"Line":1},"fn_name":"cursors\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_24::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e, aoc_pos::dim_2::geo_hex::PosGeoHexLat\u003ci16\u003e, 2\u003e"},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":103},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","grid.rs"],"content":"use std::fmt::Debug;\nuse std::marker::PhantomData;\nuse std::slice::Iter as SliceIter;\n\nuse aoc_bitvec as bitvec;\nuse aoc_checked::checked as chk;\nuse aoc_misc::prelude::*;\nuse aoc_nums as nums;\nuse aoc_parser::*;\n\nuse bitvec::BitVec;\nuse bitvec::BitVecEncoding;\nuse bitvec::BitVecIter;\nuse nums::Int;\nuse nums::IntConv;\nuse nums::IntSigned;\nuse nums::NumResult;\nuse nums::Overflow;\nuse nums::TryAdd;\nuse nums::TryAddAssign;\nuse nums::TryMul;\nuse nums::TrySub;\n\nmod buf;\nmod cursor;\nmod display;\nmod extend;\nmod iter;\nmod parse;\nmod pos;\nmod storage;\nmod transform;\nmod view;\n\npub use buf::*;\npub use cursor::*;\npub use display::*;\npub use extend::*;\npub use iter::*;\npub use parse::*;\npub use pos::*;\npub use storage::*;\npub use transform::*;\npub use view::*;\n\npub mod prelude {\n\tpub use crate::GridBuf;\n\tpub use crate::GridCursor;\n\tpub use crate::GridCursorCompact;\n\tpub use crate::GridOffset;\n\tpub use crate::GridPos;\n\tpub use crate::GridView;\n\tpub use crate::GridViewExtend;\n\tpub use crate::GridViewIter;\n\tpub use crate::GridViewPrint;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","iter.rs"],"content":"use super::*;\n\npub trait GridViewIter \u003cPos, const DIMS: usize\u003e: GridView \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Values: Iterator \u003cItem = Self::Item\u003e;\n\n\tfn values (self) -\u003e Self::Values;\n\n\t#[ inline ]\n\tfn iter (self) -\u003e GridIter \u003cSelf::Values, Pos, DIMS\u003e\n\t\t\twhere Self: Copy + Sized {\n\t\tIterator::zip (self.keys (), self.values ())\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn to_buf \u003cStorage\u003e (self) -\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\t\t\twhere Storage: Clone + GridStorage + FromIterator \u003cSelf::Item\u003e {\n\t\tlet storage = self.values ().collect ();\n\t\tlet (start, end) = (self.start (), self.end ());\n\t\tGridBuf::wrap_range (storage, start, end).unwrap ()\n\t}\n\n}\n\npub type GridIter \u003cValues, Pos, const DIMS: usize\u003e =\n\tstd::iter::Zip \u003cGridKeysIter \u003cPos, DIMS\u003e, Values\u003e;\n\npub struct GridKeysIter \u003cPos: GridPos \u003cDIMS\u003e, const DIMS: usize\u003e {\n\tstart: Pos,\n\tend: Pos,\n\tval: Pos,\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003cPos: GridPos \u003cDIMS\u003e, const DIMS: usize\u003e GridKeysIter \u003cPos, DIMS\u003e {\n\tpub (crate) const fn new (start: Pos, end: Pos) -\u003e Self {\n\t\tSelf { start, end, val: start, phantom: PhantomData }\n\t}\n}\n\nimpl \u003cPos: GridPos \u003cDIMS\u003e, const DIMS: usize\u003e Iterator for GridKeysIter \u003cPos, DIMS\u003e {\n\n\ttype Item = Pos;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cPos\u003e {\n\t\tif self.val == self.end { return None }\n\t\tlet result = self.val;\n\t\tlet start_arr = self.start.to_array ();\n\t\tlet end_arr = self.end.to_array ();\n\t\tlet mut val_arr = self.val.to_array ();\n\t\tfor dim_idx in (0 .. DIMS).rev () {\n\t\t\tval_arr [dim_idx] += Pos::Coord::ONE;\n\t\t\tif val_arr [dim_idx] \u003c end_arr [dim_idx] { break }\n\t\t\tval_arr [dim_idx] = start_arr [dim_idx];\n\t\t\tif dim_idx == 0 { self.val = self.end; return Some (result) }\n\t\t}\n\t\tself.val = Pos::from_array (val_arr);\n\t\tSome (result)\n\t}\n\n}\n\npub struct GridCursorIter \u003cPos, const DIMS: usize\u003e {\n\tstart: Pos,\n\tsize: Pos,\n\tnative: Pos,\n\tidx: usize,\n\tdone: bool,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GridCursorIter \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub (crate) fn new_grid (grid: impl GridView \u003cPos, DIMS\u003e) -\u003e Self {\n\t\tSelf {\n\t\t\tstart: grid.start (),\n\t\t\tsize: grid.size (),\n\t\t\tnative: Pos::from_array ([Pos::Coord::ZERO; DIMS]),\n\t\t\tidx: 0,\n\t\t\tdone: false,\n\t\t}\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Iterator\n\tfor GridCursorIter \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = GridCursor \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tif self.done { return None }\n\t\tlet size_arr = self.size.to_array ();\n\t\tlet cur_native = self.native;\n\t\tlet cur_idx = self.idx;\n\t\tlet mut native_arr = self.native.to_array ();\n\t\tfor dim_idx in (0 .. DIMS).rev () {\n\t\t\tnative_arr [dim_idx] += Pos::Coord::ONE;\n\t\t\tif native_arr [dim_idx] \u003c size_arr [dim_idx] { break }\n\t\t\tnative_arr [dim_idx] = Pos::Coord::ZERO;\n\t\t\tif dim_idx == 0 { self.done = true; }\n\t\t}\n\t\tself.native = Pos::from_array (native_arr);\n\t\tself.idx += 1;\n\t\tSome (GridCursor::new_size (self.start, self.size, cur_native, cur_idx))\n\t}\n\n}\n\n/// Wrapping iterator which clones items.\n///\n/// We don't use [`Cloned`](std::iter::Cloned) from the standard library because it doesn't handle\n/// [`Iterator::skip`] the way we would like. Although it says in the documentation that there is\n/// no guarantee each element will be processed, it seems like it does so. Instead, we want to\n/// completely bypass any elements which aren't required.\n///\n#[ derive (Clone) ]\npub struct GridStorageClone \u003cStorage\u003e {\n\tstorage: Storage,\n}\n\nimpl \u003cStorage\u003e GridStorageClone \u003cStorage\u003e {\n\tpub (crate) const fn new (storage: Storage) -\u003e Self {\n\t\tSelf { storage }\n\t}\n}\n\nimpl \u003c'sto, Storage, Item\u003e Iterator for GridStorageClone \u003cStorage\u003e\n\twhere\n\t\tStorage: Iterator \u003cItem = \u0026 'sto Item\u003e,\n\t\tItem: Clone + 'sto {\n\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cItem\u003e {\n\t\tself.storage.next ().cloned ()\n\t}\n\n\t#[ inline ]\n\tfn nth (\u0026 mut self, num: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.storage.nth (num).cloned ()\n\t}\n\n}\n","traces":[{"line":11,"address":[59040],"length":1,"stats":{"Line":0},"fn_name":"iter\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2018_day_18::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e"},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":51,"address":[74590],"length":1,"stats":{"Line":26},"fn_name":null},{"line":52,"address":[74612],"length":1,"stats":{"Line":26},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":28,"coverable":42},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","parse.rs"],"content":"use super::*;\n\nimpl \u003c'inp, Storage, Pos\u003e GridBuf \u003cStorage, Pos, 2\u003e\n\twhere\n\t\tPos: GridPosParse,\n\t\tStorage: Clone + FromIterator \u003cStorage::Item\u003e + GridStorage,\n\t\tStorage::Item: Clone + Default + FromParser \u003c'inp\u003e {\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn parse_with_delim_and_fn (\n\t\tparser: \u0026 mut Parser \u003c'inp\u003e,\n\t\tdelim: impl ParseDelimiter,\n\t\tdefault_fn: impl Fn () -\u003e Storage::Item,\n\t\tparse_fn: impl Fn (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cStorage::Item\u003e + Clone,\n\t) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet lines: Vec \u003cVec \u003cStorage::Item\u003e\u003e = parser.delim_fn (\"\\n\", |parser| {\n\t\t\tparser.any ().of (|parser| {\n\t\t\t\tlet items: Vec \u003cStorage::Item\u003e = parser.delim_fn (delim, parse_fn.clone ()).collect ();\n\t\t\t\tif items.is_empty () { return Err (parser.err ()) }\n\t\t\t\tOk (items)\n\t\t\t}).done ()\n\t\t}).collect ();\n\t\tif lines.is_empty () { return Err (parser.err ()) }\n\t\tlet num_lines = lines.len ();\n\t\tlet num_lines_coord = Pos::Coord::from_usize (num_lines).map_err (|_err| parser.err ()) ?;\n\t\tlet num_cols = lines.iter ().map (Vec::len).max ().unwrap_or (0);\n\t\tlet num_cols_coord = Pos::Coord::from_usize (num_cols).map_err (|_err| parser.err ()) ?;\n\t\tlet grid_size = Pos::grid_parse_grid_size (num_lines_coord, num_cols_coord);\n\t\tlet line_offset = Pos::grid_parse_row_offset (num_lines, num_cols);\n\t\tlet tile_offset = Pos::grid_parse_col_offset (num_lines, num_cols);\n\t\tlet first_idx = Pos::grid_parse_first_index (num_lines, num_cols).pan_isize ();\n\t\tlet mut grid_vec = vec! [ default_fn (); num_lines * num_cols ];\n\t\tlet mut line_idx = first_idx;\n\t\tfor line in lines.iter () {\n\t\t\tlet mut tile_idx = line_idx;\n\t\t\tfor tile in line.iter ().cloned ()\n\t\t\t\t\t.chain (std::iter::repeat (default_fn ()))\n\t\t\t\t\t.take (num_cols) {\n\t\t\t\tgrid_vec [tile_idx.pan_usize ()] = tile;\n\t\t\t\ttile_idx += tile_offset;\n\t\t\t}\n\t\t\tline_idx += line_offset;\n\t\t}\n\t\tOk (Self::wrap_size (grid_vec.into_iter ().collect (), grid_size))\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn parse_with_delim (\n\t\tparser: \u0026 mut Parser \u003c'inp\u003e,\n\t\tdefault_fn: impl Fn () -\u003e Storage::Item,\n\t\tdelim: impl ParseDelimiter,\n\t) -\u003e ParseResult \u003cSelf\u003e {\n\t\tSelf::parse_with_delim_and_fn (parser, delim, default_fn, Parser::item)\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn parse_with_fn (\n\t\tparser: \u0026 mut Parser \u003c'inp\u003e,\n\t\tdefault_fn: impl Fn () -\u003e Storage::Item,\n\t\tparse_fn: impl Fn (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cStorage::Item\u003e + Clone,\n\t) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet lines: Vec \u003cVec \u003cStorage::Item\u003e\u003e = parser.delim_fn (\"\\n\", |parser| {\n\t\t\tparser.any ().of (|parser| {\n\t\t\t\tlet items: Vec \u003cStorage::Item\u003e = parser.repeat (parse_fn.clone ()).collect ();\n\t\t\t\tif items.is_empty () { return Err (parser.err ()) }\n\t\t\t\tOk (items)\n\t\t\t}).done ()\n\t\t}).collect ();\n\t\tif lines.is_empty () { return Err (parser.err ()) }\n\t\tlet num_lines = lines.len ();\n\t\tlet num_lines_coord = Pos::Coord::from_usize (num_lines).map_err (|_err| parser.err ()) ?;\n\t\tlet num_cols = lines.iter ().map (Vec::len).max ().unwrap_or (0);\n\t\tlet num_cols_coord = Pos::Coord::from_usize (num_cols).map_err (|_err| parser.err ()) ?;\n\t\tlet grid_size = Pos::grid_parse_grid_size (num_lines_coord, num_cols_coord);\n\t\tlet line_offset = Pos::grid_parse_row_offset (num_lines, num_cols);\n\t\tlet tile_offset = Pos::grid_parse_col_offset (num_lines, num_cols);\n\t\tlet first_idx = Pos::grid_parse_first_index (num_lines, num_cols).pan_isize ();\n\t\tlet mut grid_vec = vec! [ default_fn (); num_lines * num_cols ];\n\t\tlet mut line_idx = first_idx;\n\t\tfor line in lines.iter () {\n\t\t\tlet mut tile_idx = line_idx;\n\t\t\tfor tile in line.iter ().cloned ()\n\t\t\t\t\t.chain (std::iter::repeat (default_fn ()))\n\t\t\t\t\t.take (num_cols) {\n\t\t\t\tgrid_vec [tile_idx.pan_usize ()] = tile;\n\t\t\t\ttile_idx += tile_offset;\n\t\t\t}\n\t\t\tline_idx += line_offset;\n\t\t}\n\t\tOk (Self::wrap_size (grid_vec.into_iter ().collect (), grid_size))\n\t}\n\n}\n\nimpl \u003c'inp, Storage, Pos\u003e FromParser \u003c'inp\u003e for GridBuf \u003cStorage, Pos, 2\u003e\n\twhere\n\t\tPos: GridPosParse,\n\t\tStorage: Clone + FromIterator \u003cStorage::Item\u003e + GridStorage,\n\t\tStorage::Item: Clone + Default + FromParser \u003c'inp\u003e {\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tSelf::parse_with_fn (parser, Storage::Item::default, Parser::item)\n\t}\n\n}\n\npub trait GridPosParse: GridPos \u003c2\u003e {\n\tfn grid_parse_grid_size (rows: Self::Coord, cols: Self::Coord) -\u003e Self;\n\tfn grid_parse_row_offset (rows: usize, cols: usize) -\u003e isize;\n\tfn grid_parse_col_offset (rows: usize, cols: usize) -\u003e isize;\n\tfn grid_parse_first_index (rows: usize, cols: usize) -\u003e usize;\n}\n\nimpl \u003cPos: GridPosDisplayAuto\u003e GridPosParse for Pos {\n\n\t#[ inline ]\n\tfn grid_parse_grid_size (rows: Self::Coord, cols: Self::Coord) -\u003e Self {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tSelf::from_array (match Self::DISPLAY_TYPE {\n\t\t\tDownRight | UpRight | UpRightSlant =\u003e [ rows, cols ],\n\t\t\tRightUp =\u003e [ cols, rows ],\n\t\t})\n\t}\n\n\t#[ inline ]\n\tfn grid_parse_row_offset (_rows: usize, cols: usize) -\u003e isize {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tmatch Self::DISPLAY_TYPE {\n\t\t\tDownRight | UpRight | UpRightSlant =\u003e cols.pan_isize (),\n\t\t\tRightUp =\u003e -1_isize,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn grid_parse_col_offset (rows: usize, _cols: usize) -\u003e isize {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tmatch Self::DISPLAY_TYPE {\n\t\t\tDownRight =\u003e 1_isize,\n\t\t\tRightUp =\u003e rows.pan_isize (),\n\t\t\tUpRight | UpRightSlant =\u003e -1_isize,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn grid_parse_first_index (rows: usize, cols: usize) -\u003e usize {\n\t\tuse GridPosDisplayType::{ DownRight, RightUp, UpRight, UpRightSlant };\n\t\tmatch Self::DISPLAY_TYPE {\n\t\t\tDownRight =\u003e 0_usize,\n\t\t\tRightUp =\u003e rows.pan_usize () - 1,\n\t\t\tUpRight | UpRightSlant =\u003e (rows.pan_usize () - 1) * cols.pan_usize (),\n\t\t}\n\t}\n\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[59792,61429],"length":1,"stats":{"Line":33},"fn_name":"parse_with_fn\u003calloc::vec::Vec\u003caoc_2018_day_18::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, fn() -\u003e aoc_2018_day_18::model::Tile, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2018_day_18::model::Tile, aoc_parser::ParseError\u003e\u003e"},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":32},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":33},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":18,"coverable":76},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","pos.rs"],"content":"use super::*;\n\nuse aoc_pos::PosGeo;\nuse aoc_pos::PosGeoHexLat;\nuse aoc_pos::PosRowCol;\nuse aoc_pos::PosWXYZ;\nuse aoc_pos::PosXY;\nuse aoc_pos::PosXYZ;\nuse aoc_pos::PosXYZW;\nuse aoc_pos::PosYX;\n\n/// Trait for values to use as indices for a [`GridView`].\n///\n/// For example, a two dimensional grid might be indexed with a struct containing an `x` and a `y`\n/// coordinate.\n///\n/// This trait provides methods to translate whatever coordinate system is in use to and from a\n/// single `usize` value.\n///\npub trait GridPos \u003cconst DIMS: usize\u003e: Copy + Debug + Default + Eq + Sized {\n\n\ttype Coord: Int;\n\n\tfn to_array (self) -\u003e [Self::Coord; DIMS];\n\tfn from_array (array: [Self::Coord; DIMS]) -\u003e Self;\n\n\t#[ inline ]\n\tfn map \u003cMapFn, Output\u003e (self, map_fn: MapFn) -\u003e [Output; DIMS]\n\t\t\twhere MapFn: FnMut (Self::Coord) -\u003e Output {\n\t\tself.to_array ().map (map_fn)\n\t}\n\n\t#[ inline ]\n\tfn to_native (self, start: Self) -\u003e Option \u003cSelf\u003e {\n\t\tlet self_arr = self.to_array ();\n\t\tlet start_arr = start.to_array ();\n\t\tlet mut result_arr = [Self::Coord::ZERO; DIMS];\n\t\tfor idx in 0 .. DIMS {\n\t\t\tlet result = chk! (self_arr [idx] - start_arr [idx]).ok () ?;\n\t\t\tif result \u003c Self::Coord::ZERO { return None }\n\t\t\tresult_arr [idx] = result;\n\t\t}\n\t\tSome (Self::from_array (result_arr))\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn native_to_index (self, size: Self) -\u003e Option \u003cisize\u003e {\n\t\tself.to_array ().iter ()\n\t\t\t.zip (size.to_array ().iter ())\n\t\t\t.map (|(\u0026 val, \u0026 size)| (val.qck_isize (), size.qck_isize ()))\n\t\t\t.try_fold (0, |idx, (val, size)| {\n\t\t\t\tif size \u003c= val { return Err (Overflow) }\n\t\t\t\tchk! (idx * size + val)\n\t\t\t})\n\t\t\t.ok ()\n\t}\n\n\t#[ inline ]\n\tfn from_native (native: Self, start: Self) -\u003e Option \u003cSelf\u003e {\n\t\tlet native_arr = native.to_array ();\n\t\tlet start_arr = start.to_array ();\n\t\tlet mut result_arr = [Self::Coord::ZERO; DIMS];\n\t\tfor idx in 0 .. DIMS {\n\t\t\tresult_arr [idx] = chk! (native_arr [idx] + start_arr [idx]).ok () ?;\n\t\t}\n\t\tSome (Self::from_array (result_arr))\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosXY \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 2] {\n\t\t[ self.x, self.y ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 2]) -\u003e Self {\n\t\tSelf { x: array [0], y: array [1] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosYX \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 2] {\n\t\t[ self.y, self.x ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 2]) -\u003e Self {\n\t\tSelf { y: array [0], x: array [1] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosRowCol \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 2] {\n\t\t[ self.row, self.col ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 2]) -\u003e Self {\n\t\tSelf { row: array [0], col: array [1] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosGeo \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 2] {\n\t\t[ self.n, self.e ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 2]) -\u003e Self {\n\t\tSelf { n: array [0], e: array [1] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosGeoHexLat \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 2] {\n\t\t[ self.nw, self.e ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 2]) -\u003e Self {\n\t\tSelf { nw: array [0], e: array [1] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c3\u003e for PosXYZ \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 3] {\n\t\t[ self.x, self.y, self.z ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 3]) -\u003e Self {\n\t\tSelf { x: array [0], y: array [1], z: array [2] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c4\u003e for PosWXYZ \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 4] {\n\t\t[ self.w, self.x, self.y, self.z ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 4]) -\u003e Self {\n\t\tSelf { w: array [0], x: array [1], y: array [2], z: array [3] }\n\t}\n\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c4\u003e for PosXYZW \u003cVal\u003e {\n\n\ttype Coord = Val;\n\n\t#[ inline ]\n\tfn to_array (self) -\u003e [Val; 4] {\n\t\t[ self.x, self.y, self.z, self.w ]\n\t}\n\n\t#[ inline ]\n\tfn from_array (array: [Val; 4]) -\u003e Self {\n\t\tSelf { x: array [0], y: array [1], z: array [2], w: array [3] }\n\t}\n\n}\n","traces":[{"line":28,"address":[53632,53648,53600,53616],"length":1,"stats":{"Line":0},"fn_name":"map\u003caoc_pos::PosXYZW\u003ci8\u003e, 4, aoc_2020_day_17::logic::next_grid::{closure_env#1}\u003caoc_pos::PosXYZW\u003ci8\u003e, 4\u003e, i8\u003e"},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":86},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":111},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":95},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":71},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":22,"coverable":57},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","storage.rs"],"content":"use super::*;\n\n/// Trait for backing stores for a [`GridBuf`]\n///\n/// This provides a simple abstraction over a fixed size array of items. It is implemented for\n/// [`Vec`] and [`BitVec`].\n///\npub trait GridStorage {\n\n\ttype Item;\n\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cSelf::Item\u003e;\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item);\n\tfn storage_len (\u0026 self) -\u003e usize;\n\n}\n\nimpl \u003cItem, const LEN: usize\u003e GridStorage for [Item; LEN] where Item: Clone {\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.get (idx).cloned ()\n\t}\n\n\t#[ inline ]\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item) {\n\t\tself [idx] = item;\n\t}\n\n\t#[ inline ]\n\tfn storage_len (\u0026 self) -\u003e usize {\n\t\tself.len ()\n\t}\n\n}\n\nimpl \u003cItem\u003e GridStorage for Vec \u003cItem\u003e where Item: Clone {\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.get (idx).cloned ()\n\t}\n\n\t#[ inline ]\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item) {\n\t\tself [idx] = item;\n\t}\n\n\t#[ inline ]\n\tfn storage_len (\u0026 self) -\u003e usize {\n\t\tself.len ()\n\t}\n\n}\n\nimpl \u003cItem, Encoding\u003e GridStorage for BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.get (idx)\n\t}\n\n\t#[ inline ]\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item) {\n\t\tself.set (idx, item);\n\t}\n\n\t#[ inline ]\n\tfn storage_len (\u0026 self) -\u003e usize {\n\t\tself.len ()\n\t}\n\n}\n\n/// Additional trait for backing stores which which can provide references to items\n///\npub trait GridStorageMut: GridStorage {\n\tfn storage_ref (\u0026 self, idx: usize) -\u003e Option \u003c\u0026 Self::Item\u003e;\n\tfn storage_mut (\u0026 mut self, idx: usize) -\u003e Option \u003c\u0026 mut Self::Item\u003e;\n}\n\nimpl \u003cItem\u003e GridStorageMut for Vec \u003cItem\u003e where Item: Clone {\n\n\t#[ inline ]\n\tfn storage_ref (\u0026 self, idx: usize) -\u003e Option \u003c\u0026 Item\u003e {\n\t\tself.get (idx)\n\t}\n\n\t#[ inline ]\n\tfn storage_mut (\u0026 mut self, idx: usize) -\u003e Option \u003c\u0026 mut Item\u003e {\n\t\tself.get_mut (idx)\n\t}\n\n}\n\n/// Extra trait for [`GridStorage`] to support iteration.\n///\n/// This is a separate trait to make the lifetimes work. It should be implemented on a reference to\n/// the storage, rather than directly. This allows us to capture the lifetime without polluting the\n/// main trait.\n///\npub trait GridStorageIntoIter {\n\n\ttype Item;\n\ttype Iter: Iterator \u003cItem = Self::Item\u003e;\n\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter;\n\n}\n\nimpl \u003c'sto, Item\u003e GridStorageIntoIter for \u0026 'sto Vec \u003cItem\u003e where Item: Clone {\n\n\ttype Item = Item;\n\ttype Iter = GridStorageClone \u003cSliceIter \u003c'sto, Item\u003e\u003e;\n\n\t#[ inline ]\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter {\n\t\tGridStorageClone::new (self.iter ())\n\t}\n\n}\n\nimpl \u003c'sto, Item, Encoding\u003e GridStorageIntoIter for \u0026 'sto BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\n\ttype Item = Item;\n\ttype Iter = BitVecIter \u003c'sto, Item, Encoding\u003e;\n\n\t#[ inline ]\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter {\n\t\tself.iter ()\n\t}\n\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[35792],"length":1,"stats":{"Line":0},"fn_name":"storage_get\u003caoc_2020_day_03::model::Tile\u003e"},{"line":43,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":47,"address":[82768],"length":1,"stats":{"Line":0},"fn_name":"storage_set\u003caoc_2020_day_17::model::Tile\u003e"},{"line":48,"address":[107992,108632],"length":1,"stats":{"Line":32},"fn_name":null},{"line":52,"address":[82752],"length":1,"stats":{"Line":0},"fn_name":"storage_len\u003caoc_2020_day_17::model::Tile\u003e"},{"line":53,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[71760],"length":1,"stats":{"Line":0},"fn_name":"storage_iter\u003caoc_2018_day_18::model::Tile\u003e"},{"line":125,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":4,"coverable":26},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","transform.rs"],"content":"use super::*;\n\nimpl \u003c'grd, Storage, Pos, const DIMS: usize\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorage + Clone + FromIterator \u003c\u003cStorage as GridStorage\u003e::Item\u003e + 'grd,\n\t\tStorage::Item: Default,\n\t\t\u0026 'grd Storage: GridStorageIntoIter,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub fn resize (\u0026 'grd self, start: Pos, end: Pos) -\u003e NumResult \u003cSelf\u003e\n\t\t\twhere \u003cStorage as GridStorage\u003e::Item: Default {\n\t\tlet storage =\n\t\t\tGridKeysIter::new (start, end)\n\t\t\t\t.map (|pos| self.get (pos).unwrap_or_default ())\n\t\t\t\t.collect ();\n\t\tSelf::wrap_range (storage, start, end)\n\t}\n\n\t#[ inline ]\n\tpub fn extend_in_place (\u0026 'grd self, amts: [(Pos::Coord, Pos::Coord); DIMS]) -\u003e NumResult \u003cSelf\u003e\n\t\t\twhere \u003cStorage as GridStorage\u003e::Item: Default {\n\t\tlet mut start_arr = self.start ().to_array ();\n\t\tlet mut end_arr = self.end ().to_array ();\n\t\tfor dim_idx in 0 .. DIMS {\n\t\t\tchk! (start_arr [dim_idx] -= amts [dim_idx].0) ?;\n\t\t\tchk! (end_arr [dim_idx] += amts [dim_idx].1) ?;\n\t\t}\n\t\tself.resize (Pos::from_array (start_arr), Pos::from_array (end_arr))\n\t}\n\n}\n\npub struct GridTransformIter \u003cPos, const DIMS: usize\u003e\n\t\twhere Pos: GridPos \u003cDIMS\u003e {\n\tcursors: [GridCursor \u003cPos, DIMS\u003e; DIMS],\n\toffsets: [GridOffset \u003cPos, DIMS\u003e; DIMS],\n\tdone: bool,\n}\n\nimpl \u003cPos, const DIMS: usize\u003e GridTransformIter \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\t#[ inline ]\n\tpub const fn new (\n\t\tcursor: GridCursor \u003cPos, DIMS\u003e,\n\t\toffsets: [GridOffset \u003cPos, DIMS\u003e; DIMS],\n\t) -\u003e Self {\n\t\tlet cursors = [cursor; DIMS];\n\t\tSelf { cursors, offsets, done: false }\n\t}\n\n}\n\nimpl \u003cPos, const DIMS: usize\u003e Iterator\n\tfor GridTransformIter \u003cPos, DIMS\u003e\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Item = GridCursor \u003cPos, DIMS\u003e;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tif self.done { return None }\n\t\tlet result = self.cursors [DIMS - 1];\n\t\tfor idx_0 in (0 .. DIMS).rev () {\n\t\t\tif let Ok (cur) = self.cursors [idx_0].try_add (self.offsets [idx_0]) {\n\t\t\t\tfor idx_1 in idx_0 .. DIMS { self.cursors [idx_1] = cur; }\n\t\t\t\treturn Some (result);\n\t\t\t}\n\t\t}\n\t\tself.done = true;\n\t\tSome (result)\n\t}\n\n}\n","traces":[{"line":11,"address":[114368,114272],"length":1,"stats":{"Line":0},"fn_name":"resize\u003calloc::vec::Vec\u003caoc_2020_day_17::model::Tile, alloc::alloc::Global\u003e, aoc_pos::PosXYZW\u003ci8\u003e, 4\u003e"},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[75697],"length":1,"stats":{"Line":10},"fn_name":null},{"line":17,"address":[136136,137062],"length":1,"stats":{"Line":9},"fn_name":null},{"line":21,"address":[132080],"length":1,"stats":{"Line":4},"fn_name":"extend_in_place\u003calloc::vec::Vec\u003caoc_2020_day_20::model::Pixel, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e"},{"line":23,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[132122,132266],"length":1,"stats":{"Line":8},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":27,"address":[79868,79896],"length":1,"stats":{"Line":8},"fn_name":null},{"line":29,"address":[58440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[77184],"length":1,"stats":{"Line":0},"fn_name":"new\u003caoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e"},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":18,"coverable":23},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","grid","view.rs"],"content":"use super::*;\n\npub trait GridView \u003cPos, const DIMS: usize\u003e: Copy + Sized\n\twhere Pos: GridPos \u003cDIMS\u003e {\n\n\ttype Item;\n\ttype Cursors: Iterator \u003cItem = GridCursor \u003cPos, DIMS\u003e\u003e;\n\n\tfn start (self) -\u003e Pos;\n\tfn end (self) -\u003e Pos;\n\tfn size (self) -\u003e Pos;\n\n\tfn get_trusted (self, native: Pos, idx: usize) -\u003e Self::Item;\n\n\tfn cursors (self) -\u003e Self::Cursors;\n\n\t#[ inline ]\n\tfn len (self) -\u003e usize {\n\t\tself.size ().to_array ().into_iter ().map (Pos::Coord::qck_usize).product ()\n\t}\n\n\t#[ inline ]\n\tfn is_empty (self) -\u003e bool {\n\t\tself.size ().to_array ().into_iter ().any (|dim| dim == Pos::Coord::ZERO)\n\t}\n\n\t#[ inline ]\n\tfn keys (self) -\u003e GridKeysIter \u003cPos, DIMS\u003e {\n\t\tGridKeysIter::new (self.start (), self.end ())\n\t}\n\n\t#[ inline ]\n\tfn first_key (self) -\u003e Pos {\n\t\tself.start ()\n\t}\n\n\t#[ inline ]\n\tfn last_key (self) -\u003e Pos {\n\t\tlet mut last_arr = self.end ().to_array ();\n\t\tfor dim_idx in 0 .. DIMS { last_arr [dim_idx] -= Pos::Coord::ONE; }\n\t\tPos::from_array (last_arr)\n\t}\n\n\t#[ inline ]\n\tfn get (self, pos: Pos) -\u003e Option \u003cSelf::Item\u003e {\n\t\tlet native = pos.to_native (self.start ()) ?;\n\t\tlet idx = native.native_to_index (self.size ()) ?;\n\t\tSome (self.get_trusted (native, idx.qck_usize ()))\n\t}\n\n\t#[ inline ]\n\tfn get_native (self, native: Pos) -\u003e Option \u003cSelf::Item\u003e {\n\t\tlet idx = native.native_to_index (self.size ()) ?;\n\t\tSome (self.get_trusted (native, idx.qck_usize ()))\n\t}\n\n\t#[ inline ]\n\tfn offset (self, pos: Pos) -\u003e NumResult \u003cGridOffset \u003cPos, DIMS\u003e\u003e {\n\t\tGridOffset::new (self.size (), pos)\n\t}\n\n\t#[ inline ]\n\tfn cursor (self, pos: Pos) -\u003e Option \u003cGridCursor \u003cPos, DIMS\u003e\u003e {\n\t\tlet native = pos.to_native (self.start ()) ?;\n\t\tlet idx = native.native_to_index (self.size ()) ?;\n\t\tSome (GridCursor::new_grid (self, native, idx.qck_usize ()))\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tfn map \u003cStorage, MapFn, Output\u003e (self, map_fn: MapFn) -\u003e GridBuf \u003cStorage, Pos, DIMS\u003e\n\t\twhere\n\t\t\tMapFn: FnMut (GridCursor \u003cPos, DIMS\u003e) -\u003e Output,\n\t\t\tStorage: Clone + GridStorage + FromIterator \u003cOutput\u003e {\n\t\tlet storage = self.cursors ().map (map_fn).collect ();\n\t\tGridBuf::wrap_range (storage, self.start (), self.end ()).unwrap ()\n\t}\n\n\t#[ inline ]\n\tfn extend_map \u003cStorage, MapFn, Output\u003e (\n\t\tself,\n\t\tamts: [(Pos::Coord, Pos::Coord); DIMS],\n\t\tmap_fn: MapFn,\n\t) -\u003e NumResult \u003cGridBuf \u003cStorage, Pos, DIMS\u003e\u003e\n\t\twhere\n\t\t\tMapFn: FnMut (GridCursor \u003cPos, DIMS\u003e) -\u003e Output,\n\t\t\tStorage: Clone + GridStorage + FromIterator \u003cOutput\u003e,\n\t\t\tSelf::Item: Default {\n\t\tOk (self.extend (amts) ?.map (map_fn))\n\t}\n\n\t#[ inline ]\n\tfn try_map \u003cStorage, MapFn, Output, Error\u003e (\n\t\tself,\n\t\tmap_fn: MapFn,\n\t) -\u003e Result \u003cGridBuf \u003cStorage, Pos, DIMS\u003e, Error\u003e\n\t\twhere\n\t\t\tMapFn: FnMut (GridCursor \u003cPos, DIMS\u003e) -\u003e Result \u003cOutput, Error\u003e,\n\t\t\tStorage: Clone + GridStorage + FromIterator \u003cOutput\u003e {\n\t\tlet storage = self.cursors ().map (map_fn).try_collect () ?;\n\t\tOk (GridBuf::wrap_range (storage, self.start (), self.end ()).unwrap ())\n\t}\n\n\t#[ inline ]\n\tfn transform \u003cStorage\u003e (\n\t\tself,\n\t\tstart: Pos,\n\t\taxes: [impl Into \u003cPos\u003e; DIMS],\n\t) -\u003e NumResult \u003cGridBuf \u003cStorage, Pos, DIMS\u003e\u003e\n\t\twhere\n\t\t\tStorage: Clone + GridStorage + FromIterator \u003cSelf::Item\u003e,\n\t\t\tPos::Coord: IntSigned {\n\t\tif self.start () != Pos::default () { unimplemented! () }\n\t\tlet offsets: [GridOffset \u003cPos, DIMS\u003e; DIMS] = axes.into_iter ()\n\t\t\t.map (|axis| self.offset (axis.into ()))\n\t\t\t.try_array () ?;\n\t\tlet mut cur = self.cursor (self.first_key ()).unwrap ();\n\t\tfor offset in offsets {\n\t\t\tlet offset = - offset;\n\t\t\twhile cur.try_add_assign (offset).is_ok () { }\n\t\t}\n\t\tlet storage =\n\t\t\tGridTransformIter::new (cur, offsets)\n\t\t\t\t.map (|cur| cur.get (self))\n\t\t\t\t.collect ();\n\t\tlet size = Pos::from_array (offsets\n\t\t\t.map (|offset|\n\t\t\t\tstd::iter::successors (\n\t\t\t\t\t\tSome (cur),\n\t\t\t\t\t\t|\u0026 cur| cur.try_add (offset).ok ())\n\t\t\t\t\t.count ())\n\t\t\t.map (|val| Pos::Coord::from_usize (val).unwrap ()));\n\t\tlet end = Pos::from_array (\n\t\t\tstd::iter::zip (start.to_array (), size.to_array ())\n\t\t\t\t.map (|(start, size)| chk! (start + size))\n\t\t\t\t.try_array () ?);\n\t\tGridBuf::wrap_range (storage, start, end)\n\t}\n\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":26},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":29},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":105},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":85},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[111968,112192],"length":1,"stats":{"Line":0},"fn_name":"map\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_17::model::Tile, alloc::alloc::Global\u003e, aoc_pos::PosXYZW\u003ci8\u003e, 4\u003e, aoc_pos::PosXYZW\u003ci8\u003e, 4, alloc::vec::Vec\u003caoc_2020_day_17::model::Tile, alloc::alloc::Global\u003e, aoc_2020_day_17::logic::next_grid::{closure_env#3}\u003caoc_pos::PosXYZW\u003ci8\u003e, 4\u003e, aoc_2020_day_17::model::Tile\u003e"},{"line":75,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[128736,130380],"length":1,"stats":{"Line":1},"fn_name":"transform\u003c\u0026aoc_grid::buf::GridBuf\u003calloc::vec::Vec\u003caoc_2020_day_20::model::Pixel, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2\u003e, aoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 2, alloc::vec::Vec\u003caoc_2020_day_20::model::Pixel, alloc::alloc::Global\u003e, aoc_pos::dim_2::row_col::Dir2d\u003e"},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":25,"coverable":52},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","inpstr","inpstr.rs"],"content":"use aoc_misc::prelude::*;\n\n#[ derive (Clone) ]\npub enum InpStr \u003c'inp\u003e {\n\tBorrow (\u0026 'inp str),\n\tRefCount (Rc \u003cstr\u003e),\n}\n\nimpl InpStr \u003c'static\u003e {\n\n\t#[ inline ]\n\tpub fn alloc (val: impl AsRef \u003cstr\u003e) -\u003e Self {\n\t\tSelf::RefCount (Rc::from (val.as_ref ()))\n\t}\n\n}\n\nimpl \u003c'inp\u003e InpStr \u003c'inp\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn borrow (val: \u0026 'inp str) -\u003e Self {\n\t\tSelf::Borrow (val)\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn to_owned (\u0026 self) -\u003e String {\n\t\tself.deref ().to_owned ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn borrowed (\u0026 self) -\u003e \u0026 'inp str {\n\t\tmatch * self {\n\t\t\tSelf::Borrow (val) =\u003e val,\n\t\t\tSelf::RefCount (_) =\u003e panic! (\"Can't call borrowed () on an InpStr::RefCount\"),\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn as_str (\u0026 self) -\u003e \u0026 str {\n\t\tmatch * self {\n\t\t\tSelf::Borrow (val) =\u003e val,\n\t\t\tSelf::RefCount (ref val) =\u003e val,\n\t\t}\n\t}\n\n}\n\nimpl \u003c'inp\u003e Debug for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tDebug::fmt (\u0026 ** self, formatter)\n\t}\n}\n\nimpl \u003c'inp\u003e Deref for InpStr \u003c'inp\u003e {\n\ttype Target = str;\n\t#[ inline ]\n\tfn deref (\u0026 self) -\u003e \u0026 str {\n\t\tmatch * self {\n\t\t\tSelf::Borrow (val) =\u003e val,\n\t\t\tSelf::RefCount (ref val) =\u003e val,\n\t\t}\n\t}\n}\n\nimpl \u003c'inp\u003e Display for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tDisplay::fmt (\u0026 ** self, formatter)\n\t}\n}\n\nimpl \u003c'inp\u003e Eq for InpStr \u003c'inp\u003e {\n}\n\nimpl \u003c'inp\u003e From \u003c\u0026 'inp str\u003e for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn from (from: \u0026 'inp str) -\u003e Self {\n\t\tSelf::borrow (from)\n\t}\n}\n\nimpl \u003c'inp\u003e Hash for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn hash \u003cHshr: Hasher\u003e (\u0026 self, hasher: \u0026 mut Hshr) {\n\t\tself.deref ().hash (hasher);\n\t}\n}\n\nimpl \u003c'inp\u003e Ord for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tself.deref ().cmp (\u0026 ** other)\n\t}\n}\n\nimpl \u003c'inp\u003e PartialEq for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.deref ().eq (\u0026 ** other)\n\t}\n}\n\nimpl \u003c'inp\u003e PartialEq \u003c\u0026 str\u003e for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn eq (\u0026 self, other: \u0026\u0026 str) -\u003e bool {\n\t\tself.deref ().eq (* other)\n\t}\n}\n\nimpl \u003c'inp\u003e PartialEq \u003c\u0026 str\u003e for \u0026 InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn eq (\u0026 self, other: \u0026\u0026 str) -\u003e bool {\n\t\t(* self).deref ().eq (* other)\n\t}\n}\n\nimpl \u003c'inp\u003e PartialEq \u003cInpStr \u003c'inp\u003e\u003e for \u0026 str {\n\t#[ inline ]\n\tfn eq (\u0026 self, other: \u0026 InpStr \u003c'inp\u003e) -\u003e bool {\n\t\tself.eq (\u0026\u0026 ** other)\n\t}\n}\n\nimpl \u003c'inp\u003e PartialOrd for InpStr \u003c'inp\u003e {\n\t#[ inline ]\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tself.deref ().partial_cmp (\u0026 ** other)\n\t}\n}\n\n// conversions to other types\n\nimpl \u003c'inp\u003e From \u003cInpStr \u003c'inp\u003e\u003e for Rc \u003cstr\u003e {\n\t#[ inline ]\n\tfn from (val: InpStr \u003c'inp\u003e) -\u003e Self {\n\t\tmatch val {\n\t\t\tInpStr::Borrow (val) =\u003e Self::from (val),\n\t\t\tInpStr::RefCount (val) =\u003e val,\n\t\t}\n\t}\n}\n\nimpl \u003c'inp\u003e From \u003cInpStr \u003c'inp\u003e\u003e for String {\n\t#[ inline ]\n\tfn from (val: InpStr \u003c'inp\u003e) -\u003e Self {\n\t\tval.to_owned ()\n\t}\n}\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":188},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":7,"coverable":44},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","list","list.rs"],"content":"//! Implementation of lisp-like lists\n//!\n//! A list is represented as the first list item and a reference to another list to represent the\n//! remaining items - these are referred to as the \"head\" and the \"tail\". There is a special case\n//! for the empty list.\n//!\n//! While this is much less efficient than a [`Vec`], it allows reuse in a way which can be very\n//! beneficial for certain types of algorithm. Adding new items to a list only creates one new\n//! allocation per item, and removing any number of items from the start of the list requires no\n//! allocation.\n//!\n//! We also declare [`CharList`] as `List \u003cchar\u003e`, and implement some extra methods and traits to\n//! make it work nicely with [`String`] and [`prim@str`].\n\nuse aoc_misc::prelude::*;\n\npub use base_list::List;\npub use char_list::CharList;\n\nmod base_list {\n\n\tuse super::*;\n\n\tpub enum List \u003cItem\u003e {\n\t\tEmpty,\n\t\tPresent (Rc \u003c(Item, List \u003cItem\u003e)\u003e),\n\t}\n\n\timpl \u003cItem: Clone\u003e List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn new () -\u003e Self { Self::Empty }\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn cons (\u0026 self) -\u003e Option \u003c(\u0026 Item, \u0026 Self)\u003e {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Present (ref inner) =\u003e {\n\t\t\t\t\tlet (ref head, ref tail) = * inner.as_ref ();\n\t\t\t\t\tSome ((head, tail))\n\t\t\t\t},\n\t\t\t\tSelf::Empty =\u003e None,\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn head (\u0026 self) -\u003e Option \u003c\u0026 Item\u003e {\n\t\t\tself.cons ().map (|(head, _)| head)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn tail (\u0026 self) -\u003e Option \u003c\u0026 Self\u003e {\n\t\t\tself.cons ().map (|(_, tail)| tail)\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\t\tself.cons ().is_none ()\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn len (\u0026 self) -\u003e usize {\n\t\t\tlet mut cur = self.clone ();\n\t\t\tlet mut len = 0;\n\t\t\twhile let Self::Present (inner) = cur {\n\t\t\t\tlet (_, ref new) = * inner.as_ref ();\n\t\t\t\tcur = new.clone ();\n\t\t\t\tlen += 1;\n\t\t\t}\n\t\t\tlen\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn with_push_front (\u0026 self, head: Item) -\u003e Self {\n\t\t\tSelf::Present (Rc::new ((head, self.clone ())))\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub const fn iter (\u0026 self) -\u003e ListIter \u003cItem\u003e {\n\t\t\tListIter { list: self }\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn contains (\u0026 self, item: \u0026 Item) -\u003e bool\n\t\t\t\twhere Item: Eq {\n\t\t\tlet mut cur = self.clone ();\n\t\t\twhile let Self::Present (ref inner) = cur {\n\t\t\t\tlet (ref head, ref tail) = * inner.as_ref ();\n\t\t\t\tif head == item { return true }\n\t\t\t\tcur = tail.clone ();\n\t\t\t}\n\t\t\tfalse\n\t\t}\n\n\t}\n\n\timpl \u003cItem: Clone + Debug\u003e Debug for List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"[\") ?;\n\t\t\tlet mut cur = self;\n\t\t\tlet mut idx = 0_usize;\n\t\t\twhile let Some ((head, tail)) = cur.cons () {\n\t\t\t\tif idx \u003e 0 { write! (formatter, \", \") ?; }\n\t\t\t\tDebug::fmt (\u0026 head, formatter) ?;\n\t\t\t\tcur = tail;\n\t\t\t\tidx += 1;\n\t\t\t}\n\t\t\twrite! (formatter, \"]\") ?;\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\timpl \u003cItem: Clone\u003e Clone for List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn clone (\u0026 self) -\u003e Self {\n\t\t\tmatch * self {\n\t\t\t\tSelf::Present (ref inner) =\u003e Self::Present (Rc::clone (inner)),\n\t\t\t\tSelf::Empty =\u003e Self::Empty,\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl \u003cItem: Clone + PartialEq\u003e PartialEq for List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\t\tlet mut left = self;\n\t\t\tlet mut right = other;\n\t\t\tloop {\n\t\t\t\tmatch (left.cons (), right.cons ()) {\n\t\t\t\t\t(None, None) =\u003e return true,\n\t\t\t\t\t(Some (_), None) | (None, Some (_)) =\u003e return false,\n\t\t\t\t\t(Some ((left_head, left_tail)), Some ((right_head, right_tail))) =\u003e {\n\t\t\t\t\t\tif ! Item::eq (left_head, right_head) { return false }\n\t\t\t\t\t\t(left, right) = (left_tail, right_tail);\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl \u003cItem\u003e PartialOrd for List \u003cItem\u003e where Item: Clone + PartialOrd {\n\t\t#[ inline ]\n\t\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\t\tlet mut left = self;\n\t\t\tlet mut right = other;\n\t\t\tloop {\n\t\t\t\tmatch (left.cons (), right.cons ()) {\n\t\t\t\t\t(None, None) =\u003e return Some (Ordering::Equal),\n\t\t\t\t\t(None, Some (_)) =\u003e return Some (Ordering::Less),\n\t\t\t\t\t(Some (_), None) =\u003e return Some (Ordering::Greater),\n\t\t\t\t\t(Some ((left_head, left_tail)), Some ((right_head, right_tail))) =\u003e {\n\t\t\t\t\t\tmatch left_head.partial_cmp (right_head) {\n\t\t\t\t\t\t\tSome (Ordering::Equal) =\u003e {\n\t\t\t\t\t\t\t\tleft = left_tail;\n\t\t\t\t\t\t\t\tright = right_tail;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tSome (Ordering::Greater) =\u003e return Some (Ordering::Greater),\n\t\t\t\t\t\t\tSome (Ordering::Less) =\u003e return Some (Ordering::Less),\n\t\t\t\t\t\t\tNone =\u003e return None,\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\timpl \u003cItem\u003e Ord for List \u003cItem\u003e where Item: Clone + Ord {\n\t\t#[ inline ]\n\t\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\t\tlet mut left = self;\n\t\t\tlet mut right = other;\n\t\t\tloop {\n\t\t\t\tmatch (left.cons (), right.cons ()) {\n\t\t\t\t\t(None, None) =\u003e return Ordering::Equal,\n\t\t\t\t\t(None, Some (_)) =\u003e return Ordering::Less,\n\t\t\t\t\t(Some (_), None) =\u003e return Ordering::Greater,\n\t\t\t\t\t(Some ((left_head, left_tail)), Some ((right_head, right_tail))) =\u003e {\n\t\t\t\t\t\tmatch left_head.cmp (right_head) {\n\t\t\t\t\t\t\tOrdering::Equal =\u003e {\n\t\t\t\t\t\t\t\tleft = left_tail;\n\t\t\t\t\t\t\t\tright = right_tail;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tOrdering::Greater =\u003e return Ordering::Greater,\n\t\t\t\t\t\t\tOrdering::Less =\u003e return Ordering::Less,\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\timpl \u003cItem: Clone + Eq\u003e Eq for List \u003cItem\u003e { }\n\n\timpl \u003cItem: Clone + Hash\u003e Hash for List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tfn hash \u003cHshr: Hasher\u003e (\u0026 self, hasher: \u0026 mut Hshr) {\n\t\t\tlet mut cur = self;\n\t\t\twhile let Some ((head, tail)) = cur.cons () {\n\t\t\t\thead.hash (hasher);\n\t\t\t\tcur = tail;\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl Display for List \u003cchar\u003e {\n\n\t\t#[ inline ]\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet mut cur = self.clone ();\n\t\t\twhile let Self::Present (inner) = cur {\n\t\t\t\tlet \u0026 (head, ref tail) = inner.as_ref ();\n\t\t\t\twrite! (formatter, \"{}\", head) ?;\n\t\t\t\tcur = tail.clone ();\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n\tpub struct ListIter \u003c'dat, Item: Clone\u003e {\n\t\tlist: \u0026 'dat List \u003cItem\u003e,\n\t}\n\n\timpl \u003c'dat, Item: Clone\u003e Iterator for ListIter \u003c'dat, Item\u003e {\n\t\ttype Item = \u0026 'dat Item;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003c\u0026 'dat Item\u003e {\n\t\t\tself.list.cons ().map (|(head, tail)| {\n\t\t\t\tself.list = tail;\n\t\t\t\thead\n\t\t\t})\n\t\t}\n\t}\n\n}\n\nmod char_list {\n\n\tuse super::*;\n\n\tpub type CharList = List \u003cchar\u003e;\n\n\timpl CharList {\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn starts_with (\u0026 self, pat: \u0026 str) -\u003e bool {\n\t\t\tself.strip_prefix (pat).is_some ()\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn strip_prefix (\u0026 self, pat: \u0026 str) -\u003e Option \u003c\u0026 Self\u003e {\n\t\t\tlet mut cur = self;\n\t\t\tlet mut pat_chars = pat.chars ();\n\t\t\tloop {\n\t\t\t\tmatch (cur.cons (), pat_chars.next ()) {\n\t\t\t\t\t(_, None) =\u003e return Some (cur),\n\t\t\t\t\t(None, _) =\u003e return None,\n\t\t\t\t\t(Some ((\u0026 head, tail)), Some (pat_ch)) =\u003e {\n\t\t\t\t\t\tif head != pat_ch { return None }\n\t\t\t\t\t\tcur = tail;\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tpub fn prepend (\u0026 self, prefix: \u0026 str) -\u003e Self {\n\t\t\tlet mut cur = self.clone ();\n\t\t\tfor prefix_ch in prefix.chars ().rev () {\n\t\t\t\tcur = cur.with_push_front (prefix_ch);\n\t\t\t}\n\t\t\tcur\n\t\t}\n\n\t}\n\n\timpl From \u003c\u0026 str\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn from (src: \u0026 str) -\u003e Self {\n\t\t\tSelf::Empty.prepend (src)\n\t\t}\n\t}\n\n\timpl From \u003c\u0026 String\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn from (src: \u0026 String) -\u003e Self {\n\t\t\tSelf::Empty.prepend (src)\n\t\t}\n\t}\n\n\timpl PartialEq \u003cstr\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 str) -\u003e bool {\n\t\t\tlet mut cur = self;\n\t\t\tlet mut other_iter = other.chars ();\n\t\t\tloop {\n\t\t\t\tmatch (cur.cons (), other_iter.next ()) {\n\t\t\t\t\t(Some (_), None) | (None, Some (_)) =\u003e return false,\n\t\t\t\t\t(None, None) =\u003e return true,\n\t\t\t\t\t(Some ((\u0026 cur_head, cur_tail)), Some (other_ch)) =\u003e {\n\t\t\t\t\t\tif cur_head != other_ch { return false }\n\t\t\t\t\t\tcur = cur_tail;\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\timpl PartialEq \u003cString\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 String) -\u003e bool {\n\t\t\tPartialEq::eq (self, other.as_str ())\n\t\t}\n\t}\n\n\timpl PartialEq \u003cCharList\u003e for \u0026 String {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 CharList) -\u003e bool {\n\t\t\tPartialEq::eq (self.as_str (), other)\n\t\t}\n\t}\n\n\timpl PartialEq \u003cCharList\u003e for str {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 CharList) -\u003e bool {\n\t\t\tPartialEq::eq (other, self)\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\t\tuse CharList as CL;\n\n\t\tfn cl (src: \u0026 str) -\u003e CL { CL::from (src) }\n\n\t\tconst SAMPLES: \u0026 [\u0026 str] = \u0026 [ \"\", \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\" ];\n\n\t\t#[ test ]\n\t\tfn eq () {\n\t\t\tfor left in SAMPLES.iter ().cloned () {\n\t\t\t\tfor right in SAMPLES.iter ().cloned () {\n\t\t\t\t\tif left == right {\n\t\t\t\t\t\tassert! (cl (left) == cl (right),\n\t\t\t\t\t\t\t\"{:?} == {:?} but CharList::from ({:?}) != CharList::from ({:?})\",\n\t\t\t\t\t\t\tleft, right, left, right);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert! (cl (left) != cl (right),\n\t\t\t\t\t\t\t\"{:?} != {:?} but CharList::from ({:?}) == CharList::from ({:?})\",\n\t\t\t\t\t\t\tleft, right, left, right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#[ test ]\n\t\tfn strip_prefix () {\n\t\t\tfor left in SAMPLES.iter ().cloned () {\n\t\t\t\tfor right in SAMPLES.iter ().cloned () {\n\t\t\t\t\tlet expected = left.strip_prefix (right);\n\t\t\t\t\tlet actual = cl (left).strip_prefix (right).cloned ();\n\t\t\t\t\tassert_eq! (expected.map (cl), actual,\n\t\t\t\t\t\t\"{:?}.strip_prefix ({:?}) == {:?} but {:?}.strip_prefix ({:?}) == {:?}\",\n\t\t\t\t\t\tleft, right, expected, cl (left), right, actual);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":33,"address":[37808],"length":1,"stats":{"Line":0},"fn_name":"new\u003calloc::string::String\u003e"},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[9120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[9056,9060],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":360,"address":[9260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":361,"address":[9335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":362,"address":[9375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[9538,9523,9561,9626,9928,9760],"length":1,"stats":{"Line":4},"fn_name":null},{"line":367,"address":[9900,9419,9494,9943,9396,9381,9793],"length":1,"stats":{"Line":4},"fn_name":null},{"line":376,"address":[9088,9092],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":377,"address":[10058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[10136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[10151,10225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[10860,10354,10235,10257],"length":1,"stats":{"Line":3},"fn_name":null},{"line":381,"address":[10515,10620,10880,10384,10374,10418],"length":1,"stats":{"Line":4},"fn_name":null},{"line":383,"address":[10610,10588],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":31,"coverable":153},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","md5","md5.rs"],"content":"use std::cmp;\nuse std::fmt::{ self, Debug, Display, Write as _ };\nuse std::ops::Index;\n\n#[ cfg (test) ] use aoc_misc::*;\nuse aoc_nums as nums;\nuse nums::IntConv;\n\n#[ derive (Clone, Copy, Default, Eq, PartialEq) ]\npub struct Output ([u8; 16]);\n\n#[ inline ]\n#[ must_use ]\npub fn md5_hash (input: \u0026 [u8]) -\u003e Output {\n\tlet mut md5 = MD5::new ();\n\tmd5.update (input);\n\tmd5.finish ()\n}\n\npub struct MD5 {\n\tstate: State,\n\tmessage: [u8; 64],\n\tmessage_len: usize,\n\tlen: usize,\n}\n\ntype State = [u32; 4];\n\nimpl Output {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn len (\u0026 self) -\u003e usize {\n\t\tself.0.len ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.0.is_empty ()\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tpub fn from_hex (input: \u0026 str) -\u003e Result \u003cSelf, String\u003e {\n\t\tlet input_len = input.chars ().count ();\n\t\tif input_len != 32 { return Err (format! (\"Expected 32 chars, not {}\", input_len)) }\n\t\tlet mut result = [0; 16];\n\t\tlet mut input_iter = input.chars ();\n\t\tfor result_ch in result.iter_mut () {\n\t\t\tlet high_ch = input_iter.next ().unwrap ();\n\t\t\tlet low_ch = input_iter.next ().unwrap ();\n\t\t\tlet decode = |ch: char| ch.to_digit (16).ok_or (format! (\"Invalid hex: {}\", ch));\n\t\t\t* result_ch = (decode (high_ch) ?.qck_u8 ()) \u003c\u003c 4_i32 | decode (low_ch) ?.qck_u8 ();\n\t\t}\n\t\tOk (Self (result))\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn num_zeros (\u0026 self) -\u003e u8 {\n\t\tlet mut result = 0;\n\t\tfor byte in self.0.iter ().copied () {\n\t\t\tif byte \u0026 0xf0 != 0 { break }\n\t\t\tresult += 1;\n\t\t\tif byte \u0026 0x0f != 0 { break }\n\t\t\tresult += 1;\n\t\t}\n\t\tresult\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn as_hex_bytes (\u0026 self) -\u003e [u8; 32] {\n\t\t#[ inline ]\n\t\tconst fn nibble_as_hex (nibble: u8) -\u003e u8 {\n\t\t\tif nibble \u003e= 10 { b'a' + nibble - 10 } else { b'0' + nibble }\n\t\t}\n\t\tlet mut result = [0; 32];\n\t\tlet mut result_iter = result.iter_mut ();\n\t\tfor byte in self.0.iter () {\n\t\t\t* result_iter.next ().unwrap () = nibble_as_hex (byte \u003e\u003e 4_u32);\n\t\t\t* result_iter.next ().unwrap () = nibble_as_hex (byte \u0026 0xf);\n\t\t}\n\t\tresult\n\t}\n\n}\n\nimpl Index \u003cusize\u003e for Output {\n\n\ttype Output = u8;\n\n\t#[ inline ]\n\tfn index (\u0026 self, idx: usize) -\u003e \u0026 u8 {\n\t\t\u0026 self.0 [idx]\n\t}\n\n}\n\nimpl Debug for Output {\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.write_str (\"md5::Output (\\\"\") ?;\n\t\tDisplay::fmt (self, formatter) ?;\n\t\tformatter.write_str (\"\\\")\") ?;\n\t\tOk (())\n\t}\n\n}\n\nimpl Display for Output {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor byte in self.0.iter ().copied () {\n\t\t\tlet byte = byte.pan_u32 ();\n\t\t\tformatter.write_char (char::from_digit (byte \u003e\u003e 4, 16).unwrap ()) ?;\n\t\t\tformatter.write_char (char::from_digit (byte \u0026 0xf, 16).unwrap ()) ?;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\nimpl MD5 {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn new () -\u003e Self {\n\t\tSelf {\n\t\t\tstate: INITIAL_STATE,\n\t\t\tmessage: [0; 64],\n\t\t\tmessage_len: 0,\n\t\t\tlen: 0,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn reset (\u0026 mut self) {\n\t\tself.state = INITIAL_STATE;\n\t\tself.message_len = 0;\n\t\tself.len = 0;\n\t}\n\n\t#[ inline ]\n\tpub fn push (\u0026 mut self, byte: u8) {\n\t\tself.message [self.message_len] = byte;\n\t\tself.message_len += 1;\n\t\tif self.message_len == 64 {\n\t\t\tself.apply ();\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn update (\u0026 mut self, mut message: \u0026 [u8]) {\n\n\t\t// iterate over message\n\n\t\twhile ! message.is_empty () {\n\n\t\t\t// copy max sized chunk to buffer\n\n\t\t\tlet bytes = cmp::min (64 - self.message_len, message.len ());\n\t\t\tself.message [self.message_len .. self.message_len + bytes].copy_from_slice (\u0026 message [ .. bytes]);\n\t\t\tself.message_len += bytes;\n\t\t\tmessage = \u0026 message [bytes .. ];\n\t\t\tself.len = self.len.wrapping_add (bytes \u003c\u003c 3);\n\n\t\t\t// stop now if buffer is part filled\n\n\t\t\tif self.message_len != 64 { return }\n\n\t\t\t// consume buffer\n\n\t\t\tself.apply ();\n\n\t\t}\n\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn finish (mut self) -\u003e Output {\n\t\tself.finish_real ()\n\t}\n\n\t#[ inline ]\n\tpub fn finish_reset (\u0026 mut self) -\u003e Output {\n\t\tlet output = self.finish_real ();\n\t\tself.reset ();\n\t\toutput\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t#[ must_use ]\n\tfn finish_real (\u0026 mut self) -\u003e Output {\n\n\t\t// remember the length before padding\n\n\t\tlet len = self.len;\n\n\t\t// add one then zeros, leaving exactly 56 bytes buffered\n\n\t\tself.push (0x80);\n\t\tif self.message_len \u003e 56 {\n\t\t\tfor idx in self.message_len .. 64 { self.message [idx] = 0; }\n\t\t\tself.message_len = 64;\n\t\t\tself.apply ();\n\t\t}\n\t\tfor idx in self.message_len .. 56 { self.message [idx] = 0; }\n\t\tself.message_len = 56;\n\n\t\t// then the length, which takes us to 64 bytes\n\n\t\tself.message [56 .. 64].copy_from_slice (\u0026 len.to_le_bytes ());\n\t\tself.message_len += 8;\n\t\tself.apply ();\n\n\t\t// convert result words to byte array\n\n\t\tassert! (self.message_len == 0);\n\n\t\tlet mut result = [0; 16];\n\t\tfor src_idx in 0 .. 4 {\n\t\t\tlet dst_idx = src_idx \u003c\u003c 2_i32;\n\t\t\tresult [dst_idx] = (self.state [src_idx] \u0026 0xff).qck_u8 ();\n\t\t\tresult [dst_idx + 1] = (self.state [src_idx] \u003e\u003e 8_i32 \u0026 0xff).qck_u8 ();\n\t\t\tresult [dst_idx + 2] = (self.state [src_idx] \u003e\u003e 16_i32 \u0026 0xff).qck_u8 ();\n\t\t\tresult [dst_idx + 3] = (self.state [src_idx] \u003e\u003e 24_i32 \u0026 0xff).qck_u8 ();\n\t\t}\n\n\t\tOutput (result)\n\n\t}\n\n\tfn apply (\u0026 mut self) {\n\n\t\t// convert message buffer into words\n\n\t\tassert! (self.message_len == 64);\n\n\t\tlet mut message = [0; 16];\n\t\t#[ allow (clippy::needless_range_loop) ]\n\t\tfor dst_idx in 0_usize .. 16_usize {\n\t\t\tlet src_idx = dst_idx \u003c\u003c 2_u32;\n\t\t\tmessage [dst_idx] = u32::from_le_bytes (\n\t\t\t\tself.message [src_idx .. src_idx + 4].try_into ().unwrap ());\n\t\t}\n\n\t\t// apply rounds as specified\n\n\t\tlet [mut a, mut b, mut c, mut d] = self.state;\n\n\t\tfor op in 0 .. 16 {\n\t\t\tlet func = ((b \u0026 c) | (! b \u0026 d))\n\t\t\t\t.wrapping_add (a)\n\t\t\t\t.wrapping_add (ADDS [op])\n\t\t\t\t.wrapping_add (message [op]);\n\t\t\t(a, b, c, d) = (d, b.wrapping_add (func.rotate_left (ROTATES [op].qck_u32 ())), b, c);\n\t\t}\n\n\t\tfor op in 16 .. 32 {\n\t\t\tlet func = ((d \u0026 b) | (! d \u0026 c))\n\t\t\t\t.wrapping_add (a)\n\t\t\t\t.wrapping_add (ADDS [op])\n\t\t\t\t.wrapping_add (message [(5 * op + 1) % 16]);\n\t\t\t(a, b, c, d) = (d, b.wrapping_add (func.rotate_left (ROTATES [op].qck_u32 ())), b, c);\n\t\t}\n\n\t\tfor op in 32 .. 48 {\n\t\t\tlet func = (b ^ c ^ d)\n\t\t\t\t.wrapping_add (a)\n\t\t\t\t.wrapping_add (ADDS [op])\n\t\t\t\t.wrapping_add (message [(3 * op + 5) % 16]);\n\t\t\t(a, b, c, d) = (d, b.wrapping_add (func.rotate_left (ROTATES [op].qck_u32 ())), b, c);\n\t\t}\n\n\t\tfor op in 48 .. 64 {\n\t\t\tlet func = (c ^ (b | ! d))\n\t\t\t\t.wrapping_add (a)\n\t\t\t\t.wrapping_add (ADDS [op])\n\t\t\t\t.wrapping_add (message [7 * op % 16]);\n\t\t\t(a, b, c, d) = (d, b.wrapping_add (func.rotate_left (ROTATES [op].qck_u32 ())), b, c);\n\t\t}\n\n\t\tself.state = [\n\t\t\tself.state [0].wrapping_add (a),\n\t\t\tself.state [1].wrapping_add (b),\n\t\t\tself.state [2].wrapping_add (c),\n\t\t\tself.state [3].wrapping_add (d),\n\t\t];\n\n\t\t// clear buffer\n\n\t\tself.message_len = 0;\n\n\t}\n\n}\n\nimpl Default for MD5 {\n\n\t#[ inline ]\n\tfn default () -\u003e Self {\n\t\tSelf::new ()\n\t}\n\n}\n\nconst INITIAL_STATE: State = [ 0x_6745_2301, 0x_efcd_ab89, 0x_98ba_dcfe, 0x_1032_5476 ];\n\nconst ROTATES: [u8; 64] = [\n\t7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n\t5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,\n\t4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n\t6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\nconst ADDS: [u32; 64] = [\n\t0x_d76a_a478, 0x_e8c7_b756, 0x_2420_70db, 0x_c1bd_ceee, 0x_f57c_0faf, 0x_4787_c62a,\n\t0x_a830_4613, 0x_fd46_9501, 0x_6980_98d8, 0x_8b44_f7af, 0x_ffff_5bb1, 0x_895c_d7be,\n\t0x_6b90_1122, 0x_fd98_7193, 0x_a679_438e, 0x_49b4_0821, 0x_f61e_2562, 0x_c040_b340,\n\t0x_265e_5a51, 0x_e9b6_c7aa, 0x_d62f_105d, 0x_0244_1453, 0x_d8a1_e681, 0x_e7d3_fbc8,\n\t0x_21e1_cde6, 0x_c337_07d6, 0x_f4d5_0d87, 0x_455a_14ed, 0x_a9e3_e905, 0x_fcef_a3f8,\n\t0x_676f_02d9, 0x_8d2a_4c8a, 0x_fffa_3942, 0x_8771_f681, 0x_6d9d_6122, 0x_fde5_380c,\n\t0x_a4be_ea44, 0x_4bde_cfa9, 0x_f6bb_4b60, 0x_bebf_bc70, 0x_289b_7ec6, 0x_eaa1_27fa,\n\t0x_d4ef_3085, 0x_0488_1d05, 0x_d9d4_d039, 0x_e6db_99e5, 0x_1fa2_7cf8, 0x_c4ac_5665,\n\t0x_f429_2244, 0x_432a_ff97, 0x_ab94_23a7, 0x_fc93_a039, 0x_655b_59c3, 0x_8f0c_cc92,\n\t0x_ffef_f47d, 0x_8584_5dd1, 0x_6fa8_7e4f, 0x_fe2c_e6e0, 0x_a301_4314, 0x_4e08_11a1,\n\t0x_f753_7e82, 0x_bd3a_f235, 0x_2ad7_d2bb, 0x_eb86_d391,\n];\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tconst LOREM_IPSUM: \u0026 str =\n\t\t\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut at tempus ligula, ac \\\n\t\tpellentesque leo. Nullam molestie justo sit amet neque venenatis, at laoreet urna \\\n\t\tmollis. Mauris eget mollis quam. Maecenas ultricies odio dolor, id luctus lorem \\\n\t\taliquam at. Vestibulum est lectus, egestas vehicula mi vel, pharetra elementum \\\n\t\tligula. Nam cursus, magna vitae sodales pretium, metus ligula facilisis nisl, pretium \\\n\t\taccumsan leo justo sed elit. Vestibulum efficitur justo quis molestie luctus. Aliquam \\\n\t\tvolutpat at quam quis egestas. Proin et turpis nec lacus maximus iaculis. Donec vitae \\\n\t\tmassa magna. Nulla pulvinar eleifend erat et fringilla.\";\n\n\tmacro_rules! assert_md5 {\n\t\t( $expect:expr , $input:expr ) =\u003e {\n\t\t\tassert_eq! (\n\t\t\t\tOutput::from_hex ($expect).unwrap (),\n\t\t\t\tmd5_hash ($input.as_bytes ()));\n\t\t}\n\t}\n\n\t#[ test ]\n\tfn test_md5_hash () {\n\t\tassert_md5! (\"d41d8cd98f00b204e9800998ecf8427e\", \"\");\n\t\tassert_md5! (\"6cd3556deb0da54bca060b4c39479839\", \"Hello, world!\");\n\t\tassert_md5! (\"7bb31841cf426a6de079421b2590cf82\", \"The Ideal Stocking Stuffer\");\n\t\tassert_md5! (\"777f5a5ebdeab74ab0299512f9688be0\", LOREM_IPSUM);\n\t}\n\n\t#[ test ]\n\tfn test_output () {\n\t\tlet output = Output::from_hex (\"0123456789abcdef0123456789abcdef\").unwrap ();\n\t\tassert_eq! (16, output.len ());\n\t\tassert_eq! (false, output.is_empty ());\n\t\tassert_eq! (0x01, output [0]);\n\t\tassert_eq! (0xef, output [15]);\n\t\tassert_eq! (\"md5::Output (\\\"0123456789abcdef0123456789abcdef\\\")\", format! (\"{:?}\", output));\n\t\tassert_eq! (\"0123456789abcdef0123456789abcdef\", format! (\"{}\", output));\n\t\tassert_err! (\"Expected 32 chars, not 31\", Output::from_hex (\"0123456789abcdef0123456789abcde\"));\n\t\tassert_err! (\"Expected 32 chars, not 33\", Output::from_hex (\"0123456789abcdef0123456789abcdef0\"));\n\t\tassert_err! (\"Invalid hex: X\", Output::from_hex (\"0123456789abcdeX0123456789abcdef\"));\n\t}\n\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[16448],"length":1,"stats":{"Line":1},"fn_name":"from_hex"},{"line":45,"address":[16496,16632],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[16640,16504,16604],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[16658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[17163,17388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[16726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[17523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[17728],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":104,"address":[9039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[9159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[18320],"length":1,"stats":{"Line":1},"fn_name":"finish_real"},{"line":206,"address":[18378,18561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[18596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[18604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[18611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[18410,18619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[18422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[18429],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[18684,18437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[18488,18458,18447,18513],"length":1,"stats":{"Line":4},"fn_name":null},{"line":229,"address":[18462,18531,18507,18482],"length":1,"stats":{"Line":4},"fn_name":null},{"line":230,"address":[18517,18451,18534,18465,18485,18492,18510],"length":1,"stats":{"Line":7},"fn_name":null},{"line":233,"address":[18537,18494,18470,18453,18519],"length":1,"stats":{"Line":5},"fn_name":null},{"line":237,"address":[18720],"length":1,"stats":{"Line":1},"fn_name":"apply"},{"line":241,"address":[20801,18737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[19100,18750,18816,19354,19224,18980,18898,19397,19056,19176,19017,18861,19264,19310,19138],"length":1,"stats":{"Line":15},"fn_name":null},{"line":253,"address":[18767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[19084,18783,19003,19247,19292,19375,19391,19042,19161,18939,19335,18831,18966,18868,19123,19207,18910],"length":1,"stats":{"Line":17},"fn_name":null},{"line":264,"address":[19735,19578,19473,19484,19797,19555,19774,19877,19454,19615,19745,19764,19901,19386,19643,19867,19911,19841,19545,19699,19446,19588,19633,19677,19807,19605,19831,19667,19709,19512,19523,19425],"length":1,"stats":{"Line":32},"fn_name":null},{"line":272,"address":[20145,19935,20049,20225,20305,20198,20172,20122,19979,19958,20002,20024,20251,20071,20277,20094],"length":1,"stats":{"Line":16},"fn_name":null},{"line":280,"address":[20404,20480,20531,20609,20664,20455,20505,20716,20559,20376,20326,20431,20637,20351,20584,20692],"length":1,"stats":{"Line":16},"fn_name":null},{"line":287,"address":[20755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[20775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[13280],"length":1,"stats":{"Line":2},"fn_name":"test_md5_hash"},{"line":359,"address":[13288,13457,14224],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[13463,13684,14319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":361,"address":[13690,13911,14411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[13917,14138,14500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[11908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":367,"address":[14667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[14710,15912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[14721,15947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[14737,16220,15637,14856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[14891,15680,16207,15013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[15723,15169,15045,16186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":375,"address":[15768,15385,15231,16163],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[15810,16140,15447,15563],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":79,"coverable":109},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","misc","collections","test_map.rs"],"content":"use super::*;\n\npub struct HashMap \u003cKey, Val, Hshr = RandomHasher\u003e {\n\tmap: BTreeMap \u003cKey, Val\u003e,\n\tphantom: PhantomData \u003cHshr\u003e,\n}\n\nimpl \u003cKey, Val, Hshr\u003e HashMap \u003cKey, Val, Hshr\u003e\n\twhere Key: Ord {\n\n\tpub fn new () -\u003e Self {\n\t\tSelf {\n\t\t\tmap: BTreeMap::new (),\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\n\tpub fn with_capacity (_capacity: usize) -\u003e Self {\n\t\tSelf::new ()\n\t}\n\n\tpub fn clear (\u0026 mut self) {\n\t\tself.map.clear ();\n\t}\n\n\tpub fn contains_key \u003cQry\u003e (\u0026 self, key: \u0026 Qry) -\u003e bool\n\t\twhere\n\t\t\tKey: Borrow \u003cQry\u003e,\n\t\t\tQry: Eq + Hash + Ord + ?Sized {\n\t\tself.map.contains_key (key)\n\t}\n\n\tpub fn get \u003cQry\u003e (\u0026 self, key: \u0026 Qry) -\u003e Option \u003c\u0026 Val\u003e\n\t\twhere\n\t\t\tKey: Borrow \u003cQry\u003e,\n\t\t\tQry: Eq + Hash + Ord + ?Sized {\n\t\tself.map.get (key)\n\t}\n\n\tpub fn get_mut \u003cQry\u003e (\u0026 mut self, key: \u0026 Qry) -\u003e Option \u003c\u0026 mut Val\u003e\n\t\twhere\n\t\t\tKey: Borrow \u003cQry\u003e,\n\t\t\tQry: Eq + Hash + Ord + ?Sized {\n\t\tself.map.get_mut (key)\n\t}\n\n\tpub fn entry (\u0026 mut self, key: Key) -\u003e BTreeEntry \u003c'_, Key, Val\u003e {\n\t\tself.map.entry (key)\n\t}\n\n\tpub fn insert (\u0026 mut self, key: Key, val: Val) -\u003e Option \u003cVal\u003e {\n\t\tself.map.insert (key, val)\n\t}\n\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.map.is_empty ()\n\t}\n\n\tpub fn iter (\u0026 self) -\u003e BTreeIter \u003c'_, Key, Val\u003e {\n\t\tself.map.iter ()\n\t}\n\n\tpub fn iter_mut (\u0026 mut self) -\u003e BTreeIterMut \u003c'_, Key, Val\u003e {\n\t\tself.map.iter_mut ()\n\t}\n\n\tpub fn keys (\u0026 self) -\u003e BTreeKeys \u003c'_, Key, Val\u003e {\n\t\tself.map.keys ()\n\t}\n\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.map.len ()\n\t}\n\n\tpub fn remove \u003cQry: ?Sized\u003e (\u0026 mut self, value: \u0026 Qry) -\u003e Option \u003cVal\u003e\n\t\twhere\n\t\t\tKey: Borrow \u003cQry\u003e,\n\t\t\tQry: Hash + Eq + Ord {\n\t\tself.map.remove (value)\n\t}\n\n\tpub fn retain \u003cFunc\u003e (\u0026 mut self, func: Func)\n\t\t\twhere Func: FnMut (\u0026 Key, \u0026 mut Val) -\u003e bool {\n\t\tself.map.retain (func)\n\t}\n\n\tpub fn values (\u0026 self) -\u003e BTreeValues \u003cKey, Val\u003e {\n\t\tself.map.values ()\n\t}\n\n}\n\nimpl \u003cKey, Val\u003e Clone for HashMap \u003cKey, Val\u003e where Key: Clone, Val: Clone {\n\tfn clone (\u0026 self) -\u003e Self {\n\t\tSelf {\n\t\t\tmap: self.map.clone (),\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n}\n\nimpl \u003cKey, Val\u003e Debug for HashMap \u003cKey, Val\u003e\n\t\twhere Key: Debug, Val: Debug {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tself.map.fmt (formatter)\n\t}\n}\n\nimpl \u003cKey, Val\u003e Default for HashMap \u003cKey, Val\u003e {\n\tfn default () -\u003e Self {\n\t\tSelf {\n\t\t\tmap: BTreeMap::default (),\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n}\n\nimpl \u003cKey, Val\u003e Eq for HashMap \u003cKey, Val\u003e\n\twhere Key: Eq, Val: Eq {\n}\n\nimpl \u003cKey, Val\u003e FromIterator \u003c(Key, Val)\u003e for HashMap \u003cKey, Val\u003e\n\t\twhere Key: Ord {\n\tfn from_iter \u003cIter\u003e (iter: Iter) -\u003e Self\n\t\t\twhere Iter: IntoIterator \u003cItem = (Key, Val)\u003e {\n\t\tSelf {\n\t\t\tmap: BTreeMap::from_iter (iter),\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n}\n\nimpl \u003cKey, Val, Qry\u003e Index \u003c\u0026 '_ Qry\u003e for HashMap \u003cKey, Val\u003e\n\twhere\n\t\tKey: Ord + Borrow \u003cQry\u003e,\n\t\tQry: Ord + ?Sized {\n\ttype Output = Val;\n\tfn index (\u0026 self, query: \u0026 Qry) -\u003e \u0026 Val {\n\t\tself.map.get (query).unwrap ()\n\t}\n}\n\nimpl \u003c'map, Key, Val\u003e IntoIterator for \u0026 'map HashMap \u003cKey, Val\u003e {\n\ttype Item = (\u0026 'map Key, \u0026 'map Val);\n\ttype IntoIter = BTreeIter \u003c'map, Key, Val\u003e;\n\tfn into_iter (self) -\u003e BTreeIter \u003c'map, Key, Val\u003e {\n\t\t(\u0026 self.map).into_iter ()\n\t}\n}\n\nimpl \u003cKey, Val\u003e PartialEq for HashMap \u003cKey, Val\u003e\n\t\twhere Key: PartialEq, Val: PartialEq {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.map.eq (\u0026 other.map)\n\t}\n}\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","misc","collections.rs"],"content":"use super::prelude::*;\n\n#[ cfg (not (fuzzing)) ]\n//pub use std_hash::*;\npub use fast_hash::*;\n\n#[ cfg (fuzzing) ]\npub use test_hash::*;\n\nmod std_hash {\n\tpub use std::collections::HashMap;\n\tpub use std::collections::HashSet;\n}\n\nmod fast_hash {\n\tpub use ahash::AHashMap as HashMap;\n\tpub use ahash::AHashSet as HashSet;\n}\n\n#[ cfg (fuzzing) ]\nmod test_hash {\n\tpub use std::collections::BTreeSet as HashSet;\n\tpub use super::test_map::HashMap;\n}\n\n#[ cfg (fuzzing) ]\nmod test_map;\n\npub struct MapToIndex \u003cItem\u003e {\n\titems: Vec \u003cItem\u003e,\n\tindexes: HashMap \u003cItem, usize\u003e,\n}\n\nimpl \u003cItem: Clone + Eq + Hash + Ord\u003e MapToIndex \u003cItem\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new () -\u003e Self {\n\t\tSelf {\n\t\t\titems: Vec::new (),\n\t\t\tindexes: HashMap::new (),\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.items.len ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.items.is_empty ()\n\t}\n\n\t#[ inline ]\n\tpub fn insert (\u0026 mut self, item: Item) -\u003e usize {\n\t\t* self.indexes.entry (item.clone ()).or_insert_with (|| {\n\t\t\tlet idx = self.items.len ();\n\t\t\tself.items.push (item);\n\t\t\tidx\n\t\t})\n\t}\n\n}\n\nimpl \u003cItem: Clone + Eq + Hash + Ord\u003e Default for MapToIndex \u003cItem\u003e {\n\n\t#[ inline ]\n\tfn default () -\u003e Self {\n\t\tSelf::new ()\n\t}\n\n}\n\nimpl \u003cItem\u003e Deref for MapToIndex \u003cItem\u003e {\n\n\ttype Target = [Item];\n\n\t#[ inline ]\n\tfn deref (\u0026 self) -\u003e \u0026 [Item] {\n\t\t\u0026 self.items\n\t}\n\n}\n\nimpl \u003cItem: Clone + Eq + Hash + Ord\u003e FromIterator \u003cItem\u003e for MapToIndex \u003cItem\u003e {\n\n\t#[ inline ]\n\tfn from_iter \u003cIter: IntoIterator \u003cItem = Item\u003e\u003e (iter: Iter) -\u003e Self {\n\t\titer.into_iter ()\n\t\t\t.fold (Self::new (), |mut map, item| { map.insert (item); map })\n\t}\n\n}\n\nimpl \u003cItem: Eq + Hash + Ord\u003e Index \u003c\u0026 Item\u003e for MapToIndex \u003cItem\u003e {\n\n\ttype Output = usize;\n\n\t#[ inline ]\n\tfn index (\u0026 self, item: \u0026 Item) -\u003e \u0026 usize {\n\t\tself.indexes.get (item).unwrap ()\n\t}\n\n}\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[56688],"length":1,"stats":{"Line":0},"fn_name":"len\u003caoc_inpstr::InpStr\u003e"},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[58809,58861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[76067,76182],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","misc","iter.rs"],"content":"use super::prelude::*;\n\npub trait IteratorExt: Iterator {\n\n\t#[ inline ]\n\tfn array \u003cconst DIM: usize\u003e (mut self) -\u003e [Self::Item; DIM]\n\t\t\twhere Self: Sized, Self::Item: Copy + Default {\n\t\tlet mut result = [default (); DIM];\n\t\tfor idx in 0 .. DIM {\n\t\t\tresult [idx] = self.next ().unwrap ();\n\t\t}\n\t\tassert! (self.next ().is_none ());\n\t\tresult\n\t}\n\n\t#[ inline ]\n\tfn try_array \u003cItem, Error, const DIM: usize\u003e (mut self) -\u003e Result \u003c[Item; DIM], Error\u003e\n\t\t\twhere Self: Sized + Iterator \u003cItem = Result \u003cItem, Error\u003e\u003e, Item: Copy + Default {\n\t\tlet mut result = [default (); DIM];\n\t\tfor idx in 0 .. DIM {\n\t\t\tresult [idx] = self.next ().unwrap () ?;\n\t\t}\n\t\tassert! (self.next ().is_none ());\n\t\tOk (result)\n\t}\n\n\t#[ inline ]\n\tfn max_ok_by_key \u003cItem, Error, Key, KeyFn\u003e (mut self, mut key_fn: KeyFn) -\u003e Result \u003cOption \u003cItem\u003e, Error\u003e\n\t\twhere\n\t\t\tKey: Ord,\n\t\t\tKeyFn: FnMut (\u0026 Item) -\u003e Key,\n\t\t\tSelf: Sized + Iterator \u003cItem = Result \u003cItem, Error\u003e\u003e {\n\t\tlet (mut max_key, mut max_item) = if let Some (item) = self.next () {\n\t\t\tlet item = item ?;\n\t\t\t(key_fn (\u0026 item), item)\n\t\t} else { return Ok (None) };\n\t\tfor item in self {\n\t\t\tlet item = item ?;\n\t\t\tlet key = key_fn (\u0026 item);\n\t\t\tif key \u003c= max_key { continue }\n\t\t\tmax_key = key;\n\t\t\tmax_item = item;\n\t\t}\n\t\tOk (Some (max_item))\n\t}\n\n}\n\nimpl \u003cSomeIter: Iterator\u003e IteratorExt for SomeIter {}\n","traces":[{"line":6,"address":[69040,69912],"length":1,"stats":{"Line":2},"fn_name":"array\u003ccore::iter::adapters::map::Map\u003carrayvec::arrayvec::IntoIter\u003caoc_pos::dim_2::yx::PosYX\u003ci8\u003e, 8\u003e, aoc_2021_day_11::logic::step_iter::{closure_env#0}\u003e, 8\u003e"},{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[58883,58288],"length":1,"stats":{"Line":65},"fn_name":"try_array\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::zip::Zip\u003ccore::array::iter::IntoIter\u003ci16, 2\u003e, core::array::iter::IntoIter\u003ci16, 2\u003e\u003e, aoc_grid::buf::{impl#0}::wrap_range::{closure_env#0}\u003calloc::vec::Vec\u003caoc_2020_day_03::model::Tile, alloc::alloc::Global\u003e, aoc_pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e\u003e, i16, aoc_nums::Overflow, 2\u003e"},{"line":19,"address":[122369,122977,124785,123585,124177],"length":1,"stats":{"Line":28},"fn_name":null},{"line":20,"address":[85561],"length":1,"stats":{"Line":67},"fn_name":null},{"line":21,"address":[124040,122610,125026,123218,123452,123810,125257,124418,124649,122844],"length":1,"stats":{"Line":65},"fn_name":null},{"line":23,"address":[86079,85996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[122811,125226,123419,124010,124618],"length":1,"stats":{"Line":65},"fn_name":null},{"line":28,"address":[73664],"length":1,"stats":{"Line":2},"fn_name":"max_ok_by_key\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::filter::Filter\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003c(usize, \u0026aoc_2018_day_24::model::Group)\u003e\u003e, aoc_2018_day_24::logic::choose_targets::{closure_env#1}\u003e, aoc_2018_day_24::logic::choose_targets::{closure_env#2}\u003e, (usize, \u0026aoc_2018_day_24::model::Group, u32), aoc_nums::Overflow, (u32, u32, u32), aoc_2018_day_24::logic::choose_targets::{closure_env#3}\u003e"},{"line":33,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":16,"coverable":24},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","misc","misc.rs"],"content":"#![ allow (clippy::inline_always) ]\n\nmod collections;\nmod iter;\npub mod prelude;\n\nmod result {\n\n\tpub use crate::prelude::*;\n\n\tpub use crate::ok_or;\n\tpub use crate::ok_or_else;\n\tpub use crate::assert_is_err;\n\tpub use crate::assert_is_ok;\n\tpub use crate::assert_eq_ok;\n\tpub use crate::assert_err;\n\n\tpub type GenResult \u003cOk\u003e = Result \u003cOk, GenError\u003e;\n\n\tpub trait ResultEither \u003cVal\u003e {\n\t\tfn either (self) -\u003e Val;\n\t}\n\n\timpl \u003cVal\u003e ResultEither \u003cVal\u003e for Result \u003cVal, Val\u003e {\n\t\t#[ inline (always) ]\n\t\t#[ must_use ]\n\t\tfn either (self) -\u003e Val {\n\t\t\tmatch self { Ok (val) =\u003e val, Err (val) =\u003e val }\n\t\t}\n\t}\n\n\t#[ allow (clippy::missing_const_for_fn) ]\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub fn ok_or_err \u003cVal\u003e (result: Result \u003cVal, Val\u003e) -\u003e Val {\n\t\tmatch result {\n\t\t\tOk (val) =\u003e val,\n\t\t\tErr (val) =\u003e val,\n\t\t}\n\t}\n\n\tpub trait ResultMapRef \u003cVal, Error: Copy\u003e {\n\t\tfn map_ref \u003cOut\u003e (\u0026 self, map_fn: impl FnMut (\u0026 Val) -\u003e Out) -\u003e Result \u003cOut, Error\u003e;\n\t}\n\n\timpl \u003cVal, Error: Copy\u003e ResultMapRef \u003cVal, Error\u003e for Result \u003cVal, Error\u003e {\n\t\t#[ inline (always) ]\n\t\tfn map_ref \u003cOut\u003e (\u0026 self, map_fn: impl FnMut (\u0026 Val) -\u003e Out) -\u003e Result \u003cOut, Error\u003e {\n\t\t\tself.as_ref ().map_err (|\u0026 err| err).map (map_fn)\n\t\t}\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! ok_or {\n\t\t( $val:expr, $if_err:expr $(,)? ) =\u003e {\n\t\t\tmatch ($val) { Ok (val) =\u003e val, Err (_) =\u003e $if_err }\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! ok_or_else {\n\t\t( $val:expr, |$arg:ident| $if_err:expr $(,)? ) =\u003e {\n\t\t\tmatch ($val) { Ok (val) =\u003e val, Err ($arg) =\u003e $if_err }\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_is_ok {\n\t\t( $actual:expr ) =\u003e {\n\t\t\tassert! ($actual.is_ok ());\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_eq_ok {\n\t\t( $expect:expr , $actual:expr ) =\u003e {\n\t\t\tlet actual = $actual;\n\t\t\tassert! (actual.is_ok (), \"Expected Ok but got {:?}\", actual);\n\t\t\tassert_eq! ($expect, actual.unwrap ());\n\t\t};\n\t\t( $expect: expr , $actual:expr , $($rest:tt)* ) =\u003e {\n\t\t\tlet actual = $actual;\n\t\t\tassert! (actual.is_ok (), $($rest)*);\n\t\t\tassert_eq! ($expect, actual.unwrap ());\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_err {\n\t\t( $expect:expr , $actual:expr ) =\u003e {\n\t\t\tassert_eq! ($expect, $actual.unwrap_err ().to_string ());\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_is_err {\n\t\t( $actual:expr ) =\u003e {\n\t\t\tlet actual = $actual;\n\t\t\tassert! (actual.is_err (), \"Expected Err (_) but got {actual:?}\");\n\t\t};\n\t}\n\n}\n\nmod error {\n\n\tuse crate::prelude::*;\n\n\tpub type GenError = Box \u003cdyn Error\u003e;\n\n}\n\nmod default {\n\n\t#[ inline (always) ]\n\t#[ must_use ]\n\tpub fn default \u003cT: Default\u003e () -\u003e T {\n\t\tDefault::default ()\n\t}\n\n}\n\nmod option {\n\n\tpub use crate::some_or;\n\n\t#[ macro_export ]\n\tmacro_rules! some_or {\n\t\t( $val:expr, $if_err:expr $(,)? ) =\u003e {\n\t\t\tmatch ($val) { Some (val) =\u003e val, None =\u003e $if_err }\n\t\t};\n\t}\n\n}\n\nmod array_vec {\n\n\tpub use crate::array_vec;\n\n\t#[ macro_export ]\n\tmacro_rules! array_vec {\n\t\t() =\u003e { ArrayVec::new () };\n\t\t( $($val:expr),* $(,)? ) =\u003e {\n\t\t\t{\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\t$( result.push ($val); )*\n\t\t\t\tresult\n\t\t\t}\n\t\t};\n\t\t( $val:expr; $num:expr ) =\u003e {\n\t\t\t[$val; $num].into_iter ().collect ()\n\t\t};\n\t}\n\n}\n\nmod deref {\n\n\tpub use crate::wrapper_deref;\n\tpub use crate::wrapper_deref_mut;\n\n\t#[ macro_export ]\n\tmacro_rules! wrapper_deref {\n\t\t(\n\t\t\t$(#[$struct_meta:meta])*\n\t\t\t$struct_vis:vis struct $struct_name:ident $(\u003c$($struct_param:tt),*\u003e)? {\n\t\t\t\t$field_vis:vis $field_name:ident: $field_type:ty,\n\t\t\t}\n\t\t) =\u003e {\n\n\t\t\t$(#[$struct_meta])*\n\t\t\t$struct_vis struct $struct_name $(\u003c$($struct_param),*\u003e)? {\n\t\t\t\t$field_vis $field_name: $field_type,\n\t\t\t}\n\n\t\t\timpl $(\u003c$($struct_param),*\u003e)? ::std::ops::Deref for $struct_name $(\u003c$($struct_param),*\u003e)? {\n\t\t\t\ttype Target = $field_type;\n\t\t\t\t#[ inline ]\n\t\t\t\tfn deref (\u0026 self) -\u003e \u0026 $field_type {\n\t\t\t\t\t\u0026 self.$field_name\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! wrapper_deref_mut {\n\t\t(\n\t\t\t$(#[$struct_meta:meta])*\n\t\t\t$struct_vis:vis struct $struct_name:ident $(\u003c$($struct_param:tt),*\u003e)? {\n\t\t\t\t$field_vis:vis $field_name:ident: $field_type:ty,\n\t\t\t}\n\t\t) =\u003e {\n\n\t\t\t$(#[$struct_meta])*\n\t\t\t$struct_vis struct $struct_name $(\u003c$($struct_param),*\u003e)? {\n\t\t\t\t$field_vis $field_name: $field_type,\n\t\t\t}\n\n\t\t\timpl $(\u003c$($struct_param),*\u003e)? ::std::ops::Deref for $struct_name $(\u003c$($struct_param),*\u003e)? {\n\t\t\t\ttype Target = $field_type;\n\t\t\t\t#[ inline ]\n\t\t\t\tfn deref (\u0026 self) -\u003e \u0026 $field_type {\n\t\t\t\t\t\u0026 self.$field_name\n\t\t\t\t}\n\t\t\t}\n\n\t\t\timpl $(\u003c$($struct_param),*\u003e)? ::std::ops::DerefMut for $struct_name $(\u003c$($struct_param),*\u003e)? {\n\t\t\t\t#[ inline ]\n\t\t\t\tfn deref_mut (\u0026 mut self) -\u003e \u0026 mut $field_type {\n\t\t\t\t\t\u0026 mut self.$field_name\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}\n\n}\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[127383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[34320],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":211,"address":[146208],"length":1,"stats":{"Line":0},"fn_name":"deref_mut"}],"covered":1,"coverable":12},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","misc","prelude.rs"],"content":"pub use arrayvec::ArrayVec;\npub use crate::array_vec::*;\npub use crate::collections::*;\npub use crate::default::*;\npub use crate::deref::*;\npub use crate::error::*;\npub use crate::iter::*;\npub use crate::option::*;\npub use crate::result::*;\npub use itertools;\npub use itertools::Either;\npub use itertools::EitherOrBoth;\npub use itertools::Itertools;\npub use itertools::MultiPeek;\npub use itertools::izip;\npub use std::array;\npub use std::borrow::Borrow;\npub use std::borrow::BorrowMut;\npub use std::borrow::Cow;\npub use std::cell::Cell;\npub use std::cell::RefCell;\npub use std::cmp;\npub use std::cmp::Ordering;\npub use std::collections::BinaryHeap;\npub use std::collections::BTreeMap;\npub use std::collections::BTreeSet;\npub use std::collections::VecDeque;\npub use std::collections::btree_map::Entry as BTreeEntry;\npub use std::collections::btree_map::Iter as BTreeIter;\npub use std::collections::btree_map::IterMut as BTreeIterMut;\npub use std::collections::btree_map::Keys as BTreeKeys;\npub use std::collections::btree_map::Values as BTreeValues;\npub use std::collections::hash_map::DefaultHasher;\npub use std::collections::hash_map::Entry as HashMapEntry;\npub use std::collections::hash_map::RandomState as RandomHasher;\npub use std::convert::Infallible;\npub use std::error::Error;\npub use std::ffi::OsString;\npub use std::fmt;\npub use std::fmt::Debug;\npub use std::fmt::Display;\npub use std::fmt::Write as _;\npub use std::fs;\npub use std::hash;\npub use std::hash::BuildHasher;\npub use std::hash::BuildHasherDefault;\npub use std::hash::Hash;\npub use std::hash::Hasher;\npub use std::iter;\npub use std::iter::FusedIterator;\npub use std::iter::Peekable;\npub use std::io;\npub use std::marker::PhantomData;\npub use std::mem;\npub use std::num::ParseIntError;\npub use std::ops;\npub use std::ops::Add;\npub use std::ops::AddAssign;\npub use std::ops::BitAnd;\npub use std::ops::BitAndAssign;\npub use std::ops::BitOr;\npub use std::ops::BitOrAssign;\npub use std::ops::Bound;\npub use std::ops::Bound::Included;\npub use std::ops::Bound::Excluded;\npub use std::ops::Bound::Unbounded;\npub use std::ops::Deref;\npub use std::ops::DerefMut;\npub use std::ops::Div;\npub use std::ops::Index;\npub use std::ops::IndexMut;\npub use std::ops::Mul;\npub use std::ops::Neg;\npub use std::ops::Range;\npub use std::ops::RangeBounds;\npub use std::ops::RangeInclusive;\npub use std::ops::Rem;\npub use std::ops::Shl;\npub use std::ops::ShlAssign;\npub use std::ops::Shr;\npub use std::ops::ShrAssign;\npub use std::ops::Sub;\npub use std::path::Path;\npub use std::rc::Rc;\npub use std::rc::Weak as RcWeak;\npub use std::slice;\npub use std::slice::Iter as SliceIter;\npub use std::slice::IterMut as SliceIterMut;\npub use std::str;\npub use std::str::Chars;\npub use std::str::FromStr;\npub use std::sync::Arc;\npub use std::sync::Condvar;\npub use std::sync::Mutex;\npub use std::sync::atomic::AtomicUsize;\npub use std::sync::atomic::Ordering as AtomicOrdering;\npub use std::thread;\npub use std::thread::JoinHandle;\npub use std::time;\npub use std::vec::IntoIter as VecIntoIter;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","nums","nums.rs"],"content":"#![ allow (clippy::as_conversions) ]\n#![ allow (clippy::default_numeric_fallback) ]\n#![ allow (clippy::inline_always) ]\n#![ allow (clippy::wrong_self_convention) ]\n\nuse std::cmp;\nuse std::error::Error;\nuse std::fmt;\nuse std::fmt::Debug;\nuse std::fmt::Display;\nuse std::hash::Hash;\nuse std::ops::Add;\nuse std::ops::AddAssign;\nuse std::ops::BitAnd;\nuse std::ops::BitAndAssign;\nuse std::ops::BitOr;\nuse std::ops::BitOrAssign;\nuse std::ops::Bound;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Neg;\nuse std::ops::RangeBounds;\nuse std::ops::Rem;\nuse std::ops::Shl;\nuse std::ops::ShlAssign;\nuse std::ops::Shr;\nuse std::ops::ShrAssign;\nuse std::ops::Sub;\nuse std::ops::SubAssign;\nuse std::str::FromStr;\n\npub use crate::bits::*;\n\npub type NumResult \u003cVal\u003e = Result \u003cVal, Overflow\u003e;\n\n#[ derive (Clone, Copy, Debug, Eq, Ord, PartialEq, PartialOrd) ]\npub struct Overflow;\n\nimpl Display for Overflow {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Overflow\") ?;\n\t\tOk (())\n\t}\n\n}\n\nimpl Error for Overflow {\n}\n\npub trait TryAdd \u003cArg = Self\u003e {\n\ttype Output;\n\tfn try_add (self, arg: Arg) -\u003e Result \u003cSelf::Output, Overflow\u003e;\n}\n\npub trait TryAddAssign \u003cArg = Self\u003e {\n\tfn try_add_assign (\u0026 mut self, arg: Arg) -\u003e Result \u003c(), Overflow\u003e;\n}\n\npub trait TryDiv \u003cArg = Self\u003e {\n\ttype Output;\n\tfn try_div (self, arg: Arg) -\u003e Result \u003cSelf::Output, Overflow\u003e;\n}\n\npub trait TryDivAssign \u003cArg = Self\u003e {\n\tfn try_div_assign (\u0026 mut self, arg: Arg) -\u003e Result \u003c(), Overflow\u003e;\n}\n\npub trait TryMul \u003cArg = Self\u003e {\n\ttype Output;\n\tfn try_mul (self, arg: Arg) -\u003e Result \u003cSelf::Output, Overflow\u003e;\n}\n\npub trait TryMulAssign \u003cArg = Self\u003e {\n\tfn try_mul_assign (self, arg: Arg) -\u003e Result \u003c(), Overflow\u003e;\n}\n\npub trait TryRem \u003cArg = Self\u003e {\n\ttype Output;\n\tfn try_rem (self, arg: Arg) -\u003e Result \u003cSelf::Output, Overflow\u003e;\n}\n\npub trait TryRemAssign \u003cArg = Self\u003e {\n\tfn try_rem_assign (self, arg: Arg) -\u003e Result \u003c(), Overflow\u003e;\n}\n\npub trait TrySub \u003cArg = Self\u003e {\n\ttype Output;\n\tfn try_sub (self, arg: Arg) -\u003e Result \u003cSelf::Output, Overflow\u003e;\n}\n\npub trait TrySubAssign \u003cArg = Self\u003e {\n\tfn try_sub_assign (self, arg: Arg) -\u003e Result \u003c(), Overflow\u003e;\n}\n\npub trait Int: Clone + Copy + Debug + Default + Display + Eq + FromStr + Hash + Ord + IntOps\n\t\t+ IntConv {\n\ttype Signed: IntSigned;\n\ttype Unsigned: IntUnsigned;\n\tconst BITS: u32;\n\tconst ZERO: Self;\n\tconst ONE: Self;\n\tconst TWO: Self;\n\tconst THREE: Self;\n\tconst FOUR: Self;\n\tconst FIVE: Self;\n\tconst SIX: Self;\n\tconst SEVEN: Self;\n\tconst EIGHT: Self;\n\tconst NINE: Self;\n\tconst MIN: Self;\n\tconst MAX: Self;\n\tfn unsigned_abs (self) -\u003e Self::Unsigned;\n\tfn signum (self) -\u003e Self::Signed;\n\n\t/// Signed difference between two numbers\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented, ie if the difference is too\n\t/// high\n\t///\n\tfn signed_diff (self, other: Self) -\u003e NumResult \u003cSelf::Signed\u003e;\n\n\t/// Unsigned difference between two numbers\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented, ie if the second number is\n\t/// greater than the first\n\t///\n\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003cSelf::Unsigned\u003e;\n\n\t/// Add a signed number\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn add_signed (self, other: Self::Signed) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Subtract a signed number\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn sub_signed (self, other: Self::Signed) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Add two numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn add_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Add three numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline ]\n\tfn add_3 (arg_0: Self, arg_1: Self, arg_2: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::add_2 (Self::add_2 (arg_0, arg_1) ?, arg_2)\n\t}\n\n\t/// Add four numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline ]\n\tfn add_4 (arg_0: Self, arg_1: Self, arg_2: Self, arg_3: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::add_2 (Self::add_3 (arg_0, arg_1, arg_2) ?, arg_3)\n\t}\n\n\t/// Divide one number by another\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn div_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Multiply two numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn mul_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Multiply three numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline ]\n\tfn mul_3 (arg_0: Self, arg_1: Self, arg_2: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::mul_2 (Self::mul_2 (arg_0, arg_1) ?, arg_2)\n\t}\n\n\t/// Multiply four numbers together\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline ]\n\tfn mul_4 (arg_0: Self, arg_1: Self, arg_2: Self, arg_3: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::mul_2 (Self::mul_3 (arg_0, arg_1, arg_2) ?, arg_3)\n\t}\n\n\t/// Find the remainder from dividing one number by another\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn rem_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Subtract one number from another\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn sub_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\n\tfn gen_count_ones (self) -\u003e u32;\n\n\t#[ inline (always) ]\n\tfn check_bit (self, bit: u32) -\u003e bool {\n\t\tself \u0026 (Self::ONE \u003c\u003c bit) != Self::ZERO\n\t}\n\n\t#[ inline (always) ]\n\tfn bound_start_assign (\u0026 mut self, other: Self) {\n\t\t* self = cmp::max (* self, other);\n\t}\n\n\t#[ inline (always) ]\n\tfn bound_end_assign (\u0026 mut self, other: Self) {\n\t\t* self = cmp::min (* self, other);\n\t}\n\n\t#[ inline (always) ]\n\tfn bounds_assign (\u0026 mut self, bounds: impl RangeBounds \u003cSelf\u003e) {\n\t\tlet start = match bounds.start_bound () {\n\t\t\tBound::Included (\u0026 bound) =\u003e Some (bound),\n\t\t\tBound::Excluded (\u0026 bound) =\u003e Some (bound + Self::ONE),\n\t\t\tBound::Unbounded =\u003e None,\n\t\t};\n\t\tlet end = match bounds.end_bound () {\n\t\t\tBound::Included (\u0026 bound) =\u003e Some (bound),\n\t\t\tBound::Excluded (\u0026 bound) =\u003e Some (bound - Self::ONE),\n\t\t\tBound::Unbounded =\u003e None,\n\t\t};\n\t\tif let (Some (start), Some (end)) = (start, end) {\n\t\t\tassert! (start \u003c= end);\n\t\t}\n\t\tif let Some (start) = start { self.bound_start_assign (start); }\n\t\tif let Some (end) = end { self.bound_end_assign (end); }\n\t}\n\n}\n\npub trait IntOpsTry: Sized +\n\tTryAdd \u003cOutput = Self\u003e +\n\tTryDiv \u003cOutput = Self\u003e +\n\tTryMul \u003cOutput = Self\u003e +\n\tTryRem \u003cOutput = Self\u003e +\n\tTrySub \u003cOutput = Self\u003e {\n}\n\nimpl \u003cVal\u003e IntOpsTry for Val\n\twhere Val: Sized +\n\t\tTryAdd \u003cOutput = Self\u003e +\n\t\tTryDiv \u003cOutput = Self\u003e +\n\t\tTryMul \u003cOutput = Self\u003e +\n\t\tTryRem \u003cOutput = Self\u003e +\n\t\tTrySub \u003cOutput = Self\u003e {\n}\n\nmacro_rules! prim_int {\n\t( $signed:ident , $unsigned:ident, $bits:literal ) =\u003e {\n\n\t\timpl Int for $signed {\n\n\t\t\ttype Signed = $signed;\n\t\t\ttype Unsigned = $unsigned;\n\n\t\t\tconst BITS: u32 = $signed::BITS;\n\n\t\t\tconst ZERO: $signed = 0;\n\t\t\tconst ONE: $signed = 1;\n\t\t\tconst TWO: $signed = 2;\n\t\t\tconst THREE: $signed = 3;\n\t\t\tconst FOUR: $signed = 4;\n\t\t\tconst FIVE: $signed = 5;\n\t\t\tconst SIX: $signed = 6;\n\t\t\tconst SEVEN: $signed = 7;\n\t\t\tconst EIGHT: $signed = 8;\n\t\t\tconst NINE: $signed = 9;\n\n\t\t\tconst MIN: $signed = $signed::MIN;\n\t\t\tconst MAX: $signed = $signed::MAX;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn unsigned_abs (self) -\u003e $unsigned { $signed::unsigned_abs (self) }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn signum (self) -\u003e $signed { $signed::signum (self) }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn signed_diff (self, other: Self) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t(other \u003c= self).then (|| $signed::abs_diff (self, other)).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn add_signed (self, other: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_add (self, other).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn sub_signed (self, other: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn add_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_add (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn div_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_div (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn mul_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_mul (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn rem_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_rem (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn sub_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn gen_count_ones (self) -\u003e u32 {\n\t\t\t\tself.count_ones ()\n\t\t\t}\n\n\t\t}\n\n\t\timpl Int for $unsigned {\n\n\t\t\ttype Signed = $signed;\n\t\t\ttype Unsigned = $unsigned;\n\n\t\t\tconst BITS: u32 = $signed::BITS;\n\t\t\tconst ZERO: $unsigned = 0;\n\t\t\tconst ONE: $unsigned = 1;\n\t\t\tconst TWO: $unsigned = 2;\n\t\t\tconst THREE: $unsigned = 3;\n\t\t\tconst FOUR: $unsigned = 4;\n\t\t\tconst FIVE: $unsigned = 5;\n\t\t\tconst SIX: $unsigned = 6;\n\t\t\tconst SEVEN: $unsigned = 7;\n\t\t\tconst EIGHT: $unsigned = 8;\n\t\t\tconst NINE: $unsigned = 9;\n\t\t\tconst MIN: $unsigned = $unsigned::MIN;\n\t\t\tconst MAX: $unsigned = $unsigned::MAX;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn unsigned_abs (self) -\u003e $unsigned { self }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn signum (self) -\u003e $signed {\n\t\t\t\tif self \u003e 0 { Self::Signed::ONE } else { Self::Signed::ZERO }\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn signed_diff (self, other: Self) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\tif other \u003c self {\n\t\t\t\t\t(self - other).try_into ().ok ().ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t(other - self).try_into ().map ($signed::neg).ok ().ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn add_signed (self, other: $signed) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\tif other \u003e= Self::Signed::ZERO {\n\t\t\t\t\t$unsigned::checked_add (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t$unsigned::checked_sub (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn sub_signed (self, other: $signed) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\tif other \u003e= Self::Signed::ZERO {\n\t\t\t\t\t$unsigned::checked_sub (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t$unsigned::checked_add (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn add_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_add (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn div_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_div (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn mul_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_mul (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn rem_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_rem (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tfn sub_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_sub (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn gen_count_ones (self) -\u003e u32 {\n\t\t\t\tself.count_ones ()\n\t\t\t}\n\n\t\t}\n\n\t\timpl IntOpsSafe for $signed {\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn safe_add (self, arg: $signed) -\u003e $signed {\n\t\t\t\t$signed::checked_add (self, arg).unwrap ()\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn safe_sub (self, arg: $signed) -\u003e $signed {\n\t\t\t\t$signed::checked_sub (self, arg).unwrap ()\n\t\t\t}\n\n\t\t}\n\n\t\timpl IntOpsSafe for $unsigned {\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn safe_add (self, arg: $unsigned) -\u003e $unsigned {\n\t\t\t\t$unsigned::checked_add (self, arg).unwrap ()\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn safe_sub (self, arg: $unsigned) -\u003e $unsigned {\n\t\t\t\t$unsigned::checked_sub (self, arg).unwrap ()\n\t\t\t}\n\n\t\t}\n\n\t\timpl IntSigned for $signed {\n\t\t\tconst NEG_ONE: $signed = Self::ZERO - Self::ONE;\n\t\t}\n\n\t\timpl IntUnsigned for $unsigned {}\n\n\t\timpl IntSized \u003c$bits\u003e for $signed {}\n\t\timpl IntSized \u003c$bits\u003e for $unsigned {}\n\n\t\timpl IntConv for $signed {\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_char (val: char) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.qck_u32 ().try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_u8 (val: u8) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_isize (val: isize) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_char (self) -\u003e NumResult \u003cchar\u003e {\n\t\t\t\tself.to_u32 () ?.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_f32 (self) -\u003e f32 { self as f32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_f64 (self) -\u003e f64 { self as f64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i8 (self) -\u003e i8 { self as i8 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i16 (self) -\u003e i16 { self as i16 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i32 (self) -\u003e i32 { self as i32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i64 (self) -\u003e i64 { self as i64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i128 (self) -\u003e i128 { self as i128 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_isize (self) -\u003e isize { self as isize }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u8 (self) -\u003e u8 { self as u8 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u16 (self) -\u003e u16 { self as u16 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u32 (self) -\u003e u32 { self as u32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u64 (self) -\u003e u64 { self as u64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u128 (self) -\u003e u128 { self as u128 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_usize (self) -\u003e usize { self as usize }\n\n\t\t}\n\n\t\timpl IntConv for $unsigned {\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_char (val: char) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.qck_u32 ().try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_u8 (val: u8) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn from_isize (val: isize) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tval.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_char (self) -\u003e NumResult \u003cchar\u003e {\n\t\t\t\tself.to_u32 () ?.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e {\n\t\t\t\tself.try_into ().ok ().ok_or (Overflow)\n\t\t\t}\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_f32 (self) -\u003e f32 { self as f32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_f64 (self) -\u003e f64 { self as f64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i8 (self) -\u003e i8 { self as i8 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i16 (self) -\u003e i16 { self as i16 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i32 (self) -\u003e i32 { self as i32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i64 (self) -\u003e i64 { self as i64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_i128 (self) -\u003e i128 { self as i128 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_isize (self) -\u003e isize { self as isize }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u8 (self) -\u003e u8 { self as u8 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u16 (self) -\u003e u16 { self as u16 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u32 (self) -\u003e u32 { self as u32 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u64 (self) -\u003e u64 { self as u64 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_u128 (self) -\u003e u128 { self as u128 }\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn qck_usize (self) -\u003e usize { self as usize }\n\n\t\t}\n\n\t\timpl TryAdd \u003cSelf\u003e for $signed {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_add (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_add (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryAdd \u003cSelf\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_add (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_add (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryAdd \u003c$signed\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_add (self, arg: $signed) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.add_signed (arg)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryDiv \u003cSelf\u003e for $signed {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_div (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_div (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryDiv \u003cSelf\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_div (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_div (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryMul \u003cSelf\u003e for $signed {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_mul (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_mul (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryMul \u003cSelf\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_mul (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_mul (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryRem \u003cSelf\u003e for $signed {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_rem (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_rem (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TryRem \u003cSelf\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_rem (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_rem (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TrySub \u003cSelf\u003e for $signed {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_sub (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_sub (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\timpl TrySub \u003cSelf\u003e for $unsigned {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline (always) ]\n\t\t\tfn try_sub (self, arg: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tself.checked_sub (arg).ok_or (Overflow)\n\t\t\t}\n\n\t\t}\n\n\t\tquick_from! ($unsigned, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n\t\tquick_from! ($signed, u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n\n\t};\n\n}\n\nmacro_rules! quick_from {\n\t( $target:ident, $( $source:ident ),* ) =\u003e {\n\t\t$(\n\n\t\t\timpl QuickFrom \u003c$source\u003e for $target {\n\n\t\t\t\t#[ inline (always) ]\n\t\t\t\tfn quick_from (arg: $source) -\u003e Self {\n\t\t\t\t\targ as $target\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t)*\n\t};\n}\n\nprim_int! (i8, u8, 8);\nprim_int! (i16, u16, 16);\nprim_int! (i32, u32, 32);\nprim_int! (i64, u64, 64);\nprim_int! (i128, u128, 128);\nprim_int! (isize, usize, 128);\n\npub trait IntSigned: Int + Neg \u003cOutput = Self\u003e {\n\tconst NEG_ONE: Self::Signed;\n}\n\npub trait IntUnsigned: Int {}\n\npub trait IntSized \u003cconst BITS: usize\u003e: Int {}\n\npub trait IntOpsRust: Sized + Add \u003cOutput = Self\u003e + AddAssign + BitAnd \u003cOutput = Self\u003e\n\t+ BitAndAssign + BitOr \u003cOutput = Self\u003e + BitOrAssign + Div \u003cOutput = Self\u003e\n\t+ Mul \u003cOutput = Self\u003e + Rem \u003cOutput = Self\u003e + Shl \u003cu32, Output = Self\u003e + ShlAssign \u003cu32\u003e\n\t+ Shr \u003cu32, Output = Self\u003e + ShrAssign \u003cu32\u003e + Sub \u003cOutput = Self\u003e + SubAssign {}\nimpl \u003cVal\u003e IntOpsRust for Val where Val: Sized + Add \u003cOutput = Self\u003e + AddAssign\n\t+ BitAnd \u003cOutput = Self\u003e + BitAndAssign + BitOr \u003cOutput = Self\u003e + BitOrAssign\n\t+ Div \u003cOutput = Self\u003e + Mul \u003cOutput = Self\u003e + Rem \u003cOutput = Self\u003e + Shl \u003cu32, Output = Self\u003e\n\t+ ShlAssign \u003cu32\u003e + Shr \u003cu32, Output = Self\u003e + ShrAssign \u003cu32\u003e + Sub \u003cOutput = Self\u003e\n\t+ SubAssign {}\n\npub trait IntOpsSafe: Sized {\n\n\t#[ must_use ]\n\tfn safe_add (self, arg: Self) -\u003e Self;\n\n\t#[ must_use ]\n\tfn safe_sub (self, arg: Self) -\u003e Self;\n\n}\n\npub trait IntOps: IntOpsRust + IntOpsSafe + IntOpsTry {}\nimpl \u003cVal\u003e IntOps for Val where Val: IntOpsRust + IntOpsSafe + IntOpsTry {}\n\npub trait IntConv: Sized {\n\n\t#[ inline (always) ]\n\tfn pan_f32 (self) -\u003e f32 { self.to_f32 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_f64 (self) -\u003e f64 { self.to_f64 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_i8 (self) -\u003e i8 { self.to_i8 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_i16 (self) -\u003e i16 { self.to_i16 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_i32 (self) -\u003e i32 { self.to_i32 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_i64 (self) -\u003e i64 { self.to_i64 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_i128 (self) -\u003e i128 { self.to_i128 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_isize (self) -\u003e isize { self.to_isize ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_u8 (self) -\u003e u8 { self.to_u8 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_u16 (self) -\u003e u16 { self.to_u16 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_u32 (self) -\u003e u32 { self.to_u32 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_u64 (self) -\u003e u64 { self.to_u64 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_u128 (self) -\u003e u128 { self.to_u128 ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_usize (self) -\u003e usize { self.to_usize ().unwrap () }\n\n\t#[ inline (always) ]\n\tfn pan_char (self) -\u003e char { self.to_char ().unwrap () }\n\n\tfn qck_f32 (self) -\u003e f32;\n\tfn qck_f64 (self) -\u003e f64;\n\tfn qck_i8 (self) -\u003e i8;\n\tfn qck_i16 (self) -\u003e i16;\n\tfn qck_i32 (self) -\u003e i32;\n\tfn qck_i64 (self) -\u003e i64;\n\tfn qck_i128 (self) -\u003e i128;\n\tfn qck_isize (self) -\u003e isize;\n\tfn qck_u8 (self) -\u003e u8;\n\tfn qck_u16 (self) -\u003e u16;\n\tfn qck_u32 (self) -\u003e u32;\n\tfn qck_u64 (self) -\u003e u64;\n\tfn qck_u128 (self) -\u003e u128;\n\tfn qck_usize (self) -\u003e usize;\n\n\tfn from_char (val: char) -\u003e NumResult \u003cSelf\u003e;\n\n\tfn from_u8 (val: u8) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Safely convert from [`usize`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e;\n\n\tfn from_isize (val: isize) -\u003e NumResult \u003cSelf\u003e;\n\n\t/// Safely convert to [`f32`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline (always) ]\n\tfn to_f32 (self) -\u003e NumResult \u003cf32\u003e { self.to_u16 ().map (Into::into) }\n\n\t/// Safely convert to [`f64`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\t#[ inline (always) ]\n\tfn to_f64 (self) -\u003e NumResult \u003cf64\u003e { self.to_u32 ().map (Into::into) }\n\n\t/// Safely convert to [`i8`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e;\n\n\t/// Safely convert to [`i16`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e;\n\n\t/// Safely convert to [`i32`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e;\n\n\t/// Safely convert to [`i64`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e;\n\n\t/// Safely convert to [`i128`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e;\n\n\t/// Safely convert to [`isize`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e;\n\n\t/// Safely convert to [`u8`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e;\n\n\t/// Safely convert to [`u16`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e;\n\n\t/// Safely convert to [`u32`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e;\n\n\t/// Safely convert to [`u64`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e;\n\n\t/// Safely convert to [`u128`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e;\n\n\t/// Safely convert to [`usize`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (Overflow)` if the result can't be represented\n\t///\n\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e;\n\n\tfn to_char (self) -\u003e NumResult \u003cchar\u003e;\n\n}\n\nimpl IntConv for char {\n\n\t#[ inline (always) ]\n\tfn from_char (val: char) -\u003e NumResult \u003cSelf\u003e {\n\t\tOk (val)\n\t}\n\n\t#[ inline (always) ]\n\tfn from_u8 (val: u8) -\u003e NumResult \u003cSelf\u003e {\n\t\tval.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e {\n\t\tval.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn from_isize (val: isize) -\u003e NumResult \u003cSelf\u003e {\n\t\tval.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_char (self) -\u003e NumResult \u003cchar\u003e {\n\t\tOk (self)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e {\n\t\tself.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always)]\n\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e {\n\t\tself.to_u32 () ?.try_into ().map_err (|_err| Overflow)\n\t}\n\n\t#[ inline (always) ]\n\tfn qck_f32 (self) -\u003e f32 { self.qck_u32 ().qck_f32 () }\n\n\t#[ inline (always) ]\n\tfn qck_f64 (self) -\u003e f64 { self.qck_u32 ().qck_f64 () }\n\n\t#[ inline (always) ]\n\tfn qck_i8 (self) -\u003e i8 { self as i8 }\n\n\t#[ inline (always) ]\n\tfn qck_i16 (self) -\u003e i16 { self as i16 }\n\n\t#[ inline (always) ]\n\tfn qck_i32 (self) -\u003e i32 { self as i32 }\n\n\t#[ inline (always) ]\n\tfn qck_i64 (self) -\u003e i64 { self as i64 }\n\n\t#[ inline (always) ]\n\tfn qck_i128 (self) -\u003e i128 { self as i128 }\n\n\t#[ inline (always) ]\n\tfn qck_isize (self) -\u003e isize { self as isize }\n\n\t#[ inline (always) ]\n\tfn qck_u8 (self) -\u003e u8 { self as u8 }\n\n\t#[ inline (always) ]\n\tfn qck_u16 (self) -\u003e u16 { self as u16 }\n\n\t#[ inline (always) ]\n\tfn qck_u32 (self) -\u003e u32 { self as u32 }\n\n\t#[ inline (always) ]\n\tfn qck_u64 (self) -\u003e u64 { self as u64 }\n\n\t#[ inline (always) ]\n\tfn qck_u128 (self) -\u003e u128 { self as u128 }\n\n\t#[ inline (always) ]\n\tfn qck_usize (self) -\u003e usize { self as usize }\n\n}\n\npub trait QuickFrom \u003cOther\u003e {\n\tfn quick_from (other: Other) -\u003e Self;\n}\n\npub trait QuickInto \u003cOther\u003e {\n\tfn quick_into (self) -\u003e Other;\n}\n\nimpl \u003cFrom, To\u003e QuickInto \u003cTo\u003e for From where To: QuickFrom \u003cFrom\u003e {\n\t#[ inline (always) ]\n\tfn quick_into (self) -\u003e To {\n\t\tTo::quick_from (self)\n\t}\n}\n\nmod bits {\n\n\tuse super::*;\n\n\tpub struct BitPusher \u003cData: Int\u003e {\n\t\tdata: Data,\n\t\tbits: u32,\n\t}\n\n\timpl \u003cData: Int\u003e BitPusher \u003cData\u003e {\n\n\t\t#[ inline (always) ]\n\t\t#[ must_use ]\n\t\tpub fn new () -\u003e Self {\n\t\t\tSelf { data: Data::ZERO, bits: 0 }\n\t\t}\n\n\t\t#[ inline (always) ]\n\t\tpub fn push \u003cVal: Int + QuickInto \u003cData\u003e\u003e (\u0026 mut self, val: Val, bits: u32) {\n\t\t\tdebug_assert! (self.bits + bits \u003c= Data::BITS);\n\t\t\tself.data \u003c\u003c= bits;\n\t\t\tself.data |= val.quick_into ();\n\t\t\tself.bits += bits;\n\t\t}\n\n\t\t#[ inline (always) ]\n\t\tpub fn finish (self) -\u003e Data {\n\t\t\tself.data \u003c\u003c (Data::BITS - self.bits)\n\t\t}\n\n\t}\n\n\timpl \u003cData: Int\u003e Default for BitPusher \u003cData\u003e {\n\n\t\t#[ inline (always) ]\n\t\tfn default () -\u003e Self {\n\t\t\tSelf::new ()\n\t\t}\n\n\t}\n\n\tpub struct BitPopper \u003cData: Int\u003e {\n\t\tdata: Data,\n\t\tbits: u32,\n\t}\n\n\timpl \u003cData: Int\u003e BitPopper \u003cData\u003e {\n\n\t\t#[ inline (always) ]\n\t\tpub fn new (data: Data) -\u003e Self {\n\t\t\tSelf { data, bits: Data::BITS }\n\t\t}\n\n\t\t#[ inline (always) ]\n\t\tpub fn pop \u003cVal: Int + QuickFrom \u003cData\u003e\u003e (\u0026 mut self, bits: u32) -\u003e Val {\n\t\t\tdebug_assert! (bits \u003c= Val::BITS);\n\t\t\tdebug_assert! (bits \u003c= self.bits);\n\t\t\tlet result = (self.data \u003e\u003e (Data::BITS - bits)).quick_into ();\n\t\t\tself.data \u003c\u003c= bits;\n\t\t\tself.bits -= bits;\n\t\t\tresult\n\t\t}\n\n\t}\n\n}\n\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[73040],"length":1,"stats":{"Line":0},"fn_name":"add_2"},{"line":342,"address":[73049],"length":1,"stats":{"Line":46},"fn_name":null},{"line":351,"address":[48336],"length":1,"stats":{"Line":0},"fn_name":"mul_2"},{"line":352,"address":[48344],"length":1,"stats":{"Line":5},"fn_name":null},{"line":356,"address":[4624],"length":1,"stats":{"Line":0},"fn_name":"rem_2"},{"line":357,"address":[4674,4652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[73072],"length":1,"stats":{"Line":0},"fn_name":"sub_2"},{"line":362,"address":[73081],"length":1,"stats":{"Line":33},"fn_name":null},{"line":415,"address":[44130,44227,44323,44398,44470],"length":1,"stats":{"Line":5},"fn_name":null},{"line":432,"address":[26432],"length":1,"stats":{"Line":0},"fn_name":"add_2"},{"line":433,"address":[26439],"length":1,"stats":{"Line":27},"fn_name":null},{"line":437,"address":[35248],"length":1,"stats":{"Line":0},"fn_name":"div_2"},{"line":438,"address":[23654],"length":1,"stats":{"Line":3},"fn_name":null},{"line":442,"address":[35280],"length":1,"stats":{"Line":0},"fn_name":"mul_2"},{"line":443,"address":[23701,24168,23800,24054],"length":1,"stats":{"Line":12},"fn_name":null},{"line":452,"address":[35312],"length":1,"stats":{"Line":0},"fn_name":"sub_2"},{"line":453,"address":[23530,23580],"length":1,"stats":{"Line":8},"fn_name":null},{"line":514,"address":[59897,60297],"length":1,"stats":{"Line":63},"fn_name":null},{"line":529,"address":[27361,27082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":539,"address":[26594,27042],"length":1,"stats":{"Line":16},"fn_name":null},{"line":544,"address":[72596],"length":1,"stats":{"Line":8},"fn_name":null},{"line":569,"address":[46917,47021],"length":1,"stats":{"Line":8},"fn_name":null},{"line":574,"address":[5328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":584,"address":[31608],"length":1,"stats":{"Line":81},"fn_name":null},{"line":627,"address":[58665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[40331],"length":1,"stats":{"Line":2},"fn_name":null},{"line":645,"address":[23896],"length":1,"stats":{"Line":19},"fn_name":null},{"line":655,"address":[83195],"length":1,"stats":{"Line":3},"fn_name":null},{"line":660,"address":[56505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":670,"address":[59853],"length":1,"stats":{"Line":13},"fn_name":null},{"line":675,"address":[31147],"length":1,"stats":{"Line":12},"fn_name":null},{"line":680,"address":[5255,4608,4534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[47476],"length":1,"stats":{"Line":66},"fn_name":null},{"line":690,"address":[70629],"length":1,"stats":{"Line":36},"fn_name":null},{"line":695,"address":[51201],"length":1,"stats":{"Line":11},"fn_name":null},{"line":700,"address":[56387],"length":1,"stats":{"Line":187},"fn_name":null},{"line":705,"address":[52669,52753],"length":1,"stats":{"Line":57},"fn_name":null},{"line":710,"address":[28150,28079,28532,28603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":715,"address":[31957,32150,32240],"length":1,"stats":{"Line":782},"fn_name":null},{"line":743,"address":[30416],"length":1,"stats":{"Line":1},"fn_name":null},{"line":758,"address":[36464],"length":1,"stats":{"Line":56},"fn_name":"idx"},{"line":767,"address":[133494],"length":1,"stats":{"Line":147},"fn_name":null},{"line":777,"address":[23850,22089],"length":1,"stats":{"Line":43},"fn_name":null},{"line":797,"address":[45845,46572,44251,46331,45259,44012,45660,44187,45324,44725,46668,46156,44827,44501,45947],"length":1,"stats":{"Line":6},"fn_name":null},{"line":807,"address":[22255,22773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":817,"address":[35430,35670],"length":1,"stats":{"Line":77},"fn_name":null},{"line":827,"address":[38251,38219,36482],"length":1,"stats":{"Line":30},"fn_name":null},{"line":847,"address":[23539,23377],"length":1,"stats":{"Line":6},"fn_name":null},{"line":857,"address":[133750],"length":1,"stats":{"Line":104},"fn_name":null},{"line":867,"address":[55629,56221,55985,55393],"length":1,"stats":{"Line":34},"fn_name":null},{"line":940,"address":[153942,148824,151002,151465,154006,148890,149353,150936,148721,150769,150833,153718,153782,148657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[56541],"length":1,"stats":{"Line":5},"fn_name":null},{"line":949,"address":[35681],"length":1,"stats":{"Line":29},"fn_name":null},{"line":952,"address":[31176],"length":1,"stats":{"Line":18},"fn_name":null},{"line":955,"address":[5288,4641,4574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":958,"address":[60490,60552],"length":1,"stats":{"Line":66},"fn_name":null},{"line":961,"address":[43174],"length":1,"stats":{"Line":42},"fn_name":null},{"line":964,"address":[51227],"length":1,"stats":{"Line":11},"fn_name":null},{"line":967,"address":[56413],"length":1,"stats":{"Line":228},"fn_name":null},{"line":970,"address":[52715,52777],"length":1,"stats":{"Line":55},"fn_name":null},{"line":973,"address":[28115,28186,28639,28568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":976,"address":[32270,32180,31989],"length":1,"stats":{"Line":850},"fn_name":null},{"line":979,"address":[57137,56854],"length":1,"stats":{"Line":3},"fn_name":null},{"line":1026,"address":[154000,148647,148880,149343,151455,150926,148711,148814,150992,150759,153705,153776,153929,150823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":1131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1187,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":1191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1197,"address":[],"length":0,"stats":{"Line":43},"fn_name":null},{"line":1201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1293,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1330,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1331,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":1332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1333,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":58,"coverable":148},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","ocr","ocr.rs"],"content":"use std::fmt::{ self, Display };\n\nuse aoc_misc::prelude::*;\nuse aoc_nums as nums;\nuse nums::Int;\n\npub struct DrawDots \u003cVal, Iter\u003e (pub Iter)\n\twhere\n\t\tVal: Int,\n\t\tIter: Iterator \u003cItem = (Val, Val)\u003e + Clone;\n\nimpl \u003cVal, Iter\u003e Display for DrawDots \u003cVal, Iter\u003e\n\twhere\n\t\tIter: Iterator \u003cItem = (Val, Val)\u003e + Clone,\n\t\tVal: Int {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet dots = {\n\t\t\tlet mut dots_temp: Vec \u003c(usize, usize)\u003e =\n\t\t\t\tself.0.clone ()\n\t\t\t\t\t.map (|(row, col)| (row.qck_usize (), col.qck_usize ()))\n\t\t\t\t\t.collect ();\n\t\t\tdots_temp.sort_by_key (|\u0026 (row, col)| (row, col));\n\t\t\tdots_temp\n\t\t};\n\t\tSelf::display_fmt_real (dots, formatter)\n\t}\n\n}\n\nimpl \u003cVal, Iter\u003e DrawDots \u003cVal, Iter\u003e\n\twhere\n\t\tIter: Iterator \u003cItem = (Val, Val)\u003e + Clone,\n\t\tVal: Int {\n\n\tfn display_fmt_real (dots: Vec \u003c(usize, usize)\u003e, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut first_row = true;\n\t\tlet mut first_col = true;\n\t\tlet mut row = 0;\n\t\tlet mut col = 0;\n\t\tfor (dot_row, dot_col) in dots {\n\t\t\twhile first_row || row \u003c dot_row {\n\t\t\t\twrite! (formatter, \"\\n\") ?;\n\t\t\t\tcol = 0;\n\t\t\t\tif ! first_row { row += 1; }\n\t\t\t\tfirst_row = false;\n\t\t\t\tfirst_col = true;\n\t\t\t}\n\t\t\twhile first_col || col \u003c dot_col {\n\t\t\t\twrite! (formatter, \"  \") ?;\n\t\t\t\tif ! first_col { col += 1; }\n\t\t\t\tfirst_col = false;\n\t\t\t}\n\t\t\twrite! (formatter, \"##\") ?;\n\t\t\tcol += 1;\n\t\t\tfirst_col = false;\n\t\t}\n\t\twrite! (formatter, \"\\n\\n\") ?;\n\t\tOk (())\n\t}\n\n}\n\n#[ allow (clippy::missing_inline_in_public_items) ]\npub fn read_dots \u003cVal: Int\u003e (\n\tdots: impl IntoIterator \u003cItem = (Val, Val)\u003e,\n) -\u003e GenResult \u003cString\u003e {\n\tlet dots: Vec \u003c(Val, Val)\u003e =\n\t\tdots.into_iter ()\n\t\t\t.map (|(row, col)| (col, row))\n\t\t\t.sorted ()\n\t\t\t.collect ();\n\tlet base_row = some_or! (\n\t\tdots.iter ().copied ().map (|(_, row)| row).min (),\n\t\treturn Ok (String::new ()));\n\tlet mut result = String::new ();\n\tlet mut dots_iter = dots.iter ().copied ().peekable ();\n\twhile dots_iter.peek ().is_some () {\n\t\tlet base_col = dots_iter.peek ().unwrap ().0;\n\t\tlet mut encoded = 0_u128;\n\t\tlet mut col = base_col;\n\t\twhile let Some ((dot_col, dot_row)) = dots_iter.peek ().copied () {\n\t\t\tif dot_col == col + Val::ONE {\n\t\t\t\tcol = dot_col;\n\t\t\t}\n\t\t\tif col \u003c dot_col { break }\n\t\t\tif dot_col == col {\n\t\t\t\tlet rel_col = dot_col - base_col;\n\t\t\t\tlet rel_row = dot_row - base_row;\n\t\t\t\tif rel_col \u003e= Val::from_usize (10).unwrap () { return Err (\"Too wide\".into ()) }\n\t\t\t\tif rel_row \u003e= Val::from_usize (12).unwrap () { return Err (\"Too tall\".into ()) }\n\t\t\t\tlet row_bit = (Val::from_usize (11).unwrap () - rel_row).pan_u32 ();\n\t\t\t\tlet col_bit = (Val::from_usize (9).unwrap () - rel_col).pan_u32 ();\n\t\t\t\tlet bit = row_bit * 10 + col_bit;\n\t\t\t\tencoded |= 1_u128 \u003c\u003c bit;\n\t\t\t}\n\t\t\tdots_iter.next ().unwrap ();\n\t\t}\n\t\tif let Some (ch) = decode_char (encoded) {\n\t\t\tresult.push (ch);\n\t\t\tcontinue;\n\t\t}\n\t\t#[ allow (clippy::print_stderr) ]\n\t\t#[ cfg (all (debug_assertions, not (fuzzing))) ]\n\t\t{\n\t\t\tlet mut drawn = String::new ();\n\t\t\tlet mut val = encoded;\n\t\t\tfor _ in 0_u32 .. 12 {\n\t\t\t\tfor _ in 0_u32 .. 10 {\n\t\t\t\t\tdrawn.push (if val \u0026 (1 \u003c\u003c 119_u32) != 0 { '#' } else { ' ' });\n\t\t\t\t\tval = (val \u003c\u003c 1_u128) \u0026 ! (0xff \u003c\u003c 120_u32);\n\t\t\t\t}\n\t\t\t\tif val == 0 { break }\n\t\t\t\tdrawn.push ('\\n');\n\t\t\t}\n\t\t\teprintln! (\"{drawn}\");\n\t\t}\n\t\tlet mut shift = 0_u32;\n\t\twhile encoded != 0 \u0026\u0026 encoded.trailing_zeros () \u003e= 16 {\n\t\t\tshift += 16;\n\t\t\tencoded \u003e\u003e= 16_u32;\n\t\t}\n\t\treturn Err (format! (\n\t\t\t\"Unrecognised character: 0x{encoded:x} \u003c\u003c {shift} in position {}\",\n\t\t\tresult.len () + 1,\n\t\t).into ());\n\t}\n\tOk (result)\n}\n\nconst fn decode_char (encoded: u128) -\u003e Option \u003cchar\u003e {\n\tif encoded.trailing_zeros () \u003e= 60 {\n\t\tdecode_six (encoded)\n\t} else if encoded.trailing_zeros () \u003e= 20 {\n\t\tdecode_ten (encoded)\n\t} else {\n\t\tNone\n\t}\n}\n\nconst fn decode_ten (encoded: u128) -\u003e Option \u003cchar\u003e {\n\tSome (match encoded \u003e\u003e 24_u32 {\n\t\t0x_3012_0842_1084_3f08_4210_8421 =\u003e 'A',\n\t\t0x_f821_0842_10f8_2108_4210_843e =\u003e 'B',\n\t\t0x_7821_0802_0080_2008_0200_841e =\u003e 'C',\n\t\t0x_8822_0883_e088_2208_8220_0000 =\u003e 'H',\n\t\t0x_e010_0401_0040_1004_0380_0000 =\u003e 'I',\n\t\t0x_1c02_0080_2008_0200_8220_881c =\u003e 'J',\n\t\t0x_f821_0842_10f8_2408_8220_8421 =\u003e 'R',\n\t\t0x_8421_0481_2030_0c04_8120_8421 =\u003e 'X',\n\t\t0x_fc01_0040_2010_0804_0200_803f =\u003e 'Z',\n\t\t_ =\u003e return None,\n\t})\n}\n\nconst fn decode_six (encoded: u128) -\u003e Option \u003cchar\u003e {\n\tSome (match encoded \u003e\u003e 64_u32 {\n\t\t0x_0060_2409_03c0_9024 =\u003e 'A',\n\t\t0x_00e0_240e_0240_9038 =\u003e 'B',\n\t\t0x_0060_2408_0200_9018 =\u003e 'C',\n\t\t// TODO =\u003e 'D',\n\t\t0x_00f0_200e_0200_803c =\u003e 'E',\n\t\t0x_00f0_200e_0200_8020 =\u003e 'F',\n\t\t0x_0060_2408_02c0_901c =\u003e 'G',\n\t\t0x_0090_240f_0240_9024 =\u003e 'H',\n\t\t// TODO =\u003e 'I',\n\t\t0x_0030_0401_0040_9018 =\u003e 'J',\n\t\t0x_0090_280c_0280_a024 =\u003e 'K',\n\t\t0x_0080_2008_0200_803c =\u003e 'L',\n\t\t// TODO =\u003e 'M',\n\t\t// TODO =\u003e 'N',\n\t\t0x_0060_2409_0240_9018 =\u003e 'O',\n\t\t0x_00e0_2409_0380_8020 =\u003e 'P',\n\t\t// TODO =\u003e 'Q',\n\t\t0x_00e0_2409_0380_a024 =\u003e 'R',\n\t\t0x_0070_2008_0180_1038 =\u003e 'S',\n\t\t0x_0090_2409_0240_9018 =\u003e 'U',\n\t\t// TODO =\u003e 'V',\n\t\t// TODO =\u003e 'W',\n\t\t// TODO =\u003e 'X',\n\t\t0x_0088_2205_0080_2008 =\u003e 'Y',\n\t\t0x_00f0_0402_0100_803c =\u003e 'Z',\n\t\t_ =\u003e return None,\n\t})\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[46144,48415],"length":1,"stats":{"Line":3},"fn_name":"read_dots\u003ci32, core::iter::adapters::map::Map\u003ccore::slice::iter::Iter\u003caoc_2018_day_10::model::Point\u003e, aoc_2018_day_10::logic::calc_result::{closure_env#2}\u003e\u003e"},{"line":69,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":77},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parallel","parallel.rs"],"content":"use std::cmp;\nuse std::collections::VecDeque;\nuse std::fmt;\nuse std::fs::File;\nuse std::io::BufRead as _;\nuse std::io::BufReader;\nuse std::ops::Deref;\nuse std::process;\nuse std::sync::Arc;\nuse std::sync::Condvar;\nuse std::sync::Mutex;\nuse std::sync::atomic::AtomicUsize;\nuse std::sync::atomic::Ordering;\nuse std::thread;\nuse std::thread::JoinHandle;\n\npub mod prelude {\n\tpub use super::IteratorThreadMap;\n\tpub use super::ThreadMap;\n}\n\npub trait IteratorThreadMap: Iterator {\n\n\t#[ inline ]\n\tfn thread_map \u003cMapFn, Out\u003e (\n\t\tself,\n\t\tnum_threads: usize,\n\t\tmap_fn: MapFn,\n\t) -\u003e ThreadMap \u003cSelf, Out\u003e\n\t\twhere\n\t\t\tMapFn: Fn (Self::Item) -\u003e Out + Clone + Send + 'static,\n\t\t\tOut: Clone + Send + 'static,\n\t\t\tSelf: Send + Sized + 'static {\n\t\tThreadMap::start (self, map_fn, num_threads)\n\t}\n\n}\n\nimpl \u003cIter\u003e IteratorThreadMap for Iter where Iter: Iterator {\n}\n\npub struct ThreadMap \u003cInner, Out\u003e {\n\tshared: Arc \u003cThreadMapShared \u003cInner, Out\u003e\u003e,\n\tthreads: Vec \u003cJoinHandle \u003c()\u003e\u003e,\n}\n\nstruct ThreadMapShared \u003cInner, Out\u003e {\n\tstate: Mutex \u003cThreadMapState \u003cInner, Out\u003e\u003e,\n\tqueue_push_cond: Condvar,\n\tqueue_pop_cond: Condvar,\n\tqueue_size: usize,\n}\n\nstruct ThreadMapState \u003cInner, Out\u003e {\n\tinner: Inner,\n\tqueue: VecDeque \u003cArc \u003cMutex \u003cOption \u003cOut\u003e\u003e\u003e\u003e,\n\tfinished: bool,\n}\n\nimpl \u003cInner, Out\u003e ThreadMap \u003cInner, Out\u003e\n\twhere Inner: Iterator + Send + 'static, Out: Clone + Send + 'static {\n\n\t#[ inline ]\n\tpub fn start \u003cMapFn: Fn (Inner::Item) -\u003e Out + Clone + Send + 'static\u003e (\n\t\tinner: Inner,\n\t\tmap_fn: MapFn,\n\t\tnum_threads: usize,\n\t) -\u003e Self {\n\n\t\tlet state = Mutex::new (ThreadMapState {\n\t\t\tinner,\n\t\t\tqueue: VecDeque::new (),\n\t\t\tfinished: false,\n\t\t});\n\n\t\tlet shared = Arc::new (ThreadMapShared {\n\t\t\tstate,\n\t\t\tqueue_push_cond: Condvar::new (),\n\t\t\tqueue_pop_cond: Condvar::new (),\n\t\t\tqueue_size: num_threads * 2,\n\t\t});\n\n\t\tlet threads = (0 .. num_threads).map (|_| {\n\t\t\tlet map_fn = map_fn.clone ();\n\t\t\tlet shared = Arc::clone (\u0026 shared);\n\t\t\tthread::spawn (move || Self::worker (shared, map_fn))\n\t\t}).collect ();\n\n\t\tSelf { shared, threads }\n\n\t}\n\n\t#[ allow (clippy::needless_pass_by_value) ]\n\tfn worker \u003cMapFn\u003e (\n\t\tshared: Arc \u003cThreadMapShared \u003cInner, Out\u003e\u003e,\n\t\tmap_fn: MapFn,\n\t) where MapFn: Fn (Inner::Item) -\u003e Out + Clone + Send + 'static {\n\t\tloop {\n\n\t\t\tlet mut state = shared.state.lock ().unwrap ();\n\n\t\t\tlet input_opt = loop {\n\t\t\t\tif state.finished { return }\n\t\t\t\tif state.queue.len () \u003c shared.queue_size {\n\t\t\t\t\tbreak state.inner.next ();\n\t\t\t\t}\n\t\t\t\tstate = shared.queue_pop_cond.wait (state).unwrap ();\n\t\t\t};\n\n\t\t\tlet input = if let Some (input) = input_opt { input } else {\n\t\t\t\tstate.finished = true;\n\t\t\t\tstate.queue.push_back (Arc::new (Mutex::new (None)));\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\tlet output_mutex = Arc::new (Mutex::new (None));\n\t\t\tlet mut output_lock = output_mutex.lock ().unwrap ();\n\n\t\t\tstate.queue.push_back (Arc::clone (\u0026 output_mutex));\n\t\t\tshared.queue_push_cond.notify_one ();\n\n\t\t\tdrop (state);\n\n\t\t\t* output_lock = Some (map_fn (input));\n\n\t\t}\n\t}\n\n}\n\nimpl \u003cInner, Out\u003e Drop for ThreadMap \u003cInner, Out\u003e {\n\n\t#[ inline ]\n\tfn drop (\u0026 mut self) {\n\n\t\tlet mut state = self.shared.state.lock ().unwrap ();\n\t\tstate.finished = true;\n\t\tself.shared.queue_push_cond.notify_all ();\n\t\tself.shared.queue_pop_cond.notify_all ();\n\t\tdrop (state);\n\n\t\tfor handle in self.threads.drain ( .. ) {\n\t\t\thandle.join ().unwrap ();\n\t\t}\n\n\t}\n\n}\n\nimpl \u003cInner, Out\u003e Iterator for ThreadMap \u003cInner, Out\u003e\n\twhere Out: Clone {\n\n\ttype Item = Out;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cOut\u003e {\n\n\t\tlet mut state = self.shared.state.lock ().unwrap ();\n\n\t\tlet output_mutex = loop {\n\t\t\tif let Some (output) = state.queue.pop_front () { break output }\n\t\t\tstate = self.shared.queue_push_cond.wait (state).unwrap ();\n\t\t};\n\n\t\tself.shared.queue_pop_cond.notify_one ();\n\n\t\tdrop (state);\n\n\t\tlet output = output_mutex.lock ().unwrap ().deref ().clone ();\n\t\toutput\n\n\t}\n\n}\n\n#[ inline ]\npub fn num_cpus_max \u003cVal\u003e (max: Val) -\u003e Val\n\twhere\n\t\tVal: Ord + TryFrom \u003cusize\u003e + TryInto \u003cusize\u003e,\n\t\t\u003cVal as TryInto \u003cusize\u003e\u003e::Error: fmt::Debug,\n\t\t\u003cVal as TryFrom \u003cusize\u003e\u003e::Error: fmt::Debug {\n\tlet max: usize = max.try_into ().unwrap ();\n\tif max \u003c 2 { return 1.try_into ().unwrap () }\n\tcmp::min (num_cpus ().unwrap_or (1), max).try_into ().unwrap ()\n}\n\n#[ inline ]\npub fn num_cpus () -\u003e Option \u003cusize\u003e {\n\n\tstatic CACHE: AtomicUsize = AtomicUsize::new (0);\n\tlet cached_value = CACHE.load (Ordering::Relaxed);\n\tif cached_value != 0 { return Some (cached_value) }\n\n\tlet num_threads = num_cpus_real ().unwrap_or (1);\n\tCACHE.store (num_threads, Ordering::Relaxed);\n\n\tSome (num_threads)\n\n}\n\nfn num_cpus_real () -\u003e Option \u003cusize\u003e {\n\tNone\n\t\t.or_else (num_cpus_allowed)\n\t\t.or_else (num_cpus_cpuinfo)\n}\n\nfn num_cpus_allowed () -\u003e Option \u003cusize\u003e {\n\n\tlet path = format! (\"/proc/{}/status\", process::id ());\n\tlet file = File::open (path).ok () ?;\n\tlet reader = BufReader::new (file);\n\n\tfor line in reader.lines () {\n\t\tlet line = line.ok () ?;\n\t\tif let Some (mask_str) = line.strip_prefix (\"Cpus_allowed:\\t\") {\n\t\t\tlet mask = u128::from_str_radix (mask_str, 16).ok () ?;\n\t\t\treturn Some (mask.count_ones ().try_into ().unwrap ());\n\t\t}\n\t}\n\n\tNone\n\n}\n\nfn num_cpus_cpuinfo () -\u003e Option \u003cusize\u003e {\n\n\tlet file = File::open (\"/proc/cpuinfo\").ok () ?;\n\tlet reader = BufReader::new (file);\n\n\tlet mut num_threads = 0;\n\tfor line in reader.lines () {\n\t\tlet line = line.ok () ?;\n\t\tif ! line.starts_with (\"processor\\t: \") { continue }\n\t\tnum_threads += 1;\n\t}\n\n\tSome (num_threads)\n\n}\n","traces":[{"line":25,"address":[181280],"length":1,"stats":{"Line":0},"fn_name":"thread_map\u003ccore::iter::adapters::step_by::StepBy\u003ccore::ops::range::RangeFrom\u003cu32\u003e\u003e, aoc_2015_day_04::logic::calc_result::{closure_env#0}, core::option::Option\u003cu32\u003e\u003e"},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[137714,137104],"length":1,"stats":{"Line":4},"fn_name":"start\u003ccore::iter::adapters::step_by::StepBy\u003ccore::ops::range::RangeFrom\u003cu32\u003e\u003e, core::option::Option\u003cu32\u003e, aoc_2015_day_04::logic::calc_result::{closure_env#0}\u003e"},{"line":70,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[137776,139272],"length":1,"stats":{"Line":4},"fn_name":"worker\u003ccore::iter::adapters::step_by::StepBy\u003ccore::ops::range::RangeFrom\u003cu32\u003e\u003e, core::option::Option\u003cu32\u003e, aoc_2015_day_04::logic::calc_result::{closure_env#0}\u003e"},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[137024],"length":1,"stats":{"Line":2},"fn_name":"num_cpus_max\u003cu32\u003e"},{"line":182,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[9264],"length":1,"stats":{"Line":0},"fn_name":"num_cpus_real"},{"line":207,"address":[10496,9296],"length":1,"stats":{"Line":0},"fn_name":"num_cpus_allowed"},{"line":209,"address":[9313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[9570,9410,9502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[9607,10481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[9687,9844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[9907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[10126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[10512,11495],"length":1,"stats":{"Line":0},"fn_name":"num_cpus_cpuinfo"},{"line":227,"address":[10711,10639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[10749,11480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[10839,10998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[11057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[11135,11343],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":37,"coverable":77},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","delim.rs"],"content":"use super::*;\n\nimpl \u003c'inp\u003e Parser \u003c'inp\u003e {\n\n\t#[ inline ]\n\tpub fn delim_fn \u003c'par0, Delim, Output, ParseFn\u003e (\n\t\t\u0026 'par0 mut self,\n\t\tdelim: Delim,\n\t\tparse_fn: ParseFn,\n\t) -\u003e ParserDelim \u003c'par0, 'inp, Delim, Output, ParseFn\u003e\n\t\twhere\n\t\t\tDelim: ParseDelimiter,\n\t\t\tParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tassert! (delim.is_valid ());\n\t\tParserDelim {\n\t\t\tparser: self,\n\t\t\tdelim,\n\t\t\tparse_fn,\n\t\t\tfirst: true,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn repeat \u003c'par, Output, ParseFn\u003e (\n\t\t\u0026 'par mut self,\n\t\tparse_fn: ParseFn,\n\t) -\u003e ParserRepeat \u003c'par, 'inp, Output, ParseFn\u003e\n\t\t\twhere ParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tParserRepeat {\n\t\t\tparser: self,\n\t\t\tparse_fn,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn delim_items \u003c'par, Delim, Output, ParseFn\u003e (\n\t\t\u0026 'par mut self,\n\t\tdelim: Delim,\n\t) -\u003e ParserDelim \u003c'par, 'inp, Delim, Output, impl FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e\u003e\n\t\twhere\n\t\t\tDelim: ParseDelimiter,\n\t\t\tOutput: FromParser \u003c'inp\u003e {\n\t\tself.delim_fn (delim, Parser::item)\n\t}\n\n\t#[ inline ]\n\tpub fn delim_uints \u003c'par, Delim, Output: FromStr\u003e (\n\t\t\u0026 'par mut self,\n\t\tdelim: Delim,\n\t) -\u003e ParserDelim \u003c'par, 'inp, Delim, Output, impl FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e\u003e\n\t\t\twhere Delim: ParseDelimiter {\n\t\tself.delim_fn (delim, Parser::uint)\n\t}\n\n\t#[ inline ]\n\tpub fn delim_ints \u003c'par, Delim, Output: FromStr + 'static\u003e (\n\t\t\u0026 'par mut self,\n\t\tdelim: Delim,\n\t) -\u003e ParserDelim \u003c'par, 'inp, Delim, Output, impl FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e\u003e\n\t\t\twhere Delim: ParseDelimiter {\n\t\tself.delim_fn (delim, Parser::int)\n\t}\n\n}\n\npub struct ParserDelim \u003c\n\t'par,\n\t'inp,\n\tDelim,\n\tOutput,\n\tParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e,\n\u003e {\n\tparser: \u0026 'par mut Parser \u003c'inp\u003e,\n\tdelim: Delim,\n\tparse_fn: ParseFn,\n\tfirst: bool,\n}\n\nimpl \u003c'par, 'inp, Delim, Output, ParseFn\u003e Iterator\n\tfor ParserDelim \u003c'par, 'inp, Delim, Output, ParseFn\u003e\n\twhere\n\t\tDelim: ParseDelimiter,\n\t\tParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\n\ttype Item = Output;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cOutput\u003e {\n\t\tlet saved = * self.parser;\n\t\tlet result = if self.first {\n\t\t\tself.first = false;\n\t\t\t(self.parse_fn) (self.parser)\n\t\t} else {\n\t\t\tself.delim.expect (self.parser)\n\t\t\t\t.and_then (|()| (self.parse_fn) (self.parser))\n\t\t};\n\t\tif result.is_err () { * self.parser = saved; }\n\t\tresult.ok ()\n\t}\n\n}\n\npub trait ParseDelimiter: Copy + Display + Sized {\n\n\t#[ inline ]\n\tfn is_valid (self) -\u003e bool {\n\t\ttrue\n\t}\n\n\tfn expect (self, parser: \u0026 mut Parser) -\u003e ParseResult \u003c()\u003e;\n\n}\n\nimpl ParseDelimiter for \u0026 str {\n\n\t#[ inline ]\n\tfn is_valid (self) -\u003e bool {\n\t\t! self.is_empty ()\n\t}\n\n\t#[ inline ]\n\tfn expect (self, parser: \u0026 mut Parser) -\u003e ParseResult \u003c()\u003e {\n\t\tparser.expect (self) ?;\n\t\tOk (())\n\t}\n\n}\n\n#[ derive (Clone, Copy, Debug) ]\npub struct ParseWhitespace;\n\nimpl ParseDelimiter for ParseWhitespace {\n\n\t#[ inline ]\n\tfn expect (self, parser: \u0026 mut Parser) -\u003e ParseResult \u003c()\u003e {\n\t\tparser.skip_whitespace (1 .. ) ?;\n\t\tOk (())\n\t}\n\n}\n\nimpl Display for ParseWhitespace {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tformatter.write_char (' ')\n\t}\n\n}\n\npub struct ParserRepeat \u003c\n\t'par,\n\t'inp,\n\tOutput,\n\tParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e ,\n\u003e {\n\tparser: \u0026 'par mut Parser \u003c'inp\u003e,\n\tparse_fn: ParseFn,\n}\n\nimpl \u003c'par, 'inp, Output, ParseFn\u003e Iterator for ParserRepeat \u003c'par, 'inp, Output, ParseFn\u003e\n\t\twhere ParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\n\ttype Item = Output;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cOutput\u003e {\n\t\tself.parser.any ().of (\u0026 mut self.parse_fn).done ().ok ()\n\t}\n\n}\n","traces":[{"line":6,"address":[43040],"length":1,"stats":{"Line":0},"fn_name":"delim_fn\u003c\u0026str, aoc_2017_cpu::model::Instr, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2017_cpu::model::Instr, aoc_parser::ParseError\u003e\u003e"},{"line":14,"address":[43066,43044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[63312],"length":1,"stats":{"Line":0},"fn_name":"repeat\u003caoc_2018_day_18::model::Tile, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2018_day_18::model::Tile, aoc_parser::ParseError\u003e\u003e"},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":89,"address":[30367],"length":1,"stats":{"Line":217},"fn_name":null},{"line":90,"address":[34382],"length":1,"stats":{"Line":217},"fn_name":null},{"line":91,"address":[30420],"length":1,"stats":{"Line":217},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":314},"fn_name":null},{"line":98,"address":[34573,34630],"length":1,"stats":{"Line":112},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[34417],"length":1,"stats":{"Line":216},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":178},"fn_name":null}],"covered":11,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","display.rs"],"content":"use super::*;\n\npub struct DisplayDelim \u003cDelim, Inner\u003e {\n\tdelim: Delim,\n\tinner: Inner,\n}\n\nimpl \u003cDelim, Inner\u003e Display for DisplayDelim \u003cDelim, Inner\u003e\n\twhere\n\t\tDelim: Clone + Display,\n\t\tInner: Clone + IntoIterator,\n\t\tInner::Item: Display {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut first = true;\n\t\tfor item in self.inner.clone () {\n\t\t\tif ! first { Display::fmt (\u0026 self.delim, formatter) ?; }\n\t\t\tDisplay::fmt (\u0026 item, formatter) ?;\n\t\t\tfirst = false;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\npub struct DisplayDelimWith \u003cDelim, Inner, Item, DisplayFn\u003e {\n\tdelim: Delim,\n\tinner: Inner,\n\tdisplay_fn: DisplayFn,\n\tphantom: PhantomData \u003cItem\u003e,\n}\n\nimpl \u003cDelim, Inner, Item, DisplayFn\u003e Display for DisplayDelimWith \u003cDelim, Inner, Item, DisplayFn\u003e\n\twhere\n\t\tDelim: Clone + Display,\n\t\tDisplayFn: Fn (Item, \u0026 mut fmt::Formatter) -\u003e fmt::Result,\n\t\tInner: Clone + IntoIterator \u003cItem = Item\u003e {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet mut first = true;\n\t\tfor item in self.inner.clone () {\n\t\t\tif ! first { Display::fmt (\u0026 self.delim, formatter) ?; }\n\t\t\t(self.display_fn) (item, formatter) ?;\n\t\t\tfirst = false;\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\npub trait IntoIteratorDisplayDelim: IntoIterator {\n\n\t#[ inline ]\n\tfn display_delim \u003cDelim\u003e (\n\t\tself,\n\t\tdelim: Delim,\n\t) -\u003e DisplayDelim \u003cDelim, Self\u003e\n\t\t\twhere Self: Sized {\n\t\tDisplayDelim { delim, inner: self }\n\t}\n\n\t#[ inline ]\n\tfn display_delim_with \u003cDelim, Item, DisplayFn\u003e (\n\t\tself,\n\t\tdelim: Delim,\n\t\tdisplay_fn: DisplayFn,\n\t) -\u003e DisplayDelimWith \u003cDelim, Self, Item, DisplayFn\u003e\n\t\t\twhere Self: Sized {\n\t\tDisplayDelimWith { delim, inner: self, display_fn, phantom: PhantomData }\n\t}\n\n}\n\nimpl \u003cSomeIter\u003e IntoIteratorDisplayDelim for SomeIter where SomeIter: IntoIterator {\n}\n\n#[ macro_export ]\nmacro_rules! display {\n\n\t( $formatter:ident $(,)? ) =\u003e {};\n\n\t// field\n\n\t( $formatter:ident, $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, $field:ident = $parse_fn:path $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, $field:ident = ($parse:path, $display:path) $(,$($rest:tt)*)? ) =\u003e {\n\t\t$display (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, $field:ident { $($nest:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tdisplay! (@nest $($nest)*) ($field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, $field:ident = $range:expr $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// (tuple, ...)\n\n\t( $formatter:ident, ($($field:ident),*) = $display:path $(,$($rest:tt)*)? ) =\u003e {\n\t\t$display (\u0026 ($($field),*), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, ($($field:ident),*) = ($parse:path, $display:path) $(,$($rest:tt)*)? ) =\u003e {\n\t\t$display (\u0026 ($($field),*), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, ($($field:ident),*) { $($nest:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tdisplay! (@nest $($nest)*) (\u0026 ($($field),*), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, $expect:literal $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt ($expect, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @array\n\n\t( $formatter:ident, @array $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @array_delim\n\n\t( $formatter:ident, @array_delim $delim:literal $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @char\n\n\t( $formatter:ident, @char $field:ident = |$arg:ident| { $($parse:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\t$formatter.write_char (* $field) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @collect\n\n\t( $formatter:ident, @collect $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @collect $field:ident = $parse:path $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @collect $field:ident = ($parse:path, $display:path) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with (\"\", $display), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @collect $field:ident { $($nest:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet display_fn = display! (@nest $($nest)*);\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with (\"\", display_fn), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @collect_max\n\n\t( $formatter:ident, @collect_max $max:literal $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t// @collect_some\n\n\t( $formatter:ident, @collect_some $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @collect_some_max $max:literal $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @confirm $(,$($rest:tt)*)? ) =\u003e {\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident { $($nest:tt)* } $(,$($rest:tt)*)?) =\u003e {\n\t\tlet display_fn = display! (@nest $($nest)*);\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with ($delim, display_fn), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident = ($rng_0:literal .. ) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident = ($rng_0:literal .. $rng_1:literal) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident = ($rng_0:literal ..= $rng_1:literal) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident = $parse:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim $delim:literal $field:ident = ($parse:path, $display:path) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with ($delim, $display), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @delim_some $delim:literal $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim ($delim), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @lines $field:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim (\"\\n\"), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @lines $field:ident { $($nest:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet display_fn = display! (@nest $($nest)*);\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with (\"\\n\", display_fn), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @lines $field:ident = $display:ident $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with (\"\\n\", $display), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @lines $field:ident = ($parse:ident, $display:ident) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field.display_delim_with (\"\\n\", $display), $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @opt $field:ident { $($nest:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tif $field != default () {\n\t\t\tlet display_fn = display! (@nest $($nest)*);\n\t\t\tdisplay_fn (\u0026 $field, $formatter) ?;\n\t\t}\n\t};\n\t( $formatter:ident, @parse $(|$arg:ident|)? { $($body:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @parse $field:ident { $($body:tt)* } $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet _ = $field;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @skip $display:literal $(,$($rest:tt)*)? ) =\u003e {\n\t\t$formatter.write_str ($display) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @str $field:ident = ($ch_0:literal ..= $ch_1:literal, $len:expr) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\t( $formatter:ident, @str $field:ident = (|$ch_arg:ident| { $($ch_body:tt)* }, $len:expr) $(,$($rest:tt)*)? ) =\u003e {\n\t\t::std::fmt::Display::fmt (\u0026 $field, $formatter) ?;\n\t\tdisplay! ($formatter, $($($rest)*)?);\n\t};\n\n\t( @nest $name:ident = [ $($display:tt)* ] ) =\u003e {\n\t\t|$name, formatter: \u0026 mut ::std::fmt::Formatter| {\n\t\t\tdisplay! (formatter, $($display)*);\n\t\t\t::std::result::Result::Ok (())\n\t\t}\n\t};\n\t( @nest type = $type:ty; $($nest:tt)* ) =\u003e {\n\t\t|val: \u0026 $type, formatter: \u0026 mut ::std::fmt::Formatter| {\n\t\t\tdisplay! (@nest_var formatter val $($nest)*);\n\t\t\t::std::result::Result::Ok (())\n\t\t}\n\t};\n\t( @nest display_type = $type:ty; $($nest:tt)* ) =\u003e {\n\t\t|val: \u0026 $type, formatter: \u0026 mut ::std::fmt::Formatter| {\n\t\t\tdisplay! (@nest_var formatter val $($nest)*);\n\t\t\t::std::result::Result::Ok (())\n\t\t}\n\t};\n\t( @nest input_lifetime = $input_life:lifetime; type = $type:ty; $($nest:tt)* ) =\u003e {\n\t\t|val: \u0026 $type, formatter: \u0026 mut ::std::fmt::Formatter| {\n\t\t\tdisplay! (@nest_var formatter val $($nest)*);\n\t\t\t::std::result::Result::Ok (())\n\t\t}\n\t};\n\t( @nest $($nest:tt)* ) =\u003e {\n\t\t|val, formatter: \u0026 mut ::std::fmt::Formatter| {\n\t\t\tdisplay! (@nest_var formatter val $($nest)*);\n\t\t\t::std::result::Result::Ok (())\n\t\t}\n\t};\n\n\t( @nest_var $formatter:ident $val:ident $lit:literal = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let \u0026 lit = $val {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t}\n\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t};\n\t( @nest_var $formatter:ident $val:ident $name:ident $( if ($cond:expr) )? = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let ($name, true) = ($val, display! (@opt_cond $($cond)?)) {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident $name_0:ident::$name_1:ident = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let $name_0::$name_1 = $val {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident $name:ident: $type:ty = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let $name = $val {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident ( $($item:tt),* ) $( if ($cond:expr) )? = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let (($($item),*), true) = ($val, display! (@opt_cond $($cond)?)) {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident $var:ident ( $($decl:tt)* ) = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let $var ($($decl)*) = $val {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident $var:ident { $($decl:tt)* } = [ $($display:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tif let \u0026 $var { $($decl)* } = $val {\n\t\t\tdisplay! ($formatter, $($display)*);\n\t\t} else {\n\t\t\tdisplay! (@nest_var $formatter $val $($($rest)*)?);\n\t\t}\n\t};\n\t( @nest_var $formatter:ident $val:ident $(,)? ) =\u003e { };\n\n\t( @opt_cond $cond:expr ) =\u003e {\n\t\t$cond\n\t};\n\t( @opt_cond ) =\u003e {\n\t\ttrue\n\t};\n\n}\n","traces":[{"line":15,"address":[34864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[42928,43699],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[34958,33375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[40464],"length":1,"stats":{"Line":0},"fn_name":"display_delim\u003ccore::iter::adapters::map::Map\u003ccore::slice::iter::Iter\u003c(aoc_inpstr::InpStr, aoc_inpstr::InpStr)\u003e, aoc_2020_day_21::logic::part_two::{closure_env#2}\u003e, \u0026str\u003e"}],"covered":3,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","enums.rs"],"content":"#[ macro_export ]\nmacro_rules! enum_parser_display {\n\t( $($rest:tt)* ) =\u003e {\n\t\tenum_parser! ($($rest)*);\n\t\tenum_display! ($($rest)*);\n\t};\n}\n\n#[ macro_export ]\nmacro_rules! enum_display {\n\n\t( $enum_name:ident $( \u003c$($param:tt),*\u003e )?, $($rest:tt)* ) =\u003e {\n\t\timpl $( \u003c$($param),*\u003e )? ::std::fmt::Display for $enum_name $(\u003c$($param),*\u003e)? {\n\t\t\tfn fmt (\u0026 self, formatter: \u0026 mut ::std::fmt::Formatter) -\u003e ::std::fmt::Result {\n\t\t\t\tenum_display! (@variants $enum_name, self, formatter, $($rest)*);\n\t\t\t\tpanic! (\"Unhandled variant {}::{:?}\", stringify! ($enum_name), self);\n\t\t\t}\n\t\t}\n\t};\n\n\t( @variants $enum_name:ident, $self:ident, $formatter:ident $(,)? ) =\u003e {};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident { $($var_fields:tt)* } = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name { $($var_fields)* } = $self {\n\t\t\tlet $var_arg = $formatter;\n\t\t\treturn (|| -\u003e ::std::fmt::Result { $($var_body)*; Ok (()) }) ();\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident ( $($var_fields:tt)* ) = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name ( $($var_fields)* ) = $self {\n\t\t\tlet $var_arg = \u0026 mut $formatter;\n\t\t\t$($var_body)*\n\t\t\treturn Ok (());\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name = $self {\n\t\t\tlet $var_arg = \u0026 mut $formatter;\n\t\t\t$($var_body)*\n\t\t\treturn Ok (());\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident { $($var_fields:tt)* } = [ $($var_arg:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name { $($var_fields)* } = $self {\n\t\t\tdisplay! ($formatter, $($var_arg)*);\n\t\t\treturn Ok (());\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident ( $($var_fields:tt)* ) = [ $($var_arg:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name ( $($var_fields)* ) = $self {\n\t\t\tdisplay! ($formatter, $($var_arg)*);\n\t\t\treturn Ok (());\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $self:ident, $formatter:ident,\n\t\t$var_name:ident = [ $($var_arg:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\tif let $enum_name::$var_name = $self {\n\t\t\tdisplay! ($formatter, $($var_arg)*);\n\t\t\treturn Ok (());\n\t\t};\n\t\tenum_display! (@variants $enum_name, $self, $formatter, $($($rest)*)?);\n\t};\n\n}\n\n#[ macro_export ]\nmacro_rules! parse_display_enum {\n\n\t( $(\n\t\t$( #[ $($enum_attrs:tt)* ] )*\n\t\t$enum_vis:vis enum $enum_name:ident {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attrs:tt)* ] )*\n\t\t\t\t$var_name:ident = $var_str:literal\n\t\t\t),*\n\t\t\t$(,)?\n\t\t}\n\t)* ) =\u003e { $(\n\n\t\t$( #[ $($enum_attrs)* ] )*\n\t\t$enum_vis enum $enum_name {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attrs)* ] )*\n\t\t\t\t$var_name,\n\t\t\t)*\n\t\t}\n\n\t\timpl $enum_name {\n\n\t\t\tpub const NUM_VARIANTS: usize = [ $(stringify! ($var_name)),* ].len ();\n\t\t\tpub const VARIANTS: [$enum_name; Self::NUM_VARIANTS] = [ $(Self::$var_name),* ];\n\n\t\t\t#[ inline ]\n\t\t\tpub const fn as_str (self) -\u003e \u0026 'static str {\n\t\t\t\tmatch self {\n\t\t\t\t\t$( Self::$var_name =\u003e $var_str, )*\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub const fn idx (self) -\u003e usize {\n\t\t\t\tparse_display_enum! (@variant_to_idx self [0] [] $($var_name)*)\n\t\t\t}\n\n\t\t}\n\n\t\timpl ::std::fmt::Display for $enum_name {\n\t\t\tfn fmt (\n\t\t\t\t\u0026 self,\n\t\t\t\tformatter: \u0026 mut ::std::fmt::Formatter,\n\t\t\t) -\u003e ::std::fmt::Result {\n\t\t\t\twrite! (formatter, \"{}\", match * self {\n\t\t\t\t\t$( Self::$var_name =\u003e $var_str, )*\n\t\t\t\t}) ?;\n\t\t\t\tOk (())\n\t\t\t}\n\t\t}\n\n\t\timpl \u003c'inp\u003e ::aoc_common::parser::FromParser \u003c'inp\u003e for $enum_name {\n\t\t\tfn from_parser (\n\t\t\t\tparser: \u0026 mut ::aoc_common::parser::Parser \u003c'inp\u003e,\n\t\t\t) -\u003e ::aoc_common::parser::ParseResult \u003cSelf\u003e {\n\t\t\t\tparser.any ()\n\t\t\t\t\t$( .of (|parser| {\n\t\t\t\t\t\tparser.expect ($var_str) ?;\n\t\t\t\t\t\tOk (Self::$var_name)\n\t\t\t\t\t}) ) *\n\t\t\t\t\t.done ()\n\t\t\t}\n\t\t}\n\n\t\timpl ::std::str::FromStr for $enum_name {\n\t\t\ttype Err = ();\n\t\t\tfn from_str (src: \u0026 str) -\u003e Result \u003cSelf, ()\u003e {\n\t\t\t\tmatch src {\n\t\t\t\t\t$( $var_str =\u003e Ok (Self::$var_name), )*\n\t\t\t\t\t_ =\u003e Err (()),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t)* };\n\n\t(@variant_to_idx $self:ident [$next_idx:expr] [$($data:tt)*] $var_name:ident $($rest:tt)*) =\u003e {\n\t\tparse_display_enum! (@variant_to_idx $self [$next_idx + 1] [$($data)* ($var_name, $next_idx)] $($rest)*)\n\t};\n\t(@variant_to_idx $self:ident [$next_idx:expr] [$(($name:ident, $idx:expr))*]) =\u003e {\n\t\tmatch $self { $(Self::$name =\u003e $idx),* }\n\t};\n\n}\n\n#[ macro_export ]\nmacro_rules! enum_decl_parser_display {\n\n\t( $(\n\t\t$( #[ $($attrs:tt)* ] )*\n\t\t$vis:vis enum $name:ident {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attr:tt)* ] )*\n\t\t\t\t$var_name:ident\n\t\t\t\t$(( $($tuple_name:ident: $tuple_type:ty),* ))?\n\t\t\t\t$({ $($struct_name:ident: $struct_type:ty),* })?\n\t\t\t\t\t= [ $($var_parse:tt)* ]\n\t\t\t),*\n\t\t\t$(,)?\n\t\t}\n\t)* ) =\u003e { $(\n\n\t\t$( #[ $($attrs)* ] )*\n\t\t$vis enum $name {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attr)* ] )*\n\t\t\t\t$var_name\n\t\t\t\t$(( $($tuple_type),* ))?\n\t\t\t\t$({ $($struct_name: $struct_type),* })?\n\t\t\t),*\n\t\t}\n\n\t\tenum_display! {\n\t\t\t$name,\n\t\t\t$(\n\t\t\t\t$var_name\n\t\t\t\t$(( $($tuple_name),* ))?\n\t\t\t\t$({ $($struct_name),* })?\n\t\t\t\t\t= [ $($var_parse)* ]\n\t\t\t),*\n\t\t}\n\n\t\tenum_parser! {\n\t\t\t$name,\n\t\t\t$(\n\t\t\t\t$var_name\n\t\t\t\t$(( $($tuple_name),* ))?\n\t\t\t\t$({ $($struct_name),* })?\n\t\t\t\t\t= [ $($var_parse)* ]\n\t\t\t),*\n\t\t}\n\n\t)* };\n\n\t(\n\t\tinput_lifetime = $inp:tt;\n\t\t$( #[ $($attrs:tt)* ] )*\n\t\t$vis:vis enum $name:ident \u003c$param:tt\u003e {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attr:tt)* ] )*\n\t\t\t\t$var_name:ident\n\t\t\t\t\t$(($($tuple_name:ident: $tuple_type:ty),*))?\n\t\t\t\t\t\t= [ $($var_parse:tt)* ]\n\t\t\t),*\n\t\t\t$(,)?\n\t\t}\n\t) =\u003e {\n\n\t\t$( #[ $($attrs)* ] )*\n\t\t$vis enum $name \u003c$param\u003e {\n\t\t\t$(\n\t\t\t\t$( #[ $($var_attr)* ] )*\n\t\t\t\t$var_name $(( $($tuple_type),* ))?\n\t\t\t),*\n\t\t}\n\n\t\tenum_display! {\n\t\t\t$name \u003c$param\u003e,\n\t\t\t$( $var_name $(($($tuple_name),*))? = [ $($var_parse)* ] ),*\n\t\t}\n\n\t\tenum_parser! {\n\t\t\tinput_lifetime = $inp;\n\t\t\t$name \u003c$param\u003e,\n\t\t\t$( $var_name $(($($tuple_name),*))? = [ $($var_parse)* ] ),*\n\t\t}\n\n\t};\n\n}\n","traces":[{"line":134,"address":[152400],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[92624],"length":1,"stats":{"Line":12},"fn_name":null},{"line":141,"address":[106608],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":145,"address":[58976,59296,59180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[69408],"length":1,"stats":{"Line":11},"fn_name":"from_parser"},{"line":156,"address":[60725],"length":1,"stats":{"Line":21},"fn_name":null},{"line":157,"address":[58992,58896],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":158,"address":[51886,51582],"length":1,"stats":{"Line":80},"fn_name":null},{"line":159,"address":[60765,60669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[140754,140850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[58848],"length":1,"stats":{"Line":2},"fn_name":"from_str"},{"line":169,"address":[58983,59047,58951,58876,59015,58915],"length":1,"stats":{"Line":12},"fn_name":null},{"line":207,"address":[60400,60432,60435,60403],"length":1,"stats":{"Line":19},"fn_name":"{constructor#0}"},{"line":208,"address":[71965,71997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[146307,146336,146339,146304],"length":1,"stats":{"Line":11},"fn_name":"{constructor#0}"}],"covered":8,"coverable":15},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","from_parser.rs"],"content":"use super::*;\n\n/// Trait implemented by types which can be produced by [`Parser::item`]\n///\npub trait FromParser \u003c'inp\u003e: Sized {\n\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e;\n\n\t#[ inline ]\n\tfn parse_from_str (input: \u0026 'inp str) -\u003e GenResult \u003cSelf\u003e {\n\t\tParser::wrap_auto (input, Parser::item)\n\t}\n\n\t#[ inline ]\n\tfn parse_from_lines (input: \u0026 'inp [\u0026 'inp str]) -\u003e GenResult \u003cSelf\u003e {\n\t\tParser::wrap_lines (input, Parser::item)\n\t}\n\n}\n\nmacro_rules! from_parser_impl {\n\t( $name:ident, $method:ident ) =\u003e {\n\t\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for $name {\n\t\t\t#[ inline ]\n\t\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003c$name\u003e {\n\t\t\t\tparser.$method ()\n\t\t\t}\n\t\t}\n\t};\n}\n\nfrom_parser_impl! (i8, int);\nfrom_parser_impl! (i16, int);\nfrom_parser_impl! (i32, int);\nfrom_parser_impl! (i64, int);\nfrom_parser_impl! (i128, int);\nfrom_parser_impl! (isize, int);\n\nfrom_parser_impl! (u8, uint);\nfrom_parser_impl! (u16, uint);\nfrom_parser_impl! (u32, uint);\nfrom_parser_impl! (u64, uint);\nfrom_parser_impl! (u128, uint);\nfrom_parser_impl! (usize, uint);\n\nfrom_parser_impl! (char, expect_next);\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for bool {\n\n\t#[ inline ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tparser.any ()\n\t\t\t.of (|parser| { parser.expect (\"true\") ?; Ok (true) })\n\t\t\t.of (|parser| { parser.expect (\"false\") ?; Ok (false) })\n\t\t\t.done ()\n\t}\n\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for InpStr \u003c'inp\u003e {\n\n\t#[ inline ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tOk (parser.take_rest ())\n\t}\n\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for Rc \u003cstr\u003e {\n\n\t#[ inline ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet inp_str = parser.take_rest ();\n\t\tOk (Self::from (\u0026 * inp_str))\n\t}\n\n}\n\nimpl \u003c'inp\u003e FromParser \u003c'inp\u003e for String {\n\n\t#[ inline ]\n\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\tlet inp_str = parser.take_rest ();\n\t\tOk (Self::from (\u0026 * inp_str))\n\t}\n\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[58896],"length":1,"stats":{"Line":0},"fn_name":"parse_from_lines\u003caoc_2017_day_08::input::Input\u003e"},{"line":16,"address":[45844,45332],"length":1,"stats":{"Line":270},"fn_name":null},{"line":25,"address":[37792,37776],"length":1,"stats":{"Line":0},"fn_name":"from_parser"},{"line":26,"address":[28949],"length":1,"stats":{"Line":42},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":18},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","parse.rs"],"content":"#[ macro_export ]\nmacro_rules! parse {\n\t( $parser:expr, $($rest:tt)* ) =\u003e {\n\t\tparse! (@recurse $parser, $($rest)*);\n\t};\n\t( @recurse $parser:expr $(,)? ) =\u003e {\n\t};\n\t( @recurse $parser:expr, $it_0:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $it_6:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5 $it_6);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $it_6:tt $it_7:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5 $it_6 $it_7);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $it_6:tt $it_7:tt $it_8:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5 $it_6 $it_7 $it_8);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $it_6:tt $it_7:tt $it_8:tt $it_9:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5 $it_6 $it_7 $it_8 $it_9);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @recurse $parser:expr, $it_0:tt $it_1:tt $it_2:tt $it_3:tt $it_4:tt $it_5:tt $it_6:tt $it_7:tt $it_8:tt $it_9:tt $it_10:tt $(, $($rest:tt)*)? ) =\u003e {\n\t\tparse! (@item $parser, $it_0 $it_1 $it_2 $it_3 $it_4 $it_5 $it_6 $it_7 $it_8 $it_9 $it_10);\n\t\tparse! (@recurse $parser $(, $($rest)*)?);\n\t};\n\t( @item $parser:expr, $expect_str:literal ) =\u003e {\n\t\t$parser.expect ($expect_str) ?;\n\t};\n\t( @item $parser:expr, $item_name:ident ) =\u003e {\n\t\tlet $item_name = $parser.item () ?;\n\t};\n\t( @item $parser:expr, $item_name:ident: $item_type:ty ) =\u003e {\n\t\tlet $item_name: $item_type = $parser.item () ?;\n\t};\n\t( @item $parser:expr, $item_name:ident = $item_parse:ident ) =\u003e {\n\t\tlet $item_name = $item_parse ($parser) ?;\n\t};\n\t( @item $parser:expr, $name:ident = ($parse:path, $display:path) ) =\u003e {\n\t\tlet $name = $parse ($parser) ?;\n\t};\n\t( @item $parser:expr, $item_name:ident { $($nest:tt)* } ) =\u003e {\n\t\tlet $item_name = $parser.nest (parse! (@nest $($nest)*)) ?;\n\t};\n\t( @item $parser:expr, ($($name:ident),*) = $item_parse:ident ) =\u003e {\n\t\tlet ($($name),*) = $item_parse ($parser) ?;\n\t};\n\t( @item $parser:expr, ($($name:ident),*) = ($parse:ident, $display:ident) ) =\u003e {\n\t\tlet ($($name),*) = $parse ($parser) ?;\n\t};\n\t( @item $parser:expr, ($($name:ident),*) { $($nest:tt)* } ) =\u003e {\n\t\tlet ($($name),*) = $parser.nest (parse! (@nest $($nest)*)) ?;\n\t};\n\t( @item $parser:expr, $item_name:ident = $item_range:expr ) =\u003e {\n\t\tlet $item_name = $parser.item_range ($item_range) ?;\n\t};\n\t( @item $parser:expr, @array $item_name:ident ) =\u003e {\n\t\tlet temp_vec: Vec \u003c_\u003e = $parser\n\t\t\t.repeat (Parser::item)\n\t\t\t.collect ();\n\t\tlet $item_name = temp_vec.try_into ().map_err (|_err| $parser.err ()) ?;\n\t};\n\t( @item $parser:expr, @array_delim $delim:literal $name:ident $($rest:tt)* ) =\u003e {\n\t\tlet temp_vec: Vec \u003c_\u003e = {\n\t\t\tparse! (@item $parser, @delim $delim temp_vec $($rest)*);\n\t\t\ttemp_vec\n\t\t};\n\t\tlet $name = temp_vec.try_into ().map_err (|_err| $parser.err ()) ?;\n\t};\n\t( @item $parser:expr, @char $name:ident = |$arg:ident| { $($valid:tt)* } ) =\u003e {\n\t\tlet $name: char = match $parser.peek () {\n\t\t\tSome (ch) if (|$arg: char| { $($valid)* }) (ch) =\u003e { $parser.next ().unwrap (); ch },\n\t\t\t_ =\u003e { return Err ($parser.err ()) },\n\t\t};\n\t};\n\t( @item $parser:expr, @collect $name:ident ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.repeat (Parser::item)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect $name:ident: $type:ty ) =\u003e {\n\t\tlet $name: $type = $parser\n\t\t\t.repeat (Parser::item)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect $name:ident = $parse:path ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.repeat ($parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect $name:ident = ($parse:expr, $display:expr) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.repeat ($parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect $name:ident { $($nest:tt)* } ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.repeat (parse! (@nest $($nest)*))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect_max $max:literal $name:ident ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.repeat (Parser::item)\n\t\t\t.take ($max)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @collect_some $item_name:ident ) =\u003e {\n\t\tlet mut temp_iter = $parser.repeat (Parser::item);\n\t\tlet $item_name = match temp_iter.next () {\n\t\t\tSome (first) =\u003e iter::once (first).chain (temp_iter).collect (),\n\t\t\tNone =\u003e return Err ($parser.err ()),\n\t\t};\n\t};\n\t( @item $parser:expr, @collect_some $item_name:ident: $item_type:ty ) =\u003e {\n\t\tlet $item_name: $item_type = $parser\n\t\t\t.repeat (Parser::item)\n\t\t\t.collect ();\n\t\tif $item_name.is_empty () { return Err ($parser.err ()) }\n\t};\n\t( @item $parser:expr, @collect_some_max $max:literal $item_name:ident ) =\u003e {\n\t\tlet mut temp_iter = $parser.repeat (Parser::item).take ($max);\n\t\tlet $item_name = match temp_iter.next () {\n\t\t\tSome (first) =\u003e iter::once (first).chain (temp_iter).collect (),\n\t\t\tNone =\u003e return Err ($parser.err ()),\n\t\t};\n\t};\n\t( @item $parser:expr, @delim $delim:literal $item_name:ident ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.delim_fn ($delim, Parser::item)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, (@delim $delim:literal $item_name:ident): $item_type:ty ) =\u003e {\n\t\tlet $item_name: $item_type = $parser\n\t\t\t.delim_fn ($delim, Parser::item)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $name:ident = $parse:path ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn ($delim, $parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $name:ident = ($rng_0:literal .. ) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn ($delim, |parser| parser.item_range ($rng_0 .. ))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $name:ident = ($rng_0:literal .. $rng_1:literal) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn ($delim, |parser| parser.item_range ($rng_0 .. $rng_1))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $name:ident = ($rng_0:literal ..= $rng_1:literal) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn ($delim, |parser| parser.item_range ($rng_0 ..= $rng_1))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $name:ident = ($parse:path, $display:path) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn ($delim, $parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim $delim:literal $item_name:ident { $($nest:tt)* } ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.delim_fn ($delim, parse! (@nest $($nest)*))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @delim_some $delim:literal $item_name:ident ) =\u003e {\n\t\tlet mut temp_iter = $parser.delim_fn ($delim, Parser::item);\n\t\tlet $item_name = match temp_iter.next () {\n\t\t\tSome (first) =\u003e iter::once (first).chain (temp_iter).collect (),\n\t\t\tNone =\u003e return Err ($parser.err ()),\n\t\t};\n\t};\n\t( @item $parser:expr, @lines $item_name:ident ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.delim_fn (\"\\n\", Parser::item)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident: $type:ty { $($nest:tt)* } ) =\u003e {\n\t\tlet $name: $type = $parser\n\t\t\t.delim_fn (\"\\n\", parse! (@nest $($nest)*))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident = $rng_0:literal ..= $rng_1:literal ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn (\"\\n\", |parser| parser.item_range ($rng_0 ..= $rng_1))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident = $parse:path ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn (\"\\n\", $parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident = |$arg:ident| { $($body:tt)* } ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn (\"\\n\", |$arg| { $($body)* })\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident = ($parse:path, $display:path) ) =\u003e {\n\t\tlet $name = $parser\n\t\t\t.delim_fn (\"\\n\", $parse)\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @lines $name:ident = (|$arg:ident| { $($body:tt)* }, $rng_0:literal ..= $rng_1:literal) ) =\u003e {\n\t\ttodo! ();\n\t};\n\t( @item $parser:expr, @lines $item_name:ident { $($nest:tt)* } ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.delim_fn (\"\\n\", parse! (@nest $($nest)*))\n\t\t\t.collect ();\n\t};\n\t( @item $parser:expr, @opt $name:ident { $($nest:tt)* } ) =\u003e {\n\t\tlet $name = $parser.any ()\n\t\t\t.of (parse! (@nest $($nest)*))\n\t\t\t.of (|parser| { Ok (default ()) })\n\t\t\t.done () ?;\n\t};\n\t( @item $parser:expr, @str $item_name:ident = (|$fn_arg:ident| { $($fn_body:tt)* }, $len:expr) ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.take_rest_while (|$fn_arg| { $($fn_body)* }, $len) ?\n\t\t\t.into ();\n\t};\n\t( @item $parser:expr, @str $item_name:ident = ($rng_0:literal ..= $rng_1:literal, $len:expr) ) =\u003e {\n\t\tlet $item_name = $parser\n\t\t\t.take_rest_while (|ch| ($rng_0 ..= $rng_1).contains (\u0026 ch), $len) ?\n\t\t\t.into ();\n\t};\n\t( @item $parser:expr, @end ) =\u003e {\n\t\t$parser.end () ?;\n\t};\n\t( @item $parser:expr, @confirm ) =\u003e {\n\t\t$parser.confirm ();\n\t};\n\t( @item $parser:expr, @parse { $($body:tt)* } ) =\u003e {\n\t\t{ $($body)* }\n\t};\n\t( @item $parser:expr, @parse |$arg:ident| { $($body:tt)* } ) =\u003e {\n\t\t{ let $arg = $parser; $($body)* }\n\t};\n\t( @item $parser:expr, @parse $name:ident { $($body:tt)* } ) =\u003e {\n\t\tlet $name = { $($body)* };\n\t};\n\t( @item $parser:expr, @skip ) =\u003e {\n\t\t$parser.skip_whitespace ( .. ) ?;\n\t};\n\t( @item $parser:expr, @skip $display:literal ) =\u003e {\n\t\t$parser.skip_whitespace ( .. ) ?;\n\t};\n\n\t( @nest input_lifetime = $input_life:lifetime; type = $type:ty; $($rest:tt)* ) =\u003e {\n\t\t|parser: \u0026 mut Parser \u003c$input_life\u003e| {\n\t\t\tlet parser = parser.any ();\n\t\t\tparse! (@nest_var parser $($rest)*);\n\t\t\tparser.done ()\n\t\t}\n\t};\n\t( @nest type = $type:ty; $($rest:tt)* ) =\u003e {\n\t\t|parser: \u0026 mut Parser| {\n\t\t\tlet parser = parser.any ();\n\t\t\tparse! (@nest_var parser $($rest)*);\n\t\t\tparser.done ()\n\t\t}\n\t};\n\t( @nest input_lifetime = $input_life:lifetime; $($var:tt)* ) =\u003e {\n\t\t|parser: \u0026 mut Parser \u003c$input_life\u003e| {\n\t\t\tlet parser = parser.any ();\n\t\t\tparse! (@nest_var parser $($var)*);\n\t\t\tparser.done ()\n\t\t}\n\t};\n\t( @nest display_type = $display_type:ty; $($var:tt)* ) =\u003e {\n\t\t|parser: \u0026 mut Parser| {\n\t\t\tlet parser = parser.any ();\n\t\t\tparse! (@nest_var parser $($var)*);\n\t\t\tparser.done ()\n\t\t}\n\t};\n\t( @nest $($var:tt)* ) =\u003e {\n\t\t|parser: \u0026 mut Parser| {\n\t\t\tlet parser = parser.any ();\n\t\t\tparse! (@nest_var parser $($var)*);\n\t\t\tparser.done ()\n\t\t}\n\t};\n\n\t( @nest_var $parser:ident $lit:literal = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($lit)\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $var:ident $( if ($cond:expr) )? = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($var)\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $enum:ident::$var:ident = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($enum::$var)\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $var:ident: $type:ty = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($var)\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident ( $($decl:tt)* ) $( if ($cond:expr) )? = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk (( $($decl)* ))\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $var:ident ( $($decl:tt)* ) = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($var ($($decl)*))\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $var:ident { $($decl:tt)* } = [ $($parse:tt)* ] $(,$($rest:tt)*)? ) =\u003e {\n\t\tlet $parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($parse)*);\n\t\t\tOk ($var { $($decl)* })\n\t\t});\n\t\tparse! (@nest_var $parser $($($rest)*)?);\n\t};\n\t( @nest_var $parser:ident $(,)? ) =\u003e { };\n\n}\n\n#[ macro_export ]\nmacro_rules! enum_parser {\n\n\t( $enum_name:ident, $($rest:tt)* ) =\u003e {\n\t\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for $enum_name {\n\t\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\t\tlet mut parser = parser.any ();\n\t\t\t\tenum_parser! (@variants $enum_name, parser, $($rest)*);\n\t\t\t\tparser.done ()\n\t\t\t}\n\t\t}\n\t};\n\n\t(\n\t\tinput_lifetime = $inp:lifetime;\n\t\t$enum_name:ident \u003c$param:tt\u003e,\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\timpl \u003c$inp\u003e FromParser \u003c$inp\u003e for $enum_name \u003c$param\u003e {\n\t\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\t\tlet mut parser = parser.any ();\n\t\t\t\tenum_parser! (@variants $enum_name, parser, $($rest)*);\n\t\t\t\tparser.done ()\n\t\t\t}\n\t\t}\n\t};\n\n\t( @variants $enum_name:ident, $parser:ident $(,)? ) =\u003e {};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident { $($var_fields:tt)* } = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(,$($rest:tt)*)?\n\t) =\u003e {\n\t\t$parser = $parser.of (|$var_arg| {\n\t\t\t$($var_body)*\n\t\t\tOk (Self::$var_name { $($var_fields)* })\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident ( $($var_fields:tt)* ) = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\t$parser = $parser.of (|$var_arg| {\n\t\t\t$($var_body)*\n\t\t\tOk (Self::$var_name ( $($var_fields)* ))\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $(, $($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident { $($var_fields:tt)* } = [ $($var_args:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\t$parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($var_args)*);\n\t\t\tOk (Self::$var_name { $($var_fields)* })\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident ( $($var_fields:tt)* ) = [ $($var_args:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\t$parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($var_args)*);\n\t\t\tOk (Self::$var_name ( $($var_fields)* ))\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident = [ $($var_args:tt)* ]\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\t$parser = $parser.of (|parser| {\n\t\t\tparse! (parser, $($var_args)*);\n\t\t\tOk (Self::$var_name)\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $($($rest)*)?);\n\t};\n\n\t(\n\t\t@variants $enum_name:ident, $parser:ident,\n\t\t$var_name:ident = |$var_arg:ident| { $($var_body:tt)* }\n\t\t$(, $($rest:tt)* )?\n\t) =\u003e {\n\t\t$parser = $parser.of (|$var_arg| {\n\t\t\t$($var_body)*\n\t\t\tOk (Self::$var_name)\n\t\t});\n\t\tenum_parser! (@variants $enum_name, $parser, $(, $($rest)*)?);\n\t};\n\n}\n","traces":[{"line":86,"address":[90775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[87424,87443,87456,87475],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":169,"address":[50032,50276],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":179,"address":[22855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[53312,53327,53343,53328],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":250,"address":[37904,37909],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":283,"address":[52592],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":285,"address":[24590],"length":1,"stats":{"Line":23},"fn_name":null},{"line":286,"address":[24616],"length":1,"stats":{"Line":17},"fn_name":null},{"line":297,"address":[84080],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":304,"address":[144320],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":305,"address":[33101],"length":1,"stats":{"Line":2},"fn_name":null},{"line":306,"address":[51032],"length":1,"stats":{"Line":4},"fn_name":null},{"line":307,"address":[51057],"length":1,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[47552,48320],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":313,"address":[48330,47562],"length":1,"stats":{"Line":6},"fn_name":null},{"line":314,"address":[47653,48421],"length":1,"stats":{"Line":6},"fn_name":null},{"line":319,"address":[29488],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":320,"address":[29518],"length":1,"stats":{"Line":12},"fn_name":null},{"line":321,"address":[47833,48601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[26976,27072],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":327,"address":[27082,26986],"length":1,"stats":{"Line":20},"fn_name":null},{"line":328,"address":[27149,27053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[53297,52928],"length":1,"stats":{"Line":20},"fn_name":"{closure#0}"},{"line":341,"address":[53017,52946,53178],"length":1,"stats":{"Line":58},"fn_name":null},{"line":342,"address":[53231],"length":1,"stats":{"Line":17},"fn_name":null},{"line":347,"address":[56656],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":348,"address":[31027,30893],"length":1,"stats":{"Line":4},"fn_name":null},{"line":349,"address":[56725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[144608],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":355,"address":[144631,144875],"length":1,"stats":{"Line":10},"fn_name":null},{"line":356,"address":[144880],"length":1,"stats":{"Line":4},"fn_name":null},{"line":369,"address":[32160,32512],"length":1,"stats":{"Line":23},"fn_name":"from_parser"},{"line":371,"address":[32532,33202,32180],"length":1,"stats":{"Line":88},"fn_name":null},{"line":372,"address":[40165],"length":1,"stats":{"Line":78},"fn_name":null},{"line":383,"address":[146576],"length":1,"stats":{"Line":3},"fn_name":"from_parser"},{"line":385,"address":[111260,109528,109074,109908,110739,110398],"length":1,"stats":{"Line":16},"fn_name":null},{"line":386,"address":[109598,110475,109982,111337,109149,110813],"length":1,"stats":{"Line":8},"fn_name":null},{"line":422,"address":[56704,57056],"length":1,"stats":{"Line":16},"fn_name":"{closure#0}"},{"line":423,"address":[57022,57074,57374,56722],"length":1,"stats":{"Line":44},"fn_name":null},{"line":424,"address":[57027,57379],"length":1,"stats":{"Line":16},"fn_name":null},{"line":434,"address":[52416,52752,52737],"length":1,"stats":{"Line":45},"fn_name":"{closure#0}"},{"line":435,"address":[52769,52435,52896,52904,52594],"length":1,"stats":{"Line":158},"fn_name":null},{"line":436,"address":[52970,52682],"length":1,"stats":{"Line":45},"fn_name":null},{"line":446,"address":[44432,44528,44240,44624,44144,43952,44336,44048],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":447,"address":[43962,44250,44154,44442,44634,44538,44346,44058],"length":1,"stats":{"Line":128},"fn_name":null},{"line":448,"address":[44125,44221,44605,44317,44413,44509,44701,44029],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":33,"coverable":47},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","parser.rs"],"content":"use aoc_inpstr::*;\nuse aoc_misc::prelude::*;\nuse aoc_nums as nums;\n\nuse nums::IntConv;\n\nmod delim;\nmod display;\nmod enums;\nmod from_parser;\nmod parse;\nmod structs;\n\npub use delim::*;\npub use display::IntoIteratorDisplayDelim;\npub use from_parser::FromParser;\n\npub type ParseResult \u003cItem\u003e = Result \u003cItem, ParseError\u003e;\n\n#[ derive (Clone, Copy) ]\npub struct Parser \u003c'inp\u003e {\n\tinput_line: \u0026 'inp str,\n\tinput_lines: \u0026 'inp [\u0026 'inp str],\n\tline_idx: u32,\n\tcol_idx: u32,\n\tbyte_idx: u32,\n\tword_pred: fn (char) -\u003e bool,\n\tignore_whitespace: bool,\n\tconfirmed: bool,\n}\n\n#[ derive (Debug) ]\npub enum ParseError {\n\tSimple (u32, u32),\n\tWrapped (GenError),\n}\n\npub trait ResultParser \u003cItem\u003e {\n\n\t/// Map error from [`ParseError`] to `Box \u003cdyn Error\u003e` using the provided function\n\t///\n\t#[ allow (clippy::missing_errors_doc) ]\n\tfn map_parse_err \u003cMapFn, IntoGenErr\u003e (self, map_fn: MapFn) -\u003e GenResult \u003cItem\u003e\n\t\twhere\n\t\t\tMapFn: FnOnce (u32, u32) -\u003e IntoGenErr,\n\t\t\tIntoGenErr: Into \u003cGenError\u003e;\n\n\tfn map_parse_err_auto (self, parser: \u0026 Parser) -\u003e GenResult \u003cItem\u003e;\n\n\tfn map_parse_err_line (self, line_idx: usize, line: \u0026 str) -\u003e GenResult \u003cItem\u003e;\n\n}\n\nimpl \u003cItem\u003e ResultParser \u003cItem\u003e for Result \u003cItem, ParseError\u003e {\n\n\t#[ inline ]\n\tfn map_parse_err \u003cMapFn, IntoGenErr\u003e (self, map_fn: MapFn) -\u003e GenResult \u003cItem\u003e\n\t\twhere\n\t\t\tMapFn: FnOnce (u32, u32) -\u003e IntoGenErr,\n\t\t\tIntoGenErr: Into \u003cGenError\u003e {\n\t\tmatch self {\n\t\t\tOk (item) =\u003e Ok (item),\n\t\t\tErr (ParseError::Simple (line_idx, col_idx)) =\u003e\n\t\t\t\tErr (map_fn (line_idx, col_idx).into ()),\n\t\t\tErr (ParseError::Wrapped (err)) =\u003e Err (err),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn map_parse_err_auto (self, parser: \u0026 Parser) -\u003e GenResult \u003cItem\u003e {\n\t\tself.map_parse_err (|line_idx, col_idx| {\n\t\t\tlet line = parser.input_lines [line_idx.pan_usize ()];\n\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, col_idx + 1, line)\n\t\t})\n\t}\n\n\t#[ inline ]\n\tfn map_parse_err_line (self, line_idx: usize, line: \u0026 str) -\u003e GenResult \u003cItem\u003e {\n\t\tself.map_parse_err (|_, col_idx|\n\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, col_idx + 1, line))\n\t}\n\n}\n\nimpl Display for ParseError {\n\n\t#[ inline ]\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tSelf::Simple (line_idx, col_idx) =\u003e\n\t\t\t\twrite! (formatter, \"Parser error at line {}, col {}\", line_idx + 1, col_idx + 1) ?,\n\t\t\tSelf::Wrapped (ref inner) =\u003e\n\t\t\t\tDisplay::fmt (inner, formatter) ?,\n\t\t}\n\t\tOk (())\n\t}\n\n}\n\nimpl Error for ParseError {\n}\n\nimpl From \u003cGenError\u003e for ParseError {\n\n\t#[ inline ]\n    fn from (other: GenError) -\u003e Self {\n        Self::Wrapped (other)\n    }\n\n}\n\nimpl From \u003cnums::Overflow\u003e for ParseError {\n\n\t#[ inline ]\n\tfn from (other: nums::Overflow) -\u003e Self {\n\t\tSelf::Wrapped (Box::new (other))\n\t}\n\n}\n\nimpl From \u003c\u0026 str\u003e for ParseError {\n\n\t#[ inline ]\n\tfn from (other: \u0026 str) -\u003e Self {\n\t\tSelf::Wrapped (other.into ())\n\t}\n\n}\n\nimpl From \u003cString\u003e for ParseError {\n\n\t#[ inline ]\n\tfn from (other: String) -\u003e Self {\n\t\tSelf::Wrapped (other.into ())\n\t}\n\n}\n\nimpl \u003c'inp\u003e Parser \u003c'inp\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new (input_line: \u0026 'inp str) -\u003e Parser \u003c'inp\u003e {\n\t\tParser {\n\t\t\tinput_line,\n\t\t\tinput_lines: \u0026 [],\n\t\t\tline_idx: 0,\n\t\t\tcol_idx: 0,\n\t\t\tbyte_idx: 0,\n\t\t\tword_pred: |ch| ! ch.is_whitespace (),\n\t\t\tignore_whitespace: false,\n\t\t\tconfirmed: false,\n\t\t}\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new_lines (input_lines: \u0026 'inp [\u0026 'inp str]) -\u003e Parser \u003c'inp\u003e {\n\t\tParser {\n\t\t\tinput_line: input_lines.first ().copied ().unwrap_or (\"\"),\n\t\t\tinput_lines,\n\t\t\tline_idx: 0,\n\t\t\tcol_idx: 0,\n\t\t\tbyte_idx: 0,\n\t\t\tword_pred: |ch| ! ch.is_whitespace (),\n\t\t\tignore_whitespace: false,\n\t\t\tconfirmed: false,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn confirm (\u0026 mut self) -\u003e \u0026 mut Self {\n\t\tself.confirmed = true;\n\t\tself\n\t}\n\n\t#[ inline ]\n\tpub fn set_ignore_whitespace (\u0026 mut self, ignore_whitespace: bool) -\u003e \u0026 mut Self {\n\t\tself.ignore_whitespace = ignore_whitespace;\n\t\tself\n\t}\n\n\t#[ inline ]\n\tpub fn set_word_pred (\u0026 mut self, word_pred: fn (char) -\u003e bool) -\u003e \u0026 mut Self {\n\t\tself.word_pred = word_pred;\n\t\tself\n\t}\n\n\t/// Consume a specific string from the input\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if the input does not match the specified value\n\t///\n\t#[ allow (clippy::string_slice) ]\n\t#[ inline ]\n\tpub fn expect (\u0026 mut self, expect: \u0026 str) -\u003e ParseResult \u003c\u0026 mut Self\u003e {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tlet saved = * self;\n\t\tlet mut input_iter = self.input_line.bytes ();\n\t\tlet mut num_chars = 0_u32;\n\t\tlet mut num_bytes = 0_u32;\n\t\tfor expect_byte in expect.bytes () {\n\t\t\tmatch input_iter.next () {\n\t\t\t\tSome (input_byte) if input_byte == expect_byte =\u003e {\n\t\t\t\t\tif expect_byte \u0026 0xc0 != 0x80 { num_chars += 1; }\n\t\t\t\t\tnum_bytes += 1;\n\t\t\t\t},\n\t\t\t\tNone if expect_byte == b'\\n'\n\t\t\t\t\t\t\u0026\u0026 self.line_idx.pan_usize () + 1 \u003c self.input_lines.len () =\u003e {\n\t\t\t\t\tself.line_idx += 1;\n\t\t\t\t\tself.col_idx = 0;\n\t\t\t\t\tself.byte_idx = 0;\n\t\t\t\t\tself.input_line = self.input_lines [self.line_idx.pan_usize ()];\n\t\t\t\t\tinput_iter = self.input_line.bytes ();\n\t\t\t\t\tnum_chars = 0;\n\t\t\t\t\tnum_bytes = 0;\n\t\t\t\t},\n\t\t\t\t_ =\u003e {\n\t\t\t\t\t* self = saved;\n\t\t\t\t\treturn Err (self.err ());\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\tself.col_idx += num_chars;\n\t\tself.byte_idx += num_bytes;\n\t\tself.input_line = \u0026 self.input_line [num_bytes.pan_usize () .. ];\n\t\tOk (self)\n\t}\n\n\t/// Consume a specific word from the input\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if the input does not match the specified value\n\t///\n\t#[ inline ]\n\tpub fn expect_word (\u0026 mut self, expect: \u0026 str) -\u003e ParseResult \u003c\u0026 mut Self\u003e {\n\t\tif self.word () ? != expect { Err (self.err ()) ? }\n\t\tOk (self)\n\t}\n\n\t/// Consume and return a decimal integer from the input\n\t///\n\t/// This consumes a string of the form [-+]?[0-9]+ from the input and calls [`str::parse`] to\n\t/// convert it to the specified type.\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if `parse` returns an `Err`\n\t///\n\t#[ inline ]\n\tpub fn int \u003cIntType\u003e (\u0026 mut self) -\u003e ParseResult \u003cIntType\u003e where IntType: FromStr {\n\t\tlet saved = * self;\n\t\tself.int_str ().parse ().map_err (|_err| {\n\t\t\t* self = saved;\n\t\t\tself.err ()\n\t\t})\n\t}\n\n\t/// Consume and return an unsigned decimal integer from the input\n\t///\n\t/// This consumes a string of the form [0-9]+ from the input and calls [`str::parse`] to\n\t/// convert it to the specified type.\n\t///\n\t/// This will actually work with signed integers, although note that it will only match digits\n\t/// and never a leading minus sign.\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if `parse` returns an `Err`\n\t///\n\t#[ inline ]\n\tpub fn uint \u003cIntType\u003e (\n\t\t\u0026 mut self,\n\t) -\u003e ParseResult \u003cIntType\u003e where IntType: FromStr {\n\t\tlet saved = * self;\n\t\tself.uint_str ().parse ().map_err (|_err| { * self = saved; self.err () })\n\t}\n\n\t#[ inline ]\n\tpub fn item \u003cItem\u003e (\u0026 mut self) -\u003e ParseResult \u003cItem\u003e\n\t\t\twhere Item: FromParser \u003c'inp\u003e {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tItem::from_parser (self)\n\t}\n\n\t#[ inline ]\n\tpub fn item_range \u003cItem\u003e (\u0026 mut self, range: impl RangeBounds \u003cItem\u003e) -\u003e ParseResult \u003cItem\u003e\n\t\t\twhere Item: FromParser \u003c'inp\u003e + PartialOrd {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tlet saved = * self;\n\t\tlet val = Item::from_parser (self) ?;\n\t\tif ! range.contains (\u0026 val) {\n\t\t\t* self = saved;\n\t\t\treturn Err (self.err ());\n\t\t}\n\t\tOk (val)\n\t}\n\n\t#[ allow (clippy::string_slice) ]\n\tfn int_str (\u0026 mut self) -\u003e \u0026 str {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tlet num_digits =\n\t\t\tself.input_line.bytes ().enumerate ()\n\t\t\t\t.take_while (|\u0026 (idx, ch)|\n\t\t\t\t\tch.is_ascii_digit () || (idx == 0 \u0026\u0026 (ch == b'-' || ch == b'+')))\n\t\t\t\t.fold (0, |sum, _| sum + 1);\n\t\tlet val = \u0026 self.input_line [ .. num_digits.pan_usize ()];\n\t\tself.input_line = \u0026 self.input_line [num_digits.pan_usize () .. ];\n\t\tself.col_idx += num_digits;\n\t\tself.byte_idx += num_digits;\n\t\tval\n\t}\n\n\t#[ allow (clippy::string_slice) ]\n\tfn uint_str (\u0026 mut self) -\u003e \u0026 str {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tlet num_digits =\n\t\t\tself.input_line.bytes ()\n\t\t\t\t.take_while (|\u0026 ch| ch.is_ascii_digit ())\n\t\t\t\t.fold (0, |sum, _| sum + 1);\n\t\tlet val = \u0026 self.input_line [ .. num_digits.pan_usize ()];\n\t\tself.input_line = \u0026 self.input_line [num_digits.pan_usize () .. ];\n\t\tself.col_idx += num_digits;\n\t\tself.byte_idx += num_digits;\n\t\tval\n\t}\n\n\t/// Consume and return a single word from the input\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if there is no word remaining\n\t///\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t#[ allow (clippy::string_slice) ]\n\tpub fn word (\u0026 mut self) -\u003e ParseResult \u003c\u0026 'inp str\u003e {\n\t\tif self.ignore_whitespace { self.skip_whitespace ( .. ).unwrap (); }\n\t\tlet (num_chars, num_bytes) =\n\t\t\tself.input_line.chars ()\n\t\t\t\t.take_while (|\u0026 ch| (self.word_pred) (ch))\n\t\t\t\t.map (char::len_utf8)\n\t\t\t\t.fold ((0_u32, 0_usize), |(num_chars, num_bytes), ch_bytes|\n\t\t\t\t\t(num_chars + 1, num_bytes + ch_bytes));\n\t\tif num_chars == 0 { return Err (self.err ()) }\n\t\tlet word = \u0026 self.input_line [ .. num_bytes.pan_usize ()];\n\t\tself.input_line = \u0026 self.input_line [num_bytes.pan_usize () .. ];\n\t\tself.col_idx += num_chars;\n\t\tself.byte_idx += num_bytes.pan_u32 ();\n\t\tOk (word)\n\t}\n\n\t/// Consume and return a single word from the input, transforming it with [`TryInto`]\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if there is no word remaining.\n\t///\n\t/// Returns `Err (ParseError::Wrapped (err))` if the conversion fails.\n\t///\n\t#[ inline ]\n\tpub fn word_into \u003c'par, Output\u003e (\u0026 'par mut self) -\u003e ParseResult \u003cOutput\u003e\n\t\t\twhere Output: TryFrom \u003c\u0026 'par str, Error = GenError\u003e {\n\t\tOk (self.word () ?.try_into () ?)\n\t}\n\n\t/// Consume and return a single word from the input, validating it with the provided function\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if there is no word remaining, or if the provided predicate\n\t/// function returns false\n\t///\n\t#[ inline ]\n\tpub fn word_if \u003c'par_1\u003e (\n\t\t\u0026 'par_1 mut self,\n\t\tpred: impl FnOnce (\u0026 'inp str) -\u003e bool,\n\t) -\u003e ParseResult \u003c\u0026 'inp str\u003e {\n\t\tlet word = self.word () ?;\n\t\tif ! pred (word) { Err (self.err ()) ?; }\n\t\tOk (word)\n\t}\n\n\t/// Return a word from the input without consuming it\n\t///\n\t#[ inline ]\n\tpub fn peek_word (\u0026 mut self) -\u003e Option \u003c\u0026 'inp str\u003e {\n\t\tself.clone ().word ().ok ()\n\t}\n\n\t/// Consume any whitespace from the start of the remaining input\n\t///\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t#[ allow (clippy::string_slice) ]\n\tpub fn skip_whitespace (\u0026 mut self, range: impl RangeBounds \u003cu32\u003e) -\u003e ParseResult \u003c\u0026 mut Self\u003e {\n\t\tlet saved = * self;\n\t\tlet num_spaces =\n\t\t\tself.input_line.bytes ()\n\t\t\t\t.take_while (|\u0026 ch| ch.is_ascii_whitespace ())\n\t\t\t\t.fold (0_u32, |sum, _| sum + 1);\n\t\tif ! range.contains (\u0026 num_spaces) { * self = saved; return Err (self.err ()) }\n\t\tself.input_line = \u0026 self.input_line [num_spaces.pan_usize () .. ];\n\t\tself.col_idx += num_spaces;\n\t\tself.byte_idx += num_spaces;\n\t\tOk (self)\n\t}\n\n\t/// Assert that there is no more input to consume\n\t///\n\t/// # Errors\n\t///\n\t/// Returns `Err (self.err ())` if there is more input.\n\t///\n\t#[ inline ]\n\tpub fn end (\u0026 mut self) -\u003e ParseResult \u003c()\u003e {\n\t\tif self.peek ().is_some () { Err (self.err ()) ? }\n\t\tOk (())\n\t}\n\n\t/// Consume and return the next character from the input\n\t///\n\t#[ allow (clippy::should_implement_trait) ]\n\t#[ allow (clippy::string_slice) ]\n\t#[ inline ]\n\tpub fn next (\u0026 mut self) -\u003e Option \u003cchar\u003e {\n\t\tif self.input_line.is_empty () \u0026\u0026 self.line_idx + 1 \u003c self.input_lines.len ().pan_u32 () {\n\t\t\tself.line_idx += 1;\n\t\t\tself.input_line = self.input_lines [self.line_idx.pan_usize ()];\n\t\t\tself.col_idx = 0;\n\t\t\treturn Some ('\\n');\n\t\t}\n\t\tlet ch = self.input_line.chars ().next () ?;\n\t\tself.input_line = \u0026 self.input_line [ch.len_utf8 () .. ];\n\t\tself.col_idx += 1;\n\t\tself.byte_idx += ch.len_utf8 ().pan_u32 ();\n\t\tSome (ch)\n\t}\n\n\t/// Return the next character from the input without consuming it\n\t///\n\t#[ inline ]\n\tpub fn peek (\u0026 mut self) -\u003e Option \u003cchar\u003e {\n\t\tself.input_line.chars ().next ().or_else (||\n\t\t\t(self.line_idx + 1 \u003c self.input_lines.len ().pan_u32 ()).then_some ('\\n'))\n\t}\n\n\t/// Consume and return the next character from the input\n\t///\n\t/// # Errors\n\t///\n\t/// Will return `Err (self.err ())` if there is no input remaining.\n\t///\n\t#[ inline ]\n\tpub fn expect_next (\u0026 mut self) -\u003e ParseResult \u003cchar\u003e {\n\t\tself.next ().ok_or_else (|| self.err ())\n\t}\n\n\t/// Return a `ParseError` with the current position\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn err (\u0026 self) -\u003e ParseError {\n\t\tParseError::Simple (self.line_idx, self.col_idx)\n\t}\n\n\t#[ inline ]\n\tpub fn any \u003cItem\u003e (\u0026 mut self) -\u003e ParserAny \u003c'_, 'inp, Item\u003e {\n\t\tParserAny::Parser (self)\n\t}\n\n\t#[ inline ]\n\tpub fn wrap \u003cOutput, WrapFn\u003e (\n\t\tinput: \u0026 'inp str,\n\t\tmut wrap_fn: WrapFn,\n\t) -\u003e ParseResult \u003cOutput\u003e\n\t\t\twhere WrapFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tlet mut parser = Parser::new (input);\n\t\twrap_fn (\u0026 mut parser)\n\t}\n\n\t#[ inline ]\n\tpub fn wrap_auto \u003cOutput, WrapFn\u003e (\n\t\tinput: \u0026 'inp str,\n\t\tmut wrap_fn: WrapFn,\n\t) -\u003e GenResult \u003cOutput\u003e\n\t\t\twhere WrapFn: for \u003c'par1\u003e FnMut (\u0026 'par1 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tSelf::wrap (input, |parser: \u0026 mut Parser \u003c'inp\u003e| {\n\t\t\tlet item = wrap_fn (parser) ?;\n\t\t\tparser.end () ?;\n\t\t\tOk (item)\n\t\t}).map_parse_err_line (0, input)\n\t}\n\n\t#[ inline ]\n\tpub fn wrap_lines_auto \u003cOutput, WrapFn\u003e (\n\t\tinput: impl Iterator \u003cItem = (usize, \u0026 'inp str)\u003e,\n\t\tmut wrap_fn: WrapFn,\n\t) -\u003e GenResult \u003cVec \u003cOutput\u003e\u003e\n\t\t\twhere WrapFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tinput\n\t\t\t.map (|(line_idx, line)| Self::wrap (line, \u0026 mut wrap_fn)\n\t\t\t\t.map_parse_err_line (line_idx, line))\n\t\t\t.collect ()\n\t}\n\n\t#[ inline ]\n\tpub fn wrap_lines \u003cOutput, WrapFn\u003e (\n\t\tinput_lines: \u0026 'inp [\u0026 'inp str],\n\t\tmut wrap_fn: WrapFn,\n\t) -\u003e GenResult \u003cOutput\u003e\n\t\t\twhere WrapFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tlet mut parser = Parser::new_lines (input_lines);\n\t\tlet item = wrap_fn (\u0026 mut parser).map_parse_err_auto (\u0026 parser) ?;\n\t\tparser.end ().map_parse_err_auto (\u0026 parser) ?;\n\t\tOk (item)\n\t}\n\n\t#[ inline ]\n\tpub fn wrap_lines_auto_items \u003cOutput: FromParser \u003c'inp\u003e\u003e (\n\t\tinput: impl Iterator \u003cItem = (usize, \u0026 'inp str)\u003e,\n\t) -\u003e GenResult \u003cVec \u003cOutput\u003e\u003e {\n\t\tSelf::wrap_lines_auto (input, |parser| {\n\t\t\tlet item = parser.item () ?;\n\t\t\tparser.end () ?;\n\t\t\tOk (item)\n\t\t})\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn peek_rest (\u0026 self) -\u003e \u0026 'inp str {\n\t\tself.input_line\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn take_rest (\u0026 mut self) -\u003e InpStr \u003c'inp\u003e {\n\t\tlet result = self.input_line;\n\t\tself.input_line = \"\";\n\t\tInpStr::borrow (result)\n\t}\n\n\t#[ allow (clippy::string_slice) ]\n\t#[ inline ]\n\tpub fn take_rest_while (\n\t\t\u0026 mut self,\n\t\tchar_pred: fn (char) -\u003e bool,\n\t\tlen: impl RangeBounds \u003cu32\u003e,\n\t) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\t\tlet mut num_bytes = 0_u32;\n\t\tlet mut num_chars = 0_u32;\n\t\tfor ch in self.input_line.chars () {\n\t\t\tif ! (Unbounded, len.end_bound ()).contains (\u0026 (num_chars + 1)) { break }\n\t\t\tif ! char_pred (ch) { break }\n\t\t\tnum_chars += 1;\n\t\t\tnum_bytes += ch.len_utf8 ().qck_u32 ();\n\t\t}\n\t\tif ! (len.start_bound (), Unbounded).contains (\u0026 num_chars) {\n\t\t\treturn Err (self.err ());\n\t\t}\n\t\tlet result = InpStr::borrow (\u0026 self.input_line [ .. num_bytes.qck_usize ()]);\n\t\tself.input_line = \u0026 self.input_line [num_bytes.qck_usize () .. ];\n\t\tself.col_idx += num_chars;\n\t\tself.byte_idx += num_bytes;\n\t\tOk (result)\n\t}\n\n\t#[ allow (clippy::missing_inline_in_public_items) ]\n\t#[ allow (clippy::string_slice) ]\n\tpub fn take_exactly (\u0026 mut self, num_chars: u32) -\u003e ParseResult \u003cInpStr \u003c'inp\u003e\u003e {\n\t\tlet (num_bytes, num_chars_found) =\n\t\t\tself.input_line.chars ()\n\t\t\t\t.take (num_chars.pan_usize ())\n\t\t\t\t.fold ((0_u32, 0_u32), |(num_bytes, num_chars), ch|\n\t\t\t\t\t(num_bytes + ch.len_utf8 ().qck_u32 (), num_chars + 1));\n\t\tif num_chars_found \u003c num_chars { return Err (self.err ()) }\n\t\tlet result = InpStr::borrow (\u0026 self.input_line [ .. num_bytes.qck_usize ()]);\n\t\tself.input_line = \u0026 self.input_line [num_bytes.qck_usize () .. ];\n\t\tself.col_idx += num_chars;\n\t\tself.byte_idx += num_bytes.pan_u32 ();\n\t\tOk (result)\n\t}\n\t\t\n\n\t#[ inline ]\n\tpub fn opt_fn \u003cParseFn, Output\u003e (\u0026 mut self, mut parse_fn: ParseFn) -\u003e Output\n\t\twhere\n\t\t\tOutput: Default,\n\t\t\tParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tlet saved = * self;\n\t\tif let Ok (val) = parse_fn (self) { return val }\n\t\t* self = saved;\n\t\tOutput::default ()\n\t}\n\n\t#[ inline ]\n\tpub fn nest \u003cParseFn, Output\u003e (\u0026 mut self, mut parse_fn: ParseFn) -\u003e ParseResult \u003cOutput\u003e\n\t\t\twhere ParseFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cOutput\u003e {\n\t\tlet saved = * self;\n\t\tlet result = parse_fn (self);\n\t\tself.ignore_whitespace = saved.ignore_whitespace;\n\t\tself.word_pred = saved.word_pred;\n\t\tresult\n\t}\n\n}\n\npub enum ParserAny \u003c'par, 'inp, Item\u003e {\n\tParser (\u0026 'par mut Parser \u003c'inp\u003e),\n\tItem (Item),\n\tConfirmedError (ParseError),\n}\n\nimpl \u003c'par, 'inp, Item\u003e ParserAny \u003c'par, 'inp, Item\u003e {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn of \u003cOfFn\u003e (self, mut of_fn: OfFn) -\u003e Self\n\t\t\twhere OfFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cItem\u003e {\n\t\tmatch self {\n\t\t\tParserAny::Parser (parser) =\u003e {\n\t\t\t\tlet mut sub_parser = Parser { confirmed: false, .. * parser };\n\t\t\t\tmatch of_fn (\u0026 mut sub_parser) {\n\t\t\t\t\tOk (item) =\u003e {\n\t\t\t\t\t\tparser.input_line = sub_parser.input_line;\n\t\t\t\t\t\tparser.line_idx = sub_parser.line_idx;\n\t\t\t\t\t\tparser.col_idx = sub_parser.col_idx;\n\t\t\t\t\t\tparser.byte_idx = sub_parser.byte_idx;\n\t\t\t\t\t\tParserAny::Item (item)\n\t\t\t\t\t},\n\t\t\t\t\tErr (err) =\u003e\n\t\t\t\t\t\tif sub_parser.confirmed { ParserAny::ConfirmedError (err) }\n\t\t\t\t\t\telse { ParserAny::Parser (parser) },\n\t\t\t\t}\n\t\t\t},\n\t\t\tParserAny::Item (item) =\u003e ParserAny::Item (item),\n\t\t\tParserAny::ConfirmedError (err) =\u003e ParserAny::ConfirmedError (err),\n\t\t}\n\t}\n\n\t#[ inline ]\n\tpub fn done (self) -\u003e ParseResult \u003cItem\u003e {\n\t\tmatch self {\n\t\t\tParserAny::Parser (parser) =\u003e Err (parser.err ()),\n\t\t\tParserAny::Item (item) =\u003e Ok (item),\n\t\t\tParserAny::ConfirmedError (err) =\u003e Err (err),\n\t\t}\n\t}\n\n}\n\n/// Utility method to parse a parameter from the start of an input with default value\n///\n#[ inline ]\npub fn input_param \u003cVal: FromStr, Def: Into \u003cVal\u003e\u003e (\n\tinput: \u0026 mut \u0026 [\u0026 str],\n\tprefix: \u0026 str,\n\tdefault: Def,\n) -\u003e GenResult \u003cVal\u003e\n\t\twhere Val::Err: Error + 'static {\n\tOk (\n\t\tif let Some (line) = input.first () {\n\t\t\tif let Some (val) = line.strip_prefix (prefix) {\n\t\t\t\t* input = \u0026 (* input) [1 .. ];\n\t\t\t\tval.parse () ?\n\t\t\t} else { default.into () }\n\t\t} else { default.into () }\n\t)\n}\n\n/// Utility method to prepend parameters to an example\n///\n#[ inline ]\n#[ must_use ]\npub fn with_params \u003cconst LEN: usize\u003e (\n\tparams: [\u0026 'static str; LEN],\n\texample: \u0026 [\u0026 'static str],\n) -\u003e Vec \u003c\u0026 'static str\u003e {\n\tparams.into_iter ()\n\t\t.chain (example.iter ().copied ())\n\t\t.collect ()\n}\n\n#[ macro_export ]\nmacro_rules! input_params {\n\t(\n\t\t$( #[ $($attrs:tt)* ] )*\n\t\tpub struct $struct_name:ident {\n\t\t\t$(\n\t\t\t\tpub $member_name:ident: $member_type:ty =\n\t\t\t\t\t($member_prefix:literal, $member_default:expr, $member_range:expr),\n\t\t\t)*\n\t\t}\n\t) =\u003e {\n\n\t\t$( #[ $($attrs)* ] )*\n\t\tpub struct $struct_name {\n\t\t\t$( pub $member_name: $member_type, )*\n\t\t}\n\n\t\timpl $struct_name {\n\t\t\t#[ inline ]\n\t\t\tpub fn parse (input: \u0026 mut \u0026 [\u0026 str]) -\u003e ::aoc_common::GenResult \u003cSelf\u003e {\n\t\t\t\tuse ::aoc_common::parser as parser;\n\t\t\t\tuse ::std::ops::Bound as Bound;\n\t\t\t\tuse ::std::ops::RangeBounds as _;\n\t\t\t\tuse ::std::result::Result as Result;\n\t\t\t\tlet default = Self::default ();\n\t\t\t\t$(\n\t\t\t\t\tlet $member_name =\n\t\t\t\t\t\tparser::input_param (\n\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t$member_prefix,\n\t\t\t\t\t\t\tdefault.$member_name) ?;\n\t\t\t\t\t::aoc_common::parser::check_range::\u003c$member_type, _\u003e (\n\t\t\t\t\t\t\u0026 $member_prefix [ .. $member_prefix.len () - 1],\n\t\t\t\t\t\t\u0026 $member_name,\n\t\t\t\t\t\t$member_range) ?;\n\t\t\t\t)*\n\t\t\t\tOk (Self { $( $member_name, )* })\n\t\t\t}\n\t\t}\n\n\t\timpl ::std::default::Default for $struct_name {\n\t\t\t#[ inline ]\n\t\t\tfn default () -\u003e Self {\n\t\t\t\tSelf {\n\t\t\t\t\t$( $member_name: $member_default, )*\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\timpl ::std::fmt::Display for $struct_name {\n\t\t\t#[ inline ]\n\t\t\tfn fmt (\n\t\t\t\t\u0026 self,\n\t\t\t\tformatter: \u0026 mut ::std::fmt::Formatter,\n\t\t\t) -\u003e ::std::fmt::Result {\n\t\t\t\tlet default = Self::default ();\n\t\t\t\t$(\n\t\t\t\t\tif self.$member_name != default.$member_name {\n\t\t\t\t\t\twrite! (formatter, \"{}{}\\n\", $member_prefix, self.$member_name) ?;\n\t\t\t\t\t}\n\t\t\t\t)*\n\t\t\t\tOk (())\n\t\t\t}\n\t\t}\n\n\t\timpl \u003c'inp\u003e FromParser \u003c'inp\u003e for $struct_name {\n\t\t\t#[ inline ]\n\t\t\tfn from_parser (parser: \u0026 mut Parser \u003c'inp\u003e) -\u003e ::aoc_common::parser::ParseResult \u003cSelf\u003e {\n\t\t\t\tuse ::aoc_common::parser as parser;\n\t\t\t\tuse ::std::ops::Bound as Bound;\n\t\t\t\tuse ::std::ops::RangeBounds as _;\n\t\t\t\tuse ::std::result::Result as Result;\n\t\t\t\tlet default = Self::default ();\n\t\t\t\t$(\n\t\t\t\t\tlet $member_name = parser.any ().of (|parser| {\n\t\t\t\t\t\tparse! (parser, $member_prefix, val, \"\\n\");\n\t\t\t\t\t\tOk (val)\n\t\t\t\t\t}).done ().unwrap_or (default.$member_name);\n\t\t\t\t\t::aoc_common::parser::check_range::\u003c$member_type, _\u003e (\n\t\t\t\t\t\t\u0026 $member_prefix [ .. $member_prefix.len () - 1],\n\t\t\t\t\t\t\u0026 $member_name,\n\t\t\t\t\t\t$member_range) ?;\n\t\t\t\t)*\n\t\t\t\tOk (Self { $( $member_name, )* })\n\t\t\t}\n\t\t}\n\n\t};\n}\n\n#[ inline ]\npub fn check_range \u003cVal: Debug + Display + Ord, Rng: Debug + RangeBounds \u003cVal\u003e\u003e (\n\tname: \u0026 str,\n\tval: \u0026 Val,\n\trange: Rng,\n) -\u003e GenResult \u003c()\u003e {\n\tif range.contains (val) { return Ok (()) }\n\tErr (check_range_error (name, val, range).into ())\n}\n\n#[ allow (clippy::missing_inline_in_public_items) ]\npub fn check_range_error \u003cVal: Debug + Display + Ord, Rng: Debug + RangeBounds \u003cVal\u003e\u003e (\n\tname: \u0026 str,\n\tval: \u0026 Val,\n\trange: Rng,\n) -\u003e String {\n\tmatch (range.start_bound (), range.end_bound ()) {\n\t\t(Bound::Included (start), Bound::Included (end)) =\u003e\n\t\t\tformat! (\"{name} must be between {start} and {end}, but was {val}\"),\n\t\t(Bound::Included (start), Bound::Unbounded) =\u003e\n\t\t\tformat! (\"{name} must be at least {start}, but was {val}\"),\n\t\t(Bound::Excluded (start), Bound::Unbounded) =\u003e\n\t\t\tformat! (\"{name} must be more than {start}, but was {val}\"),\n\t\t(Bound::Unbounded, Bound::Included (end)) =\u003e\n\t\t\tformat! (\"{name} must be at most {end}, but was {val}\"),\n\t\t(Bound::Unbounded, Bound::Excluded (end)) =\u003e\n\t\t\tformat! (\"{name} must be less than {end}, but was {val}\"),\n\t\t_ =\u003e\n\t\t\tformat! (\"{name} is out of acceptable range: {range:?}\"),\n\t}\n}\n","traces":[{"line":61,"address":[],"length":0,"stats":{"Line":260},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":116},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":233},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":232},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":461},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":669},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":228},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":198},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":176},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":206},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":382},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":193},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":193},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":193},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":191},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":216},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":434},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":217},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[19888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[53904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":282,"address":[44448,44272],"length":1,"stats":{"Line":61},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":413},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":194},"fn_name":null},{"line":289,"address":[28544,28848],"length":1,"stats":{"Line":19},"fn_name":"item_range\u003cchar, core::ops::range::RangeInclusive\u003cchar\u003e\u003e"},{"line":291,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":49},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":51},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":25},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":42},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":245},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":247},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":246},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":60},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":63},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":793},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":443},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":443},"fn_name":null},{"line":473,"address":[20928],"length":1,"stats":{"Line":1},"fn_name":"wrap\u003caoc_2018_cpu::instr::Instr\u003ci32\u003e, aoc_parser::{impl#7}::wrap_auto::{closure_env#0}\u003caoc_2018_cpu::instr::Instr\u003ci32\u003e, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2018_cpu::instr::Instr\u003ci32\u003e, aoc_parser::ParseError\u003e\u003e\u003e"},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":483,"address":[21280],"length":1,"stats":{"Line":0},"fn_name":"wrap_auto\u003caoc_2018_cpu::instr::Instr\u003ci32\u003e, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2018_cpu::instr::Instr\u003ci32\u003e, aoc_parser::ParseError\u003e\u003e"},{"line":488,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[43760,44251],"length":1,"stats":{"Line":237},"fn_name":"wrap_lines\u003caoc_2017_day_18::input::Input, fn(\u0026mut aoc_parser::Parser) -\u003e core::result::Result\u003caoc_2017_day_18::input::Input, aoc_parser::ParseError\u003e\u003e"},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":279},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":249},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":250},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[55026,54400],"length":1,"stats":{"Line":59},"fn_name":"take_rest_while\u003ccore::ops::range::RangeFrom\u003cu32\u003e\u003e"},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":224},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":87},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":21},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":55},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":59},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[30896],"length":1,"stats":{"Line":2},"fn_name":"nest\u003caoc_2016_day_01::input::{impl#2}::from_parser::{closure#0}::{closure#0}::{closure_env#0}, aoc_pos::dim_2::Turn2d\u003e"},{"line":600,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[53408],"length":1,"stats":{"Line":589},"fn_name":"of\u003c(aoc_inpstr::InpStr, aoc_inpstr::InpStr), aoc_2015_day_19::input::{impl#2}::from_parser::{closure#0}::{closure_env#0}\u003e"},{"line":621,"address":[],"length":0,"stats":{"Line":626},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":573},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":614},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":665},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":113},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":484},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":485},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":486},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":487},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":346},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":440},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":883},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":881},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":243},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":465},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":227},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[30928,31123],"length":1,"stats":{"Line":0},"fn_name":"with_params\u003c2\u003e"},{"line":680,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":727,"address":[33008],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":728,"address":[52336],"length":1,"stats":{"Line":2},"fn_name":null},{"line":752,"address":[39568],"length":1,"stats":{"Line":75},"fn_name":"from_parser"},{"line":759,"address":[94864,94640],"length":1,"stats":{"Line":440},"fn_name":"{closure#0}"},{"line":760,"address":[94880,94656],"length":1,"stats":{"Line":166},"fn_name":null},{"line":761,"address":[95067,94843],"length":1,"stats":{"Line":58},"fn_name":null},{"line":762,"address":[95053,94829],"length":1,"stats":{"Line":156},"fn_name":null},{"line":763,"address":[103718,103976],"length":1,"stats":{"Line":136},"fn_name":null},{"line":764,"address":[103606,103864],"length":1,"stats":{"Line":136},"fn_name":null},{"line":768,"address":[39571],"length":1,"stats":{"Line":74},"fn_name":null},{"line":776,"address":[95088],"length":1,"stats":{"Line":2},"fn_name":"check_range\u003cu32, core::ops::range::RangeFrom\u003cu32\u003e\u003e"},{"line":781,"address":[],"length":0,"stats":{"Line":110},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[95184],"length":1,"stats":{"Line":0},"fn_name":"check_range_error\u003cu32, core::ops::range::RangeFrom\u003cu32\u003e\u003e"},{"line":791,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":123,"coverable":289},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","parser","structs.rs"],"content":"#[ macro_export ]\nmacro_rules! struct_parser_display {\n\t( $($rest:tt)* ) =\u003e {\n\t\tstruct_parser! { $($rest)* }\n\t\tstruct_display! { $($rest)* }\n\t};\n}\n\n#[ macro_export ]\nmacro_rules! struct_parser {\n\n\t( \u003c $($rest:tt)* ) =\u003e {\n\t\tstruct_parser! (@outer 'inp [] \u003c $($rest)*);\n\t};\n\n\t( $first:ident $($rest:tt)* ) =\u003e {\n\t\tstruct_parser! (@outer 'inp [] $first $($rest)*);\n\t};\n\n\t(\n\t\t@outer $inp_life_old:tt [$($param_decl:tt)*]\n\t\tinput_lifetime = $inp_life:tt;\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tstruct_parser! (@outer $inp_life [$($param_decl)*] $($rest)*);\n\t};\n\t\t\n\t(\n\t\t@outer $inp_life:tt [$($param_decl_old:tt)*]\n\t\tparams = { $($param_decl:tt)* }\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tstruct_parser! (@outer $inp_life [$($param_decl)*] $($rest)*);\n\t};\n\t\t\n\t(\n\t\t@outer $inp_life:tt [$($param_decl:tt)*]\n\t\t$name:ident\n\t\t$( \u003c $($param:tt),* \u003e )?\n\t\t{ $($fields:tt)* }\n\t\t= [ $($args:tt)* ]\n\t) =\u003e {\n\t\tstruct_parser! (\n\t\t\t@main $name $inp_life\n\t\t\t[ $($param_decl)* ]\n\t\t\t[ $( $($param),* )? ]\n\t\t\t[ { $($fields)* } ]\n\t\t\t[ $($args)* ]);\n\t};\n\n\t(\n\t\t@outer $inp_life:tt [$($param_decl:tt)*]\n\t\t$name:ident\n\t\t$( \u003c $($param:tt),* \u003e )?\n\t\t( $($fields:tt)* )\n\t\t= [ $($args:tt)* ]\n\t) =\u003e {\n\t\tstruct_parser! (\n\t\t\t@main $name $inp_life\n\t\t\t[ $( $($param_decl)* )? ]\n\t\t\t[ $($param),* ]\n\t\t\t[ ( $($fields)* ) ]\n\t\t\t[ $($args)* ]);\n\t};\n\n\t(\n\t\t@main $name:ident $inp_life:tt\n\t\t[ $($param_decl:tt)* ]\n\t\t[ $($param:tt)* ]\n\t\t[ $($fields:tt)* ]\n\t\t[ $($args:tt)* ]\n\t) =\u003e {\n\t\timpl \u003c$inp_life, $($param_decl)*\u003e FromParser \u003c$inp_life\u003e for $name \u003c$($param)*\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn from_parser (parser: \u0026 mut Parser \u003c$inp_life\u003e) -\u003e ParseResult \u003cSelf\u003e {\n\t\t\t\tparse! (parser, $($args)*);\n\t\t\t\tOk (Self $($fields)*)\n\t\t\t}\n\t\t}\n\t};\n\n}\n\n#[ macro_export ]\nmacro_rules! struct_display {\n\n\t( \u003c $($rest:tt)* ) =\u003e {\n\t\tstruct_display! (@outer 'inp [] \u003c $($rest)*);\n\t};\n\n\t( $first:ident $($rest:tt)* ) =\u003e {\n\t\tstruct_display! (@outer 'inp [] $first $($rest)*);\n\t};\n\n\t(\n\t\t@outer $inp_life_old:tt [$($param_decl:tt)*]\n\t\tinput_lifetime = $inp_life:tt;\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tstruct_display! (@outer $inp_life [$($param_decl)*] $($rest)*);\n\t};\n\n\t(\n\t\t@outer $inp_life:tt [$($param_decl_old:tt)*]\n\t\tparams = { $($param_decl:tt)* }\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tstruct_display! (@outer $inp_life [$($param_decl)*] $($rest)*);\n\t};\n\n\t(\n\t\t@outer $inp_life:tt [$($param_decl:tt)*]\n\t\t$name:ident\n\t\t$( \u003c $($param:tt),* \u003e )?\n\t\t{ $($fields:tt)* }\n\t\t= [ $($args:tt)* ]\n\t) =\u003e {\n\t\tstruct_display! (\n\t\t\t@main $name $inp_life\n\t\t\t[ $($param_decl)* ]\n\t\t\t[ $( $($param),* )? ]\n\t\t\t[ { $($fields)* } ]\n\t\t\t[ $($args)* ]);\n\t};\n\n\t(\n\t\t@outer $inp_life:tt [$($param_decl:tt)*]\n\t\t$name:ident\n\t\t$( \u003c $($param:tt),* \u003e )?\n\t\t( $($fields:tt)* )\n\t\t= [ $($args:tt)* ]\n\t) =\u003e {\n\t\tstruct_display! (\n\t\t\t@main $name $inp_life\n\t\t\t[ $($param_decl)* ]\n\t\t\t[ $( $($param),* )? ]\n\t\t\t[ ( $($fields)* ) ]\n\t\t\t[ $($args)* ]);\n\t};\n\n\t(\n\t\t@main $name:ident $inp_life:tt\n\t\t[ $($param_decl:tt)* ]\n\t\t[ $($param:tt),* ]\n\t\t[ $($fields:tt)* ]\n\t\t[ $($args:tt)* ]\n\t) =\u003e {\n\t\timpl \u003c$inp_life, $($param_decl)*\u003e ::std::fmt::Display\n\t\t\t\tfor $name \u003c$($param),*\u003e {\n\t\t\tfn fmt (\u0026 self, formatter: \u0026 mut ::std::fmt::Formatter) -\u003e ::std::fmt::Result {\n\t\t\t\tlet Self $($fields)* = self;\n\t\t\t\tdisplay! (formatter, $($args)*);\n\t\t\t\t::std::result::Result::Ok (())\n\t\t\t}\n\t\t}\n\t};\n\n}\n","traces":[{"line":47,"address":[146023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[52432,52272],"length":1,"stats":{"Line":130},"fn_name":"from_parser"},{"line":76,"address":[52453,52604],"length":1,"stats":{"Line":438},"fn_name":null},{"line":77,"address":[48717],"length":1,"stats":{"Line":154},"fn_name":null}],"covered":4,"coverable":4},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","pos","pos.rs"],"content":"use std::fmt::{ self, Debug };\nuse std::ops::{ Add, Neg, Rem, Sub };\n\nuse aoc_checked::checked as chk;\nuse aoc_misc::prelude::*;\nuse aoc_nums as nums;\nuse nums::Int;\nuse nums::IntSigned;\nuse nums::NumResult;\nuse nums::TryAdd;\nuse nums::TryMul;\nuse nums::TrySub;\n\npub use gen::GenAxis;\npub use gen::GenPos;\npub use dim_2::AxisRowCol;\npub use dim_2::AxisXY;\npub use dim_2::Dir2d;\npub use dim_2::DirGeo;\npub use dim_2::DirGeoHexLat;\npub use dim_2::PosXY;\npub use dim_2::PosYX;\npub use dim_2::PosGeo;\npub use dim_2::PosGeoHexLat;\npub use dim_2::PosRowCol;\npub use dim_2::Turn2d;\npub use dim_2::TurnHex;\n\nmacro_rules! pos_decl {\n\t(\n\t\t$name:ident $axis_type:ident $dims:literal\n\t\t$(, $field:ident $axis:ident $neg:ident $pos:ident )+\n\t) =\u003e {\n\n\t\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\t\tpub enum $axis_type { $($axis),+ }\n\n\t\timpl GenAxis \u003c$dims\u003e for $axis_type { }\n\n\t\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct $name \u003cVal\u003e { $(pub $field: Val),+ }\n\n\t\timpl \u003cVal: Int\u003e $name \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub const fn new ($($field: Val),+) -\u003e Self {\n\t\t\t\tSelf { $($field),+ }\n\t\t\t}\n\n\t\t\tpub const ZERO: Self = Self { $($field: Val::ZERO),+ };\n\t\t\tpub const MIN: Self = Self { $($field: Val::MIN),+ };\n\t\t\tpub const MAX: Self = Self { $($field: Val::MAX),+ };\n\n\t\t\t$(\n\n\t\t\t\t#[ inline ]\n\t\t\t\tpub fn $neg (self, num: Val) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\t\tlet mut result = self;\n\t\t\t\t\tresult.$field = Val::sub_2 (result.$field, num) ?;\n\t\t\t\t\tOk (result)\n\t\t\t\t}\n\n\t\t\t\t#[ inline ]\n\t\t\t\tpub fn $pos (self, num: Val) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\t\tlet mut result = self;\n\t\t\t\t\tresult.$field = Val::add_2 (result.$field, num) ?;\n\t\t\t\t\tOk (result)\n\t\t\t\t}\n\n\t\t\t)+\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e GenPos \u003c$dims\u003e for $name \u003cVal\u003e {\n\n\t\t\ttype Val = Val;\n\t\t\ttype Axis = $axis_type;\n\n\t\t\tconst ZERO: Self = Self { $($field: Val::ZERO),+ };\n\t\t\tconst MIN: Self = Self { $($field: Val::MIN),+ };\n\t\t\tconst MAX: Self = Self { $($field: Val::MAX),+ };\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e From \u003c[Val; $dims]\u003e for $name \u003cVal\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn from (array: [Val; $dims]) -\u003e Self {\n\t\t\t\tlet [ $($field),+ ] = array;\n\t\t\t\tSelf { $($field),+ }\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e From \u003c$name \u003cVal\u003e\u003e for [Val; $dims] {\n\t\t\t#[ inline ]\n\t\t\tfn from (pos: $name \u003cVal\u003e) -\u003e Self {\n\t\t\t\t[ $(pos.$field),+ ]\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Index \u003c$axis_type\u003e for $name \u003cVal\u003e {\n\n\t\t\ttype Output = Val;\n\n\t\t\t#[ inline ]\n\t\t\tfn index (\u0026 self, axis: $axis_type) -\u003e \u0026 Val {\n\t\t\t\tmatch axis {\n\t\t\t\t\t$( $axis_type::$axis =\u003e \u0026 self.$field, )+\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e IndexMut \u003c$axis_type\u003e for $name \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\tfn index_mut (\u0026 mut self, axis: $axis_type) -\u003e \u0026 mut Val {\n\t\t\t\tmatch axis {\n\t\t\t\t\t$( $axis_type::$axis =\u003e \u0026 mut self.$field, )+\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: Debug, Default);\n\t\tpos_ops! ($name \u003c$dims\u003e: Add, Mul, Neg, Rem, Sub);\n\n\t};\n}\n\nmacro_rules! pos_dirs {\n\n\t(\n\t\t$name:ident $dir:ident $dims:literal\n\t\t$(, $variant:ident $method:ident [ $($sign:ident),+ ] )+\n\t\t$(,)?\n\t) =\u003e {\n\n\t\timpl \u003cVal: Int \u003cSigned = Val\u003e + IntSigned\u003e From \u003c$dir\u003e for $name \u003cVal\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn from (dir: $dir) -\u003e Self {\n\t\t\t\tmatch dir {\n\t\t\t\t\t$( $dir::$variant =\u003e Self::new ($(Val::$sign),+), )+\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t};\n\n}\n\nmacro_rules! pos_ops {\n\n\t( $name:ident \u003c$dims:literal\u003e: Debug $(,$rest:ident)*) =\u003e {\n\n\t\timpl \u003cVal: Int\u003e Debug for $name \u003cVal\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\t\tlet array: [Val; $dims] = (* self).into ();\n\t\t\t\tformatter.write_str (stringify! ($name)) ?;\n\t\t\t\tformatter.write_str (\" (\") ?;\n\t\t\t\tfor idx in 0 .. array.len () {\n\t\t\t\t\tif idx != 0 { formatter.write_str (\", \") ?; }\n\t\t\t\t\tDebug::fmt (\u0026 array [idx], formatter) ?;\n\t\t\t\t}\n\t\t\t\tformatter.write_str (\")\") ?;\n\t\t\t\tOk (())\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Default $(,$rest:ident)*) =\u003e {\n\n\t\timpl \u003cVal: Int\u003e Default for $name \u003cVal\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn default () -\u003e Self {\n\t\t\t\tSelf::ZERO\n\t\t\t}\n\t\t}\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Add $(,$rest:ident)* ) =\u003e {\n\n\t\timpl \u003cVal: Int, ArgVal: Int\u003e Add \u003c$name \u003cArgVal\u003e\u003e for $name \u003cVal\u003e\n\t\t\t\twhere Val: TryAdd \u003cArgVal, Output = Val\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn add (self, other: $name \u003cArgVal\u003e) -\u003e Self {\n\t\t\t\tself.try_add (other).unwrap ()\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int, ArgVal: Int\u003e AddAssign \u003c$name \u003cArgVal\u003e\u003e for $name \u003cVal\u003e\n\t\t\t\twhere Val: TryAdd \u003cArgVal, Output = Val\u003e {\n\t\t\t#[ inline ]\n\t\t\tfn add_assign (\u0026 mut self, other: $name \u003cArgVal\u003e) {\n\t\t\t\t* self = self.try_add (other).unwrap ()\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int, ArgVal: Int\u003e TryAdd \u003c$name \u003cArgVal\u003e\u003e for $name \u003cVal\u003e\n\t\t\t\twhere Val: TryAdd \u003cArgVal, Output = Val\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn try_add (self, other: $name \u003cArgVal\u003e) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet other_array: [ArgVal; $dims] = other.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = self_array [idx].try_add (other_array [idx]) ?\n\t\t\t\t}\n\t\t\t\tOk (result_array.into ())\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Mul $(,$rest:ident)* ) =\u003e {\n\n\t\timpl \u003cVal: Int + TryMul \u003cOutput = Val\u003e\u003e TryMul \u003cVal\u003e for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn try_mul (self, arg: Val) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = self_array [idx].try_mul (arg) ?;\n\t\t\t\t}\n\t\t\t\tOk (result_array.into ())\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Mul \u003cVal\u003e for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn mul (self, arg: Val) -\u003e Self {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = self_array [idx] * arg;\n\t\t\t\t}\n\t\t\t\tresult_array.into ()\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Neg $(,$rest:ident)* ) =\u003e {\n\n\t\timpl \u003cVal: Int + Neg \u003cOutput = Val\u003e\u003e Neg for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn neg (self) -\u003e Self {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = - self_array [idx];\n\t\t\t\t}\n\t\t\t\tresult_array.into ()\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Rem $(,$rest:ident)* ) =\u003e {\n\n\t\timpl \u003cVal: Int\u003e Rem for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn rem (self, other: $name \u003cVal\u003e) -\u003e Self {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet other_array: [Val; $dims] = other.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = self_array [idx] % other_array [idx];\n\t\t\t\t}\n\t\t\t\tresult_array.into ()\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: Sub $(,$rest:ident)* ) =\u003e {\n\n\t\timpl \u003cVal: Int, ArgVal: Int\u003e Sub \u003c$name \u003cArgVal\u003e\u003e for $name \u003cVal\u003e\n\t\t\t\twhere Val: TrySub \u003cArgVal, Output = Val\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn sub (self, other: $name \u003cArgVal\u003e) -\u003e Self {\n\t\t\t\tself.try_sub (other).unwrap ()\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int, ArgVal: Int\u003e TrySub \u003c$name \u003cArgVal\u003e\u003e for $name \u003cVal\u003e\n\t\t\t\twhere Val: TrySub \u003cArgVal, Output = Val\u003e {\n\t\t\ttype Output = Self;\n\t\t\t#[ inline ]\n\t\t\tfn try_sub (self, other: $name \u003cArgVal\u003e) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet self_array: [Val; $dims] = self.into ();\n\t\t\t\tlet other_array: [ArgVal; $dims] = other.into ();\n\t\t\t\tlet mut result_array = [Val::ZERO; $dims];\n\t\t\t\tfor idx in 0 .. self_array.len () {\n\t\t\t\t\tresult_array [idx] = self_array [idx].try_sub (other_array [idx]) ?\n\t\t\t\t}\n\t\t\t\tOk (result_array.into ())\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! ($name \u003c$dims\u003e: $($rest),*);\n\n\t};\n\n\t( $name:ident \u003c$dims:literal\u003e: ) =\u003e {};\n\n}\n\nmod gen {\n\n\tuse super::*;\n\n\tpub trait GenAxis \u003cconst DIMS: usize\u003e {\n\t}\n\n\tpub trait GenPos \u003cconst DIMS: usize\u003e:\n\t\tCopy + Debug + Eq + Hash + Ord + Sized +\n\t\tFrom \u003c[Self::Val; DIMS]\u003e +\n\t\tInto \u003c[Self::Val; DIMS]\u003e +\n\t\tTryAdd \u003cOutput = Self\u003e +\n\t\tTryMul \u003cSelf::Val, Output = Self\u003e {\n\n\t\ttype Val: Int;\n\t\ttype Axis: GenAxis \u003cDIMS\u003e;\n\n\t\t#[ inline ]\n\t\t#[ must_use ]\n\t\tfn zero () -\u003e Self {\n\t\t\t[Self::Val::ZERO; DIMS].into ()\n\t\t}\n\n\t\t#[ inline ]\n\t\tfn as_array (self) -\u003e [Self::Val; DIMS] {\n\t\t\tself.into ()\n\t\t}\n\n\t\t#[ inline ]\n\t\tfn into_iter (self) -\u003e array::IntoIter \u003cSelf::Val, DIMS\u003e {\n\t\t\tself.as_array ().into_iter ()\n\t\t}\n\n\t\tconst ZERO: Self;\n\t\tconst MIN: Self;\n\t\tconst MAX: Self;\n\n\t}\n\n}\n\nmod dim_2 {\n\n\tuse super::*;\n\n\tpub use geo::*;\n\tpub use geo_hex::*;\n\tpub use row_col::*;\n\tpub use xy::*;\n\tpub use yx::*;\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Turn2d { None, Left, Right, Around }\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum TurnHex { None, SoftRight, HardRight, Around, HardLeft, SoftLeft }\n\n\tmod xy {\n\n\t\tuse super::*;\n\n\t\tpos_decl! (PosXY AxisXY 2, x X left right, y Y down up);\n\n\t\timpl \u003cVal: Int\u003e PosXY \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cSelf, 4\u003e {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { x, y } = * self;\n\t\t\t\tif self.x \u003e Val::MIN { result.push (Self { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (Self { x: x + Val::ONE, y }); }\n\t\t\t\tif self.y \u003e Val::MIN { result.push (Self { x, y: y - Val::ONE }); }\n\t\t\t\tif self.y \u003c Val::MAX { result.push (Self { x, y: y + Val::ONE }); }\n\t\t\t\tresult\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmod yx {\n\n\t\tuse super::*;\n\n\t\tpos_decl! (PosYX AxisXY 2, y Y up down, x X left right);\n\n\t\tpos_dirs! {\n\t\t\tPosYX Dir2d 2,\n\t\t\tUp up [ NEG_ONE, ZERO ],\n\t\t\tDown down [ ONE, ZERO ],\n\t\t\tLeft left [ ZERO, NEG_ONE ],\n\t\t\tRight right [ ZERO, ONE ],\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e PosYX \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cSelf, 4\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { y, x } = * self;\n\t\t\t\tif self.y \u003e Val::MIN { result.push (Self { x, y: y - Val::ONE }); }\n\t\t\t\tif self.y \u003c Val::MAX { result.push (Self { x, y: y + Val::ONE }); }\n\t\t\t\tif self.x \u003e Val::MIN { result.push (Self { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (Self { x: x + Val::ONE, y }); }\n\t\t\t\tresult\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_8 (\u0026 self) -\u003e ArrayVec \u003cSelf, 8\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { y, x } = * self;\n\t\t\t\tif self.y \u003e Val::MIN {\n\t\t\t\t\tlet y = y - Val::ONE;\n\t\t\t\t\tif self.x \u003e Val::MIN { result.push (Self { x: x - Val::ONE, y }); }\n\t\t\t\t\tresult.push (Self { y, x });\n\t\t\t\t\tif self.x \u003c Val::MAX { result.push (Self { x: x + Val::ONE, y }); }\n\t\t\t\t}\n\t\t\t\tif self.x \u003e Val::MIN { result.push (Self { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (Self { x: x + Val::ONE, y }); }\n\t\t\t\tif self.y \u003c Val::MAX {\n\t\t\t\t\tlet y = y + Val::ONE;\n\t\t\t\t\tif self.x \u003e Val::MIN { result.push (Self { x: x - Val::ONE, y }); }\n\t\t\t\t\tresult.push (Self { y, x });\n\t\t\t\t\tif self.x \u003c Val::MAX { result.push (Self { x: x + Val::ONE, y }); }\n\t\t\t\t}\n\t\t\t\tresult\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: IntSigned\u003e Add \u003cTurn2d\u003e for PosYX \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn add (self, turn: Turn2d) -\u003e Self {\n\t\t\t\tmatch turn {\n\t\t\t\t\tTurn2d::None =\u003e Self::new (self.y, self.x),\n\t\t\t\t\tTurn2d::Right =\u003e Self::new (self.x, - self.y),\n\t\t\t\t\tTurn2d::Around =\u003e Self::new (- self.y, - self.x),\n\t\t\t\t\tTurn2d::Left =\u003e Self::new (- self.x, self.y),\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Index \u003cAxisXY\u003e for PosXYZ \u003cVal\u003e {\n\n\t\t\ttype Output = Val;\n\n\t\t\t#[ inline ]\n\t\t\tfn index (\u0026 self, axis: AxisXY) -\u003e \u0026 Val {\n\t\t\t\tmatch axis {\n\t\t\t\t\tAxisXY::X =\u003e \u0026 self.x,\n\t\t\t\t\tAxisXY::Y =\u003e \u0026 self.y,\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e TryAdd \u003c(Dir2d, Val)\u003e for PosYX \u003cVal\u003e {\n\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn try_add (self, (dir, dist): (Dir2d, Val)) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet mut result = self;\n\t\t\t\tmatch dir {\n\t\t\t\t\tDir2d::Up =\u003e result.y = Val::sub_2 (result.y, dist) ?,\n\t\t\t\t\tDir2d::Down =\u003e result.y = Val::add_2 (result.y, dist) ?,\n\t\t\t\t\tDir2d::Left =\u003e result.x = Val::sub_2 (result.x, dist) ?,\n\t\t\t\t\tDir2d::Right =\u003e result.x = Val::add_2 (result.x, dist) ?,\n\t\t\t\t}\n\t\t\t\tOk (result)\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmod geo {\n\n\t\tuse super::*;\n\n\t\tpos_decl! (PosGeo AxisGeo 2, n N south north, e E west east);\n\t\tpos_dirs! (PosGeo DirGeo 2,\n\t\t\tSouth south [ NEG_ONE, ZERO ],\n\t\t\tNorth north [ ONE, ZERO ],\n\t\t\tWest west [ ZERO, NEG_ONE ],\n\t\t\tEast east [ ZERO, ONE ]);\n\n\t\timpl \u003cVal: Int\u003e PosGeo \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn left (\u0026 self) -\u003e Self where Val: IntSigned {\n\t\t\t\tSelf { n: self.e, e: - self.n }\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn right (\u0026 self) -\u003e Self where Val: IntSigned {\n\t\t\t\tSelf { n: - self.e, e: self.n }\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn around (\u0026 self) -\u003e Self where Val: IntSigned {\n\t\t\t\tSelf { n: - self.n, e: - self.e }\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cSelf, 4\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { n, e } = * self;\n\t\t\t\tif n \u003e Val::MIN { result.push (Self { n: n - Val::ONE, e }); }\n\t\t\t\tif n \u003c Val::MAX { result.push (Self { n: n + Val::ONE, e }); }\n\t\t\t\tif e \u003e Val::MIN { result.push (Self { n, e: e - Val::ONE }); }\n\t\t\t\tif e \u003c Val::MAX { result.push (Self { n, e: e + Val::ONE }); }\n\t\t\t\tresult\n\t\t\t}\n\n\t\t}\n\n\t\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\t\tpub enum DirGeo { North, South, East, West }\n\n\t\timpl DirGeo {\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn left (self) -\u003e Self {\n\t\t\t\tself + Turn2d::Left\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn right (self) -\u003e Self {\n\t\t\t\tself + Turn2d::Right\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn around (self) -\u003e Self {\n\t\t\t\tself + Turn2d::Around\n\t\t\t}\n\n\t\t}\n\n\t\timpl Add \u003cTurn2d\u003e for DirGeo {\n\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn add (self, other: Turn2d) -\u003e Self {\n\t\t\t\tuse Turn2d::{ None, Left, Right, Around };\n\t\t\t\tuse DirGeo::{ North, South, East, West };\n\t\t\t\tmatch (self, other) {\n\t\t\t\t\t(North, None) | (West, Right) | (East, Left) | (South, Around) =\u003e North,\n\t\t\t\t\t(South, None) | (East, Right) | (West, Left) | (North, Around) =\u003e South,\n\t\t\t\t\t(East, None) | (North, Right) | (South, Left) | (West, Around) =\u003e East,\n\t\t\t\t\t(West, None) | (South, Right) | (North, Left) | (East, Around) =\u003e West,\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Add \u003c(DirGeo, Val)\u003e for PosGeo \u003cVal\u003e {\n\n\t\t\ttype Output = NumResult \u003cSelf\u003e;\n\n\t\t\t#[ inline ]\n\t\t\tfn add (self, (dir, dist): (DirGeo, Val)) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet mut result = self;\n\t\t\t\tmatch dir {\n\t\t\t\t\tDirGeo::North =\u003e result.n = Val::add_2 (result.n, dist) ?,\n\t\t\t\t\tDirGeo::South =\u003e result.n = Val::sub_2 (result.n, dist) ?,\n\t\t\t\t\tDirGeo::East =\u003e result.e = Val::add_2 (result.e, dist) ?,\n\t\t\t\t\tDirGeo::West =\u003e result.e = Val::sub_2 (result.e, dist) ?,\n\t\t\t\t}\n\t\t\t\tOk (result)\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmod geo_hex {\n\n\t\tuse super::*;\n\n\t\tpos_decl! (PosGeoHexLat AxisGeoHexLat 2, nw NW south_east north_west, e E west east);\n\n\t\timpl \u003cVal: Int\u003e PosGeoHexLat \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\tpub fn north_east (\u0026 self, num: Val) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tOk (Self { nw: chk! (self.nw + num) ?, e: chk! (self.e + num) ? })\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub fn south_west (\u0026 self, num: Val) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tOk (Self { nw: chk! (self.nw - num) ?, e: chk! (self.e - num) ? })\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent (\u0026 self) -\u003e ArrayVec \u003cSelf, 6\u003e where Val: Int {\n\t\t\t\t[\n\t\t\t\t\tself.north_west (Val::ONE).ok (),\n\t\t\t\t\tself.north_east (Val::ONE).ok (),\n\t\t\t\t\tself.east (Val::ONE).ok (),\n\t\t\t\t\tself.south_east (Val::ONE).ok (),\n\t\t\t\t\tself.south_west (Val::ONE).ok (),\n\t\t\t\t\tself.west (Val::ONE).ok (),\n\t\t\t\t].into_iter ().flatten ().collect ()\n\t\t\t}\n\n\t\t}\n\n\t\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\t\tpub enum DirGeoHexLat { NorthWest, NorthEast, East, SouthEast, SouthWest, West }\n\n\t\timpl DirGeoHexLat {\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn soft_right (self) -\u003e Self {\n\t\t\t\tself + TurnHex::SoftRight\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn hard_right (self) -\u003e Self {\n\t\t\t\tself + TurnHex::HardRight\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn around (self) -\u003e Self {\n\t\t\t\tself + TurnHex::Around\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn hard_left (self) -\u003e Self {\n\t\t\t\tself + TurnHex::HardLeft\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub fn soft_left (self) -\u003e Self {\n\t\t\t\tself + TurnHex::SoftLeft\n\t\t\t}\n\n\t\t}\n\n\t\timpl Add \u003cTurnHex\u003e for DirGeoHexLat {\n\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn add (self, other: TurnHex) -\u003e Self {\n\t\t\t\tuse TurnHex::{ None, SoftRight, HardRight, Around, HardLeft, SoftLeft };\n\t\t\t\tuse DirGeoHexLat::{ NorthWest, NorthEast, East, SouthEast, SouthWest, West };\n\t\t\t\tmatch (self, other) {\n\t\t\t\t\t(NorthWest, None) | (West, SoftRight) | (SouthWest, HardRight) |\n\t\t\t\t\t\t(SouthEast, Around) | (East, HardLeft) | (NorthEast, SoftLeft) =\u003e\n\t\t\t\t\t\t\tNorthWest,\n\t\t\t\t\t(NorthEast, None) | (NorthWest, SoftRight) | (West, HardRight) |\n\t\t\t\t\t\t(SouthWest, Around) | (SouthEast, HardLeft) | (East, SoftLeft) =\u003e\n\t\t\t\t\t\t\tNorthEast,\n\t\t\t\t\t(East, None) | (NorthEast, SoftRight) | (NorthWest, HardRight) |\n\t\t\t\t\t\t(West, Around) | (SouthWest, HardLeft) | (SouthEast, SoftLeft) =\u003e\n\t\t\t\t\t\t\tEast,\n\t\t\t\t\t(SouthEast, None) | (East, SoftRight) | (NorthEast, HardRight) |\n\t\t\t\t\t\t(NorthWest, Around) | (West, HardLeft) | (SouthWest, SoftLeft) =\u003e\n\t\t\t\t\t\t\tSouthEast,\n\t\t\t\t\t(SouthWest, None) | (SouthEast, SoftRight) | (East, HardRight) |\n\t\t\t\t\t\t(NorthEast, Around) | (NorthWest, HardLeft) | (West, SoftLeft) =\u003e\n\t\t\t\t\t\t\tSouthWest,\n\t\t\t\t\t(West, None) | (SouthWest, SoftRight) | (SouthEast, HardRight) |\n\t\t\t\t\t\t(East, Around) | (NorthEast, HardLeft) | (NorthWest, SoftLeft) =\u003e\n\t\t\t\t\t\t\tWest,\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tmod row_col {\n\n\t\tuse super::*;\n\n\t\tpos_decl! (PosRowCol AxisRowCol 2, row Row up down, col Col left right);\n\t\tpos_dirs! {\n\t\t\tPosRowCol Dir2d 2,\n\t\t\tUp up [ NEG_ONE, ZERO ],\n\t\t\tDown down [ ONE, ZERO ],\n\t\t\tLeft left [ ZERO, NEG_ONE ],\n\t\t\tRight right [ ZERO, ONE ],\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e PosRowCol \u003cVal\u003e {\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cSelf, 4\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { row, col } = * self;\n\t\t\t\tif row \u003e Val::MIN { result.push (Self { row: row - Val::ONE, col }); }\n\t\t\t\tif row \u003c Val::MAX { result.push (Self { row: row + Val::ONE, col }); }\n\t\t\t\tif col \u003e Val::MIN { result.push (Self { row, col: col - Val::ONE }); }\n\t\t\t\tif col \u003c Val::MAX { result.push (Self { row, col: col + Val::ONE }); }\n\t\t\t\tresult\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\tpub fn adjacent_8 (\u0026 self) -\u003e ArrayVec \u003cSelf, 8\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet Self { row, col } = * self;\n\t\t\t\tif self.row \u003e Val::MIN {\n\t\t\t\t\tlet row = row - Val::ONE;\n\t\t\t\t\tif self.col \u003e Val::MIN { result.push (Self { row, col: col - Val::ONE }); }\n\t\t\t\t\tresult.push (Self { row, col });\n\t\t\t\t\tif self.col \u003c Val::MAX { result.push (Self { row, col: col + Val::ONE }); }\n\t\t\t\t}\n\t\t\t\tif self.col \u003e Val::MIN { result.push (Self { row, col: col - Val::ONE }); }\n\t\t\t\tif self.col \u003c Val::MAX { result.push (Self { row, col: col + Val::ONE }); }\n\t\t\t\tif self.row \u003c Val::MAX {\n\t\t\t\t\tlet row = row + Val::ONE;\n\t\t\t\t\tif self.col \u003e Val::MIN { result.push (Self { row, col: col - Val::ONE }); }\n\t\t\t\t\tresult.push (Self { row, col });\n\t\t\t\t\tif self.col \u003c Val::MAX { result.push (Self { row, col: col + Val::ONE }); }\n\t\t\t\t}\n\t\t\t\tresult\n\t\t\t}\n\n\t\t}\n\n\t\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub enum Dir2d { Up, Down, Left, Right }\n\n\t\timpl Dir2d {\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub const fn left (self) -\u003e Self {\n\t\t\t\tmatch self {\n\t\t\t\t\tSelf::Up =\u003e Self::Left,\n\t\t\t\t\tSelf::Down =\u003e Self::Right,\n\t\t\t\t\tSelf::Left =\u003e Self::Down,\n\t\t\t\t\tSelf::Right =\u003e Self::Up,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub const fn right (self) -\u003e Self {\n\t\t\t\tmatch self {\n\t\t\t\t\tSelf::Up =\u003e Self::Right,\n\t\t\t\t\tSelf::Down =\u003e Self::Left,\n\t\t\t\t\tSelf::Left =\u003e Self::Up,\n\t\t\t\t\tSelf::Right =\u003e Self::Down,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t#[ inline ]\n\t\t\t#[ must_use ]\n\t\t\tpub const fn around (self) -\u003e Self {\n\t\t\t\tmatch self {\n\t\t\t\t\tSelf::Up =\u003e Self::Down,\n\t\t\t\t\tSelf::Down =\u003e Self::Up,\n\t\t\t\t\tSelf::Left =\u003e Self::Right,\n\t\t\t\t\tSelf::Right =\u003e Self::Left,\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl Add \u003cTurn2d\u003e for Dir2d {\n\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn add (self, other: Turn2d) -\u003e Self {\n\t\t\t\tuse Turn2d::{ None, Left as TLeft, Right as TRight, Around };\n\t\t\t\tuse Dir2d::{ Up, Down, Left as DLeft, Right as DRight };\n\t\t\t\tmatch (self, other) {\n\t\t\t\t\t(Up, None) | (DLeft, TRight) | (DRight, TLeft) | (Down, Around) =\u003e Up,\n\t\t\t\t\t(Down, None) | (DRight, TRight) | (DLeft, TLeft) | (Up, Around) =\u003e Down,\n\t\t\t\t\t(DLeft, None) | (Down, TRight) | (Up, TLeft) | (DRight, Around) =\u003e DLeft,\n\t\t\t\t\t(DRight, None) | (Up, TRight) | (Down, TLeft) | (DLeft, Around) =\u003e DRight,\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e TryAdd \u003c(Dir2d, Val)\u003e for PosRowCol \u003cVal\u003e {\n\n\t\t\ttype Output = Self;\n\n\t\t\t#[ inline ]\n\t\t\tfn try_add (self, (dir, dist): (Dir2d, Val)) -\u003e NumResult \u003cSelf\u003e {\n\t\t\t\tlet mut result = self;\n\t\t\t\tmatch dir {\n\t\t\t\t\tDir2d::Up =\u003e result.row = Val::sub_2 (result.row, dist) ?,\n\t\t\t\t\tDir2d::Down =\u003e result.row = Val::add_2 (result.row, dist) ?,\n\t\t\t\t\tDir2d::Left =\u003e result.col = Val::sub_2 (result.col, dist) ?,\n\t\t\t\t\tDir2d::Right =\u003e result.col = Val::add_2 (result.col, dist) ?,\n\t\t\t\t}\n\t\t\t\tOk (result)\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\npos_decl! (PosXYZ AxisXYZ 3, x X left right, y Y down up, z Z behind ahead);\n\npos_decl! (PosWXYZ AxisWXYZ 4, w W wane wax, x X left right, y Y down up, z Z behind ahead);\npos_decl! (PosXYZT AxisXYZT 4, x X left right, y Y down up, z Z behind ahead, t T before after);\npos_decl! (PosXYZW AxisXYZW 4, x X left right, y Y down up, z Z behind ahead, w W wane wax);\n","traces":[{"line":40,"address":[115368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[47956,47391,47849,47626,47372,47937,47648,47831],"length":1,"stats":{"Line":146},"fn_name":null},{"line":47,"address":[70976],"length":1,"stats":{"Line":0},"fn_name":"new\u003ci16\u003e"},{"line":58,"address":[48384,48544],"length":1,"stats":{"Line":2},"fn_name":"up\u003ci8\u003e"},{"line":60,"address":[48568,48409],"length":1,"stats":{"Line":23},"fn_name":null},{"line":65,"address":[48624,48464],"length":1,"stats":{"Line":4},"fn_name":"down\u003ci8\u003e"},{"line":67,"address":[56381],"length":1,"stats":{"Line":28},"fn_name":null},{"line":88,"address":[138416],"length":1,"stats":{"Line":0},"fn_name":"from\u003ci16\u003e"},{"line":106,"address":[54224],"length":1,"stats":{"Line":0},"fn_name":"index\u003ci16\u003e"},{"line":107,"address":[31765,30884],"length":1,"stats":{"Line":7},"fn_name":null},{"line":108,"address":[34971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[54256],"length":1,"stats":{"Line":0},"fn_name":"index_mut\u003ci16\u003e"},{"line":118,"address":[44209,44079,44144],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[54278,54273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[90496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[134738,134646],"length":1,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[137632],"length":1,"stats":{"Line":0},"fn_name":"fmt\u003ci16\u003e"},{"line":159,"address":[137649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[137663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[137697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[137759,137846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[137860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[137900,137836,138005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[137960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[48368],"length":1,"stats":{"Line":0},"fn_name":"default\u003ci8\u003e"},{"line":192,"address":[133856],"length":1,"stats":{"Line":0},"fn_name":"add\u003ci16, i16\u003e"},{"line":193,"address":[118084],"length":1,"stats":{"Line":15},"fn_name":null},{"line":200,"address":[43616],"length":1,"stats":{"Line":0},"fn_name":"add_assign\u003ci16, i16\u003e"},{"line":201,"address":[25664,25565],"length":1,"stats":{"Line":8},"fn_name":null},{"line":209,"address":[133344],"length":1,"stats":{"Line":19},"fn_name":"try_add\u003ci16, i16\u003e"},{"line":210,"address":[133357],"length":1,"stats":{"Line":20},"fn_name":null},{"line":211,"address":[133370],"length":1,"stats":{"Line":20},"fn_name":null},{"line":212,"address":[133383],"length":1,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[133514,133398],"length":1,"stats":{"Line":40},"fn_name":null},{"line":214,"address":[133568,133472,133497],"length":1,"stats":{"Line":40},"fn_name":null},{"line":216,"address":[133528],"length":1,"stats":{"Line":20},"fn_name":null},{"line":242,"address":[85328],"length":1,"stats":{"Line":0},"fn_name":"mul\u003ci16\u003e"},{"line":243,"address":[51516],"length":1,"stats":{"Line":3},"fn_name":null},{"line":244,"address":[51520],"length":1,"stats":{"Line":3},"fn_name":null},{"line":245,"address":[51528,51606],"length":1,"stats":{"Line":6},"fn_name":null},{"line":246,"address":[51601,51636,51584],"length":1,"stats":{"Line":6},"fn_name":null},{"line":248,"address":[51617],"length":1,"stats":{"Line":3},"fn_name":null},{"line":261,"address":[138208],"length":1,"stats":{"Line":0},"fn_name":"neg\u003ci16\u003e"},{"line":262,"address":[119706,118778],"length":1,"stats":{"Line":4},"fn_name":null},{"line":263,"address":[119724,118796],"length":1,"stats":{"Line":4},"fn_name":null},{"line":264,"address":[138243,138329],"length":1,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[118863,118883,118953,119881,119791,119811],"length":1,"stats":{"Line":8},"fn_name":null},{"line":267,"address":[118663,119591],"length":1,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[82832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[43673,43313],"length":1,"stats":{"Line":4},"fn_name":null},{"line":310,"address":[133600],"length":1,"stats":{"Line":4},"fn_name":"try_sub\u003ci16, i16\u003e"},{"line":311,"address":[133613],"length":1,"stats":{"Line":4},"fn_name":null},{"line":312,"address":[133626],"length":1,"stats":{"Line":4},"fn_name":null},{"line":313,"address":[133639],"length":1,"stats":{"Line":4},"fn_name":null},{"line":314,"address":[133654,133770],"length":1,"stats":{"Line":8},"fn_name":null},{"line":315,"address":[133728,133824,133753],"length":1,"stats":{"Line":8},"fn_name":null},{"line":317,"address":[133784],"length":1,"stats":{"Line":4},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[93968,94225],"length":1,"stats":{"Line":7},"fn_name":"adjacent_4\u003cu8\u003e"},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[49459,48880],"length":1,"stats":{"Line":3},"fn_name":"adjacent_8\u003ci8\u003e"},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":634,"address":[40480],"length":1,"stats":{"Line":1},"fn_name":"adjacent\u003ci16\u003e"},{"line":636,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[67456,67713],"length":1,"stats":{"Line":4},"fn_name":"adjacent_4\u003cu8\u003e"},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[24005,23408],"length":1,"stats":{"Line":1},"fn_name":"adjacent_8\u003ci16\u003e"},{"line":746,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":778,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":789,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":819,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":835,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":838,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":88,"coverable":241},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","search","pairs_map.rs"],"content":"use super::*;\n\npub struct PairsMap \u003cKey, Val\u003e {\n\tkeys: MapToIndex \u003cKey\u003e,\n\tvalues: Vec \u003cVal\u003e,\n}\n\nimpl \u003cKey, Val\u003e PairsMap \u003cKey, Val\u003e\n\twhere Key: Clone + Eq + Hash + Ord {\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.keys.len ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.keys.is_empty ()\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn keys (\u0026 self) -\u003e \u0026 [Key] {\n\t\t\u0026 self.keys\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn values (\u0026 self) -\u003e \u0026 [Val] {\n\t\t\u0026 self.values\n\t}\n\n}\n\nimpl \u003cKey, Val\u003e FromIterator \u003c(Key, Key, Val)\u003e for PairsMap \u003cKey, Val\u003e\n\twhere Key: Clone + Eq + Hash + Ord, Val: Clone + Default {\n\n\t#[ inline ]\n\tfn from_iter \u003cIter: IntoIterator \u003cItem = (Key, Key, Val)\u003e\u003e (iter: Iter) -\u003e Self {\n\t\tlet mut keys = MapToIndex::new ();\n\t\tlet mut temp = Vec::new ();\n\t\tfor (key_0, key_1, val) in iter {\n\t\t\tlet idx_0 = keys.insert (key_0);\n\t\t\tlet idx_1 = keys.insert (key_1);\n\t\t\ttemp.push ((idx_0, idx_1, val));\n\t\t}\n\t\tlet mut values: Vec \u003cVal\u003e =\n\t\t\titer::from_fn (|| Some (Val::default ()))\n\t\t\t\t.take (keys.len () * keys.len ())\n\t\t\t\t.collect ();\n\t\tfor (idx_0, idx_1, val) in temp {\n\t\t\tvalues [idx_0 * keys.len () + idx_1] = val.clone ();\n\t\t}\n\t\tSelf { keys, values }\n\t}\n\n}\n\nimpl \u003cKey, Val\u003e Index \u003c(usize, usize)\u003e for PairsMap \u003cKey, Val\u003e\n\twhere Key: Clone + Eq + Hash + Ord, Val: Clone + Default {\n\n\ttype Output = Val;\n\n\t#[ inline ]\n\tfn index (\u0026 self, (idx_0, idx_1): (usize, usize)) -\u003e \u0026 Val {\n\t\t\u0026 self.values [idx_0 * self.keys.len () + idx_1]\n\t}\n\n}\n","traces":[{"line":13,"address":[57344],"length":1,"stats":{"Line":0},"fn_name":"len\u003caoc_inpstr::InpStr, u32\u003e"},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[58945,57248],"length":1,"stats":{"Line":3},"fn_name":"from_iter\u003caoc_inpstr::InpStr, i32, core::iter::adapters::map::Map\u003ccore::slice::iter::Iter\u003c(aoc_inpstr::InpStr, aoc_inpstr::InpStr, aoc_2015_day_13::input::DiffSign, i32)\u003e, aoc_2015_day_13::model::{impl#0}::build::{closure_env#0}\u003e\u003e"},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[57707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[58095],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[58310,58714],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[58376,58454,58887,58335],"length":1,"stats":{"Line":9},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5},"fn_name":null}],"covered":8,"coverable":22},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","search","permutations.rs"],"content":"//! Generate permutations of [`usize`] from `0 .. len`.\n//!\n//! The main functionality is provided by the [`PermutationsHelper`] struct.\n//!\n//! Designed to be used with a indexed list of items of which to generate permutations, eg in a\n//! [`Vec`] or similar. Provide the number of items when calling [`PermutationsHelper::new`], then\n//! call [`next`](PermutationsHelper::next) in a loop, aborting if it returns `false`. After\n//! calling [`next`](PermutationsHelper::next), the indexes are available by treating this struct\n//! as a slice via the [`Deref`] trait.\n//!\n//! # Examples\n//!\n//! Basic usage:\n//!\n//! ```\n//! # use aoc_search::PermutationsHelper;\n//! let mut perms_helper = PermutationsHelper::new (2);\n//! assert_eq! (true, perms_helper.next ());\n//! assert_eq! (\u0026 [0, 1], \u0026 * perms_helper);\n//! assert_eq! (true, perms_helper.next ());\n//! assert_eq! (\u0026 [1, 0], \u0026 * perms_helper);\n//! assert_eq! (false, perms_helper.next ());\n//! ```\n//!\n//! This struct doesn't implement [`Iterator`] so that we avoid allocating a [`Vec`] or similar\n//! for every iteration. It can easily be wrapped as one if needed:\n//!\n//! ```\n//! # use aoc_search::PermutationsHelper;\n//! # use std::iter;\n//! let mut perms_helper = PermutationsHelper::new (2);\n//! let mut perms_iter = iter::from_fn (move ||\n//!   perms_helper.next ().then (|| perms_helper.to_vec ()));\n//! assert_eq! (Some (vec! [0, 1]), perms_iter.next ());\n//! assert_eq! (Some (vec! [1, 0]), perms_iter.next ());\n//! assert_eq! (None, perms_iter.next ());\n//! ```\n//!\n//! A more typical example is generating permutations of indexes into a [`Vec`], performing a\n//! calculation based on the items in that order, and finally performing some type of search or\n//! aggregation over the results:\n//!\n//! ```\n//! # use aoc_search::PermutationsHelper;\n//! # use std::iter;\n//! let items = vec! [ 49_u64, 93, 51, 45, 26, 73, 20, 80 ];\n//! let mut perms_helper = PermutationsHelper::new (items.len ());\n//! let calc_iter = iter::from_fn (move ||\n//!   perms_helper.next ().then (|| perms_helper.iter ()\n//!     .map (|\u0026 idx| items [idx])\n//!     .fold (0, |sum, item| sum * 100 + item)));\n//! assert_eq! (9380735149452620, calc_iter.clone ().max ().unwrap ());\n//! assert_eq! (2026454951738093, calc_iter.clone ().min ().unwrap ());\n//! ```\n//!\n//! # Algorithm\n//!\n//! This implements a \"classic\" algorithm described on\n//! [Wikipedia](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order),\n//! which produces results in lexicographical order. The alogirthm starts with the items in order,\n//! then applies the following steps to generate subsequent iterations:\n//!\n//! * Find the highest index `idx_0` where `items [idx_0] \u003c items [idx_0 + 1]`\n//! * Find the highest index `idx_1` where `idx_0 \u003c idx_1 \u0026\u0026 items [idx_0] \u003c items [idx_1]`\n//! * Swap `items [idx_0]` and `items [idx_1]`\n//! * Reverse the order of `items [idx_0 + 1 .. ]`\n\nuse super::*;\n\n/// The `PermutationsHelper` type. See the [module level documentation](self) for more\n/// information.\n///\n#[ derive (Clone, Debug) ]\npub struct PermutationsHelper \u003cconst CIR: bool = false, const MIR: bool = false\u003e {\n\tdata: Vec \u003cusize\u003e,\n\tfirst: bool,\n}\n\nimpl PermutationsHelper \u003cfalse, false\u003e {\n\n\t/// Create a new [`PermutationsHelper`].\n\t///\n\t/// # Examples\n\t///\n\t/// ```\n\t/// # use aoc_search::PermutationsHelper;\n\t/// # use std::iter;\n\t/// let mut perms_helper = PermutationsHelper::new (3);\n\t/// let mut perms_iter = iter::from_fn (move ||\n\t///   perms_helper.next ().then (|| perms_helper.to_vec ()));\n\t/// assert_eq! (Some (vec! [0, 1, 2]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [0, 2, 1]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [1, 0, 2]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [1, 2, 0]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [2, 0, 1]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [2, 1, 0]), perms_iter.next ());\n\t/// assert_eq! (None, perms_iter.next ());\n\t/// ```\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new (len: usize) -\u003e Self {\n\t\tSelf {\n\t\t\tdata: (0 .. len).collect (),\n\t\t\tfirst: true,\n\t\t}\n\t}\n\n}\n\nimpl PermutationsHelper \u003ctrue, false\u003e {\n\n\t/// Create a new [`PermutationsHelper`] in \"circular\" mode.\n\t///\n\t/// This will always return index `0` in the first position, and is intended for applications\n\t/// where rotating the permutation by any amount doesn't change its meaning.\n\t///\n\t/// This reduces the number of iterations by a factor of the number of items.\n\t///\n\t/// # Examples\n\t///\n\t/// ```\n\t/// # use aoc_search::PermutationsHelper;\n\t/// # use std::iter;\n\t/// let mut perms_helper = PermutationsHelper::new_circular (3);\n\t/// let mut perms_iter = iter::from_fn (move ||\n\t///   perms_helper.next ().then (|| perms_helper.to_vec ()));\n\t/// assert_eq! (Some (vec! [0, 1, 2]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [0, 2, 1]), perms_iter.next ());\n\t/// assert_eq! (None, perms_iter.next ());\n\t/// ```\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new_circular (len: usize) -\u003e Self {\n\t\tSelf {\n\t\t\tdata: (0 .. len).collect (),\n\t\t\tfirst: true,\n\t\t}\n\t}\n\n}\n\nimpl PermutationsHelper \u003cfalse, true\u003e {\n\n\t/// Create a new [`PermutationsHelper`] in \"mirror\" mode.\n\t///\n\t/// This will always permutations with the first position lower than the last, and is intended\n\t/// for applications where reversing the permutation doesn't change its meaning. This reduces\n\t/// the number of iterations by a factor of two.\n\t///\n\t/// Note that there is no clever optimisation here, we simply loop over the skipped iterations\n\t/// after calculating them. This may be useful, however, if an expensive calcualtion is\n\t/// performed for each one.\n\t///\n\t/// # Examples\n\t///\n\t/// ```\n\t/// # use aoc_search::PermutationsHelper;\n\t/// # use std::iter;\n\t/// let mut perms_helper = PermutationsHelper::new_mirror (3);\n\t/// let mut perms_iter = iter::from_fn (move ||\n\t///   perms_helper.next ().then (|| perms_helper.to_vec ()));\n\t/// assert_eq! (Some (vec! [0, 1, 2]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [0, 2, 1]), perms_iter.next ());\n\t/// assert_eq! (Some (vec! [1, 0, 2]), perms_iter.next ());\n\t/// assert_eq! (None, perms_iter.next ());\n\t/// ```\n\t///\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn new_mirror (len: usize) -\u003e Self {\n\t\tSelf {\n\t\t\tdata: (0 .. len).collect (),\n\t\t\tfirst: true,\n\t\t}\n\t}\n\n}\n\nimpl \u003cconst CIR: bool, const MIR: bool\u003e PermutationsHelper \u003cCIR, MIR\u003e {\n\n\t/// Find the next permutation in the sequence.\n\t///\n\t/// This returns `true` if another permutation was found, and `false` otherwise. This is\n\t/// typically called in a loop which accesses the permutation as a [`prim@slice`] via the\n\t/// [`Deref`] trait\n\t///\n\t/// # Examples\n\t///\n\t/// ```\n\t/// # use aoc_search::PermutationsHelper;\n\t/// # let mut perms_helper = PermutationsHelper::new (4);\n\t/// while perms_helper.next () {\n\t///   println! (\"{:?}\", \u0026 * perms_helper);\n\t/// }\n\t/// ```\n\t///\n\t#[ allow (clippy::should_implement_trait) ]\n\t#[ inline ]\n\tpub fn next (\u0026 mut self) -\u003e bool {\n\n\t\t// special case for first iteration\n\n\t\tif self.first {\n\t\t\tself.first = false;\n\t\t\treturn ! self.data.is_empty ();\n\t\t}\n\n\t\tloop {\n\n\t\t\t// find first index to update\n\n\t\t\tlet (idx_0, val_0) = some_or! (\n\t\t\t\tself.data.iter ().rev ()\n\t\t\t\t\t.tuple_windows ()\n\t\t\t\t\t.enumerate ()\n\t\t\t\t\t.find (|\u0026 (_, (\u0026 val_1, \u0026 val_0))| val_0 \u003c val_1)\n\t\t\t\t\t.map (|(off_0, (_, \u0026 val_0))| (self.data.len () - 2 - off_0, val_0)),\n\t\t\t\treturn false);\n\n\t\t\tif CIR \u0026\u0026 idx_0 == 0 { return false }\n\n\t\t\t// find second index to update\n\n\t\t\tlet (idx_1, val_1) = some_or! (\n\t\t\t\tself.data [idx_0 + 1 .. ].iter ().rev ()\n\t\t\t\t\t.enumerate ()\n\t\t\t\t\t.find (|\u0026 (_, \u0026 val_1)| val_0 \u003c val_1)\n\t\t\t\t\t.map (|(off_1, \u0026 val_1)| (self.data.len () - 1 - off_1, val_1)),\n\t\t\t\treturn false);\n\n\t\t\t// swap the values at the two indexes\n\n\t\t\tself.data [idx_0] = val_1;\n\t\t\tself.data [idx_1] = val_0;\n\n\t\t\t// reverse everything after the first index\n\n\t\t\tself.data [idx_0 + 1 .. ].reverse ();\n\n\t\t\t// skip mirror duplicates if that option is enabled\n\n\t\t\tif ! MIR || self.data [0] \u003c self.data [self.data.len () - 1] { break }\n\n\t\t}\n\n\t\ttrue\n\n\t}\n\n}\n\nimpl \u003cconst CIR: bool, const MIR: bool\u003e Deref for PermutationsHelper \u003cCIR, MIR\u003e {\n\n\ttype Target = [usize];\n\n\t#[ inline ]\n\tfn deref (\u0026 self) -\u003e \u0026 [usize] {\n\t\t\u0026 self.data\n\t}\n\n}\n","traces":[{"line":102,"address":[50144],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":104,"address":[63434,63114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[70337],"length":1,"stats":{"Line":3},"fn_name":null},{"line":206,"address":[70343],"length":1,"stats":{"Line":3},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[70677],"length":1,"stats":{"Line":3},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[50215,50963],"length":1,"stats":{"Line":3},"fn_name":null},{"line":219,"address":[60970,60918],"length":1,"stats":{"Line":3},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[71031,70857],"length":1,"stats":{"Line":3},"fn_name":null},{"line":227,"address":[70688,71157,70730],"length":1,"stats":{"Line":6},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6},"fn_name":null}],"covered":18,"coverable":32},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","search","priority.rs"],"content":"/// Implements [Digkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n///\n/// This searches for the cheapest path from one point to another, given a starting point (or\n/// points) and a way to iteratively find next points. While this can be used for path-finding, it\n/// can also be used to solve many other problems, assuming their state can be modeled as points,\n/// the next steps can be iterated, and each step can be scored with some kind of priority.\n///\n/// # Example\n///\n/// Here's an example taken from the\n/// [wikipedia page](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm). We use strings for the\n/// nodes instead of integers to make things a bit clearer.\n///\n/// In this example, we supply a hash map directly when constructing the [`PrioritySearch`]. This\n/// works because the trait [`PrioritySearchVisitor`] is implemented directly in this case. It is\n/// also implemented for functions, so you can pass a closure, plus the trait can be implemented\n/// directly, of course.\n///\n/// ```\n/// # use aoc_misc::prelude::*;\n/// # use aoc_search::*;\n/// // set up a data structure with a map of connected nodes and the distance between them\n/// let nodes: HashMap \u003c\u0026 str, Vec \u003c(\u0026 str, u64)\u003e\u003e = {\n///\n///    // use of Itertools::group_by requires a temporary...\n///    let nodes_group_by_temp = [\n///          // list of connected nodes and the distance between them\n///          (\"one\", \"two\", 7), (\"one\", \"three\", 9), (\"one\", \"six\", 14),\n///          (\"two\", \"three\", 10), (\"two\", \"four\", 15), (\"three\", \"four\", 11),\n///          (\"three\", \"six\", 2), (\"four\", \"five\", 6), (\"five\", \"six\", 8),\n///       ].into_iter ()\n///          // double up the connections to include the reverse\n///          .flat_map (|(node_1, node_2, dist)| [(node_1, node_2, dist), (node_2, node_1, dist)])\n///          // group by node_1 (requires sort)\n///          .sorted_by_key (|\u0026 (node_1, _, _)| node_1)\n///         .group_by (|\u0026 (node_1, _, _)| node_1);\n///\n///    // collect into a hash map from node_1 to (node_2, dist)\n///    nodes_group_by_temp.into_iter ()\n///       .map (|(node_1, group)| (\n///             node_1,\n///             group.map (|(_, node_2, dist)| (node_2, dist)).collect::\u003cVec \u003c_\u003e\u003e (),\n///          ))\n///       .collect ()\n///\n/// };\n///\n/// // create a PrioritySearch to traverse our nodes\n/// let mut search = PrioritySearch::with_hash_map (nodes);\n///\n/// // add the starting point with a total distance of 0\n/// search.push (\"one\", 0);\n///\n/// // verify the results\n/// assert_eq! (search.next (), Some ((\"one\", 0)));\n/// assert_eq! (search.next (), Some ((\"two\", 7)));\n/// assert_eq! (search.next (), Some ((\"three\", 9)));\n/// assert_eq! (search.next (), Some ((\"six\", 11)));\n/// assert_eq! (search.next (), Some ((\"five\", 19)));\n/// assert_eq! (search.next (), Some ((\"four\", 20)));\n/// assert_eq! (search.next (), None);\n/// ```\n\nuse super::*;\n\npub struct PrioritySearch \u003cNode, Pri, Visitor, SeenImpl\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, SeenImpl\u003e {\n\tvisitor: Visitor,\n\tinner: PrioritySearchInner \u003cNode, Pri, SeenImpl\u003e,\n}\n\n#[ allow (clippy::implicit_hasher) ]\nimpl \u003cNode, Pri, Visitor\u003e\n\tPrioritySearch \u003cNode, Pri, Visitor, HashMap \u003cNode, SeenState \u003cPri\u003e\u003e\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash + Ord,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, HashMap \u003cNode, SeenState \u003cPri\u003e\u003e\u003e {\n\n\t#[ inline ]\n\tpub fn with_hash_map (visitor: Visitor) -\u003e Self {\n\t\tSelf {\n\t\t\tvisitor,\n\t\t\tinner: PrioritySearchInner {\n\t\t\t\tseen: HashMap::new (),\n\t\t\t\ttodo: BinaryHeap::new (),\n\t\t\t},\n\t\t}\n\t}\n\n}\n\nimpl \u003cPos, Pri, Visitor, const DIMS: usize\u003e\n\tPrioritySearch \u003cGridCursor \u003cPos, DIMS\u003e, Pri, Visitor, GridBuf \u003cVec \u003cSeenState \u003cPri\u003e\u003e, Pos, DIMS\u003e\u003e\n\twhere\n\t\tPos: Clone + Debug + Eq + Hash + GridPos \u003cDIMS\u003e,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tVisitor: PrioritySearchVisitor \u003cGridCursor \u003cPos, DIMS\u003e, Pri, GridBuf \u003cVec \u003cSeenState \u003cPri\u003e\u003e, Pos, DIMS\u003e\u003e {\n\n\t#[ inline ]\n\tpub fn with_grid_range (start: Pos, end: Pos, visitor: Visitor) -\u003e NumResult \u003cSelf\u003e {\n\t\tOk (Self {\n\t\t\tvisitor,\n\t\t\tinner: PrioritySearchInner {\n\t\t\t\tseen: GridBuf::new_range (start, end) ?,\n\t\t\t\ttodo: BinaryHeap::new (),\n\t\t\t},\n\t\t})\n\t}\n\n\t#[ inline ]\n\tpub fn with_grid_size (size: Pos, visitor: Visitor) -\u003e Self {\n\t\tSelf {\n\t\t\tvisitor,\n\t\t\tinner: PrioritySearchInner {\n\t\t\t\tseen: GridBuf::new_size (size),\n\t\t\t\ttodo: BinaryHeap::new (),\n\t\t\t},\n\t\t}\n\t}\n\n}\n\nimpl \u003cNode, Pri, Visitor, SeenImpl\u003e PrioritySearch \u003cNode, Pri, Visitor, SeenImpl\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, SeenImpl\u003e {\n\n\t#[ inline ]\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.inner.todo.len ()\n\t}\n\n\t#[ inline ]\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.len () == 0\n\t}\n\n\t#[ inline ]\n\tpub fn push (\u0026 mut self, node: Node, priority: Pri) -\u003e \u0026 mut Self {\n\t\tself.inner.push (node, priority);\n\t\tself\n\t}\n\n}\n\nimpl \u003cNode, Pri, Visitor, SeenImpl\u003e Iterator for PrioritySearch \u003cNode, Pri, Visitor, SeenImpl\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, SeenImpl\u003e {\n\n\ttype Item = Visitor::Item;\n\n\t#[ inline ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cSelf::Item\u003e {\n\t\tif let Some (WithPriority { priority, value: node }) = self.inner.pop () {\n\t\t\tlet adder = PrioritySearchAdder { inner: \u0026 mut self.inner };\n\t\t\treturn Some (self.visitor.visit (node, priority, adder));\n\t\t}\n\t\tNone\n\t}\n\n}\n\nstruct WithPriority \u003cVal, Pri\u003e {\n\tpriority: Pri,\n\tvalue: Val,\n}\n\nimpl \u003cVal, Pri\u003e PartialEq for WithPriority \u003cVal, Pri\u003e where Pri: PartialEq {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.priority.eq (\u0026 other.priority)\n\t}\n}\n\nimpl \u003cVal, Pri\u003e Eq for WithPriority \u003cVal, Pri\u003e where Pri: Eq {\n}\n\nimpl \u003cVal, Pri\u003e PartialOrd for WithPriority \u003cVal, Pri\u003e where Pri: PartialOrd {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tother.priority.partial_cmp (\u0026 self.priority)\n\t}\n}\n\nimpl \u003cVal, Pri\u003e Ord for WithPriority \u003cVal, Pri\u003e where Pri: Ord {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tother.priority.cmp (\u0026 self.priority)\n\t}\n}\n\nstruct PrioritySearchInner \u003cNode, Pri, Seen\u003e {\n\tseen: Seen,\n\ttodo: BinaryHeap \u003cWithPriority \u003cNode, Pri\u003e\u003e,\n}\n\nimpl \u003cNode, Pri, SeenImpl\u003e PrioritySearchInner \u003cNode, Pri, SeenImpl\u003e\n\twhere\n\t\tNode: Clone + Eq + Hash,\n\t\tPri: Clone + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e {\n\tfn push (\u0026 mut self, node: Node, priority: Pri) {\n\t\tif self.seen.seen_push (node.clone (), priority.clone ()) {\n\t\t\tself.todo.push (WithPriority { priority, value: node });\n\t\t}\n\t}\n\tfn pop (\u0026 mut self) -\u003e Option \u003cWithPriority \u003cNode, Pri\u003e\u003e {\n\t\twhile let Some (WithPriority { value: node, priority }) = self.todo.pop () {\n\t\t\tif self.seen.seen_visited (\u0026 node) { continue }\n\t\t\treturn Some (WithPriority { value: node, priority });\n\t\t}\n\t\tNone\n\t}\n}\n\npub struct PrioritySearchAdder \u003c'inr, Node, Pri, Seen\u003e {\n\tinner: \u0026 'inr mut PrioritySearchInner \u003cNode, Pri, Seen\u003e,\n}\n\nimpl \u003c'inr, Node, Pri, SeenImpl\u003e PrioritySearchAdder \u003c'inr, Node, Pri, SeenImpl\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Debug + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e {\n\n\t#[ inline ]\n\tpub fn add (\u0026 mut self, node: Node, priority: Pri) {\n\t\tself.inner.push (node, priority);\n\t}\n\n}\n\npub trait PrioritySearchVisitor \u003cNode, Pri, Seen\u003e {\n\n\ttype Item;\n\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tadder: PrioritySearchAdder \u003cNode, Pri, Seen\u003e,\n\t) -\u003e Self::Item;\n\n}\n\nimpl \u003cVisitorFn, Node, Pri, Item, SeenImpl\u003e PrioritySearchVisitor \u003cNode, Pri, SeenImpl\u003e for VisitorFn\n\twhere\n\t\tNode: Clone,\n\t\tPri: Clone + Ord,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e,\n\t\tVisitorFn: FnMut (Node, Pri, PrioritySearchAdder \u003cNode, Pri, SeenImpl\u003e) -\u003e Item {\n\n\ttype Item = Item;\n\n\t#[ inline ]\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tadder: PrioritySearchAdder \u003cNode, Pri, SeenImpl\u003e,\n\t) -\u003e Self::Item {\n\t\tself (node, priority, adder)\n\t}\n\n}\n\nimpl \u003cNode, Pri, SeenImpl, NextNodesIntoIter, Hshr\u003e PrioritySearchVisitor \u003cNode, Pri, SeenImpl\u003e\n\tfor HashMap \u003cNode, NextNodesIntoIter, Hshr\u003e\n\twhere\n\t\tHshr: BuildHasher,\n\t\tNode: Clone + Debug + Eq + Hash + Ord,\n\t\tPri: Clone + Debug + Ord + Add \u003cOutput = Pri\u003e,\n\t\tSeenImpl: Seen \u003cNode, Pri\u003e,\n\t\tfor \u003c'dat\u003e \u0026 'dat NextNodesIntoIter: IntoIterator \u003cItem = \u0026 'dat (Node, Pri)\u003e {\n\n\ttype Item = (Node, Pri);\n\n\t#[ inline ]\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tmut adder: PrioritySearchAdder \u003cNode, Pri, SeenImpl\u003e,\n\t) -\u003e Self::Item {\n\t\tif let Some (next_nodes) = self.get (\u0026 node) {\n\t\t\tfor \u0026 (ref next_node, ref next_pri) in next_nodes {\n\t\t\t\tadder.add (next_node.clone (), priority.clone () + next_pri.clone ());\n\t\t\t}\n\t\t}\n\t\t(node, priority)\n\t}\n\n}\n\npub trait Seen \u003cNode, Pri\u003e where Node: Clone, Pri: Clone + Ord {\n\n\tfn seen_get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut SeenState \u003cPri\u003e;\n\n\t#[ inline ]\n\tfn seen_push (\u0026 mut self, node: Node, priority: Pri) -\u003e bool {\n\t\tlet seen_state = self.seen_get_mut (node);\n\t\tmatch seen_state.clone () {\n\t\t\tSeenState::New =\u003e {\n\t\t\t\t* seen_state = SeenState::Unvisited (priority);\n\t\t\t\ttrue\n\t\t\t},\n\t\t\tSeenState::Unvisited (seen_priority) if priority \u003c seen_priority =\u003e {\n\t\t\t\t* seen_state = SeenState::Unvisited (priority);\n\t\t\t\ttrue\n\t\t\t},\n\t\t\tSeenState::Unvisited (_) | SeenState::Visited =\u003e false,\n\t\t}\n\t}\n\n\t#[ inline ]\n\tfn seen_visited (\u0026 mut self, node: \u0026 Node) -\u003e bool {\n\t\tlet seen_state = self.seen_get_mut (node.clone ());\n\t\tif let SeenState::Visited = seen_state.clone () {\n\t\t\ttrue\n\t\t} else {\n\t\t\t* seen_state = SeenState::Visited;\n\t\t\tfalse\n\t\t}\n\t}\n\n}\n\nimpl \u003cNode, Pri, Hshr\u003e Seen \u003cNode, Pri\u003e\nfor HashMap \u003cNode, SeenState \u003cPri\u003e, Hshr\u003e\n\twhere\n\t\tHshr: BuildHasher,\n\t\tNode: Clone + Eq + Hash + Ord,\n\t\tPri: Clone + Ord {\n\n\t#[ inline ]\n\tfn seen_get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut SeenState \u003cPri\u003e {\n\t\tself.entry (node).or_insert (SeenState::New)\n\t}\n\n}\n\nimpl \u003cNode, Pri, const DIMS: usize\u003e Seen \u003cNode, Pri\u003e\n\tfor GridBuf \u003cVec \u003cSeenState \u003cPri\u003e\u003e, Node, DIMS\u003e\n\twhere\n\t\tNode: GridPos \u003cDIMS\u003e + Clone + Eq + Hash,\n\t\tPri: Clone + Ord {\n\n\t#[ inline ]\n\tfn seen_get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut SeenState \u003cPri\u003e {\n\t\tSelf::get_mut (self, node).unwrap_or_else (\n\t\t\t|| panic! (\"Position is not in grid: {node:?}\"))\n\t}\n\n}\n\nimpl \u003cPos, Pri, const DIMS: usize\u003e Seen \u003cGridCursor \u003cPos, DIMS\u003e, Pri\u003e\n\tfor GridBuf \u003cVec \u003cSeenState \u003cPri\u003e\u003e, Pos, DIMS\u003e\n\twhere\n\t\tPos: GridPos \u003cDIMS\u003e + Clone + Eq + Hash,\n\t\tPri: Clone + Ord {\n\n\t#[ inline ]\n\tfn seen_get_mut (\u0026 mut self, node: GridCursor \u003cPos, DIMS\u003e) -\u003e \u0026 mut SeenState \u003cPri\u003e {\n\t\tSelf::get_mut (self, node.native ()).unwrap_or_else (\n\t\t\t|| panic! (\"Position is not in grid: {node:?}\"))\n\t}\n\n}\n\n#[ derive (Clone) ]\npub enum SeenState \u003cPri: Clone\u003e {\n\tNew,\n\tUnvisited (Pri),\n\tVisited,\n}\n\nimpl \u003cPri: Clone\u003e Default for SeenState \u003cPri\u003e {\n\n\t#[ inline ]\n\tfn default () -\u003e Self {\n\t\tSelf::New\n\t}\n\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":22},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":263,"address":[87248],"length":1,"stats":{"Line":0},"fn_name":"visit\u003caoc_2019_day_20::logic::calc_result::{closure_env#0}, (aoc_2019_day_20::model::Portal, i32), u32, (aoc_2019_day_20::model::Portal, i32, u32), ahash::hash_map::AHashMap\u003c(aoc_2019_day_20::model::Portal, i32), aoc_search::priority::SeenState\u003cu32\u003e, ahash::random_state::RandomState\u003e\u003e"},{"line":269,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":17},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":25,"coverable":70},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","search","search.rs"],"content":"//! Iterative search algorithms for solutions in a problem space\n\nuse aoc_grid::prelude::*;\nuse aoc_misc::prelude::*;\nuse aoc_nums::NumResult;\n\npub mod pairs_map;\npub use pairs_map::*;\n\npub mod permutations;\npub use permutations::*;\n\npub mod priority;\npub use priority::*;\n\n/// Standard prelude for wildcard imports.\n///\npub mod prelude {\n\tpub use crate::pairs_map::PairsMap;\n\tpub use crate::permutations::PermutationsHelper;\n\tpub use crate::priority::PrioritySearchAdder;\n\tpub use crate::priority::PrioritySearch;\n}\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","lib.rs"],"content":"//! Common functionality used in all puzzle solutions\n\nuse clap::ArgMatches;\nuse clap::Command;\n\n#[ doc (no_inline) ]\npub use prelude::*;\n\npub mod puzzle;\n\nmod prelude {\n\n\tpub use clap;\n\n\tpub use aoc_checked::checked as chk;\n\tpub use aoc_misc::prelude::*;\n\tpub use aoc_nums as nums;\n\tpub use aoc_inpstr::InpStr;\n\tpub use aoc_parser as parser;\n\n\tpub use crate::nums::BitPopper;\n\tpub use crate::nums::BitPusher;\n\tpub use crate::nums::Int;\n\tpub use crate::nums::IntConv;\n\tpub use crate::nums::IntSigned;\n\tpub use crate::nums::IntUnsigned;\n\tpub use crate::nums::NumResult;\n\tpub use crate::nums::Overflow;\n\tpub use crate::nums::QuickFrom;\n\tpub use crate::nums::QuickInto;\n\tpub use crate::nums::TryAdd;\n\tpub use crate::nums::TryAddAssign;\n\tpub use crate::nums::TryDiv;\n\tpub use crate::nums::TryDivAssign;\n\tpub use crate::nums::TryMul;\n\tpub use crate::nums::TryMulAssign;\n\tpub use crate::nums::TryRem;\n\tpub use crate::nums::TryRemAssign;\n\tpub use crate::nums::TrySub;\n\tpub use crate::nums::TrySubAssign;\n\tpub use crate::parser::*;\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","puzzle.rs"],"content":"use std::fs::File;\nuse std::io;\nuse std::io::BufRead as _;\nuse std::io::BufReader;\nuse std::io::Write as _;\nuse std::path::PathBuf;\nuse std::time::Instant;\n\nuse super::*;\nuse nums::IntConv;\n\npub struct RunStats {\n\tnum_correct: usize,\n\tnum_incorrect: usize,\n\tnum_unknown: usize,\n}\n\n#[ allow (clippy::missing_inline_in_public_items) ]\npub fn run_year_and_exit (\n\tpuzzles: \u0026 [Box \u003cdyn Puzzle\u003e],\n\trequire_answers: bool,\n) -\u003e GenResult \u003c()\u003e {\n\tlet stats = run_year (puzzles) ?;\n\tlet num_errors =\n\t\tif require_answers { stats.num_incorrect + stats.num_unknown }\n\t\telse { stats.num_incorrect };\n\t#[ allow (clippy::exit) ]\n\tstd::process::exit (i32::from (num_errors != 0));\n}\n\n#[ allow (clippy::missing_inline_in_public_items) ]\n#[ allow (clippy::print_stdout) ]\npub fn run_year (puzzles: \u0026 [Box \u003cdyn Puzzle\u003e]) -\u003e GenResult \u003cRunStats\u003e {\n\n\tlet flush = || io::stdout ().flush ().unwrap ();\n\n\tlet mut stats = RunStats {\n\t\tnum_correct: 0,\n\t\tnum_incorrect: 0,\n\t\tnum_unknown: 0,\n\t};\n\n\t// work out max name length\n\n\tlet name_len =\n\t\tpuzzles.iter ()\n\t\t\t.map (|puzzle| puzzle.name ().len ())\n\t\t\t.max ()\n\t\t\t.unwrap ();\n\n\t// load answers\n\n\tlet answers_path = PathBuf::from (\n\t\tformat! (\"{}/inputs/answers\", puzzles [0].year ()));\n\n\tlet answers: HashMap \u003c(u8, u8), String\u003e =\n\t\tif answers_path.exists () {\n\t\t\tBufReader::new (File::open (answers_path) ?)\n\t\t\t\t.lines ()\n\t\t\t\t.map (move |line| {\n\t\t\t\t\tlet line = line ?;\n\t\t\t\t\tlet line_parts: Vec \u003cString\u003e =\n\t\t\t\t\t\tline.split (' ')\n\t\t\t\t\t\t\t.map (str::to_string)\n\t\t\t\t\t\t\t.collect ();\n\t\t\t\t\tlet day: u8 = line_parts [0].parse::\u003cu8\u003e () ?;\n\t\t\t\t\tOk (\n\t\t\t\t\t\tline_parts.into_iter ()\n\t\t\t\t\t\t\t.skip (1)\n\t\t\t\t\t\t\t.enumerate ()\n\t\t\t\t\t\t\t.map (move |(idx, val)|\n\t\t\t\t\t\t\t\t((day, idx.pan_u8 ()), val))\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.flatten_ok ()\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?\n\t\t} else { HashMap::new () };\n\n\tlet answer_lens =\n\t\tanswers.iter ()\n\t\t\t.fold ([0, 0], |[mut part_0, mut part_1], (\u0026 (_day, part), answer)| {\n\t\t\t\tif part == 0 { part_0 = cmp::max (part_0, answer.len ()); }\n\t\t\t\tif part == 1 { part_1 = cmp::max (part_1, answer.len ()); }\n\t\t\t\t[part_0, part_1]\n\t\t\t});\n\n\t// iterate puzzles\n\n\tfor puzzle in puzzles.iter () {\n\n\t\t// load input\n\n\t\tlet input_string = puzzle.load_input () ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e =\n\t\t\tinput_string.trim_end ().split ('\\n').collect ();\n\n\t\t// print day and puzzle name\n\n\t\tprint! (\n\t\t\t\"{day:02} {name:len$}\",\n\t\t\tday = puzzle.day (),\n\t\t\tname = puzzle.name (),\n\t\t\tlen = name_len + 2);\n\n\t\t// start timer\n\n\t\tlet start_time = time::Instant::now ();\n\n\t\t// iterate over parts\n\n\t\tlet mut errors = Vec::new ();\n\t\tfor (part_idx, part_name) in [ \"One\", \"Two\" ].into_iter ().enumerate () {\n\n\t\t\t// handle missing part\n\n\t\t\tif puzzle.num_parts () \u003c part_idx + 1 {\n\t\t\t\tprint! (\"{:len$} \", \"\", len = answer_lens [part_idx] + 6);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// print part name\n\n\t\t\tprint! (\"{}: \", part_name);\n\n\t\t\t// calculate result\n\n\t\t\tflush ();\n\n\t\t\tlet result =\n\t\t\t\tif part_idx == 0 { puzzle.part_one (\u0026 input_lines) ? }\n\t\t\t\telse { puzzle.part_two (\u0026 input_lines) ? };\n\n\t\t\t// check against answers\n\n\t\t\tif let Some (answer) = answers.get (\u0026 (puzzle.day (), part_idx.pan_u8 ())) {\n\t\t\t\tif \u0026 result == answer {\n\t\t\t\t\tstats.num_correct += 1;\n\t\t\t\t} else if \u0026 result != answer {\n\t\t\t\t\tstats.num_incorrect += 1;\n\t\t\t\t\terrors.push (format! (\n\t\t\t\t\t\t\"Part {part}: Expected {answer:?}, but calculated {result:?}\",\n\t\t\t\t\t\tpart = part_idx + 1,\n\t\t\t\t\t\tanswer = answer,\n\t\t\t\t\t\tresult = result));\n\t\t\t\t} else {\n\t\t\t\t\t// no answer\n\t\t\t\t}\n\t\t\t} else { stats.num_unknown += 1; }\n\n\t\t\t// print result\n\n\t\t\tprint! (\"{result:len$} \", len = answer_lens [part_idx] + 1);\n\n\t\t}\n\n\t\t// print duration\n\n\t\tlet end_time = time::Instant::now ();\n\t\tlet duration = end_time - start_time;\n\n\t\tprint! (\n\t\t\t\"Time: {millis:\u003e4}.{micros:02}ms\\n\",\n\t\t\tmillis = duration.as_millis (),\n\t\t\tmicros = (duration.as_micros () % 1000) / 10);\n\n\t\t// print errors\n\n\t\tfor error in errors {\n\t\t\tprint! (\"  {}\\n\", error);\n\t\t}\n\n\t}\n\n\tOk (stats)\n\n}\n\n#[ allow (clippy::print_stdout) ]\nfn puzzle_invoke_real (\n\tpuzzle: \u0026 dyn Puzzle,\n\targs: \u0026 [OsString],\n) -\u003e GenResult \u003c()\u003e {\n\n\tlet input_path_default = puzzle.find_input_or_default ();\n\n\tlet mut command =\n\t\tclap::Command::new (format! (\"aoc-{}-day-{}\", puzzle.year (), puzzle.day ()))\n\t\t\t.arg (\n\t\t\t\tclap::Arg::new (\"input\")\n\t\t\t\t\t.long (\"input\")\n\t\t\t\t\t.value_parser (clap::value_parser! (PathBuf))\n\t\t\t\t\t.takes_value (true)\n\t\t\t\t\t.default_value_os (input_path_default.as_os_str ())\n\t\t\t\t\t.help (\"Input file to use\")\n\t\t\t\t\t.global (true));\n\n\tfor part_num in 1 ..= puzzle.num_parts () {\n\n\t\tcommand = command.subcommand (\n\t\t\tclap::Command::new (format! (\"part-{}\", part_num))\n\t\t\t\t.arg (\n\t\t\t\t\tclap::Arg::new (\"repeat\")\n\t\t\t\t\t\t.long (\"repeat\")\n\t\t\t\t\t\t.value_parser (clap::value_parser! (u64).range (1 .. ))\n\t\t\t\t\t\t.takes_value (true)\n\t\t\t\t\t\t.default_value (\"1\")\n\t\t\t\t\t\t.help (\"Number of times to repeat the calculation\"))\n\t\t);\n\n\t}\n\n\tfor puzzle_command in puzzle.commands () {\n\t\tcommand = command.subcommand (\n\t\t\tpuzzle_command.command ()\n\t\t\t\t.name (puzzle_command.name ())\n\t\t);\n\t}\n\n\tlet matches = command.get_matches_from (args);\n\tlet input_path = matches.get_one::\u003cPathBuf\u003e (\"input\").unwrap ();\n\tlet input_string = fs::read_to_string (input_path) ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim_end ().split ('\\n').collect ();\n\n\tmatch matches.subcommand () {\n\t\tNone =\u003e {\n\t\t\tlet result = puzzle.part_one (\u0026 input_lines) ?;\n\t\t\tprintln! (\"Part one: {}\", result);\n\t\t\tif puzzle.num_parts () \u003e= 2 {\n\t\t\t\tlet result = puzzle.part_two (\u0026 input_lines) ?;\n\t\t\t\tprintln! (\"Part two: {}\", result);\n\t\t\t}\n\t\t},\n\t\tSome ((\"part-1\", matches)) =\u003e {\n\t\t\tlet repeat: u64 = * matches.get_one (\"repeat\").unwrap ();\n\t\t\trunner (repeat, |idx| {\n\t\t\t\tlet result = puzzle.part_one (\u0026 input_lines) ?;\n\t\t\t\tif idx == 0 { println! (\"Result: {}\", result); }\n\t\t\t\tOk (())\n\t\t\t}) ?;\n\t\t},\n\t\tSome ((\"part-2\", matches)) =\u003e {\n\t\t\tlet repeat: u64 = * matches.get_one (\"repeat\").unwrap ();\n\t\t\trunner (repeat, |idx| {\n\t\t\t\tlet result = puzzle.part_two (\u0026 input_lines) ?;\n\t\t\t\tif idx == 0 { println! (\"Result: {}\", result); }\n\t\t\t\tOk (())\n\t\t\t}) ?;\n\t\t},\n\t\tSome ((name, matches)) =\u003e {\n\t\t\tfor puzzle_command in puzzle.commands () {\n\t\t\t\tif puzzle_command.name () == name {\n\t\t\t\t\treturn puzzle_command.invoke (matches);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunreachable! ();\n\t\t},\n\t}\n\tOk (())\n}\n\nfn percentile (times: \u0026 [u64], num: u64, denom: u64) -\u003e u64 {\n\tlet size = times.len ().pan_u64 () - 1;\n\tlet idx: u64 = num * size / denom;\n\tlet rem = num * size % denom;\n\tif rem == 0 { return times [idx.pan_usize ()] }\n\ttimes [idx.pan_usize ()] * (denom - rem) / denom\n\t\t+ times [idx.pan_usize () + 1] * rem / denom\n}\n\n#[ allow (clippy::print_stdout) ]\nfn runner (\n\trepeat: u64,\n\tmut inner_fn: impl FnMut (u64) -\u003e GenResult \u003c()\u003e,\n) -\u003e GenResult \u003c()\u003e {\n\tlet times = {\n\t\tlet mut times: Vec \u003c_\u003e = (0 .. repeat)\n\t\t\t.map (|idx| { inner_fn (idx) ?; Ok (Instant::now ()) })\n\t\t\t.scan (Instant::now (), |state, cur|\n\t\t\t\tSome (cur.map (|cur| cur - mem::replace (state, cur))))\n\t\t\t.map_ok (|duration| duration.as_micros ().pan_u64 ())\n\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\ttimes.sort_unstable ();\n\t\ttimes\n\t};\n\tif repeat == 1 { return Ok (()) }\n\tlet total = times.iter ().map (|\u0026 val| val.pan_u128 ()).sum::\u003cu128\u003e ();\n\tlet mean = (total / repeat.pan_u128 ()).pan_u64 ();\n\tlet disp_float = |val, ref_val|\n\t\tif ref_val \u003e= 2_000_000_f64 { format! (\"{:.3}s\", val / 1_000_000_f64) }\n\t\telse if ref_val \u003e= 2_000_f64 { format! (\"{:.3}ms\", val / 1_000_f64) }\n\t\telse { format! (\"{:.0}s\", val) };\n\tlet disp = |val: u128| disp_float (val.pan_f64 (), val.pan_f64 ());\n\tlet disp_mean = |val: u64| disp_float (val.pan_f64 (), mean.pan_f64 ());\n\tlet disp_pc = |pc| disp_float (percentile (\u0026 times, pc, 1000).pan_f64 (), mean.pan_f64 ());\n\tprint! (\"Statistics: total={} count={} mean={},\", disp (total), repeat, disp_mean (mean));\n\tconst PERCENTILE_OPTIONS: \u0026 [(u64, \u0026 [u64])] = \u0026 [\n\t\t(1000, \u0026 [0, 500, 900, 990, 999, 1000]),\n\t\t(100, \u0026 [0, 500, 900, 990, 1000]),\n\t\t(25, \u0026 [0, 500, 750, 900, 1000]),\n\t\t(10, \u0026 [0, 500, 900, 1000]),\n\t\t(0, \u0026 []),\n\t];\n\tfor (min_repeat, percentiles) in PERCENTILE_OPTIONS.iter ().copied () {\n\t\tif repeat \u003c min_repeat * 2 { continue }\n\t\tfor percentile in percentiles.iter ().copied () {\n\t\t\tif percentile % 10 == 0 {\n\t\t\t\tprint! (\" p{}={}\", percentile / 10, disp_pc (percentile));\n\t\t\t} else {\n\t\t\t\tprint! (\" p{}={}\", percentile.pan_f64 () / 10.0_f64, disp_pc (percentile));\n\t\t\t}\n\t\t}\n\t\tif percentiles.is_empty () {\n\t\t\tprint! (\" min={} median={} max={}\", disp_pc (0), disp_pc (500), disp_pc (1000));\n\t\t}\n\t\tbreak;\n\t}\n\tprint! (\"\\n\");\n\tOk (())\n}\n\n#[ allow (clippy::missing_inline_in_public_items) ]\npub trait Puzzle {\n\n\tfn dyn_puzzle (\u0026 self) -\u003e \u0026 dyn Puzzle;\n\n\tfn name (\u0026 self) -\u003e \u0026 'static str;\n\tfn year (\u0026 self) -\u003e u16;\n\tfn day (\u0026 self) -\u003e u8;\n\n\t#[ inline ]\n\tfn part_one (\u0026 self, _lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e { unimplemented! () }\n\n\t#[ inline ]\n\tfn part_two (\u0026 self, _lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e { unimplemented! () }\n\n\tfn num_parts (\u0026 self) -\u003e usize;\n\n\t#[ inline ]\n\tfn commands (\u0026 self) -\u003e Vec \u003cPuzzleCommand\u003e {\n\t\tVec::new ()\n\t}\n\n\t#[ inline ]\n\tfn set_default_params (\u0026 mut self) { }\n\n\tfn set_param_real (\u0026 mut self, name: String, value: String);\n\n\t#[ inline ]\n\tfn set_param (\u0026 mut self, name: \u0026 str, value: String) {\n\t\tself.set_param_real (name.to_owned (), value);\n\t}\n\n\t#[ inline ]\n\tfn invoke (\u0026 self, args: \u0026 [OsString]) -\u003e GenResult \u003c()\u003e {\n\t\tpuzzle_invoke_real (self.dyn_puzzle (), args)\n\t}\n\n\tfn find_input_or_default (\u0026 self) -\u003e PathBuf {\n\t\tself.find_input ()\n\t\t\t.unwrap_or_else (|_| format! (\n\t\t\t\t\"{:04}/inputs/day-{:02}\", self.year (), self.day ()).into ())\n\t}\n\n\tfn find_input (\u0026 self) -\u003e GenResult \u003cPathBuf\u003e {\n\t\tOk (\n\t\t\t[\n\t\t\t\tformat! (\"{:04}/inputs/day-{:02}\", self.year (), self.day ()),\n\t\t\t\tformat! (\"inputs/day-{:02}\", self.day ()),\n\t\t\t\tformat! (\"../inputs/day-{:02}\", self.day ()),\n\t\t\t].into_iter ()\n\t\t\t\t.find (|path| Path::new (path).exists ())\n\t\t\t\t.ok_or_else (|| format! (\n\t\t\t\t\t\"Unable to find inputs/day-{:02} in \\\"{:04}\\\", \\\".\\\" or \\\"..\\\"\",\n\t\t\t\t\tself.day (),\n\t\t\t\t\tself.year ())) ?\n\t\t\t\t.into ()\n\t\t)\n\t}\n\n\tfn load_input (\u0026 self) -\u003e GenResult \u003cString\u003e {\n\t\tlet input_path = [\n\t\t\tformat! (\"{:04}/inputs/day-{:02}\", self.year (), self.day ()),\n\t\t\tformat! (\"inputs/day-{:02}\", self.day ()),\n\t\t\tformat! (\"../inputs/day-{:02}\", self.day ()),\n\t\t].into_iter ()\n\t\t\t.find (|path| Path::new (path).exists ())\n\t\t\t.ok_or_else (|| format! (\n\t\t\t\t\"Unable to find inputs/day-{:02} in \\\"{:04}\\\", \\\".\\\" or \\\"..\\\"\",\n\t\t\t\tself.day (),\n\t\t\t\tself.year ())) ?;\n\t\tlet input_string = fs::read_to_string (input_path) ?;\n\t\tOk (input_string)\n\t}\n\n}\n\npub struct PuzzleCommand {\n\tname: \u0026 'static str,\n\tinvoke_fn: Box \u003cdyn Fn (\u0026 ArgMatches) -\u003e GenResult \u003c()\u003e\u003e,\n\tmagic: Box \u003cdyn MagicTrait\u003e,\n}\n\ntrait MagicTrait {\n\tfn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e;\n}\n\nstruct MagicStruct \u003cArgs\u003e {\n\tphantom: PhantomData \u003cArgs\u003e,\n}\n\nimpl \u003cArgs: clap::CommandFactory\u003e MagicTrait for MagicStruct \u003cArgs\u003e {\n\tfn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e { Args::command () }\n}\n\nimpl PuzzleCommand {\n\n\t#[ inline ]\n\tpub fn new \u003c\n\t\tArgs: clap::Parser + 'static,\n\t\tInvokeFn: Fn (Args) -\u003e GenResult \u003c()\u003e + 'static,\n\t\u003e (\n\t\tname: \u0026 'static str,\n\t\tinvoke_fn: InvokeFn,\n\t) -\u003e Self {\n\n\t\tlet invoke_fn = Box::new (\n\t\t\tmove |matches: \u0026 _| invoke_fn (Args::from_arg_matches (matches).unwrap ()),\n\t\t);\n\n\t\tlet magic: Box \u003cMagicStruct \u003cArgs\u003e\u003e = Box::new (MagicStruct {\n\t\t\tphantom: PhantomData,\n\t\t});\n\n\t\tSelf { name, invoke_fn, magic }\n\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub const fn name (\u0026 self) -\u003e \u0026 str {\n\t\tself.name\n\t}\n\n\t#[ inline ]\n\t#[ must_use ]\n\tpub fn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e {\n\t\tself.magic.command ()\n\t}\n\n\t#[ inline ]\n\tpub fn invoke (\u0026 self, args: \u0026 ArgMatches) -\u003e GenResult \u003c()\u003e {\n\t\t(self.invoke_fn) (args)\n\t}\n\n}\n\n#[ macro_export ]\nmacro_rules! puzzle_info {\n\n\t(\n\t\tname = $name:literal ;\n\t\tyear = $year:literal ;\n\t\tday = $day:literal ;\n\t\t$($rest4:tt)*\n\t) =\u003e {\n\t\tpub fn puzzle_metadata () -\u003e Box \u003cdyn ::aoc_common::puzzle::Puzzle\u003e {\n\t\t\tuse ::aoc_common::puzzle::Puzzle;\n\t\t\tstruct ThisPuzzle { params: HashMap \u003cString, String\u003e }\n\t\t\timpl Puzzle for ThisPuzzle {\n\t\t\t\tfn dyn_puzzle (\u0026 self) -\u003e \u0026 dyn Puzzle { self }\n\t\t\t\tfn name (\u0026 self) -\u003e \u0026 'static str { $name }\n\t\t\t\tfn year (\u0026 self) -\u003e u16 { $year }\n\t\t\t\tfn day (\u0026 self) -\u003e u8 { $day }\n\t\t\t\tfn set_param_real (\u0026 mut self, name: String, value: String) {\n\t\t\t\t\tself.params.insert (name, value);\n\t\t\t\t}\n\t\t\t\tpuzzle_info! { @rest (input, Ok::\u003c_, Infallible\u003e (input), 0) $($rest4)* }\n\t\t\t}\n\t\t\tlet mut puzzle = ThisPuzzle { params: HashMap::new () };\n\t\t\tpuzzle.set_default_params ();\n\t\t\tBox::new (puzzle)\n\t\t}\n\t};\n\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr) ) =\u003e {\n\t\tfn num_parts (\u0026 self) -\u003e usize { $num_parts }\n\t};\n\t( @rest ($parse_input_old:ident, $parse_expr_old:expr, $num_parts:expr)\n\t\tparse = |$parse_input:ident| $parse_expr:expr;\n\t\t$($rest1:tt)*\n\t) =\u003e {\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest1)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tpart_one = |$part_input:ident $(, $param_name:ident : $param_type:ty)*| $part_expr:expr;\n\t\t$($rest0:tt)*\n\t) =\u003e {\n\t\tfn part_one (\u0026 self, $parse_input: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\t\t$(\n\t\t\t\tlet $param_name: $param_type =\n\t\t\t\t\tself.params [stringify! ($param_name)].parse ().unwrap ();\n\t\t\t)*\n\t\t\tlet $part_input = $parse_expr ?;\n\t\t\tlet result = $part_expr ?;\n\t\t\tOk (format! (\"{}\", result))\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts + 1) $($rest0)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tpart_two = |$part_input:ident $(, $param_name:ident : $param_type:ty)*| $part_expr:expr;\n\t\t$($rest0:tt)*\n\t) =\u003e {\n\t\tfn part_two (\u0026 self, $parse_input: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\t\t$(\n\t\t\t\tlet $param_name: $param_type =\n\t\t\t\t\tself.params [stringify! ($param_name)].parse ().unwrap ();\n\t\t\t)*\n\t\t\tlet $part_input = $parse_expr ?;\n\t\t\tlet result = $part_expr ?;\n\t\t\tOk (format! (\"{}\", result))\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts + 1) $($rest0)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tcommands = [ $($commands:tt)* ];\n\t\t$($rest3:tt)*\n\t) =\u003e {\n\t\tfn commands (\u0026 self) -\u003e Vec \u003c::aoc_common::puzzle::PuzzleCommand\u003e {\n\t\t\tlet mut commands = Vec::new ();\n\t\t\tpuzzle_info! { @commands commands $($commands)* }\n\t\t\tcommands\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest3)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tparams = [ $($params:tt)* ];\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tfn set_default_params (\u0026 mut self) {\n\t\t\tpuzzle_info! { @params self $($params)* }\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest)* }\n\t};\n\n\t( @params ) =\u003e {};\n\t( @params $self:ident $name:ident : $type:ty = $val:expr ; $($rest:tt)* ) =\u003e {\n\t\t$self.set_param_real (stringify! ($name).to_owned (), format! (\"{}\", $val as $type));\n\t\tpuzzle_info! { @params $($rest)* }\n\t};\n\n\t( @commands $commands:ident ) =\u003e {};\n\t( @commands $commands:ident (\n\t\tname = $name:literal ;\n\t\tmethod = $method:expr ;\n\t) ) =\u003e {\n\t\t$commands.push (::aoc_common::puzzle::PuzzleCommand::new ($name, $method));\n\t};\n\t( @commands $commands:ident (\n\t\tname = $name:literal ;\n\t\tmethod = $method:expr ;\n\t) , $($rest:tt)* ) =\u003e {\n\t\t$commands.push (::aoc_common::puzzle::PuzzleCommand::new ($name, $method));\n\t\tpuzzle_info! { @commands $commands $($rest)* }\n\t};\n\n}\n","traces":[{"line":179,"address":[140734,135904],"length":1,"stats":{"Line":0},"fn_name":"puzzle_invoke_real"},{"line":184,"address":[135947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[136699,135958,136150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[136261,136586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[140103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[140163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[140272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[136713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[136857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[136871,136979,137364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[137179,137323,137054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[137155,140622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[140644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[137644,140502,137450,137530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[137724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[137944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[138077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[138163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[138223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[138287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[138516,139616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[138629,138718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[138729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[138751,139634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[138953,138864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[138301,138330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[138343,138376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[147632,147871],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":236,"address":[147825,147646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[147804,147729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[139016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[139029,139062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[147888,148127],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":244,"address":[147902,148081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[147985,148060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[139205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[139296,139236,140252,139445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[139519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[140752],"length":1,"stats":{"Line":0},"fn_name":"percentile"},{"line":262,"address":[140833,141130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[140843,141149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[140864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[140933,141296,141102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[140945,141075,141192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[141039,141233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[152357,148144,150245,150256],"length":1,"stats":{"Line":0},"fn_name":"runner\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#0}\u003e"},{"line":276,"address":[148239,150351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[152415,152368,152495,152372,152448,152452],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#0}\u003e"},{"line":278,"address":[152528,148172,152608,150284],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#0}\u003e"},{"line":279,"address":[152612,152700,152643,152659,152688,152732,152563,152720,152579,152532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[152848,152752],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#1}\u003e"},{"line":283,"address":[150433,148321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[148349,150461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[146464,146672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[148567,150679,150528,150594,148482,148416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[153072,153344],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#0}\u003e"},{"line":289,"address":[153430,153086,153358,153158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[153475,153368,153203,153096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[153383,153111,153335,153607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[150867,148755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[148846,148921,150958,151033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[148575,153657,153881,153860,153746,153840,150687,153794,153616,153970,154018,153636],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}\u003caoc_common::puzzle::puzzle_invoke_real::{closure_env#1}\u003e"},{"line":295,"address":[151043,152253,151146,150191,150880,148931,148768,150141,149034,152303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[149137,151249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[151275,149163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[149273,151385,149185,151297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[149285,151397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[149520,150172,149279,149644,152284,151632,151756,151391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[151481,150209,149369,149498,151610,152321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[149665,151777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[152199,149884,150087,149687,151799,151996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[149985,152097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[38129,38128],"length":1,"stats":{"Line":0},"fn_name":"part_two\u003caoc_2016_day_25::puzzle_metadata::ThisPuzzle\u003e"},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[48096],"length":1,"stats":{"Line":0},"fn_name":"set_default_params\u003caoc_2017_day_18::puzzle_metadata::ThisPuzzle\u003e"},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[47925,47952,48069,47808],"length":1,"stats":{"Line":0},"fn_name":"command\u003caoc_2015_day_04::cli::FindTestCaseArgs\u003e"},{"line":418,"address":[36448,36512],"length":1,"stats":{"Line":0},"fn_name":"new\u003caoc_2015_day_04::cli::RunArgs, fn(aoc_2015_day_04::cli::RunArgs) -\u003e core::result::Result\u003c(), alloc::boxed::Box\u003cdyn core::error::Error, alloc::alloc::Global\u003e\u003e\u003e"},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[26592],"length":1,"stats":{"Line":231},"fn_name":"puzzle_metadata"},{"line":470,"address":[26864,26867],"length":1,"stats":{"Line":0},"fn_name":"dyn_puzzle"},{"line":471,"address":[26880],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":472,"address":[26896],"length":1,"stats":{"Line":0},"fn_name":"year"},{"line":473,"address":[26912],"length":1,"stats":{"Line":0},"fn_name":"day"},{"line":474,"address":[26928],"length":1,"stats":{"Line":0},"fn_name":"set_param_real"},{"line":475,"address":[26993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[195395,196035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[26678],"length":1,"stats":{"Line":236},"fn_name":null},{"line":486,"address":[27648],"length":1,"stats":{"Line":0},"fn_name":"num_parts"},{"line":498,"address":[27008,27315],"length":1,"stats":{"Line":138},"fn_name":"part_one"},{"line":503,"address":[27137,27053],"length":1,"stats":{"Line":138},"fn_name":null},{"line":504,"address":[27095,27155],"length":1,"stats":{"Line":249},"fn_name":null},{"line":505,"address":[27170,27253],"length":1,"stats":{"Line":276},"fn_name":null},{"line":513,"address":[27633,27328],"length":1,"stats":{"Line":128},"fn_name":"part_two"},{"line":518,"address":[27373,27457],"length":1,"stats":{"Line":128},"fn_name":null},{"line":519,"address":[27475,27415],"length":1,"stats":{"Line":229},"fn_name":null},{"line":520,"address":[27571,27488],"length":1,"stats":{"Line":252},"fn_name":null},{"line":528,"address":[180469,180128],"length":1,"stats":{"Line":0},"fn_name":"commands"}],"covered":11,"coverable":138},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_01::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_02::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_03::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_04::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_zeros_one = cmp::min (input.params.num_zeros_one, 2);\n\t\tinput.params.num_zeros_two = cmp::min (input.params.num_zeros_two, 3);\n\t\tinput.params.max_threads = 1;\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_05::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_06::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_07::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_08::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_09::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_10::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_iters_one = cmp::min (input.params.num_iters_one, 15);\n\t\tinput.params.num_iters_two = cmp::min (input.params.num_iters_two, 20);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_11::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_12::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_13::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_13::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_15::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tif input.ingrs.len () \u003c= 4 {\n\t\t\tlet _ = logic::part_one (\u0026 input);\n\t\t\tlet _ = logic::part_two (\u0026 input);\n\t\t}\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_16::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_17::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_18::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_19::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_20::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tif input.target \u003c= 1_000_000 {\n\t\t\tlet _ = logic::part_one (\u0026 input);\n\t\t\tlet _ = logic::part_two (\u0026 input);\n\t\t}\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_21::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_22::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_23::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_24::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2015-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2015::day_25::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_01::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_02::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_03::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_04::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_05::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_zeros = cmp::min (input.params.num_zeros, 1);\n\t\tinput.params.max_threads = cmp::min (input.params.max_threads, 2);\n\t\tinput.params.password_len = cmp::min (input.params.password_len, 4);\n\t\tinput.params.batch_size = cmp::min (input.params.batch_size, 100);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_06::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_07::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_08::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.width = 10;\n\t\tinput.params.height = 6;\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_09::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_10::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_11::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_12::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.ops_limit = cmp::min (input.params.ops_limit, 100_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_13::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_dist = cmp::min (input.params.max_dist, 200);\n\t\tinput.params.count_dist = cmp::min (input.params.max_dist, 100);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_14::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_keys = cmp::min (input.params.num_keys, 2);\n\t\tinput.params.hash_reps = cmp::min (input.params.hash_reps, 2);\n\t\tinput.params.max_threads = cmp::min (input.params.max_threads, 1);\n\t\tinput.params.batch_size = cmp::min (input.params.batch_size, 100);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_15::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_16::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.disk_size_one = cmp::min (input.params.disk_size_one, 1_000_000);\n\t\tinput.params.disk_size_two = cmp::min (input.params.disk_size_two, 1_000_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_17::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_18::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_rows_one = cmp::min (input.params.num_rows_one, 1_000);\n\t\tinput.params.num_rows_two = cmp::min (input.params.num_rows_two, 1_000_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_19::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet mut input_two = input;\n\t\tinput_two.num_elves = cmp::min (input_two.num_elves, 1_000_000);\n\t\tlet _ = logic::part_two (\u0026 input_two);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_20::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_21::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_22::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_23::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_24::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2016-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2016::day_25::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_01::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_02::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_03::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_04::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_05::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_06::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_mutator;\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::fuzzer_mutate;\nuse rand::prelude::*;\n\nuse aoc_2017::day_07::*;\nuse aoc_common::*;\nuse input::Input;\nuse input::InputParams;\n\nconst PROB_CUSTOM_FIRST: f64 = 0.7;\nconst PROB_BUILTIN_AFTER: f64 = 0.3;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\nfuzz_mutator! (|data: \u0026 mut [u8], size: usize, max_size: usize, seed: u32| {\n\tlet mut rng = StdRng::seed_from_u64 (seed as u64);\n\tlet mut size = size;\n\tlet mut num_mutations = 0;\n\tif rng.gen_bool (PROB_CUSTOM_FIRST) {\n\t\tif let Some (new_size) = mutator::main (data, size, max_size, \u0026 mut rng) {\n\t\t\tnum_mutations += 1;\n\t\t\tsize = new_size;\n\t\t}\n\t}\n\twhile num_mutations == 0 || rng.gen_bool (PROB_BUILTIN_AFTER) {\n\t\tsize = fuzzer_mutate (data, size, max_size);\n\t\tnum_mutations += 1;\n\t}\n\tsize\n});\n\nmod mutator {\n\n\tuse super::*;\n\tuse input::Prog;\n\tuse model::ProgInfo;\n\n\tpub fn main (\n\t\tdata: \u0026 mut [u8],\n\t\tsize: usize,\n\t\tmax_size: usize,\n\t\trng: \u0026 mut StdRng,\n\t) -\u003e Option \u003cusize\u003e {\n\n\t\tlet output_str = {\n\n\t\t\tlet input_str = str::from_utf8 (\u0026 data [ .. size]).ok () ?;\n\t\t\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\t\t\tlet input = Input::parse_from_lines (\u0026 input_vec).ok () ?;\n\n\t\t\tlet output_dat = if rng.gen_bool (0.3) {\n\t\t\t\tlet mut output_dat = input;\n\t\t\t\tmutate_input (\u0026 mut output_dat, rng);\n\t\t\t\toutput_dat\n\t\t\t} else {\n\t\t\t\tlet mut root = ProgInfo::build (\u0026 input).ok () ?;\n\t\t\t\tmutate_model (\u0026 mut root, rng);\n\t\t\t\tlet mut output_dat = Input { progs: Vec::new (), params: InputParams::default () };\n\t\t\t\troot.write_input (\u0026 mut output_dat.progs);\n\t\t\t\toutput_dat.progs.shuffle (rng);\n\t\t\t\toutput_dat\n\t\t\t};\n\n\t\t\toutput_dat.to_string ()\n\n\t\t};\n\n\t\tif max_size \u003c output_str.len () { return None }\n\t\t(\u0026 mut data [0 .. output_str.len ()]).copy_from_slice (output_str.as_bytes ());\n\t\tSome (output_str.len ())\n\n\t}\n\n\tfn fix_weights (prog: \u0026 mut ProgInfo, rng: \u0026 mut StdRng, target: u32) -\u003e bool {\n\t\tif ! prog.holds.is_empty () {\n\t\t\tlet child_target = prog.holds.choose (rng).unwrap ().total_weight;\n\t\t\tprog.holds_weight = 0;\n\t\t\tfor held in prog.holds.iter_mut () {\n\t\t\t\tif ! fix_weights (held, rng, child_target) { return false }\n\t\t\t\tprog.holds_weight += child_target;\n\t\t\t}\n\t\t\tif target \u003c= prog.holds_weight { return false }\n\t\t\tprog.prog_weight = target - prog.holds_weight;\n\t\t} else {\n\t\t\tprog.prog_weight = target;\n\t\t}\n\t\ttrue\n\t}\n\n\tfn visit (\n\t\tprog: \u0026 mut ProgInfo,\n\t\trng: \u0026 mut StdRng,\n\t\tmut_fn: fn (\u0026 mut ProgInfo, \u0026 mut StdRng),\n\t) {\n\t\tfn recurse (\n\t\t\tprog: \u0026 mut ProgInfo,\n\t\t\tcur_idx: \u0026 mut u32,\n\t\t\tmod_idx: u32,\n\t\t\trng: \u0026 mut StdRng,\n\t\t\tmut_fn: fn (\u0026 mut ProgInfo, \u0026 mut StdRng),\n\t\t) {\n\t\t\tif * cur_idx == mod_idx { mut_fn (prog, rng); }\n\t\t\t* cur_idx += 1;\n\t\t\tprog.holds_weight = 0;\n\t\t\tfor held in prog.holds.iter_mut () {\n\t\t\t\trecurse (held, cur_idx, mod_idx, rng, mut_fn);\n\t\t\t\tprog.holds_weight += held.total_weight;\n\t\t\t}\n\t\t\tprog.total_weight = prog.prog_weight + prog.holds_weight;\n\t\t}\n\t\tlet mod_idx = rng.gen_range (0 .. prog.nested_len ().pan_u32 ());\n\t\trecurse (prog, \u0026 mut 0, mod_idx, rng, mut_fn);\n\t}\n\n\tfn mutate_model (root: \u0026 mut ProgInfo, rng: \u0026 mut StdRng) {\n\t\tmatch rng.gen_range (0 .. 5) {\n\n\t\t\t// change the name of a random programme\n\n\t\t\t0 =\u003e visit (root, rng, |prog, rng| {\n\t\t\t\tprog.name = crate::InpStr::alloc (make_name (rng));\n\t\t\t}),\n\n\t\t\t// remove a random programme and all the programmes it holds\n\n\t\t\t1 =\u003e visit (root, rng, |prog, rng| {\n\t\t\t\tif prog.holds.is_empty () { return }\n\t\t\t\tprog.holds.remove (rng.gen_range (0 .. prog.holds.len ()));\n\t\t\t}),\n\n\t\t\t// replace a random programme with one of its children\n\n\t\t\t2 =\u003e visit (root, rng, |prog, rng| {\n\t\t\t\tif prog.holds.is_empty () { return }\n\t\t\t\tlet mut child = prog.holds.remove (rng.gen_range (0 .. prog.holds.len ()));\n\t\t\t\tmem::swap (prog, \u0026 mut child);\n\t\t\t}),\n\n\t\t\t// insert a new programme in a random location\n\n\t\t\t3 =\u003e visit (root, rng, |prog, rng| {\n\t\t\t\tif prog.holds.len () == 7 { return }\n\t\t\t\tprog.holds.insert (rng.gen_range (0 ..= prog.holds.len ()), ProgInfo {\n\t\t\t\t\tname: InpStr::alloc (make_name (rng)),\n\t\t\t\t\tholds: default (),\n\t\t\t\t\tprog_weight: rng.gen_range (1_u32 .. 999),\n\t\t\t\t\tholds_weight: 0,\n\t\t\t\t\ttotal_weight: 0,\n\t\t\t\t});\n\t\t\t}),\n\n\t\t\t// try and balance all programme weights, then change one randomly\n\n\t\t\t4 =\u003e {\n\t\t\t\tfor total_weight in (root.total_weight .. ).take (100) {\n\t\t\t\t\tif fix_weights (root, rng, total_weight) { break }\n\t\t\t\t}\n\t\t\t\tvisit (root, rng, |prog, rng| {\n\t\t\t\t\tprog.prog_weight = rng.gen_range (1_u32 .. 100);\n\t\t\t\t});\n\t\t\t},\n\n\t\t\t_ =\u003e unreachable! (),\n\n\t\t}\n\t}\n\n\tfn mutate_input (input: \u0026 mut Input, rng: \u0026 mut StdRng) {\n\t\tmatch rng.gen_range (0 .. 2) {\n\n\t\t\t// remove a random prog\n\n\t\t\t0 =\u003e {\n\t\t\t\tif input.progs.is_empty () { return }\n\t\t\t\tlet idx = rng.gen_range (0 .. input.progs.len ());\n\t\t\t\tinput.progs.remove (idx);\n\t\t\t},\n\n\t\t\t// insert a random prog\n\n\t\t\t1 =\u003e {\n\t\t\t\tlet idx = rng.gen_range (0 ..= input.progs.len ());\n\t\t\t\tinput.progs.insert (idx, make_input_prog (rng));\n\t\t\t},\n\n\t\t\t_ =\u003e unreachable! (),\n\n\t\t}\n\t}\n\n\tfn make_input_prog \u003c'inp\u003e (rng: \u0026 mut StdRng) -\u003e Prog \u003c'inp\u003e {\n\t\tlet num_holds = rng.gen_range (0 ..= 7);\n\t\tlet holds =\n\t\t\titer::from_fn (|| Some (InpStr::alloc (\u0026 make_name (rng))))\n\t\t\t\t.take (num_holds)\n\t\t\t\t.collect ();\n\t\tProg {\n\t\t\tname: InpStr::alloc (\u0026 make_name (rng)),\n\t\t\tweight: rng.gen_range (1 .. 100),\n\t\t\tholds,\n\t\t}\n\t}\n\n\tfn make_name (rng: \u0026 mut StdRng) -\u003e String {\n\t\tstatic NAME_LENGTHS: \u0026 [u8] = \u0026 [\n\t\t\t1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,\n\t\t\t3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 7, 8, 9,\n\t\t];\n\t\tlet name_len = NAME_LENGTHS.choose (rng).unwrap ().pan_usize ();\n\t\titer::from_fn (|| Some (rng.gen_range ('a' ..= 'z')))\n\t\t\t.take (name_len)\n\t\t\t.collect::\u003cString\u003e ()\n\t}\n\n}\n","traces":[{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_08::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2017::day_09::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_10::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.rounds_one = cmp::min (input.params.rounds_one, 2);\n\t\tinput.params.rounds_two = cmp::min (input.params.rounds_two, 4);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_11::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_mutator;\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::fuzzer_mutate;\nuse rand::prelude::*;\n\nuse aoc_common::*;\nuse aoc_2017::day_12::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\nfuzz_mutator! (|data: \u0026 mut [u8], size: usize, max_size: usize, seed: u32| {\n\tlet mut rng = StdRng::seed_from_u64 (seed as u64);\n\tlet mut size = size;\n\tlet mut num_mutations = 0;\n\tif rng.gen_bool (0.7) {\n\t\tif let Some (new_size) = mutator::main (data, size, max_size, \u0026 mut rng) {\n\t\t\tsize = new_size;\n\t\t\tnum_mutations += 1;\n\t\t}\n\t}\n\twhile num_mutations == 0 || rng.gen_bool (0.1) {\n\t\tsize = fuzzer_mutate (data, size, max_size);\n\t\tnum_mutations += 1;\n\t}\n\tsize\n});\n\nmod mutator {\n\n\tuse super::*;\n\tuse input::InputPipe;\n\tuse model::Village;\n\n\tpub fn main (\n\t\tdata: \u0026 mut [u8],\n\t\tsize: usize,\n\t\tmax_size: usize,\n\t\trng: \u0026 mut StdRng,\n\t) -\u003e Option \u003cusize\u003e {\n\n\t\t// parse input\n\n\t\tlet input_str = str::from_utf8 (\u0026 data [0 .. size]).ok () ?;\n\t\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\t\tlet mut input = Input::parse_from_lines (\u0026 input_vec).ok () ?;\n\n\t\t// apply a random transform\n\n\t\ttransforms::random (\u0026 mut input, rng);\n\n\t\t// convert to string, removing random lines until it is the right length\n\n\t\tlet output_str = loop {\n\t\t\tlet output_str = input.to_string ();\n\t\t\tif output_str.as_bytes ().len () \u003c= max_size { break output_str }\n\t\t\ttransforms::remove (\u0026 mut input, rng);\n\t\t};\n\n\t\t// update data, and return\n\n\t\t(\u0026 mut data [ .. output_str.len ()]).copy_from_slice (output_str.as_bytes ());\n\n\t\tSome (output_str.len ())\n\n\t}\n\n\tmod transforms {\n\n\t\tuse super::*;\n\t\tuse std::iter;\n\n\t\tconst TRANSFORMS: \u0026 [(u32, u32, fn (\u0026 mut Input, \u0026 mut StdRng) -\u003e Option \u003c()\u003e)] = \u0026 [\n\t\t\t(1000, 1, add),\n\t\t\t(100, 10, add),\n\t\t\t(10, 100, add),\n\t\t\t(1000, 1, remove),\n\t\t\t(100, 10, remove),\n\t\t\t(10, 100, remove),\n\t\t\t(400, 10, merge),\n\t\t\t(40, 1, merge),\n\t\t\t(400, 10, split),\n\t\t\t(40, 1, split),\n\t\t\t(5, 1, sort),\n\t\t\t(5, 1, shuffle),\n\t\t\t(3, 1, sequentialise),\n\t\t\t(2, 1, randomise),\n\t\t];\n\n\t\tpub fn random (input: \u0026 mut Input, rng: \u0026 mut StdRng) {\n\t\t\tlet \u0026 (_, reps, ref trans_fn) =\n\t\t\t\tTRANSFORMS.choose_weighted (rng, |\u0026 (weight, _, _)| weight).unwrap ();\n\t\t\tlet mut num_failure = 0;\n\t\t\tfor _ in 0 .. reps {\n\t\t\t\tloop {\n\t\t\t\t\tlet success = trans_fn (input, rng).is_some ();\n\t\t\t\t\tif success { break }\n\t\t\t\t\tnum_failure += 1;\n\t\t\t\t\tif num_failure \u003e= 10 { break }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpub fn add (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet left = rng.gen_range (0 ..= 199);\n\t\t\tlet right_len = rng.gen_range (0 ..= 8);\n\t\t\tlet right =\n\t\t\t\titer::from_fn (|| Some (rng.gen_range (0 ..= 199)))\n\t\t\t\t\t.take (right_len)\n\t\t\t\t\t.collect ();\n\t\t\tlet new_idx = rng.gen_range (0 ..= input.pipes.len ());\n\t\t\tinput.pipes.insert (new_idx, InputPipe { left, right });\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn remove (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tif input.pipes.is_empty () { return Some (()) }\n\t\t\tlet idx = rng.gen_range (0 .. input.pipes.len ());\n\t\t\tinput.pipes.remove (idx);\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn sort (input: \u0026 mut Input, _rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.pipes.sort_by_key (|pipe| pipe.left);\n\t\t\tfor pipe in input.pipes.iter_mut () { pipe.right.sort (); }\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn shuffle (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.pipes.shuffle (rng);\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn merge (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet pipe_0 = \u0026 input.pipes.choose (rng) ?;\n\t\t\tlet pipe_1 = \u0026 input.pipes.choose (rng) ?;\n\t\t\tlet mut villages: Vec \u003cVillage\u003e =\n\t\t\t\t[ pipe_0.left, pipe_1.left ].iter ().copied ()\n\t\t\t\t\t.chain (pipe_0.right.iter ().copied ())\n\t\t\t\t\t.chain (pipe_1.right.iter ().copied ())\n\t\t\t\t\t.sorted ()\n\t\t\t\t\t.dedup ()\n\t\t\t\t\t.collect ();\n\t\t\tif ! (2 ..= 9).contains (\u0026 villages.len ()) { return None }\n\t\t\tlet left_idx = rng.gen_range (0 .. villages.len ());\n\t\t\tlet left = villages.remove (left_idx);\n\t\t\tvillages.shuffle (rng);\n\t\t\tlet right = villages.into_iter ().collect ();\n\t\t\tlet new_idx = rng.gen_range (0 .. input.pipes.len ());\n\t\t\tinput.pipes.insert (new_idx, InputPipe { left, right });\n\t\t\tSome (())\n\t\t}\n\n\t\tfn split (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet pipe = \u0026 input.pipes.choose (rng) ?;\n\t\t\tlet mut villages_0: Vec \u003cVillage\u003e =\n\t\t\t\titer::once (pipe.left)\n\t\t\t\t\t.chain (pipe.right.iter ().copied ())\n\t\t\t\t\t.sorted ()\n\t\t\t\t\t.dedup ()\n\t\t\t\t\t.collect ();\n\t\t\tif villages_0.len () \u003c 2 { return None }\n\t\t\tlet split_idx = rng.gen_range (1 ..= villages_0.len () - 1);\n\t\t\tlet villages_1 = villages_0.split_off (split_idx);\n\t\t\tfor mut villages in vec! [ villages_0, villages_1 ].into_iter () {\n\t\t\t\tlet left_idx = rng.gen_range (0 .. villages.len ());\n\t\t\t\tlet left = villages.remove (left_idx);\n\t\t\t\tif villages.is_empty () { villages = vec! [ left ]; }\n\t\t\t\tlet right = villages.into_iter ().collect ();\n\t\t\t\tlet new_idx = rng.gen_range (0 ..= input.pipes.len ());\n\t\t\t\tinput.pipes.insert (new_idx, InputPipe { left, right });\n\t\t\t}\n\t\t\tSome (())\n\t\t}\n\n\t\tfn sequentialise (input: \u0026 mut Input, _rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet mut next = Village::ZERO;\n\t\t\tlet mut map: HashMap \u003cVillage, Village\u003e = HashMap::new ();\n\t\t\tlet mut apply = |village: \u0026 mut Village| {\n\t\t\t\t* village = * map.entry (* village).or_insert_with (|| {\n\t\t\t\t\tlet val = next;\n\t\t\t\t\tnext += 1;\n\t\t\t\t\tval\n\t\t\t\t});\n\t\t\t};\n\t\t\tfor pipe in input.pipes.iter_mut () {\n\t\t\t\tapply (\u0026 mut pipe.left);\n\t\t\t}\n\t\t\tfor pipe in input.pipes.iter_mut () {\n\t\t\t\tpipe.right.iter_mut ().for_each (\u0026 mut apply);\n\t\t\t}\n\t\t\tSome (())\n\t\t}\n\n\t\tfn randomise (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet mut map: HashMap \u003cVillage, Village\u003e = HashMap::new ();\n\t\t\tlet mut assigned: HashSet \u003cVillage\u003e = HashSet::new ();\n\t\t\tlet mut apply = |village: \u0026 mut Village, rng: \u0026 mut StdRng| {\n\t\t\t\t* village = * map.entry (* village).or_insert_with (|| {\n\t\t\t\t\tloop {\n\t\t\t\t\t\tlet next = rng.gen_range (0 ..= 9999);\n\t\t\t\t\t\tif assigned.insert (next) { return next }\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tfor pipe in input.pipes.iter_mut () {\n\t\t\t\tapply (\u0026 mut pipe.left, rng);\n\t\t\t}\n\t\t\tfor pipe in input.pipes.iter_mut () {\n\t\t\t\tpipe.right.iter_mut ().for_each (|village| apply (village, rng));\n\t\t\t}\n\t\t\tSome (())\n\t\t}\n\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_13::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_14::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_rounds = cmp::min (input.params.num_rounds, 4);\n\t\tinput.params.num_rows = cmp::min (input.params.num_rows, 4);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_15::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.reps_one = cmp::min (input.params.reps_one, 4_000_000);\n\t\tinput.params.reps_two = cmp::min (input.params.reps_two, 500_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_16::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_17::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_18::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_19::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_20::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_21::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_22::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.iters_one = cmp::min (input.params.iters_one, 1_000);\n\t\tinput.params.iters_two = cmp::min (input.params.iters_two, 10_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_23::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2017::day_24::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2017-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_mutator;\nuse libfuzzer_sys::fuzz_target;\nuse libfuzzer_sys::fuzzer_mutate;\nuse rand::prelude::*;\n\nuse aoc_common::*;\nuse aoc_2017::day_25::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.num_steps = cmp::min (input.num_steps, 1_000_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n\nfuzz_mutator! (|data: \u0026 mut [u8], size: usize, max_size: usize, seed: u32| {\n\tlet mut rng = StdRng::seed_from_u64 (seed as u64);\n\tlet mut size = size;\n\tlet mut num_mutations = 0;\n\tif rng.gen_bool (0.7) {\n\t\tif let Some (new_size) = mutator::main (data, size, max_size, \u0026 mut rng) {\n\t\t\tsize = new_size;\n\t\t\tnum_mutations += 1;\n\t\t}\n\t}\n\twhile num_mutations == 0 || rng.gen_bool (0.1) {\n\t\tsize = fuzzer_mutate (data, size, max_size);\n\t\tnum_mutations += 1;\n\t}\n\tsize\n});\n\nmod mutator {\n\n\tuse super::*;\n\n\tuse input::Dir;\n\tuse input::Slot;\n\tuse input::State;\n\n\tpub fn main (\n\t\tdata: \u0026 mut [u8],\n\t\tsize: usize,\n\t\tmax_size: usize,\n\t\trng: \u0026 mut StdRng,\n\t) -\u003e Option \u003cusize\u003e {\n\n\t\t// parse input\n\n\t\tlet input_str = str::from_utf8 (\u0026 data [0 .. size]).ok () ?;\n\t\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\t\tlet mut input = Input::parse_from_lines (\u0026 input_vec).ok () ?;\n\n\t\t// apply a random transform\n\n\t\ttransforms::random (\u0026 mut input, rng);\n\n\t\t// convert to string, removing random lines until it is the right length\n\n\t\tlet output_str = loop {\n\t\t\tlet output_str = input.to_string ();\n\t\t\tif output_str.as_bytes ().len () \u003c= max_size { break output_str }\n\t\t\ttransforms::remove (\u0026 mut input, rng);\n\t\t};\n\n\t\t// update data, and return\n\n\t\t(\u0026 mut data [ .. output_str.len ()]).copy_from_slice (output_str.as_bytes ());\n\n\t\tSome (output_str.len ())\n\n\t}\n\n\tmod transforms {\n\n\t\tuse super::*;\n\n\t\tconst TRANSFORMS: \u0026 [(u32, u32, fn (\u0026 mut Input, \u0026 mut StdRng) -\u003e Option \u003c()\u003e)] = \u0026 [\n\t\t\t(100, 1, modify),\n\t\t\t(10, 3, modify),\n\t\t\t(100, 1, add),\n\t\t\t(10, 3, add),\n\t\t\t(100, 1, remove),\n\t\t\t(10, 3, remove),\n\t\t\t(1, 1, begin_state),\n\t\t\t(1, 1, num_steps),\n\t\t\t(1, 1, sort),\n\t\t\t(1, 1, shuffle),\n\t\t];\n\n\t\tpub fn random (input: \u0026 mut Input, rng: \u0026 mut StdRng) {\n\t\t\tlet \u0026 (_, reps, ref trans_fn) =\n\t\t\t\tTRANSFORMS.choose_weighted (rng, |\u0026 (weight, _, _)| weight).unwrap ();\n\t\t\tlet mut num_failure = 0;\n\t\t\tfor _ in 0 .. reps {\n\t\t\t\tloop {\n\t\t\t\t\tlet success = trans_fn (input, rng).is_some ();\n\t\t\t\t\tif success { break }\n\t\t\t\t\tnum_failure += 1;\n\t\t\t\t\tif num_failure \u003e= 10 { break }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfn begin_state (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.begin_state = rng.gen_range ('A' ..= 'Z');\n\t\t\tSome (())\n\t\t}\n\n\t\tfn num_steps (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.num_steps = rng.gen_range (1 ..= 10_000_000);\n\t\t\tSome (())\n\t\t}\n\n\t\tfn modify (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet idx = rng.gen_range (0 .. input.states.len ());\n\t\t\tlet state = \u0026 mut input.states [idx];\n\t\t\tmatch rng.gen_range (0 .. 7) {\n\t\t\t\t0 =\u003e state.id = make_id (rng),\n\t\t\t\t1 =\u003e state.false_write = make_slot (rng),\n\t\t\t\t2 =\u003e state.false_dir = make_dir (rng),\n\t\t\t\t3 =\u003e state.false_state = make_id (rng),\n\t\t\t\t4 =\u003e state.true_write = make_slot (rng),\n\t\t\t\t5 =\u003e state.true_dir = make_dir (rng),\n\t\t\t\t6 =\u003e state.true_state = make_id (rng),\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t\tSome (())\n\t\t}\n\n\t\tfn add (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tlet id = make_id (rng);\n\t\t\tlet false_write = make_slot (rng);\n\t\t\tlet false_dir = make_dir (rng);\n\t\t\tlet false_state = make_id (rng);\n\t\t\tlet true_write = make_slot (rng);\n\t\t\tlet true_dir = make_dir (rng);\n\t\t\tlet true_state = make_id (rng);\n\t\t\tlet new_idx = rng.gen_range (0 ..= input.states.len ());\n\t\t\tinput.states.insert (new_idx, State {\n\t\t\t\tid,\n\t\t\t\tfalse_write, false_dir, false_state,\n\t\t\t\ttrue_write, true_dir, true_state,\n\t\t\t});\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn remove (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tif input.states.is_empty () { return Some (()) }\n\t\t\tlet idx = rng.gen_range (0 .. input.states.len ());\n\t\t\tinput.states.remove (idx);\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn sort (input: \u0026 mut Input, _rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.states.sort_by_key (|state| state.id);\n\t\t\tSome (())\n\t\t}\n\n\t\tpub fn shuffle (input: \u0026 mut Input, rng: \u0026 mut StdRng) -\u003e Option \u003c()\u003e {\n\t\t\tinput.states.shuffle (rng);\n\t\t\tSome (())\n\t\t}\n\n\t\tfn make_id (rng: \u0026 mut StdRng) -\u003e char {\n\t\t\trng.gen_range ('A' ..= 'Z')\n\t\t}\n\n\t\tfn make_dir (rng: \u0026 mut StdRng) -\u003e Dir {\n\t\t\t[ Dir::Left, Dir::Right ].choose (rng).copied ().unwrap ()\n\t\t}\n\n\t\tfn make_slot (rng: \u0026 mut StdRng) -\u003e Slot {\n\t\t\t[ Slot::Zero, Slot::One ].choose (rng).copied ().unwrap ()\n\t\t}\n\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_01::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-02.rs"],"content":"#![ no_main ]\n\nuse aoc_fuzz::aoc_fuzz_mutator;\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_02::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input \u003c'inp\u003e;\n\n\ttransform modify (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet idx = rng.gen_range (0 .. input.box_ids.len ());\n\t\tlet box_id = \u0026 mut input.box_ids [idx];\n\t\tif box_id.is_empty () { return Some (()) }\n\t\tlet char_idx = rng.gen_range (0 .. box_id.chars ().count ());\n\t\tlet new_char = rng.gen_range ('a' ..= 'z');\n\t\tinput.box_ids [idx] = InpStr::alloc (\n\t\t\t\u0026 box_id.chars ().enumerate ()\n\t\t\t\t.map (|(idx, ch)| if idx == char_idx { new_char } else { ch })\n\t\t\t\t.collect::\u003cString\u003e ());\n\t}\n\n\ttransform add (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet len = input.box_ids.first ()\n\t\t\t.map (|box_id| box_id.chars ().count ())\n\t\t\t.unwrap_or (16);\n\t\tlet box_id = InpStr::alloc (\n\t\t\t\u0026 iter::from_fn (|| Some (rng.gen_range ('a' ..= 'z')))\n\t\t\t\t.take (len)\n\t\t\t\t.collect::\u003cString\u003e ());\n\t\tlet new_idx = rng.gen_range (0 ..= input.box_ids.len ());\n\t\tinput.box_ids.insert (new_idx, box_id);\n\t}\n\n\tpub transform remove (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tif input.box_ids.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.box_ids.len ());\n\t\tinput.box_ids.remove (idx);\n\t}\n\n\ttransform add_char (10) = |input, rng| {\n\t\tlet len = input.box_ids.first ()\n\t\t\t.map (|box_id| box_id.chars ().count ())\n\t\t\t.unwrap_or (16);\n\t\tlet char_idx = rng.gen_range (0 ..= len);\n\t\tlet new_char = rng.gen_range ('a' ..= 'z');\n\t\tfor box_id in input.box_ids.iter_mut () {\n\t\t\t* box_id = InpStr::alloc (\n\t\t\t\t\u0026 iter::empty ()\n\t\t\t\t\t.chain (box_id.chars ().take (char_idx))\n\t\t\t\t\t.chain (iter::once (new_char))\n\t\t\t\t\t.chain (box_id.chars ().skip (char_idx))\n\t\t\t\t\t.collect::\u003cString\u003e ());\n\t\t}\n\t}\n\n\ttransform remove_char (10) = |input, rng| {\n\t\tlet len = input.box_ids.first ()\n\t\t\t.map (|box_id| box_id.chars ().count ())\n\t\t\t.unwrap_or (16);\n\t\tlet char_idx = rng.gen_range (0 ..= len);\n\t\tfor box_id in input.box_ids.iter_mut () {\n\t\t\t* box_id = InpStr::alloc (\n\t\t\t\t\u0026 box_id.chars ().enumerate ()\n\t\t\t\t\t.filter (|\u0026 (idx, _)| idx != char_idx)\n\t\t\t\t\t.map (|(_, ch)| ch)\n\t\t\t\t\t.collect::\u003cString\u003e ());\n\t\t}\n\t}\n\n\ttransform truncate (1) = |input, rng| {\n\t\tlet max_len = input.box_ids.iter ()\n\t\t\t.map (|box_id| box_id.chars ().count ())\n\t\t\t.max ()\n\t\t\t.unwrap_or (0);\n\t\tlet len = rng.gen_range (0 ..= max_len);\n\t\tfor box_id in input.box_ids.iter_mut () {\n\t\t\tif box_id.chars ().count () \u003c= len { continue }\n\t\t\t* box_id = InpStr::alloc (\u0026 box_id.chars ().take (len).collect::\u003cString\u003e ());\n\t\t}\n\t}\n\n\ttransform sort (1) = |input, _rng| {\n\t\tinput.box_ids.sort ();\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tinput.box_ids.shuffle (rng);\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_03::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_04::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_05::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_06::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_07::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_08::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_09::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.num_players = cmp::min (input.num_players, 1000);\n\t\tinput.last_marble = cmp::min (input.last_marble, 10_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_10::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_11::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.grid_size = cmp::min (input.params.grid_size, 30);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_12::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_13::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_14::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_recipes = cmp::min (input.params.max_recipes, 100_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_grid::prelude::*;\n\nuse aoc_2018::day_15::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tif input.grid.size ().y \u003c= 40 \u0026\u0026 input.grid.size ().x \u003c= 40 {\n\t\t\tlet _ = logic::part_one (\u0026 input);\n\t\t\tlet _ = logic::part_two (\u0026 input);\n\t\t}\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-16.rs"],"content":"#![ no_main ]\n\nuse aoc_fuzz::aoc_fuzz_mutator;\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2018::day_16::*;\nuse input::Input;\nuse model::Instr;\nuse model::Regs;\nuse model::Sample;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\tpub transform remove (1) = |input, rng| {\n\t\tmatch rng.gen_range (0 .. 2) {\n\t\t\t0 =\u003e remove_sample (input, rng),\n\t\t\t1 =\u003e remove_instr (input, rng),\n\t\t\t_ =\u003e unreachable! (),\n\t\t};\n\t}\n\n\ttransform modify_sample (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet idx = rng.gen_range (0 .. input.samples.len ());\n\t\tlet sample = \u0026 mut input.samples [idx];\n\t\tmatch rng.gen_range (0 .. 12) {\n\t\t\t0 =\u003e sample.before.set (0, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t1 =\u003e sample.before.set (1, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t2 =\u003e sample.before.set (2, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t3 =\u003e sample.before.set (3, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t4 =\u003e sample.instr.op = rng.gen_range (0 .. 16),\n\t\t\t5 =\u003e sample.instr.op = rng.gen_range (0 .. 32),\n\t\t\t6 =\u003e sample.instr.op = rng.gen_range (0 .. 32),\n\t\t\t7 =\u003e sample.instr.op = rng.gen_range (0 .. 32),\n\t\t\t8 =\u003e sample.after.set (0, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t9 =\u003e sample.after.set (1, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t10 =\u003e sample.after.set (2, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t11 =\u003e sample.after.set (3, rng.gen_range (0 .. 32)).unwrap (),\n\t\t\t_ =\u003e unreachable! (),\n\t\t}\n\t}\n\n\ttransform add_sample (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet sample = Sample {\n\t\t\tbefore: Regs::new (array::from_fn (|_| rng.gen_range (0 .. 32))),\n\t\t\tinstr: Instr {\n\t\t\t\top: rng.gen_range (0 .. 16),\n\t\t\t\targ_a: rng.gen_range (0 .. 32),\n\t\t\t\targ_b: rng.gen_range (0 .. 32),\n\t\t\t\targ_c: rng.gen_range (0 .. 32),\n\t\t\t},\n\t\t\tafter: Regs::new (array::from_fn (|_| rng.gen_range (0 .. 32))),\n\t\t};\n\t\tlet new_idx = rng.gen_range (0 ..= input.samples.len ());\n\t\tinput.samples.insert (new_idx, sample);\n\t}\n\n\tpub transform remove_sample (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tif input.samples.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.samples.len ());\n\t\tinput.samples.remove (idx);\n\t}\n\n\ttransform sort_samples (1) = |input, _rng| {\n\t\tinput.samples.sort ();\n\t}\n\n\ttransform sort_instrs (1) = |input, _rng| {\n\t\tinput.instrs.sort ();\n\t}\n\n\ttransform modify_instr (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet idx = rng.gen_range (0 .. input.instrs.len ());\n\t\tlet instr = \u0026 mut input.instrs [idx];\n\t\tmatch rng.gen_range (0 .. 4) {\n\t\t\t0 =\u003e instr.op = rng.gen_range (0 .. 16),\n\t\t\t1 =\u003e instr.op = rng.gen_range (0 .. 32),\n\t\t\t2 =\u003e instr.op = rng.gen_range (0 .. 32),\n\t\t\t3 =\u003e instr.op = rng.gen_range (0 .. 32),\n\t\t\t_ =\u003e unreachable! (),\n\t\t}\n\t}\n\n\ttransform add_instr (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tlet instr = Instr {\n\t\t\top: rng.gen_range (0 .. 16),\n\t\t\targ_a: rng.gen_range (0 .. 32),\n\t\t\targ_b: rng.gen_range (0 .. 32),\n\t\t\targ_c: rng.gen_range (0 .. 32),\n\t\t};\n\t\tlet new_idx = rng.gen_range (0 ..= input.instrs.len ());\n\t\tinput.instrs.insert (new_idx, instr);\n\t}\n\n\tpub transform remove_instr (100 * 1, 10 * 10, 1 * 100) = |input, rng| {\n\t\tif input.instrs.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.instrs.len ());\n\t\tinput.instrs.remove (idx);\n\t}\n\n\ttransform shuffle_samples (1) = |input, rng| {\n\t\tinput.samples.shuffle (rng);\n\t}\n\n\ttransform shuffle_instrs (1) = |input, rng| {\n\t\tinput.instrs.shuffle (rng);\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_17::*;\nuse aoc_common::*;\nuse aoc_fuzz::*;\n\nuse input::Input;\nuse model::ClayRange;\nuse model::Coord;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\nconst Y_START: Coord = 1;\nconst Y_END: Coord = 200;\nconst Y_LEN: Coord = 8;\nconst X_START: Coord = 451;\nconst X_END: Coord = 549;\nconst X_LEN: Coord = 20;\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\ttransform add (1000 * 1, 200 * 10, 40 * 100) = |input, rng| {\n\t\tlet clay_range = match rng.gen_range (0 .. 2) {\n\t\t\t0 =\u003e {\n\t\t\t\tlet x = rng.gen_range (X_START ..= X_END);\n\t\t\t\tlet y_start = rng.gen_range (Y_START ..= Y_END - Y_LEN + 1);\n\t\t\t\tlet y_end = rng.gen_range (y_start + 1 ..= Y_END);\n\t\t\t\tClayRange::Vert { x, y_start, y_end }\n\t\t\t},\n\t\t\t1 =\u003e {\n\t\t\t\tlet y = rng.gen_range (Y_START ..= Y_END);\n\t\t\t\tlet x_start = rng.gen_range (X_START ..= X_END - X_LEN + 1);\n\t\t\t\tlet x_end = rng.gen_range (x_start + 1 ..= X_END);\n\t\t\t\tClayRange::Horiz { y, x_start, x_end }\n\t\t\t},\n\t\t\t_ =\u003e unreachable! (),\n\t\t};\n\t\tlet new_idx = rng.gen_range (0 ..= input.clay_ranges.len ());\n\t\tinput.clay_ranges.insert (new_idx, clay_range);\n\t}\n\n\tpub transform remove (1000 * 1, 200 * 10, 40 * 100) = |input, rng| {\n\t\tif input.clay_ranges.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.clay_ranges.len ());\n\t\tinput.clay_ranges.remove (idx);\n\t}\n\n\tpub transform squish (100 * 10, 10 * 100) = |input, rng| {\n\t\tif input.clay_ranges.is_empty () { return Some (()) }\n\t\tlet y_max = input.clay_ranges.iter ().copied ()\n\t\t\t.map (|range| * range.y ().end ())\n\t\t\t.max ()\n\t\t\t.unwrap ();\n\t\tif y_max \u003c 1 { return Some (()) }\n\t\tlet cut_y = rng.gen_range (1 ..= y_max);\n\t\tinput.clay_ranges = input.clay_ranges.iter ().copied ()\n\t\t\t.filter_map (|range| match range {\n\t\t\t\tClayRange::Horiz { y, x_start, x_end } =\u003e\n\t\t\t\t\tmatch Ord::cmp (\u0026 y, \u0026 cut_y) {\n\t\t\t\t\t\tOrdering::Less =\u003e Some (range),\n\t\t\t\t\t\tOrdering::Equal =\u003e None,\n\t\t\t\t\t\tOrdering::Greater =\u003e Some (ClayRange::Horiz { y: y - 1, x_start, x_end }),\n\t\t\t\t\t},\n\t\t\t\tClayRange::Vert { x, y_start, y_end } =\u003e\n\t\t\t\t\t(cut_y != y_start \u0026\u0026 cut_y != y_end).then_some (ClayRange::Vert {\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty_start: if cut_y \u003c y_start { y_start - 1 } else { y_start },\n\t\t\t\t\t\ty_end: if cut_y \u003c= y_start { y_start - 1 } else { y_start },\n\t\t\t\t\t}),\n\t\t\t})\n\t\t\t.collect ();\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tinput.clay_ranges.shuffle (rng);\n\t}\n\n\ttransform sort (1) = |input, _rng| {\n\t\tinput.clay_ranges.sort ();\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_18::*;\nuse aoc_common::*;\n\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_19::*;\nuse aoc_common::*;\n\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_20::*;\nuse aoc_common::*;\n\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_21::*;\nuse aoc_common::*;\nuse aoc_fuzz::*;\n\nuse input::Input;\nuse model::Instr;\nuse model::Opcode;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_instrs = cmp::min (input.params.max_instrs, 1_000_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\ttransform add (1000 * 1, 10 * 10) = |input, rng| {\n\t\tlet instr = Instr {\n\t\t\topcode: Opcode::VARIANTS.choose (rng).copied ().unwrap (),\n\t\t\targ_a: rng.gen_range (0 .. 99),\n\t\t\targ_b: rng.gen_range (0 .. 99),\n\t\t\targ_c: rng.gen_range (0 .. 99),\n\t\t};\n\t\tlet mut instrs = input.instrs.to_vec ();\n\t\tlet idx = rng.gen_range (0 ..= instrs.len ());\n\t\tinstrs.insert (idx, instr);\n\t\tinput.instrs = Rc::from (instrs);\n\t}\n\n\ttransform modify (1000 * 1, 10 * 10) = |input, rng| {\n\t\tif input.instrs.is_empty () { return Some (()) }\n\t\tlet mut instrs = input.instrs.to_vec ();\n\t\tlet idx = rng.gen_range (0 .. instrs.len ());\n\t\tlet instr = \u0026 mut instrs [idx];\n\t\tmatch rng.gen_range (0 .. 4) {\n\t\t\t0 =\u003e instr.opcode = Opcode::VARIANTS.choose (rng).copied ().unwrap (),\n\t\t\t1 =\u003e instr.arg_a = rng.gen_range (0 ..= 99),\n\t\t\t2 =\u003e instr.arg_b = rng.gen_range (0 ..= 99),\n\t\t\t3 =\u003e instr.arg_c = rng.gen_range (0 ..= 99),\n\t\t\t_ =\u003e unreachable! (),\n\t\t}\n\t\tinput.instrs = Rc::from (instrs);\n\t}\n\n\tpub transform remove (1000 * 1, 10 * 5) = |input, rng| {\n\t\tif input.instrs.is_empty () { return Some (()) }\n\t\tlet mut instrs = input.instrs.to_vec ();\n\t\tlet idx = rng.gen_range (0 .. instrs.len ());\n\t\tinstrs.remove (idx);\n\t\tinput.instrs = Rc::from (instrs);\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tlet mut instrs = input.instrs.to_vec ();\n\t\tinstrs.shuffle (rng);\n\t\tinput.instrs = Rc::from (instrs);\n\t}\n\n\ttransform sort (1) = |input, _rng| {\n\t\tlet mut instrs = input.instrs.to_vec ();\n\t\tinstrs.sort ();\n\t\tinput.instrs = Rc::from (instrs);\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_22::*;\nuse aoc_common::*;\n\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_target = cmp::min (input.params.max_target, 50);\n\t\tinput.params.max_mins = cmp::min (input.params.max_mins, 100);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_23::*;\nuse aoc_common::*;\nuse aoc_fuzz::*;\n\nuse input::Input;\nuse model::Coord;\nuse model::Nanobot;\nuse model::Pos;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_iters = cmp::min (input.params.max_iters, 3000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\ttransform add (1000 * 1, 200 * 10, 40 * 100) = |input, rng| {\n\t\tlet nanobot = Nanobot {\n\t\t\tpos: Pos {\n\t\t\t\tx: rng.gen_range (Coord::MIN ..= Coord::MAX),\n\t\t\t\ty: rng.gen_range (Coord::MIN ..= Coord::MAX),\n\t\t\t\tz: rng.gen_range (Coord::MIN ..= Coord::MAX),\n\t\t\t},\n\t\t\tradius: rng.gen_range (0 ..= Coord::MAX),\n\t\t};\n\t\tlet idx = rng.gen_range (0 ..= input.nanobots.len ());\n\t\tinput.nanobots.insert (idx, nanobot);\n\t}\n\n\tpub transform remove (1000 * 1, 200 * 10, 40 * 100) = |input, rng| {\n\t\tif input.nanobots.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.nanobots.len ());\n\t\tinput.nanobots.remove (idx);\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tinput.nanobots.shuffle (rng);\n\t}\n\n\ttransform sort (1) = |input, _rng| {\n\t\tinput.nanobots.sort ();\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_24::*;\nuse aoc_common::*;\nuse aoc_fuzz::*;\n\nuse input::Input;\nuse model::AttackType;\nuse model::Group;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_rounds.bounds_assign ( ..= 800);\n\t\tinput.params.max_boost.bounds_assign ( ..= 40);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\ttransform add (1000) = |input, rng| {\n\t\tlet mut group = Group {\n\t\t\tnum_units: rng.gen_range (1 ..= 9999),\n\t\t\thit_points: rng.gen_range (1 ..= 9999),\n\t\t\tweaknesses: Vec::new (),\n\t\t\timmunities: Vec::new (),\n\t\t\tattack_damage: rng.gen_range (1 ..= 999),\n\t\t\tattack_type: AttackType::VARIANTS.choose (rng).copied ().unwrap (),\n\t\t\tinitiative: rng.gen_range (1 ..= 99),\n\t\t};\n\t\tfor attack_type in AttackType::VARIANTS {\n\t\t\tif ! rng.gen_bool (0.5) { continue }\n\t\t\tlet target = pick_one! (rng, \u0026 mut group.weaknesses, \u0026 mut group.immunities);\n\t\t\tif ! target.contains (\u0026 attack_type) { target.push (attack_type); }\n\t\t}\n\t\tlet groups = pick_one! (rng, \u0026 mut input.immune_system, \u0026 mut input.infection);\n\t\tlet idx = rng.gen_range (0 ..= groups.len ());\n\t\tgroups.insert (idx, group);\n\t}\n\n\ttransform modify (1000) = |input, rng| {\n\t\tlet groups = pick_one! (rng, \u0026 mut input.immune_system, \u0026 mut input.infection);\n\t\tif groups.is_empty () { return Some (()) }\n\t\tlet group_idx = rng.gen_range (0 .. groups.len ());\n\t\tlet group = \u0026 mut groups [group_idx];\n\t\tloop {\n\t\t\tpick_one! (\n\t\t\t\trng, { // change num units\n\t\t\t\t\tgroup.num_units = rng.gen_range (1 ..= 9999);\n\t\t\t\t}, { // change hit points\n\t\t\t\t\tgroup.hit_points = rng.gen_range (1 ..= 9999);\n\t\t\t\t}, { // remove weakness\n\t\t\t\t\tif group.weaknesses.is_empty () { continue }\n\t\t\t\t\tlet weak_idx = rng.gen_range (0 .. group.weaknesses.len ());\n\t\t\t\t\tgroup.weaknesses.remove (weak_idx);\n\t\t\t\t}, { // add weakness\n\t\t\t\t\tlet attack_type = AttackType::VARIANTS.choose (rng).copied ().unwrap ();\n\t\t\t\t\tif group.weaknesses.contains (\u0026 attack_type) { continue }\n\t\t\t\t\tgroup.weaknesses.push (attack_type);\n\t\t\t\t}, { // remove immunity\n\t\t\t\t\tif group.immunities.is_empty () { continue }\n\t\t\t\t\tlet weak_idx = rng.gen_range (0 .. group.immunities.len ());\n\t\t\t\t\tgroup.immunities.remove (weak_idx);\n\t\t\t\t}, { // add immunity\n\t\t\t\t\tlet attack_type = AttackType::VARIANTS.choose (rng).copied ().unwrap ();\n\t\t\t\t\tif group.immunities.contains (\u0026 attack_type) { continue }\n\t\t\t\t\tgroup.immunities.push (attack_type);\n\t\t\t\t}, { // change damage\n\t\t\t\t\tgroup.attack_damage = rng.gen_range (1 ..= 999);\n\t\t\t\t}, { // change attack type\n\t\t\t\t\tgroup.attack_type = AttackType::VARIANTS.choose (rng).copied ().unwrap ();\n\t\t\t\t}, { // change initiative\n\t\t\t\t\tgroup.initiative = rng.gen_range (1 ..= 99);\n\t\t\t\t},\n\t\t\t);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpub transform remove (1000) = |input, rng| {\n\t\tlet groups =\n\t\t\tif rng.gen_bool (0.5) { \u0026 mut input.immune_system }\n\t\t\telse { \u0026 mut input.infection };\n\t\tif groups.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. groups.len ());\n\t\tgroups.remove (idx);\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tlet groups =\n\t\t\tif rng.gen_bool (0.5) { \u0026 mut input.immune_system }\n\t\t\telse { \u0026 mut input.infection };\n\t\tgroups.shuffle (rng);\n\t}\n\n\ttransform sort (1) = |input, rng| {\n\t\tlet groups =\n\t\t\tif rng.gen_bool (0.5) { \u0026 mut input.immune_system }\n\t\t\telse { \u0026 mut input.infection };\n\t\tgroups.sort ();\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2018-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2018::day_25::*;\nuse aoc_common::*;\n\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_01::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_02::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_ops = cmp::min (input.params.max_ops, 100);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_03::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_04::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_05::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_06::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_07::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_ops_one = cmp::min (input.params.max_ops_one, 50);\n\t\tinput.params.max_ops_two = cmp::min (input.params.max_ops_two, 50);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_08::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_09::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_10::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_11::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_12::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_steps_one = cmp::min (input.params.num_steps_one, 1_000);\n\t\tinput.params.num_steps_two = cmp::min (input.params.num_steps_two, 500_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_common::*;\nuse aoc_2019::day_13::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\nuse rand::prelude::*;\n\nuse aoc_2019::day_14::*;\nuse aoc_common::*;\nuse aoc_fuzz::*;\nuse input::Input;\nuse model::ChemQty;\nuse model::Qty;\nuse model::Reaction;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n\naoc_fuzz_mutator! {\n\n\ttransform_lifetimes = \u003c'inp\u003e;\n\tinput_type = Input;\n\n\ttransform add (100 * 1, 10 * 5, 1 * 25) = |input, rng| {\n\t\tlet generator = Generator::new (input);\n\t\tlet reaction = generator.reaction (rng);\n\t\tlet idx = rng.gen_range (0 ..= input.reactions.len ());\n\t\tinput.reactions.insert (idx, reaction);\n\t}\n\n\tpub transform remove (100 * 1, 10 * 5, 1 * 25) = |input, rng| {\n\t\tif input.reactions.is_empty () { return Some (()) }\n\t\tlet idx = rng.gen_range (0 .. input.reactions.len ());\n\t\tinput.reactions.remove (idx);\n\t}\n\n\ttransform shuffle (1) = |input, rng| {\n\t\tinput.reactions.shuffle (rng);\n\t}\n\n\ttransform sort (1) = |input, _rng| {\n\t\tinput.reactions.sort ();\n\t}\n\n}\n\nstruct Generator \u003c'inp\u003e {\n\tchems: Vec \u003cInpStr \u003c'inp\u003e\u003e,\n}\n\nimpl \u003c'inp\u003e Generator \u003c'inp\u003e {\n\n\tfn new \u003c'inp0\u003e (input: \u0026 'inp0 Input \u003c'inp\u003e) -\u003e Self {\n\t\tGenerator {\n\t\t\tchems: input.reactions.iter ()\n\t\t\t\t.map (|reaction| reaction.output.chem.clone ())\n\t\t\t\t.filter (|chem| chem != \u0026 InpStr::borrow (\"FUEL\"))\n\t\t\t\t.chain (iter::once (InpStr::borrow (\"ORE\")))\n\t\t\t\t.collect (),\n\t\t}\n\t}\n\n\tpub fn reaction (\u0026 self, rng: \u0026 mut StdRng) -\u003e Reaction \u003c'inp\u003e {\n\t\tlet num_inputs = rng.gen_range (1 ..= 10);\n\t\tReaction {\n\t\t\tinputs: iter::from_fn (|| Some (self.chem_qty (rng, true)))\n\t\t\t\t.take (num_inputs)\n\t\t\t\t.collect (),\n\t\t\toutput: self.chem_qty (rng, false),\n\t\t}\n\t}\n\n\tpub fn chem_qty (\u0026 self, rng: \u0026 mut StdRng, input: bool) -\u003e ChemQty \u003c'inp\u003e {\n\t\tChemQty {\n\t\t\tchem: self.chem (rng, input),\n\t\t\tqty: self.qty (rng),\n\t\t}\n\t}\n\n\tpub fn chem (\u0026 self, rng: \u0026 mut StdRng, input: bool) -\u003e InpStr \u003c'inp\u003e {\n\t\tif input \u0026\u0026 ! self.chems.is_empty () \u0026\u0026 rng.gen_bool (0.9) {\n\t\t\treturn self.chems.choose (rng).unwrap ().clone ()\n\t\t}\n\t\tif ! input \u0026\u0026 ! self.chems.contains (\u0026 InpStr::borrow (\"FUEL\")) \u0026\u0026 rng.gen_bool (0.9) {\n\t\t\treturn InpStr::borrow (\"FUEL\")\n\t\t}\n\t\tlet len = Self::NAME_LENS.choose (rng).copied ().unwrap ();\n\t\tlet mut name = String::new ();\n\t\tfor _ in 0 .. len {\n\t\t\tname.push (Self::LETTERS.choose (rng).unwrap ().pan_char ());\n\t\t}\n\t\tInpStr::alloc (name)\n\t}\n\n\tpub fn qty (\u0026 self, rng: \u0026 mut StdRng) -\u003e Qty {\n\t\trng.gen::\u003cQty\u003e () \u0026 (Qty::MAX \u003e\u003e rng.gen_range (0 .. Qty::BITS))\n\t}\n\n\tconst NAME_LENS: \u0026 'static [usize] = \u0026 [ 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 4, 5 ];\n\tconst LETTERS: \u0026 'static [u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n}\n","traces":[{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_15::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_16::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_iters = cmp::min (input.params.num_iters, 10);\n\t\tinput.params.max_signal = cmp::min (input.params.max_signal, 100_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_17::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_18::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_19::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_20::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_21::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_ops = cmp::min (input.params.max_ops, 1_000_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_22::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_23::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_iters_one = cmp::min (input.params.max_iters_one, 200);\n\t\tinput.params.max_iters_two = cmp::min (input.params.max_iters_two, 2000);\n\t\tinput.params.max_ops = cmp::min (input.params.max_ops, 2000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_24::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2019-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2019::day_25::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_01::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_02::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_03::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_04::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_05::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_06::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_07::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_iters_one = cmp::min (input.params.max_iters_one, 400);\n\t\tinput.params.max_iters_two = cmp::min (input.params.max_iters_two, 200);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_08::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_09::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_10::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_11::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.max_iters = cmp::min (input.params.max_iters, 500);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_12::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_13::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_14::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_15::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.ord_one = cmp::min (input.params.ord_one, 10_000);\n\t\tinput.params.ord_two = cmp::min (input.params.ord_two, 10_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_16::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_17::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.iters_one = cmp::min (input.params.iters_one, 5);\n\t\tinput.params.iters_two = cmp::min (input.params.iters_two, 3);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_18::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_19::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_20::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_21::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_22::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_23::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.iters_one = cmp::min (input.params.iters_one, 1000);\n\t\tinput.params.iters_two = cmp::min (input.params.iters_two, 100_000);\n\t\tinput.params.deck_size_two = cmp::min (input.params.deck_size_two, 10_000);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_24::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (mut input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tinput.params.num_iters = cmp::min (input.params.num_iters, 50);\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2020-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2020::day_25::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-01.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_01::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-02.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_02::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-03.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_03::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-04.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_04::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-05.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_05::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-06.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_06::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-07.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_07::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-08.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_08::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-09.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_09::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-10.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_10::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-11.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_11::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-12.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_12::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-13.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_13::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-14.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_14::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-15.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_15::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-16.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_16::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-17.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_17::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-18.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_18::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-19.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_19::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-20.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_20::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-21.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_21::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-22.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_22::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-23.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_23::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-24.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_24::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t\tlet _ = logic::part_two (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","2021-day-25.rs"],"content":"#![ no_main ]\n\nuse libfuzzer_sys::fuzz_target;\n\nuse aoc_2021::day_25::*;\nuse aoc_common::*;\nuse input::Input;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim_end ().split ('\\n').collect ();\n\tif let Ok (input) = Input::parse_from_lines (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (\u0026 input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","fuzz","src","lib.rs"],"content":"#[ macro_export ]\nmacro_rules! aoc_fuzz_mutator {\n\t(\n\t\ttransform_lifetimes = \u003c$trans_life:lifetime\u003e;\n\t\tinput_type = $input_type:ty;\n\t\t$(\n\t\t\t$trans_vis:vis transform $trans_name:ident ($($trans_weights:tt)*) =\n\t\t\t|$trans_input:ident, $trans_rng:ident| { $($trans_body:tt)* }\n\t\t)*\n\t) =\u003e {\n\n\t\t::libfuzzer_sys::fuzz_mutator! (|\n\t\t\tdata: \u0026 mut [u8],\n\t\t\tsize: usize,\n\t\t\tmax_size: usize,\n\t\t\tseed: u32,\n\t\t| {\n\t\t\tuse ::rand::prelude::*;\n\t\t\tlet mut rng = StdRng::seed_from_u64 (seed as u64);\n\t\t\tlet mut size = size;\n\t\t\tlet mut num_mutations = 0;\n\t\t\tif rng.gen_bool (0.7) {\n\t\t\t\tif let Some (new_size) = mutator::main (data, size, max_size, \u0026 mut rng) {\n\t\t\t\t\tsize = new_size;\n\t\t\t\t\tnum_mutations += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile num_mutations == 0 || rng.gen_bool (0.1) {\n\t\t\t\tsize = ::libfuzzer_sys::fuzzer_mutate (data, size, max_size);\n\t\t\t\tnum_mutations += 1;\n\t\t\t}\n\t\t\tsize\n\t\t});\n\n\t\tmod mutator {\n\n\t\t\tuse super::*;\n\t\t\tuse ::rand::prelude::*;\n\n\t\t\tpub fn main (\n\t\t\t\tdata: \u0026 mut [u8],\n\t\t\t\tsize: usize,\n\t\t\t\tmax_size: usize,\n\t\t\t\trng: \u0026 mut StdRng,\n\t\t\t) -\u003e Option \u003cusize\u003e {\n\n\t\t\t\t// parse input\n\n\t\t\t\tlet input_str = str::from_utf8 (\u0026 data [0 .. size]).ok () ?;\n\t\t\t\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\t\t\t\tlet mut input = Input::parse_from_lines (\u0026 input_vec).ok () ?;\n\n\t\t\t\t// apply a random transform\n\n\t\t\t\ttransforms::random (\u0026 mut input, rng);\n\n\t\t\t\t// convert to string, removing random lines until it is the right length\n\n\t\t\t\tlet output_str = loop {\n\t\t\t\t\tlet output_str = input.to_string ();\n\t\t\t\t\tif output_str.as_bytes ().len () \u003c= max_size { break output_str }\n\t\t\t\t\ttransforms::remove (\u0026 mut input, rng);\n\t\t\t\t};\n\n\t\t\t\t// update data, and return\n\n\t\t\t\t(\u0026 mut data [ .. output_str.len ()]).copy_from_slice (output_str.as_bytes ());\n\n\t\t\t\tSome (output_str.len ())\n\n\t\t\t}\n\n\t\t\tmod transforms {\n\n\t\t\t\tuse super::*;\n\n\t\t\t\ttype TransFn = for \u003c'inp0, 'inp\u003e fn (\u0026 'inp0 mut $input_type, \u0026 mut StdRng) -\u003e Option \u003c()\u003e;\n\n\t\t\t\taoc_fuzz_mutator! (@transforms $(( $trans_name $($trans_weights)* ))*);\n\n\t\t\t\tpub fn random \u003c'inp0, 'inp\u003e (input: \u0026 'inp0 mut $input_type, rng: \u0026 mut StdRng) {\n\t\t\t\t\tlet \u0026 (_, reps, ref trans_fn) =\n\t\t\t\t\t\tTRANSFORMS.choose_weighted (rng, |\u0026 (weight, _, _)| weight).unwrap ();\n\t\t\t\t\tlet mut num_failure = 0;\n\t\t\t\t\tfor _ in 0 .. reps {\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\tlet success = trans_fn (input, rng).is_some ();\n\t\t\t\t\t\t\tif success { break }\n\t\t\t\t\t\t\tnum_failure += 1;\n\t\t\t\t\t\t\tif num_failure \u003e= 10 { break }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$(\n\t\t\t\t\t$trans_vis fn $trans_name \u003c'inp0, $trans_life\u003e (\n\t\t\t\t\t\t$trans_input: \u0026 'inp0 mut $input_type,\n\t\t\t\t\t\t$trans_rng: \u0026 mut StdRng,\n\t\t\t\t\t) -\u003e Option \u003c()\u003e {\n\t\t\t\t\t\t$($trans_body)*\n\t\t\t\t\t\tSome (())\n\t\t\t\t\t}\n\t\t\t\t)*\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t(@transforms $($body:tt)*) =\u003e {\n\t\taoc_fuzz_mutator! (@transforms_impl [] $($body)*);\n\t};\n\t(@transforms_impl [$($data:tt)*] ($name:ident $weight:literal) $($rest:tt)*) =\u003e {\n\t\taoc_fuzz_mutator! (@transforms_impl [$($data)* ($weight, 1, $name)] $($rest)*);\n\t};\n\t(@transforms_impl [$($data:tt)*] ($name:ident $($weight:literal * $reps:literal),*) $($rest:tt)*) =\u003e {\n\t\taoc_fuzz_mutator! (@transforms_impl [$($data)* $(($weight, $reps, $name))*] $($rest)*);\n\t};\n\t(@transforms_impl [$(( $($data:tt)* ))*]) =\u003e {\n\t\tconst TRANSFORMS: \u0026 [(u32, u32, TransFn)] = \u0026 [\n\t\t\t$(($($data)*)),*\n\t\t];\n\t};\n\n}\n\n#[ macro_export ]\nmacro_rules! pick_one {\n\t( $rng:expr, $($expr:expr),+ $(,)? ) =\u003e {\n\t\t{\n\t\t\tlet mut sel = $rng.gen_range (0 .. pick_one! (@count $($expr),+));\n\t\t\tloop {\n\t\t\t\t$(\n\t\t\t\t\tif sel == 0 { break $expr }\n\t\t\t\t\tsel -= 1;\n\t\t\t\t)+\n\t\t\t\tunreachable! ();\n\t\t\t}\n\t\t}\n\t};\n\t( @count $expr:expr ) =\u003e { 1 };\n\t( @count $expr:expr, $($rest:expr),+ ) =\u003e { 1 + pick_one! (@count $($rest),+) };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","misc","codegen","src","lib.rs"],"content":"//! Generate boilerplate code, run from build.rs\n\nuse std::collections::HashMap;\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::fs::File;\nuse std::io::Write;\nuse std::iter;\nuse std::mem;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n/// Entry point for code generation\n///\n/// # Errors\n///\n/// Returns any errors from the underlying IO operations unchanged\n///\n/// # Panics\n///\n/// If the package name does not conform to expectations.\n///\n#[ allow (clippy::missing_inline_in_public_items) ]\n#[ allow (clippy::print_stdout) ]\npub fn invoke () -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tprintln! (\"cargo:rerun-if-changed=build.rs\");\n\tprintln! (\"cargo:rerun-if-changed=.\");\n\tlet pkg_name = env::var (\"CARGO_PKG_NAME\") ?;\n\tif pkg_name == \"aoc-common\" {\n\t\tlet home = env::current_dir () ?;\n\t\tfor year in [\"2015\", \"2021\"] {\n\t\t\tenv::set_current_dir (format! (\"../{}\", year)) ?;\n\t\t\tprepare_year (year) ?;\n\t\t\tenv::set_current_dir (\u0026 home) ?;\n\t\t}\n\t} else {\n\t\tlet pkg_name_parts: Vec \u003c\u0026 str\u003e = pkg_name.split ('-').collect ();\n\t\tif pkg_name_parts.len () \u003c 2 { Err (\"Invalid package name\") ? }\n\t\tif pkg_name_parts [0] != \"aoc\" { Err (\"Invalid package name\") ? }\n\t\tlet year = pkg_name_parts [1];\n\t\tif pkg_name_parts.len () == 2 {\n\t\t\tprepare_year (year) ?;\n\t\t} else if pkg_name_parts.len () == 4 {\n\t\t\tif pkg_name_parts [2] != \"day\" { Err (\"Invalid package name\") ? }\n\t\t\tlet day = pkg_name_parts [3];\n\t\t\tprepare_day (year, day) ?;\n\t\t} else { Err (\"Invalid package name\") ? }\n\t}\n\tOk (())\n}\n\n/// Generate code for a single year\n///\nfn prepare_year (year: \u0026 str) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tlet static_part = |template| {\n\t\treplace_placeholders (\n\t\t\ttemplate,\n\t\t\t\u0026 HashMap::from_iter (vec! [\n\t\t\t\t(\"${YEAR}\", year),\n\t\t\t]))\n\t};\n\tlet dynamic_part = |template| {\n\t\t(1_u32 ..= 25)\n\t\t\t.filter_map (move |day|\n\t\t\t\tPathBuf::from (format! (\"day-{:02}\", day)).exists ().then_some (\n\t\t\t\t\treplace_placeholders (\n\t\t\t\t\t\ttemplate,\n\t\t\t\t\t\t\u0026 HashMap::from_iter (vec! [\n\t\t\t\t\t\t\t(\"${YEAR}\", year),\n\t\t\t\t\t\t\t(\"${DAY}\", \u0026 format! (\"{:02}\", day)),\n\t\t\t\t\t\t] ),\n\t\t\t\t\t)))\n\t\t\t.flatten ()\n\t};\n\tlet src_path = PathBuf::from (if Path::new (\"src/\").exists () { \"src/\" } else { \"./\" });\n\tlet mut lib_path = src_path.clone ();\n\tlib_path.push (\"lib.rs\");\n\twrite_file (\n\t\tlib_path,\n\t\titer::empty ()\n\t\t\t.chain (static_part (templates::YEAR_LIB [0]))\n\t\t\t.chain (dynamic_part (templates::YEAR_LIB [1]))\n\t\t\t.chain (static_part (templates::YEAR_LIB [2]))\n\t\t\t.chain (dynamic_part (templates::YEAR_LIB [3]))\n\t\t\t.chain (static_part (templates::YEAR_LIB [4])),\n\t) ?;\n\tlet mut main_path = src_path;\n\tmain_path.push (\"main.rs\");\n\twrite_file (\n\t\tmain_path,\n\t\tstatic_part (templates::YEAR_MAIN),\n\t) ?;\n\tOk (())\n}\n\n/// Generate code for a single day\n///\nfn prepare_day (year: \u0026 str, day: \u0026 str) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tlet src_path = PathBuf::from (if Path::new (\"src/\").exists () { \"src/\" } else { \"./\" });\n\tlet mut main_path = src_path;\n\tmain_path.push (\"main.rs\");\n\twrite_file (\n\t\tmain_path,\n\t\treplace_placeholders (templates::DAY_MAIN, \u0026 HashMap::from_iter (vec! [\n\t\t\t(\"${YEAR}\", year),\n\t\t\t(\"${DAY}\", day),\n\t\t])),\n\t) ?;\n\tOk (())\n}\n\n/// Write the provided lines to a named file\n///\nfn write_file (\n\tname: impl AsRef \u003cPath\u003e,\n\tlines: impl IntoIterator \u003cItem = impl AsRef \u003cstr\u003e\u003e,\n) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tlet mut new_contents = String::new ();\n\tfor line_temp in lines {\n\t\tlet line = line_temp.as_ref ();\n\t\tnew_contents.push_str (line);\n\t\tnew_contents.push ('\\n');\n\t}\n\tlet old_contents = fs::read_to_string (\u0026 name).unwrap_or_default ();\n\tif old_contents != new_contents {\n\t\tlet mut main_rs_file = File::create (name) ?;\n\t\twrite! (\u0026 mut main_rs_file, \"{}\", new_contents) ?;\n\t}\n\tOk (())\n}\n\n/// Replace placeholders in some strings\n///\nfn replace_placeholders (lines: \u0026 [\u0026 str], replacements: \u0026 HashMap \u003c\u0026 str, \u0026 str\u003e) -\u003e Vec \u003cString\u003e {\n\tlines.iter ().map (|line| {\n\t\tlet (output, buffer) = line.chars ().fold ((String::new (), String::new ()),\n\t\t\t|(mut output, mut buffer), letter| {\n\t\t\t\tif (buffer.is_empty () \u0026\u0026 letter == '$')\n\t\t\t\t\t\t|| (buffer.len () == 1 \u0026\u0026 letter == '{')\n\t\t\t\t\t\t|| buffer.len () \u003e 1 {\n\t\t\t\t\tbuffer.push (letter);\n\t\t\t\t\tif letter == '}' {\n\t\t\t\t\t\tlet replacement = replacements.get (buffer.as_str ()).unwrap_or_else (||\n\t\t\t\t\t\t\tpanic! (\"Replacement not found for: {}\", buffer),\n\t\t\t\t\t\t);\n\t\t\t\t\t\toutput.push_str (replacement);\n\t\t\t\t\t\tbuffer = String::new ();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push_str (mem::take (\u0026 mut buffer).as_str ());\n\t\t\t\t\toutput.push (letter);\n\t\t\t\t}\n\t\t\t\t(output, buffer)\n\t\t\t},\n\t\t);\n\t\tif ! buffer.is_empty () { panic! () }\n\t\toutput\n\t}).collect ()\n}\n\n/// Templates for generated file contents\n///\nmod templates {\n\n\t/// Template for lib.rs in a year\n\t///\n\tpub const YEAR_LIB: \u0026 [\u0026 [\u0026 str]] = \u0026 [\n\t\t\u0026 [\n\t\t\t\"#![ allow (clippy::missing_inline_in_public_items) ]\",\n\t\t\t\"\",\n\t\t\t\"use aoc_common::*;\",\n\t\t\t\"\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"pub use aoc_${YEAR}_day_${DAY} as day_${DAY};\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\",\n\t\t\t\"#[ must_use ]\",\n\t\t\t\"pub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\",\n\t\t\t\"\\tvec! [\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\\t\\tday_${DAY}::puzzle_metadata (),\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\\t]\",\n\t\t\t\"}\",\n\t\t],\n\t];\n\n\t/// Template for main.rs in a year\n\t///\n\tpub const YEAR_MAIN: \u0026 [\u0026 str] = \u0026 [\n\t\t\"use aoc_common::*;\",\n\t\t\"\",\n\t\t\"fn main () -\u003e GenResult \u003c()\u003e {\",\n\t\t\"\\tpuzzle::run_year_and_exit (\u0026 aoc_${YEAR}::puzzle_metadata (), true)\",\n\t\t\"}\",\n\t];\n\n\t/// Template for main.rs in a day\n\t///\n\tpub const DAY_MAIN: \u0026 [\u0026 str] = \u0026 [\n\t\t\"use std::env;\",\n\t\t\"use std::ffi::OsString;\",\n\t\t\"\",\n\t\t\"use aoc_common::*;\",\n\t\t\"use aoc_${YEAR}_day_${DAY}::*;\",\n\t\t\"\",\n\t\t\"fn main () -\u003e GenResult \u003c()\u003e {\",\n\t\t\"\tlet args: Vec \u003cOsString\u003e = env::args_os ().collect ();\",\n\t\t\"\tpuzzle_metadata ().invoke (\u0026 args)\",\n\t\t\"}\",\n\t];\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","src","lib.rs"],"content":"//! Advent of Code solutions by James Pharaoh\n//!\n//! [https://adventofcode.com/](https://adventofcode.com/)\n//!\n//! Home: [https://github.com/jamespharaoh/advent-of-code](https://github.com/jamespharaoh/advent-of-code)  \n\npub use aoc_2015 as year_2015;\npub use aoc_2016 as year_2016;\npub use aoc_2017 as year_2017;\npub use aoc_2018 as year_2018;\npub use aoc_2021 as year_2021;\npub use aoc_common as common;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>