<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-01","src","lib.rs"],"content":"//! Advent of Code 2015: Day 1: Not Quite Lisp\n//!\n//! [https://adventofcode.com/2015/day/1](https://adventofcode.com/2015/day/1)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Not Quite Lisp\";\n\tyear = 2015;\n\tday = 1;\n\tparse = |input| model::parse_input (input [0]);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003ci32\u003e {\n\t\tOk (\n\t\t\tinput.iter ().copied ().enumerate ()\n\t\t\t\t.scan (0, |floor, (idx, dir)| { * floor += dir.val (); Some ((idx, * floor)) })\n\t\t\t\t.last ()\n\t\t\t\t.map (|(_, floor)| floor)\n\t\t\t\t.unwrap_or (0)\n\t\t)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cusize\u003e {\n\t\tOk (\n\t\t\tinput.iter ().copied ().enumerate ()\n\t\t\t\t.scan (0, |floor, (idx, dir)| { * floor += dir.val (); Some ((idx, * floor)) })\n\t\t\t\t.filter_map (|(idx, floor)| (floor \u003c 0).then_some (idx + 1))\n\t\t\t\t.next ()\n\t\t\t\t.ok_or (\"Never visited the basement\") ?\n\t\t)\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\t\tuse model::Dir::*;\n\t\t\tassert_eq! (3, logic::part_one (vec! [Up, Up, Up]) ?);\n\t\t\tassert_eq! (-1, logic::part_one (vec! [Up, Down, Down]) ?);\n\t\t\tOk (())\n\t\t}\n\n\t\t#[ test ]\n\t\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\t\tuse model::Dir::*;\n\t\t\tassert_eq! (3, logic::part_two (vec! [Up, Down, Down]) ?);\n\t\t\tassert_err! (\"Never visited the basement\", logic::part_two (vec! [Up, Down]));\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\tpub type Input = Vec \u003cDir\u003e;\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Dir { Up, Down }\n\n\timpl Dir {\n\t\tpub fn val (\u0026 self) -\u003e i32 {\n\t\t\tmatch self { Dir::Up =\u003e 1, Dir::Down =\u003e -1 }\n\t\t}\n\t}\n\n\tpub fn parse_input (input: \u0026 str) -\u003e GenResult \u003cInput\u003e {\n\t\tOk (\n\t\t\tinput.chars ().enumerate ()\n\t\t\t\t.map (|(ch_idx, ch)| match ch {\n\t\t\t\t\t'(' =\u003e Ok (Dir::Up),\n\t\t\t\t\t')' =\u003e Ok (Dir::Down),\n\t\t\t\t\t_ =\u003e Err (format! (\"Invalid character: char {}: {}\", ch_idx + 1, ch)),\n\t\t\t\t})\n\t\t\t\t.collect::\u003cResult \u003c_, _\u003e\u003e () ?\n\t\t)\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn parse_input () {\n\t\t\tassert_err! (\"Invalid character: char 3: X\", model::parse_input (\"()X\"));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLES_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"(())\",\n\t\t\"()()\",\n\t\t\"))(((((\",\n\t\t\"())\",\n\t\t\"))(\",\n\t\t\")))\",\n\t\t\")())())\",\n\t];\n\n\tconst EXAMPLES_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\t\")\",\n\t\t\"()())\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq! (\"0\", puzzle.part_one (\u0026 [EXAMPLES_ONE [0]]) ?);\n\t\tassert_eq! (\"0\", puzzle.part_one (\u0026 [EXAMPLES_ONE [1]]) ?);\n\t\tassert_eq! (\"3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [2]]) ?);\n\t\tassert_eq! (\"-1\", puzzle.part_one (\u0026 [EXAMPLES_ONE [3]]) ?);\n\t\tassert_eq! (\"-1\", puzzle.part_one (\u0026 [EXAMPLES_ONE [4]]) ?);\n\t\tassert_eq! (\"-3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [5]]) ?);\n\t\tassert_eq! (\"-3\", puzzle.part_one (\u0026 [EXAMPLES_ONE [6]]) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq! (\"1\", puzzle.part_two (\u0026 [EXAMPLES_TWO [0]]) ?);\n\t\tassert_eq! (\"5\", puzzle.part_two (\u0026 [EXAMPLES_TWO [1]]) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":11,"address":[68459,67659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[67815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[68615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[60353,60080],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[60174,60110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[21728,21779],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":26,"address":[21951,21936],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":31,"address":[60400,60800],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":33,"address":[60430,60774,60494],"length":1,"stats":{"Line":3},"fn_name":null},{"line":34,"address":[22019,21968],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":35,"address":[22176,22194],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":37,"address":[60748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[66368,66377],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":49,"address":[78311,78659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[79047,78708,78627],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[79023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[66425,66416],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":57,"address":[79111,79465],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[79926,79518,79433],"length":1,"stats":{"Line":3},"fn_name":null},{"line":59,"address":[79957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[49600],"length":1,"stats":{"Line":1},"fn_name":"val"},{"line":77,"address":[49609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[49664],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":83,"address":[50043,49723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[63949,63904,64311],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":85,"address":[64015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[64032],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[63992,64049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[49956],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[44853,44848],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":100,"address":[20839,21135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[42048,42057],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":129,"address":[31335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[31823,31356,31471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[31969,32384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[32520,32935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[33486,33071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[34016,33622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[34143,34537],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[34664,35082],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[35209],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[35264,36388,35828],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":142,"address":[35271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[35702,35286,35392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[36237,35839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[36364],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":46},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-02","src","lib.rs"],"content":"//! Advent of Code 2015: Day 2: I Was Told There Would Be No Math\n//!\n//! [https://adventofcode.com/2015/day/2](https://adventofcode.com/2015/day/2)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"I Was Told There Would Be No Math\";\n\tyear = 2015;\n\tday = 2;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Dim;\n\tuse model::Input;\n\tuse nums::Int;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cDim\u003e {\n\t\tOk (\n\t\t\tinput.iter_vals ().map (|(l, w, h)|\n\t\t\t\tInt::add_4 (\n\t\t\t\t\tInt::mul_3 (2, l, w) ?,\n\t\t\t\t\tInt::mul_3 (2, w, h) ?,\n\t\t\t\t\tInt::mul_3 (2, h, l) ?,\n\t\t\t\t\t[ Int::mul_2 (l, w) ?, Int::mul_2 (w, h) ?, Int::mul_2 (h, l) ?].iter_vals ()\n\t\t\t\t\t\t.min ().unwrap (),\n\t\t\t\t)\n\t\t\t).fold (Ok (0), |sum, val| Int::add_2 (sum ?, val ?)) ?\n\t\t)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cDim\u003e {\n\t\tOk (\n\t\t\tinput.iter_vals ().map (|(l, w, h)|\n\t\t\t\tInt::add_2 (\n\t\t\t\t\t[\n\t\t\t\t\t\tInt::mul_2 (2, Int::add_2 (l, w) ?) ?,\n\t\t\t\t\t\tInt::mul_2 (2, Int::add_2 (w, h) ?) ?,\n\t\t\t\t\t\tInt::mul_2 (2, Int::add_2 (h, l) ?) ?,\n\t\t\t\t\t].iter_vals ().min ().unwrap (),\n\t\t\t\t\tInt::mul_3 (l, w, h) ?,\n\t\t\t\t)\n\t\t\t).fold (Ok (0), |sum, val| Int::add_2 (sum ?, val ?)) ?\n\t\t)\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn part_one () {\n\t\t\tassert_eq_ok! (0, logic::part_one (vec! []));\n\t\t\tassert_eq_ok! (101, logic::part_one (vec! [(2, 3, 4), (1, 1, 10)]));\n\t\t\tconst BIG: u32 = 24770;\n\t\t\tassert_is_ok! (logic::part_one (vec! [(BIG, BIG, BIG)]));\n\t\t\tassert_err! (\"Overflow\", logic::part_one (vec! [(BIG + 1, BIG + 1, BIG + 1)]));\n\t\t\tassert_err! (\"Overflow\", logic::part_one (vec! [(BIG, BIG, BIG), (BIG, BIG, BIG)]));\n\t\t}\n\n\t\t#[ test ]\n\t\tfn part_two () {\n\t\t\tassert_eq_ok! (0, logic::part_two (vec! []));\n\t\t\tassert_eq_ok! (48, logic::part_two (vec! [(2, 3, 4), (1, 1, 10)]));\n\t\t\tconst BIG: u32 = 1625;\n\t\t\tassert_is_ok! (logic::part_two (vec! [(BIG, BIG, BIG)]));\n\t\t\tassert_err! (\"Overflow\", logic::part_two (vec! [(BIG + 1, BIG + 1, BIG + 1)]));\n\t\t\tassert_err! (\"Overflow\", logic::part_two (vec! [(BIG, BIG, BIG), (BIG, BIG, BIG)]));\n\t\t}\n\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\tpub type Dim = u32;\n\tpub type Input = Vec \u003c(Dim, Dim, Dim)\u003e;\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser|\n\t\t\t\tOk ((\n\t\t\t\t\tparser.int () ?,\n\t\t\t\t\tparser.expect (\"x\") ?.int () ?,\n\t\t\t\t\tparser.expect (\"x\") ?.int () ?,\n\t\t\t\t))\n\t\t\t).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\tline_idx + 1, char_idx + 1, line)\n\t\t\t)\n\t\t).collect::\u003cResult::\u003c_, _\u003e\u003e ()\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn parse_input () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (vec! [(1, 2, 3), (4, 5, 6)], model::parse_input (\u0026 [\"1x2x3\", \"4x5x6\"]) ?);\n\t\t\tassert_err! (\"Invalid input: line 2: col 2: 4xx5x6\",\n\t\t\t\tmodel::parse_input (\u0026 [\"1x2x3\", \"4xx5x6\"]));\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"2x3x4\", \"1x1x10\" ];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq! (\"58\", puzzle.part_one (\u0026 EXAMPLE [0 .. 1]) ?);\n\t\tassert_eq! (\"43\", puzzle.part_one (\u0026 EXAMPLE [1 .. 2]) ?);\n\t\tassert_eq! (\"101\", puzzle.part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq! (\"34\", puzzle.part_two (\u0026 EXAMPLE [0 .. 1]) ?);\n\t\tassert_eq! (\"14\", puzzle.part_two (\u0026 EXAMPLE [1 .. 2]) ?);\n\t\tassert_eq! (\"48\", puzzle.part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":11,"address":[82715,81963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[82064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[82816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[31184,31456],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":25,"address":[31269,31430,31211,31312],"length":1,"stats":{"Line":7},"fn_name":null},{"line":26,"address":[71034],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[70302,70187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[70350,70281,70438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[70475,70417,70557],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[70542,70594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[71112,71056],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":37,"address":[31776,31504],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":39,"address":[31589,31750,31632,31531],"length":1,"stats":{"Line":7},"fn_name":null},{"line":40,"address":[72234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[71355,71499,71581],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[71812,71566,71618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[71797,71849,72064],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[72153,72252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[31616],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[34148,31888,33035],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":59,"address":[32023,31895,32277],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[32802,32332,32562,32246],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[32854,33078,32780,33050],"length":1,"stats":{"Line":3},"fn_name":null},{"line":63,"address":[33066,33116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[33581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[63056,63061],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":69,"address":[34327,34581,34199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[34550,34636,34866,35106],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[35084,35382,35354,35158],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[35420,35370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[35885],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[95792],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":90,"address":[92284,92365,92256],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":91,"address":[93331,92384,92294,92618,93464,92340],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":92,"address":[93297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[92430,92523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[92490,92820,92623,92914],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[93232,92881,93035,93338],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[92320,93472,93853],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":98,"address":[93701,93550,93640],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[93515,93576,93666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[52112,52770,52793],"length":1,"stats":{"Line":3},"fn_name":"parse_input"},{"line":111,"address":[52119,52660,52781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[52833],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[52808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[53159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[56864,56873],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":130,"address":[88183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[88204,88392,88754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[89358,88900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[89485,89873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[90000],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[56921,56912],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":139,"address":[90055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[90076,90264,90626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[91230,90772],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[91745,91357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[91872],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":58,"coverable":58},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-03","src","lib.rs"],"content":"//! Advent of Code 2015: Day 3: Perfectly Spherical Houses in a Vacuum\n//!\n//! [https://adventofcode.com/2015/day/3](https://adventofcode.com/2015/day/3)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Perfectly Spherical Houses in a Vacuum\";\n\tyear = 2015;\n\tday = 3;\n\tparse = |input| model::parse_input (input [0]);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::Pos;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tlet (seen, _) = input.iter_vals ().fold (\n\t\t\t(HashMap::\u003c_, u32\u003e::from_iter ([ (Pos::ZERO, 1) ]), Pos::ZERO),\n\t\t\t|(mut seen, pos), dir| {\n\t\t\t\tlet pos = pos + dir.to_pos ();\n\t\t\t\t* seen.entry (pos).or_insert (0) += 1;\n\t\t\t\t(seen, pos)\n\t\t\t},\n\t\t);\n\t\tOk (seen.len ().try_into () ?)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tlet (seen, _, _) = input.iter_vals ().fold (\n\t\t\t(HashMap::\u003c_, u32\u003e::from_iter ([ (Pos::ZERO, 1) ]), Pos::ZERO, Pos::ZERO),\n\t\t\t|(mut seen, pos_0, pos_1), dir| {\n\t\t\t\tlet pos_0 = pos_0 + dir.to_pos ();\n\t\t\t\t* seen.entry (pos_0).or_insert (0) += 1;\n\t\t\t\t(seen, pos_1, pos_0)\n\t\t\t},\n\t\t);\n\t\tOk (seen.len ().try_into () ?)\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\tpub type Input = Vec \u003cDir\u003e;\n\tpub type Pos = pos::PosGeo \u003ci16\u003e;\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub enum Dir {\n\t\tNorth, South, East, West,\n\t}\n\n\timpl Dir {\n\t\tpub fn to_pos (self) -\u003e Pos {\n\t\t\tmatch self {\n\t\t\t\tDir::North =\u003e Pos::ZERO.north (1),\n\t\t\t\tDir::South =\u003e Pos::ZERO.south (1),\n\t\t\t\tDir::East =\u003e Pos::ZERO.east (1),\n\t\t\t\tDir::West =\u003e Pos::ZERO.west (1),\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn parse_input (input: \u0026 str) -\u003e GenResult \u003cInput\u003e {\n\t\tinput.chars ().enumerate ().map (|(ch_idx, ch)| Ok (match ch {\n\t\t\t'^' =\u003e Dir::North,\n\t\t\t'v' =\u003e Dir::South,\n\t\t\t'\u003e' =\u003e Dir::East,\n\t\t\t'\u003c' =\u003e Dir::West,\n\t\t\t_ =\u003e Err (format! (\"Invalid input: col {}: {}\", ch_idx + 1, ch)) ?,\n\t\t})).collect::\u003cGenResult \u003c_\u003e\u003e ()\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn parse_input () {\n\t\t\tuse Dir::*;\n\t\t\tassert_eq_ok! (vec! [North, East, South, West], model::parse_input (\"^\u003ev\u003c\"));\n\t\t\tassert_err! (\"Invalid input: col 3: X\", model::parse_input (\"^vX\"));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [\"\u003e\"]));\n\t\tassert_eq_ok! (\"4\", puzzle.part_one (\u0026 [\"^\u003ev\u003c\"]));\n\t\tassert_eq_ok! (\"2\", puzzle.part_one (\u0026 [\"^v^v^v^v^v\"]));\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [\"^v\"]));\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (\u0026 [\"^\u003ev\u003c\"]));\n\t\tassert_eq_ok! (\"11\", puzzle.part_two (\u0026 [\"^v^v^v^v^v\"]));\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":11,"address":[31163,31963],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[31319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[32119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[29808,29854,29264],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[29552,29294],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[29368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[51616,52009,51653,52049],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":26,"address":[51790,51713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[52017,51861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[51935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[29603,29657,29782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[29872,30446,30492],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":35,"address":[30190,29902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[29976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[52080,52527,52567,52117],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":38,"address":[52288,52211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[52535,52359],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[52433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[30420,30241,30295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[25120],"length":1,"stats":{"Line":2},"fn_name":"to_pos"},{"line":62,"address":[25131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[25162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[25191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[25220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[25249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[25296],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":72,"address":[58628,58000,58045],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":73,"address":[58128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[58138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[58148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[58158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[58110,58173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[34354,33360,33927],"length":1,"stats":{"Line":3},"fn_name":"parse_input"},{"line":89,"address":[33946,33367,33466],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[33953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[63120,63129],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":104,"address":[36183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[36294,36360,36222],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[36687,36797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[37120,37230],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[37551],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[39151,38180,37680],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":113,"address":[37687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[37726,37798,37864],"length":1,"stats":{"Line":3},"fn_name":null},{"line":115,"address":[38191,38301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[38734,38624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[39055],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":47,"coverable":47},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","src","lib.rs"],"content":"//! Advent of Code 2015: Day 4: The Ideal Stocking Stuffer\n//!\n//! [https://adventofcode.com/2015/day/4](https://adventofcode.com/2015/day/4)\n\n#![ allow (clippy::needless_collect) ]\n#![ allow (clippy::needless_range_loop) ]\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"The Ideal Stocking Stuffer\";\n\tyear = 2015;\n\tday = 4;\n\tparse = |input| Ok::\u003c_, Infallible\u003e (input [0]);\n\tpart_one = |input, max_threads: usize| logic::part_one (input, max_threads);\n\tpart_two = |input, max_threads: usize| logic::part_two (input, max_threads);\n\tcommands = [\n\t\t( name = \"run\"; method = cli::run; ),\n\t];\n\tparams = [\n\t\tmax_threads: usize = usize::MAX;\n\t];\n}\n\npub mod md5;\n\npub mod logic {\n\n\tuse super::*;\n\tuse md5::Output;\n\n\tpub fn part_one (input: \u0026 str, max_threads: usize) -\u003e GenResult \u003cusize\u003e {\n\t\tcalc_result (input, 5, max_threads)\n\t}\n\n\tpub fn part_two (input: \u0026 str, max_threads: usize) -\u003e GenResult \u003cusize\u003e {\n\t\tcalc_result (input, 6, max_threads)\n\t}\n\n\tpub fn calc_result (input: \u0026 str, num_zeros: usize, max_threads: usize) -\u003e GenResult \u003cusize\u003e {\n\t\tlet num_threads = cmp::min (get_num_threads ().unwrap_or (1), max_threads);\n\t\tif num_threads \u003c 2 {\n\t\t\tcalc_result_serial (input, num_zeros)\n\t\t} else {\n\t\t\tcalc_result_parallel (input, num_zeros, num_threads)\n\t\t}\n\t}\n\n\tfn calc_result_serial (input: \u0026 str, num_zeros: usize) -\u003e GenResult \u003cusize\u003e {\n\t\tlet check_fn = check_zeros_fn (num_zeros);\n\t\tfor base in (0 .. ).step_by (100) {\n\t\t\tlet input_buf =\n\t\t\t\tformat! (\"{}{}\", input, if base == 0 { 1 } else { base })\n\t\t\t\t\t.as_bytes ().to_vec ();\n\t\t\tlet (min_len, loops) = if base == 0 {\n\t\t\t\t(input_buf.len () - 1, 99)\n\t\t\t} else {\n\t\t\t\t(input_buf.len () - 2, 100)\n\t\t\t};\n\t\t\tif let Some (loop_idx) = search_range (input_buf, min_len, loops, \u0026 check_fn) {\n\t\t\t\treturn Ok (if base == 0 { loop_idx + 1 } else { base + loop_idx });\n\t\t\t}\n\t\t}\n\t\tErr (\"No solution found\") ?;\n\t\tunreachable! ();\n\t}\n\n\tfn get_num_threads () -\u003e GenResult \u003cusize\u003e {\n\t\tuse std::fs::File;\n\t\tuse std::io::BufRead as _;\n\t\tuse std::io::BufReader;\n\t\tlet file = File::open (\"/proc/cpuinfo\") ?;\n\t\tlet reader = BufReader::new (file);\n\t\tlet mut num_threads = 0;\n\t\tfor line in reader.lines () {\n\t\t\tlet line = line ?;\n\t\t\tif ! line.starts_with (\"processor\\t: \") { continue }\n\t\t\tnum_threads += 1;\n\t\t}\n\t\tOk (num_threads)\n\t}\n\n\tfn calc_result_parallel (input: \u0026 str, num_zeros: usize, num_threads: usize) -\u003e GenResult \u003cusize\u003e {\n\t\tconst BATCH_SIZE: usize = 1000;\n\t\t#[ derive (Debug, Default) ]\n\t\tstruct State {\n\t\t\tqueue: VecDeque \u003cusize\u003e,\n\t\t\tsolutions: Vec \u003cusize\u003e,\n\t\t}\n\t\tlet state_mutex = Arc::new (Mutex::new (default::\u003cState\u003e ()));\n\t\tlet queue_pushed = Arc::new (Condvar::new ());\n\t\tlet queue_pulled = Arc::new (Condvar::new ());\n\t\tlet join_handles = (0 .. num_threads).map (|_| {\n\t\t\tlet input = input.to_string ();\n\t\t\tlet state_mutex = Arc::clone (\u0026 state_mutex);\n\t\t\tlet queue_pushed = Arc::clone (\u0026 queue_pushed);\n\t\t\tlet queue_pulled = Arc::clone (\u0026 queue_pulled);\n\t\t\tlet check_fn = check_zeros_fn (num_zeros);\n\t\t\tthread::spawn (move || {\n\t\t\t\tloop {\n\t\t\t\t\tlet mut state = state_mutex.lock ().unwrap ();\n\t\t\t\t\tlet base = loop {\n\t\t\t\t\t\tif ! state.solutions.is_empty () { return }\n\t\t\t\t\t\tif let Some (next) = state.queue.pop_front () {\n\t\t\t\t\t\t\tqueue_pulled.notify_one ();\n\t\t\t\t\t\t\tbreak next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate = queue_pushed.wait (state).unwrap ();\n\t\t\t\t\t};\n\t\t\t\t\tdrop (state);\n\t\t\t\t\tlet input_buf =\n\t\t\t\t\t\tformat! (\"{}{}\", input, if base == 0 { 1 } else { base })\n\t\t\t\t\t\t\t.as_bytes ().to_vec ();\n\t\t\t\t\tlet (min_len, loops) = if base == 0 {\n\t\t\t\t\t\t(input_buf.len () - 1, BATCH_SIZE - 1)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(input_buf.len () - (input_buf.len () - input.len ()), BATCH_SIZE)\n\t\t\t\t\t};\n\t\t\t\t\tif let Some (loop_idx) = search_range (input_buf, min_len, loops, \u0026 check_fn) {\n\t\t\t\t\t\tlet mut state = state_mutex.lock ().unwrap ();\n\t\t\t\t\t\tstate.solutions.push (\n\t\t\t\t\t\t\tif base == 0 { loop_idx + 1 } else { base + loop_idx });\n\t\t\t\t\t\tqueue_pulled.notify_all ();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut state = state_mutex.lock ().unwrap ();\n\t\tfor base in (0 .. ).step_by (BATCH_SIZE) {\n\t\t\twhile state.queue.len () == num_threads * 8 \u0026\u0026 state.solutions.is_empty () {\n\t\t\t\tstate = queue_pulled.wait (state).unwrap ();\n\t\t\t}\n\t\t\tif ! state.solutions.is_empty () { break }\n\t\t\tstate.queue.push_back (base);\n\t\t\tqueue_pushed.notify_one ();\n\t\t}\n\t\tqueue_pushed.notify_all ();\n\t\tdrop (state);\n\t\tjoin_handles.into_iter ().for_each (|join_handle| join_handle.join ().unwrap ());\n\t\tlet state_mutex = Arc::try_unwrap (state_mutex).unwrap ();\n\t\tlet state = state_mutex.into_inner ().unwrap ();\n\t\tlet mut solutions = state.solutions;\n\t\tsolutions.sort ();\n\t\tOk (solutions.into_iter ().next ().ok_or (\"No solution found\") ?)\n\t}\n\n\tfn search_range (\n\t\tmut input_buf: Vec \u003cu8\u003e,\n\t\tmin_len: usize,\n\t\tloops: usize,\n\t\tcheck_fn: \u0026 (dyn Fn (\u0026 Output) -\u003e bool + Send + Sync),\n\t) -\u003e Option \u003cusize\u003e {\n\t\tfor loop_idx in 0 .. loops {\n\t\t\tlet hash = md5::md5_hash (\u0026 input_buf);\n\t\t\tif check_fn (\u0026 hash) { return Some (loop_idx) }\n\t\t\tlet mut num_zeros = 0;\n\t\t\twhile input_buf.len () != min_len {\n\t\t\t\tlet next_digit = match input_buf.pop ().unwrap () {\n\t\t\t\t\tb'0' =\u003e b'1', b'1' =\u003e b'2', b'2' =\u003e b'3',\n\t\t\t\t\tb'3' =\u003e b'4', b'4' =\u003e b'5', b'5' =\u003e b'6',\n\t\t\t\t\tb'6' =\u003e b'7', b'7' =\u003e b'8', b'8' =\u003e b'9',\n\t\t\t\t\tb'9' =\u003e {\n\t\t\t\t\t\tnum_zeros += 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t\t};\n\t\t\t\tinput_buf.push (next_digit);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif input_buf.len () == min_len { input_buf.push (b'1'); }\n\t\t\tinput_buf.extend (iter::repeat (b'0').take (num_zeros));\n\t\t}\n\t\tNone\n\t}\n\n\tfn check_zeros \u003cconst ZRS: usize\u003e (hash: \u0026 Output) -\u003e bool {\n\t\tfor idx in 0 .. hash.len () {\n\t\t\tif ZRS == idx * 2 + 1 \u0026\u0026 hash [idx] \u0026 0xf0 != 0 { return false }\n\t\t\tif ZRS \u003e= idx * 2 + 2 \u0026\u0026 hash [idx] != 0 { return false }\n\t\t}\n\t\ttrue\n\t}\n\n\tfn check_zeros_fn (num_zeros: usize) -\u003e Box \u003cdyn Fn (\u0026 Output) -\u003e bool + Send + Sync\u003e {\n\t\tBox::new (match num_zeros {\n\t\t\t0 =\u003e check_zeros::\u003c0\u003e, 1 =\u003e check_zeros::\u003c1\u003e, 2 =\u003e check_zeros::\u003c2\u003e,\n\t\t\t3 =\u003e check_zeros::\u003c3\u003e, 4 =\u003e check_zeros::\u003c4\u003e, 5 =\u003e check_zeros::\u003c5\u003e,\n\t\t\t6 =\u003e check_zeros::\u003c6\u003e, 7 =\u003e check_zeros::\u003c7\u003e, 8 =\u003e check_zeros::\u003c8\u003e,\n\t\t\t9 =\u003e check_zeros::\u003c9\u003e, 10 =\u003e check_zeros::\u003c10\u003e, 11 =\u003e check_zeros::\u003c11\u003e,\n\t\t\t12 =\u003e check_zeros::\u003c12\u003e, 13 =\u003e check_zeros::\u003c13\u003e, 14 =\u003e check_zeros::\u003c14\u003e,\n\t\t\t15 =\u003e check_zeros::\u003c15\u003e, 16 =\u003e check_zeros::\u003c16\u003e, 17 =\u003e check_zeros::\u003c17\u003e,\n\t\t\t18 =\u003e check_zeros::\u003c18\u003e, 19 =\u003e check_zeros::\u003c19\u003e, 20 =\u003e check_zeros::\u003c20\u003e,\n\t\t\t21 =\u003e check_zeros::\u003c21\u003e, 22 =\u003e check_zeros::\u003c22\u003e, 23 =\u003e check_zeros::\u003c23\u003e,\n\t\t\t24 =\u003e check_zeros::\u003c24\u003e, 25 =\u003e check_zeros::\u003c25\u003e, 26 =\u003e check_zeros::\u003c26\u003e,\n\t\t\t27 =\u003e check_zeros::\u003c27\u003e, 28 =\u003e check_zeros::\u003c28\u003e, 29 =\u003e check_zeros::\u003c29\u003e,\n\t\t\t30 =\u003e check_zeros::\u003c30\u003e, 31 =\u003e check_zeros::\u003c31\u003e, 32 =\u003e check_zeros::\u003c32\u003e,\n\t\t\t_ =\u003e unreachable! (),\n\t\t})\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn check_zeros_fn () {\n\t\t\tfn with_zeros (zeros: usize) -\u003e Output {\n\t\t\t\tlet mut hex = String::new ();\n\t\t\t\tfor _ in 0 .. zeros { hex.push ('0'); }\n\t\t\t\twhile hex.len () \u003c 32 { hex.push ('f'); }\n\t\t\t\tOutput::from_hex (\u0026 hex).unwrap ()\n\t\t\t}\n\t\t\tfor zeros in 0 ..= 32 {\n\t\t\t\tlet check_fn = logic::check_zeros_fn (zeros);\n\t\t\t\tlet should_pass = with_zeros (zeros);\n\t\t\t\tassert! (check_fn (\u0026 should_pass));\n\t\t\t\tif zeros \u003e 0 {\n\t\t\t\t\tlet should_fail = with_zeros (zeros - 1);\n\t\t\t\t\tassert! (! check_fn (\u0026 should_fail), \"Should fail for {} zeros: {}\", zeros, should_fail);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#[ test ]\n\t\t#[ should_panic ]\n\t\tfn check_zeros_fn_panic () {\n\t\t\tlet _ = logic::check_zeros_fn (33);\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (not (tarpaulin_include)) ]\nmod cli {\n\n\tuse super::*;\n\n\t#[ derive (clap::Parser) ]\n\tpub struct RunArgs {\n\n\t\t#[ clap (long, default_value = \"2015/inputs/day-04\") ]\n\t\tinput: String,\n\n\t\t#[ clap (long) ]\n\t\tmax_threads: Option \u003cusize\u003e,\n\n\t\t#[ clap (long) ]\n\t\tzeros: usize,\n\n\t}\n\n\tpub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\t\tlet input_lines: Vec \u003c_\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tprintln! (\"Using input file: {}\", \u0026 args.input);\n\t\tprintln! (\"Looking for {} zeros\", args.zeros);\n\t\tlet result = logic::calc_result (\n\t\t\tinput_lines [0],\n\t\t\targs.zeros,\n\t\t\targs.max_threads.unwrap_or (usize::MAX),\n\t\t) ?;\n\t\tprintln! (\"Result: {}\", result);\n\t\tOk (())\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 str = \"abcdef\";\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet mut puzzle = puzzle_metadata ();\n\t\tpuzzle.set_param (\"max_threads\", 1.to_string ());\n\t\tassert_eq_ok! (\"609043\", puzzle.part_one (\u0026 [EXAMPLE]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"6742839\", puzzle.part_two (\u0026 [EXAMPLE]));\n\t}\n\n}\n","traces":[{"line":14,"address":[142319,142509,141965,141775],"length":1,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[141799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":16,"address":[142343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[96576],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":36,"address":[96784],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":40,"address":[96992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[96607,96815,97026],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[97132,96909,96701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[96895,96687,96707,97120,97138,96915],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[97145,96714,96922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[97216,98144],"length":1,"stats":{"Line":1},"fn_name":"calc_result_serial"},{"line":50,"address":[97248],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[97483,97632,97745,97338],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[97635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[97669,97900],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[97642,97870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[97679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[97930,97748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[98930,98160],"length":1,"stats":{"Line":1},"fn_name":"get_num_threads"},{"line":75,"address":[98915,98336],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[98426,98449],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[98491],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[98524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[98602],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[101379,98944],"length":1,"stats":{"Line":1},"fn_name":"calc_result_parallel"},{"line":90,"address":[99169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[99227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[99285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[88221,88138,87888],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":94,"address":[87908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[88005,88024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[88044,88029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[88063,88049],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[88068],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[89010,88080,89805,88240],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":103,"address":[88399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[88515],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[88521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[88551,89171,88686,88874],"length":1,"stats":{"Line":7},"fn_name":null},{"line":113,"address":[89684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[88877],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[89414,88912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[89354,88879],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[88922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[89163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[89493,89174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[89264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[88176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[99473],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[99673,99684,99626,100580],"length":1,"stats":{"Line":3},"fn_name":null},{"line":132,"address":[99695,99762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[99798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[99572],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[99851],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[99857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[89858,89824],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":141,"address":[99961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[100182],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[100217,100270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[101392,102115],"length":1,"stats":{"Line":1},"fn_name":"search_range"},{"line":155,"address":[101505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[101523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[101613,101548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[101596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[101601,101980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[101807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[102128],"length":1,"stats":{"Line":1},"fn_name":"check_zeros_fn"},{"line":187,"address":[102129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[51265],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[51312],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003caoc_2015_day_04::logic::tests::check_zeros_fn::{closure_env#0}, ()\u003e"},{"line":210,"address":[168262,167904],"length":1,"stats":{"Line":1},"fn_name":"with_zeros"},{"line":213,"address":[168134,168021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[168036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[167548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[167552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[167576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[167600,167704],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[167604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":221,"address":[167609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[167822,167634,167734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[168272],"length":1,"stats":{"Line":0},"fn_name":"check_zeros_fn_panic"},{"line":280,"address":[45408],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":281,"address":[85788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[85875],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[85927,85898,86206,86132,86051,85988],"length":1,"stats":{"Line":3},"fn_name":null},{"line":287,"address":[45424],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":288,"address":[86284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[86468,86334,86393,86589,86305],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":87,"coverable":93},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-04","src","md5.rs"],"content":"use super::*;\nuse nums::IntConv;\nuse ops::{ BitAnd, BitOr, BitXor, Not };\n\n#[ derive (Eq, PartialEq) ]\npub struct Output ([u8; 16]);\n\npub fn md5_hash (input: \u0026 [u8]) -\u003e Output {\n\tlet mut md5 = MD5::new ();\n\tmd5.update (input);\n\tmd5.finish ()\n}\n\npub struct MD5 {\n\tstate: State,\n\tmessage: ArrayVec \u003cu8, 64\u003e,\n\tlen: usize,\n}\n\ntype State = [WrappingU32; 4];\n\nimpl Output {\n\tpub fn len (\u0026 self) -\u003e usize { self.0.len () }\n\tpub fn is_empty (\u0026 self) -\u003e bool { self.0.is_empty () }\n\tpub fn from_hex (input: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet input_len = input.chars ().count ();\n\t\tif input_len != 32 { Err (format! (\"Expected 32 chars, not {}\", input_len)) ? }\n\t\tlet mut result = [0; 16];\n\t\tlet mut input_iter = input.chars ();\n\t\tfor result_ch in result.iter_mut () {\n\t\t\tlet (high_ch, low_ch) = input_iter.next_tuple ().unwrap ();\n\t\t\tlet decode = |ch: char| ch.to_digit (16).ok_or (format! (\"Invalid hex: {}\", ch));\n\t\t\t* result_ch = (decode (high_ch) ?.as_u8 ()) \u003c\u003c 4 | decode (low_ch) ?.as_u8 ();\n\t\t}\n\t\tOk (Output (result))\n\t}\n}\n\nimpl Index \u003cusize\u003e for Output {\n\ttype Output = u8;\n\tfn index (\u0026 self, idx: usize) -\u003e \u0026 u8 {\n\t\t\u0026 self.0 [idx]\n\t}\n}\n\nimpl Debug for Output {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"md5::Output (\\\"\") ?;\n\t\tfor idx in 0 .. 16 {\n\t\t\twrite! (formatter, \"{:02x}\", self.0 [idx]) ?;\n\t\t}\n\t\twrite! (formatter, \"\\\")\") ?;\n\t\tOk (())\n\t}\n}\n\nimpl Display for Output {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor idx in 0 .. 16 {\n\t\t\twrite! (formatter, \"{:02x}\", self.0 [idx]) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl MD5 {\n\n\tpub fn new () -\u003e MD5 {\n\t\tMD5 {\n\t\t\tstate: INITIAL_STATE,\n\t\t\tmessage: ArrayVec::new (),\n\t\t\tlen: 0,\n\t\t}\n\t}\n\n\tpub fn update (\u0026 mut self, mut message: \u0026 [u8]) {\n\n\t\t// iterate over message\n\n\t\twhile ! message.is_empty () {\n\n\t\t\t// copy max sized chunk to buffer\n\n\t\t\tlet bytes = cmp::min (self.message.remaining_capacity (), message.len ());\n\t\t\tself.message.extend (message.iter ().copied ().take (bytes));\n\t\t\tmessage = \u0026 message [bytes .. ];\n\t\t\tself.len = self.len.wrapping_add (bytes \u003c\u003c 3);\n\n\t\t\t// stop now if buffer is part filled\n\n\t\t\tif ! self.message.is_full () { return }\n\n\t\t\t// consume buffer\n\n\t\t\tself.apply ();\n\n\t\t}\n\n\t}\n\n\tpub fn finish (mut self) -\u003e Output {\n\n\t\t// remember the length before padding\n\n\t\tlet mut len = self.len;\n\n\t\t// add one then zeros\n\n\t\tself.update (\u0026 [ 0x80 ]);\n\t\twhile self.message.remaining_capacity () != 8 {\n\t\t\tself.update (\u0026 [ 0x00 ]);\n\t\t}\n\n\t\t// then the length\n\n\t\tfor _ in 0 .. 8 {\n\t\t\tself.update (\u0026 [ (len \u0026 0xff).as_u8 () ]);\n\t\t\tlen \u003e\u003e= 8;\n\t\t}\n\n\t\t// convert result words to byte array\n\n\t\tassert! (self.message.is_empty ());\n\t\tlet mut result = [0; 16];\n\t\tfor src_idx in 0 .. 4 {\n\t\t\tlet dst_idx = src_idx \u003c\u003c 2;\n\t\t\tresult [dst_idx] = (self.state [src_idx].0 \u0026 0xff).as_u8 ();\n\t\t\tresult [dst_idx + 1] = (self.state [src_idx].0 \u003e\u003e 8 \u0026 0xff).as_u8 ();\n\t\t\tresult [dst_idx + 2] = (self.state [src_idx].0 \u003e\u003e 16 \u0026 0xff).as_u8 ();\n\t\t\tresult [dst_idx + 3] = (self.state [src_idx].0 \u003e\u003e 24 \u0026 0xff).as_u8 ();\n\t\t}\n\n\t\tOutput (result)\n\n\t}\n\n\tfn apply (\u0026 mut self) {\n\n\t\t// convert message buffer into words\n\n\t\tassert! (self.message.is_full ());\n\t\tlet message = {\n\t\t\tlet mut message = [WrappingU32 (0); 16];\n\t\t\tfor dst_idx in 0 .. 16 {\n\t\t\t\tlet src_idx = dst_idx \u003c\u003c 2;\n\t\t\t\tmessage [dst_idx] = WrappingU32 (\n\t\t\t\t\t(self.message [src_idx]).as_u32 ()\n\t\t\t\t\t\t| (self.message [src_idx + 1].as_u32 ()) \u003c\u003c 8\n\t\t\t\t\t\t| (self.message [src_idx + 2].as_u32 ()) \u003c\u003c 16\n\t\t\t\t\t\t| (self.message [src_idx + 3].as_u32 ()) \u003c\u003c 24\n\t\t\t\t);\n\t\t\t}\n\t\t\tmessage\n\t\t};\n\n\t\t// apply rounds as specified\n\n\t\tlet [mut a, mut b, mut c, mut d] = self.state;\n\t\tfor op in 0 .. 16 {\n\t\t\tlet func = ((b \u0026 c) | (! b \u0026 d)) + a + WrappingU32 (ADDS [op]) + message [op];\n\t\t\t(a, b, c, d) = (d, b + func.rotate_left (ROTATES [op].as_u32 ()), b, c);\n\t\t}\n\t\tfor op in 16 .. 32 {\n\t\t\tlet func = ((d \u0026 b) | (! d \u0026 c)) + a + WrappingU32 (ADDS [op]) + message [(5 * op + 1) % 16];\n\t\t\t(a, b, c, d) = (d, b + func.rotate_left (ROTATES [op].as_u32 ()), b, c);\n\t\t}\n\t\tfor op in 32 .. 48 {\n\t\t\tlet func = (b ^ c ^ d) + a + WrappingU32 (ADDS [op]) + message [(3 * op + 5) % 16];\n\t\t\t(a, b, c, d) = (d, b + func.rotate_left (ROTATES [op].as_u32 ()), b, c);\n\t\t}\n\t\tfor op in 48 .. 64 {\n\t\t\tlet func = (c ^ (b | ! d)) + a + WrappingU32 (ADDS [op]) + message [7 * op % 16];\n\t\t\t(a, b, c, d) = (d, b + func.rotate_left (ROTATES [op].as_u32 ()), b, c);\n\t\t}\n\t\tself.state = [\n\t\t\tself.state [0] + a,\n\t\t\tself.state [1] + b,\n\t\t\tself.state [2] + c,\n\t\t\tself.state [3] + d,\n\t\t];\n\n\t\t// clear buffer\n\n\t\tself.message.clear ();\n\n\t}\n\n}\n\nimpl Default for MD5 {\n\tfn default () -\u003e Self { Self::new () }\n}\n\n#[ derive (Clone, Copy) ]\nstruct WrappingU32 (u32);\n\nimpl WrappingU32 {\n\tfn rotate_left (self, arg: u32) -\u003e Self { WrappingU32 (self.0.rotate_left (arg)) }\n}\n\nimpl Add for WrappingU32 {\n\ttype Output = Self;\n\tfn add (self, other: Self) -\u003e Self { WrappingU32 (self.0.wrapping_add (other.0)) }\n}\n\nimpl BitAnd for WrappingU32 {\n\ttype Output = WrappingU32;\n\tfn bitand (self, other: Self) -\u003e Self { WrappingU32 (self.0 \u0026 other.0) }\n}\n\nimpl BitOr for WrappingU32 {\n\ttype Output = WrappingU32;\n\tfn bitor (self, other: Self) -\u003e Self { WrappingU32 (self.0 | other.0) }\n}\n\nimpl BitXor for WrappingU32 {\n\ttype Output = WrappingU32;\n\tfn bitxor (self, other: Self) -\u003e Self { WrappingU32 (self.0 ^ other.0) }\n}\n\nimpl Not for WrappingU32 {\n\ttype Output = WrappingU32;\n\tfn not (self) -\u003e Self { WrappingU32 (! self.0) }\n}\n\nconst INITIAL_STATE: State = [\n\tWrappingU32 (0x67452301), WrappingU32 (0xefcdab89),\n\tWrappingU32 (0x98badcfe), WrappingU32 (0x10325476),\n];\n\nconst ROTATES: [u8; 64] = [\n\t7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n\t5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20,\n\t4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n\t6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21,\n];\n\nconst ADDS: [u32; 64] = [\n\t0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,\n\t0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193,\n\t0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d,\n\t0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n\t0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,\n\t0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,\n\t0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244,\n\t0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n\t0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,\n\t0xeb86d391,\n];\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tconst LOREM_IPSUM: \u0026 str =\n\t\t\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut at tempus ligula, ac \\\n\t\tpellentesque leo. Nullam molestie justo sit amet neque venenatis, at laoreet urna \\\n\t\tmollis. Mauris eget mollis quam. Maecenas ultricies odio dolor, id luctus lorem \\\n\t\taliquam at. Vestibulum est lectus, egestas vehicula mi vel, pharetra elementum \\\n\t\tligula. Nam cursus, magna vitae sodales pretium, metus ligula facilisis nisl, pretium \\\n\t\taccumsan leo justo sed elit. Vestibulum efficitur justo quis molestie luctus. Aliquam \\\n\t\tvolutpat at quam quis egestas. Proin et turpis nec lacus maximus iaculis. Donec vitae \\\n\t\tmassa magna. Nulla pulvinar eleifend erat et fringilla.\";\n\n\tmacro_rules! assert_md5 {\n\t\t( $expect:expr , $input:expr ) =\u003e {\n\t\t\tassert_eq! (\n\t\t\t\tOutput::from_hex ($expect).unwrap (),\n\t\t\t\tmd5_hash ($input.as_bytes ()));\n\t\t}\n\t}\n\n\t#[ test ]\n\tfn test_md5_hash () {\n\t\tassert_md5! (\"d41d8cd98f00b204e9800998ecf8427e\", \"\");\n\t\tassert_md5! (\"6cd3556deb0da54bca060b4c39479839\", \"Hello, world!\");\n\t\tassert_md5! (\"7bb31841cf426a6de079421b2590cf82\", \"The Ideal Stocking Stuffer\");\n\t\tassert_md5! (\"777f5a5ebdeab74ab0299512f9688be0\", LOREM_IPSUM);\n\t}\n\n\t#[ test ]\n\tfn test_output () {\n\t\tlet output = Output::from_hex (\"0123456789abcdef0123456789abcdef\").unwrap ();\n\t\tassert_eq! (16, output.len ());\n\t\tassert_eq! (false, output.is_empty ());\n\t\tassert_eq! (0x01, output [0]);\n\t\tassert_eq! (0xef, output [15]);\n\t\tassert_eq! (\"md5::Output (\\\"0123456789abcdef0123456789abcdef\\\")\", format! (\"{:?}\", output));\n\t\tassert_eq! (\"0123456789abcdef0123456789abcdef\", format! (\"{}\", output));\n\t\tassert_err! (\"Expected 32 chars, not 31\", Output::from_hex (\"0123456789abcdef0123456789abcde\"));\n\t\tassert_err! (\"Expected 32 chars, not 33\", Output::from_hex (\"0123456789abcdef0123456789abcdef0\"));\n\t\tassert_err! (\"Invalid hex: X\", Output::from_hex (\"0123456789abcdeX0123456789abcdef\"));\n\t}\n\n}\n","traces":[{"line":8,"address":[46545,46160],"length":1,"stats":{"Line":1},"fn_name":"md5_hash"},{"line":11,"address":[46374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[46560],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":24,"address":[46576],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":25,"address":[46592],"length":1,"stats":{"Line":1},"fn_name":"from_hex"},{"line":26,"address":[46644],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[46652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[46803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[46814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[46955,47146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[47281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[47310],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[47504],"length":1,"stats":{"Line":0},"fn_name":"index"},{"line":42,"address":[47507,47521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[47552],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":48,"address":[47628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[47680,47757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[47836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[47872],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":60,"address":[48099,47975,48022,48111,47892],"length":1,"stats":{"Line":5},"fn_name":null},{"line":76,"address":[48144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[46214,48161,48274,48645,48476,48859,46327],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[46296,48613,48438,48242,48823],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[48258,48632,46314,48840,48457],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[48459,48634,48263,46316,48842],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[48320,49135],"length":1,"stats":{"Line":1},"fn_name":"finish"},{"line":105,"address":[48342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[48531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[48754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[48725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[49077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[48876,48947,48922,48892],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[48965,48941,48896,48916],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[48899,48951,48919,48944,48968,48880,48926],"length":1,"stats":{"Line":7},"fn_name":null},{"line":133,"address":[48904,48887,48953,48971,48928],"length":1,"stats":{"Line":5},"fn_name":null},{"line":137,"address":[49152],"length":1,"stats":{"Line":1},"fn_name":"apply"},{"line":141,"address":[49173,49690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[49220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[49216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[49237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[49280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[49431],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[49510],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[49595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[49650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[49420,49332,49346],"length":1,"stats":{"Line":3},"fn_name":null},{"line":213,"address":[49584,49427,49336],"length":1,"stats":{"Line":3},"fn_name":null},{"line":218,"address":[49498,49587],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[49342,49418,49580],"length":1,"stats":{"Line":3},"fn_name":null},{"line":275,"address":[51088],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003caoc_2015_day_04::md5::tests::test_md5_hash::{closure_env#0}, ()\u003e"},{"line":276,"address":[111964,111528,111633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[111639,111682,111722,112031],"length":1,"stats":{"Line":3},"fn_name":null},{"line":278,"address":[111728,111771,111811,112095],"length":1,"stats":{"Line":3},"fn_name":null},{"line":279,"address":[111860,111817,111900,112159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":283,"address":[51232],"length":1,"stats":{"Line":2},"fn_name":"call_once\u003caoc_2015_day_04::md5::tests::test_output::{closure_env#0}, ()\u003e"},{"line":284,"address":[112318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[113716,112366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[112380,113757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[112402,113437,114207,112524],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[112559,113482,114192,112684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":291,"address":[113527,114177,112716,114298,112885,112759],"length":1,"stats":{"Line":3},"fn_name":null},{"line":292,"address":[114265,114162,113143,113572,112987,112944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[113617,114232,113363,113245,114147,113202],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":57,"coverable":63},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-05","src","lib.rs"],"content":"//! Advent of Code 2015: Day 5: Doesn't He Have Intern-Elves For This?\n//!\n//! [https://adventofcode.com/2015/day/5](https://adventofcode.com/2015/day/5)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Doesn't He Have Intern-Elves For This?\";\n\tyear = 2015;\n\tday = 5;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cusize\u003e {\n\t\tOk (\n\t\t\tinput.iter ()\n\t\t\t\t.filter (|line| is_nice_one (line))\n\t\t\t\t.count ()\n\t\t)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cusize\u003e {\n\t\tOk (\n\t\t\tinput.iter ()\n\t\t\t\t.filter (|line| is_nice_two (line))\n\t\t\t\t.count ()\n\t\t)\n\t}\n\n\tfn is_nice_one (input: \u0026 str) -\u003e bool {\n\t\tif input.chars ()\n\t\t\t\t.filter (|ch| ['a', 'e', 'i', 'o', 'u'].contains (ch))\n\t\t\t\t.count () \u003c 3\n\t\t\t{ return false }\n\t\tif ! input.chars ()\n\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.any (|(ch_0, ch_1)| ch_0 == ch_1)\n\t\t\t{ return false }\n\t\tif input.chars ()\n\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.any (|chars|\n\t\t\t\t\t[ ('a', 'b'), ('c', 'd'), ('p', 'q'), ('x', 'y') ]\n\t\t\t\t\t\t.contains (\u0026 chars))\n\t\t\t{ return false }\n\t\ttrue\n\t}\n\n\tfn is_nice_two (input: \u0026 str) -\u003e bool {\n\t\tif ! input.chars ()\n\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.any (|(idx, chars_0)|\n\t\t\t\t\tinput.chars ().skip (idx + 2)\n\t\t\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t\t\t.any (|chars_1| chars_0 == chars_1))\n\t\t\t{ return false }\n\t\tif ! input.chars ()\n\t\t\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t\t\t.any (|(ch_0, _, ch_1)| ch_0 == ch_1)\n\t\t\t{ return false }\n\t\ttrue\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn is_nice_one () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (true, logic::is_nice_one (\"ugknbfddgicrmopn\"));\n\t\t\tassert_eq! (true, logic::is_nice_one (\"aaa\"));\n\t\t\tassert_eq! (false, logic::is_nice_one (\"jchzalrnumimnmhp\"));\n\t\t\tassert_eq! (false, logic::is_nice_one (\"haegwjzuvuyypxyu\"));\n\t\t\tassert_eq! (false, logic::is_nice_one (\"dvszwmarrgswjxmb\"));\n\t\t\tOk (())\n\t\t}\n\n\t\t#[ test ]\n\t\tfn is_nice_two () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (true, logic::is_nice_two (\"qjhvhtzxzqqjkmpb\"));\n\t\t\tassert_eq! (true, logic::is_nice_two (\"xxyxx\"));\n\t\t\tassert_eq! (false, logic::is_nice_two (\"uurcxstgmygtbstg\"));\n\t\t\tassert_eq! (false, logic::is_nice_two (\"ieodomkazucvgmuy\"));\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\t#[ derive (Clone) ]\n\tpub struct Input (Vec \u003cString\u003e);\n\n\timpl Deref for Input {\n\t\ttype Target = [String];\n\t\tfn deref (\u0026 self) -\u003e \u0026 Self::Target { \u0026 self.0 }\n\t}\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tOk (\n\t\t\tinput.iter ().all (|line| line.chars ()\n\t\t\t\t\t.all (|ch| char::is_ascii_lowercase (\u0026 ch)))\n\t\t\t\t.then_some (Input (input.iter ()\n\t\t\t\t\t.map (|line| line.to_string ()).collect ()))\n\t\t\t\t.ok_or (\"Invalid input\") ?\n\t\t)\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"ugknbfddgicrmopn\",\n\t\t\"aaa\",\n\t\t\"jchzalrnumimnmhp\",\n\t\t\"haegwjzuvuyypxyu\",\n\t\t\"dvszwmarrgswjxmb\",\n\t];\n\n\tconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\t\"qjhvhtzxzqqjkmpb\",\n\t\t\"xxyxx\",\n\t\t\"uurcxstgmygtbstg\",\n\t\t\"ieodomkazucvgmuy\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"2\", puzzle.part_one (EXAMPLE_ONE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE_TWO));\n\t}\n\n}\n","traces":[{"line":11,"address":[58219,58987],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[58320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[59088],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[67392,67580],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[67419,67477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[35216,35230],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":29,"address":[67804,67616],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":31,"address":[67643,67701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[35310,35296],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":37,"address":[67840],"length":1,"stats":{"Line":1},"fn_name":"is_nice_one"},{"line":38,"address":[67873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[35393,35376],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":41,"address":[67971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[68003,67954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[35440,35456],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":45,"address":[68064],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[68081,68047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[35488,35535],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":49,"address":[35505],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[68131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[68121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[68144],"length":1,"stats":{"Line":1},"fn_name":"is_nice_two"},{"line":56,"address":[68177,68253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[35552,35567,35746],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":60,"address":[35723,35597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[35760,35777,35713],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":63,"address":[68320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[68352,68303],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[35824,35832],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":67,"address":[68399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[68392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[20816],"length":1,"stats":{"Line":3},"fn_name":"is_nice_one"},{"line":78,"address":[20956,20823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[20918,21120,20995],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[21168,21293,21082],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[21466,21255,21341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[21514,21428,21636],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[21600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[21696],"length":1,"stats":{"Line":3},"fn_name":"is_nice_two"},{"line":88,"address":[21703,21836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[22000,21798,21875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[22048,21962,22173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[22135,22345,22221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[22308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[70393,70384],"length":1,"stats":{"Line":3},"fn_name":"deref"},{"line":111,"address":[70432],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":113,"address":[26384,26398],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":114,"address":[26461,26448],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":115,"address":[70543],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[26496,26531],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":117,"address":[70880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[36416,36421],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":145,"address":[60839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[60862,61002,60936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":150,"address":[36448,36453],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":151,"address":[61367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[61530,61464,61390],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":56,"coverable":57},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-06","src","lib.rs"],"content":"//! Advent of Code 2015: Day 6: Probably a Fire Hazard\n//!\n//! [https://adventofcode.com/2015/day/6](https://adventofcode.com/2015/day/6)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Probably a Fire Hazard\";\n\tyear = 2015;\n\tday = 6;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Action;\n\tuse model::Coord;\n\tuse model::Input;\n\tuse model::Step;\n\tuse nums::Int;\n\tuse nums::IntConv;\n\n\tpub type ModeFn = fn (Action, u8) -\u003e u8;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tcalc_result (\u0026 input, mode_fn_one)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tcalc_result (\u0026 input, mode_fn_two)\n\t}\n\n\tfn mode_fn_one (action: Action, old_active: u8) -\u003e u8 {\n\t\tmatch action {\n\t\t\tAction::On =\u003e 1,\n\t\t\tAction::Off =\u003e 0,\n\t\t\tAction::Toggle =\u003e if old_active == 0 { 1 } else { 0 },\n\t\t}\n\t}\n\n\tfn mode_fn_two (action: Action, old_active: u8) -\u003e u8 {\n\t\tmatch action {\n\t\t\tAction::On =\u003e u8::checked_add (old_active, 1).unwrap (),\n\t\t\tAction::Off =\u003e u8::saturating_sub (old_active, 1),\n\t\t\tAction::Toggle =\u003e u8::checked_add (old_active, 2).unwrap (),\n\t\t}\n\t}\n\n\tfn calc_result (steps: \u0026 [Step], mode_fn: ModeFn) -\u003e GenResult \u003cu32\u003e {\n\t\tlet steps =\n\t\t\tsteps.iter ().copied ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.sorted_by_key (|(_, step)| step.origin)\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet rows =\n\t\t\tsteps.iter ().copied ()\n\t\t\t\t.flat_map (|(_, step)| [ step.origin.row, step.peak.row ])\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut cur_steps: Vec \u003c(usize, Step)\u003e = Vec::new ();\n\t\tlet mut sum = 0;\n\t\tlet mut prev_row = Coord::MIN;\n\t\tlet mut prev_active = 0;\n\t\tlet mut steps_iter = steps.into_iter ().peekable ();\n\t\tlet mut row_data: Vec \u003c(Coord, u8)\u003e = Vec::new ();\n\t\tlet mut row_data_temp = Vec::new ();\n\t\tfor row in rows {\n\t\t\tsum = u32::checked_add (sum,\n\t\t\t\tu32::checked_mul (\n\t\t\t\t\tu16::checked_sub (row, prev_row).unwrap ().as_u32 (),\n\t\t\t\t\tprev_active.as_u32 (),\n\t\t\t\t).unwrap (),\n\t\t\t).unwrap ();\n\t\t\tcur_steps.retain (|(_, step)| row \u003c step.peak.row);\n\t\t\twhile let Some ((_, step)) = steps_iter.peek () {\n\t\t\t\tif step.origin.row != row { break }\n\t\t\t\tcur_steps.push (steps_iter.next ().unwrap ());\n\t\t\t}\n\t\t\tcur_steps.sort_by_key (|\u0026 (idx, _)| idx);\n\t\t\trow_data.clear ();\n\t\t\t{\n\t\t\t\tlet mut steps = \u0026 cur_steps [ .. ];\n\t\t\t\ttrait RowIter: Iterator \u003cItem = (Coord, u8)\u003e {}\n\t\t\t\timpl \u003cSomeIter: Iterator \u003cItem = (Coord, u8)\u003e\u003e RowIter for SomeIter {}\n\t\t\t\t#[ inline ]\n\t\t\t\tfn update_once (iter: impl RowIter, step: Step, mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\t\tUpdateLineIter::new (iter, step.action, step.origin.col, step.peak.col, mode_fn)\n\t\t\t\t}\n\t\t\t\t#[ inline ]\n\t\t\t\tfn update_twice (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\t\tupdate_once (update_once (iter, steps [0].1, mode_fn), steps [1].1, mode_fn)\n\t\t\t\t}\n\t\t\t\t#[ inline ]\n\t\t\t\tfn update_four_x (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\t\tupdate_twice (update_twice (iter, \u0026 steps [0 .. 2], mode_fn), \u0026 steps [2 .. 4], mode_fn)\n\t\t\t\t}\n\t\t\t\t#[ inline ]\n\t\t\t\tfn update_eight_x (iter: impl RowIter, steps: \u0026 [(usize, Step)], mode_fn: ModeFn) -\u003e impl RowIter {\n\t\t\t\t\tupdate_four_x (update_four_x (iter, \u0026 steps [0 .. 4], mode_fn), \u0026 steps [4 .. 8], mode_fn)\n\t\t\t\t}\n\t\t\t\twhile steps.len () \u003e= 8 {\n\t\t\t\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\t\t\t\tassert! (row_data.is_empty ());\n\t\t\t\t\trow_data.extend (\n\t\t\t\t\t\tupdate_eight_x (\n\t\t\t\t\t\t\trow_data_temp.drain ( .. ),\n\t\t\t\t\t\t\t\u0026 steps [0 .. 8 ],\n\t\t\t\t\t\t\tmode_fn));\n\t\t\t\t\tsteps = \u0026 steps [ 8 .. ];\n\t\t\t\t}\n\t\t\t\twhile ! steps.is_empty () {\n\t\t\t\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\t\t\t\tassert! (row_data.is_empty ());\n\t\t\t\t\trow_data.extend (\n\t\t\t\t\t\tupdate_once (\n\t\t\t\t\t\t\trow_data_temp.drain ( .. ),\n\t\t\t\t\t\t\tsteps [0].1,\n\t\t\t\t\t\t\tmode_fn));\n\t\t\t\t\tsteps = \u0026 steps [ 1 .. ];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* old implementation:\n\t\t\tmem::swap (\u0026 mut row_data, \u0026 mut row_data_temp);\n\t\t\tassert! (row_data.is_empty ());\n\t\t\tlet mut iter: Box \u003cdyn RowIter\u003e = Box::new (row_data.drain ( .. ));\n\t\t\tfor step in steps.iter ().copied () {\n\t\t\t\titer = Box::new (UpdateLineIter::new (iter, step.action, step.origin.col, step.peak.col));\n\t\t\t}\n\t\t\trow_data = iter.collect ();\n\t\t\t*/\n\t\t\tprev_row = row;\n\t\t\tprev_active =\n\t\t\t\trow_data.iter ().copied ()\n\t\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t\t.map (|((start, val), (end, _))|\n\t\t\t\t\t\tInt::mul_2 (\n\t\t\t\t\t\t\tInt::sub_2 (end, start) ?.as_u32 (),\n\t\t\t\t\t\t\tval.as_u32 (),\n\t\t\t\t\t\t))\n\t\t\t\t\t.fold (Ok (0), |sum, val| Int::add_2 (sum ?, val ?)) ?;\n\t\t\tassert! (row_data.last ().copied ().map (|(_, val)| val).unwrap_or (0) == 0);\n\t\t}\n\t\tOk (sum)\n\t}\n\n\tstruct UpdateLineIter \u003cInner: Iterator\u003e {\n\t\tinner: Inner,\n\t\tnext: Option \u003cInner::Item\u003e,\n\t\taction: Action,\n\t\tstep: ArrayVec \u003cCoord, 2\u003e,\n\t\told_active: u8,\n\t\tcur_active: u8,\n\t\tin_step: bool,\n\t\tmode_fn: ModeFn,\n\t}\n\n\timpl \u003cInner\u003e UpdateLineIter \u003cInner\u003e\n\t\t\twhere Inner: Iterator \u003cItem = (Coord, u8)\u003e {\n\t\t#[ inline ]\n\t\tfn new (inner: Inner, action: Action, start: Coord, end: Coord, mode_fn: ModeFn) -\u003e Self {\n\t\t\tUpdateLineIter {\n\t\t\t\tinner,\n\t\t\t\tnext: None,\n\t\t\t\taction,\n\t\t\t\tstep: [ end, start ].into_iter ().collect (),\n\t\t\t\told_active: 0,\n\t\t\t\tcur_active: 0,\n\t\t\t\tin_step: false,\n\t\t\t\tmode_fn,\n\t\t\t}\n\t\t}\n\t}\n\n\timpl \u003cInner\u003e Iterator for UpdateLineIter \u003cInner\u003e\n\t\twhere Inner: Iterator \u003cItem = (Coord, u8)\u003e {\n\t\ttype Item = (Coord, u8);\n\t\tfn next (\u0026 mut self) -\u003e Option \u003c(Coord, u8)\u003e {\n\t\t\tloop {\n\t\t\t\tif self.next.is_none () { self.next = self.inner.next (); }\n\t\t\t\tlet (pos, old_val, step) = match (self.next, self.step.last ().copied ()) {\n\t\t\t\t\t(Some ((pos, val)), None) =\u003e (pos, Some (val), false),\n\t\t\t\t\t(Some ((pos_0, val)), Some (pos_1)) if pos_0 \u003c pos_1 =\u003e (pos_0, Some (val), false),\n\t\t\t\t\t(Some ((pos_0, _)), Some (pos_1)) if pos_1 \u003c pos_0 =\u003e (pos_1, None, true),\n\t\t\t\t\t(Some ((pos_0, val)), Some (pos_1)) if pos_0 == pos_1 =\u003e (pos_0, Some (val), true),\n\t\t\t\t\t(None, Some (pos)) =\u003e (pos, None, true),\n\t\t\t\t\t(None, None) =\u003e return None,\n\t\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t\t};\n\t\t\t\tif let Some (val) = old_val { self.old_active = val; self.next = None; }\n\t\t\t\tif step { self.in_step = ! self.in_step; self.step.pop ().unwrap (); }\n\t\t\t\tlet want_active = if self.in_step {\n\t\t\t\t\t(self.mode_fn) (self.action, self.old_active)\n\t\t\t\t} else { self.old_active };\n\t\t\t\tif self.cur_active != want_active {\n\t\t\t\t\tself.cur_active = want_active;\n\t\t\t\t\treturn Some ((pos, want_active));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\t\tuse model::Action::*;\n\t\tuse model::Pos;\n\n\t\tconst STEPS: \u0026 [Step] = \u0026 [\n\t\t\tStep { action: Toggle, origin: Pos { row: 0, col: 0 }, peak: Pos { row: 2, col: 9 }},\n\t\t\tStep { action: Off, origin: Pos { row: 4, col: 3 }, peak: Pos { row: 5, col: 8 }},\n\t\t\tStep { action: On, origin: Pos { row: 2, col: 2 }, peak: Pos { row: 9, col: 3 }},\n\t\t\tStep { action: Toggle, origin: Pos { row: 2, col: 4 }, peak: Pos { row: 9, col: 5 }},\n\t\t\tStep { action: Toggle, origin: Pos { row: 3, col: 3 }, peak: Pos { row: 8, col: 6 }},\n\t\t\tStep { action: Toggle, origin: Pos { row: 6, col: 3 }, peak: Pos { row: 9, col: 8 }},\n\t\t\tStep { action: Off, origin: Pos { row: 1, col: 0 }, peak: Pos { row: 1, col: 3 }},\n\t\t\tStep { action: Off, origin: Pos { row: 2, col: 2 }, peak: Pos { row: 5, col: 5 }},\n\t\t\tStep { action: Toggle, origin: Pos { row: 5, col: 5 }, peak: Pos { row: 9, col: 8 }},\n\t\t\tStep { action: Off, origin: Pos { row: 3, col: 4 }, peak: Pos { row: 7, col: 8 }},\n\t\t\tStep { action: On, origin: Pos { row: 4, col: 0 }, peak: Pos { row: 8, col: 8 }},\n\t\t\tStep { action: Off, origin: Pos { row: 1, col: 1 }, peak: Pos { row: 3, col: 5 }},\n\t\t\tStep { action: On, origin: Pos { row: 2, col: 4 }, peak: Pos { row: 6, col: 8 }},\n\t\t\tStep { action: On, origin: Pos { row: 1, col: 4 }, peak: Pos { row: 7, col: 8 }},\n\t\t\tStep { action: On, origin: Pos { row: 0, col: 3 }, peak: Pos { row: 6, col: 6 }},\n\t\t];\n\n\t\t#[ test ]\n\t\tfn calc_result () {\n\t\t\tassert_eq_ok! (59, logic::calc_result (STEPS, mode_fn_one));\n\t\t\tassert_eq_ok! (203, logic::calc_result (STEPS, mode_fn_two));\n\t\t}\n\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\tuse pos::PosRowCol;\n\tuse parser::*;\n\n\tpub type Coord = u16;\n\tpub type Pos = PosRowCol \u003cCoord\u003e;\n\tpub type Input = Vec \u003cStep\u003e;\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub struct Step {\n\t\tpub action: Action,\n\t\tpub origin: Pos,\n\t\tpub peak: Pos,\n\t}\n\n\timpl Step {\n\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cStep\u003e {\n\t\t\tParser::wrap (input, Self::parse_real)\n\t\t\t\t.map_parse_err (|col_idx|\n\t\t\t\t\tformat! (\"Invalid input: col {}: {}\", col_idx + 1, \u0026 input [col_idx .. ])\n\t\t\t\t)\n\t\t}\n\n\t\tfn parse_real (parser: \u0026 mut Parser) -\u003e ParseResult \u003cStep\u003e {\n\t\t\tparser.set_ignore_whitespace (true);\n\t\t\tlet action = match parser.word () ? {\n\t\t\t\t\"turn\" =\u003e match parser.word () ? {\n\t\t\t\t\t\"on\" =\u003e Action::On,\n\t\t\t\t\t\"off\" =\u003e Action::Off,\n\t\t\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t\t\t},\n\t\t\t\t\"toggle\" =\u003e Action::Toggle,\n\t\t\t\t_ =\u003e return Err (parser.err ()),\n\t\t\t};\n\t\t\tlet origin = Pos {\n\t\t\t\trow: parser.int () ?,\n\t\t\t\tcol: parser.expect (\",\") ?.int () ?,\n\t\t\t};\n\t\t\tlet peak = Pos {\n\t\t\t\trow: parser.expect (\"through\") ?.int::\u003cCoord\u003e () ? + 1,\n\t\t\t\tcol: parser.expect (\",\") ?.int::\u003cCoord\u003e () ? + 1,\n\t\t\t};\n\t\t\tOk (Step { action, origin, peak })\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Action { On, Off, Toggle }\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, Step::parse_real)\n\t\t\t\t.map_parse_err (|char_idx| format! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\tline_idx + 1, char_idx + 1,\n\t\t\t\t\t\u0026 line [line.chars ().take (char_idx).map (char::len_utf8).sum () .. ]))\n\t\t).collect::\u003cGenResult \u003c_\u003e\u003e ()\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\tconst STEPS: \u0026 [Step] = \u0026 [\n\t\t\tStep {\n\t\t\t\taction: Action::On,\n\t\t\t\torigin: Pos { row: 1, col: 2 },\n\t\t\t\tpeak: Pos { row: 3, col: 4 },\n\t\t\t},\n\t\t\tStep {\n\t\t\t\taction: Action::Off,\n\t\t\t\torigin: Pos { row: 0, col: 200 },\n\t\t\t\tpeak: Pos { row: 100, col: 500 },\n\t\t\t},\n\t\t\tStep {\n\t\t\t\taction: Action::Toggle,\n\t\t\t\torigin: Pos { row: 10, col: 1 },\n\t\t\t\tpeak: Pos { row: 90, col: 79 },\n\t\t\t},\n\t\t];\n\n\t\tconst STEP_TEXTS: \u0026 [\u0026 str] = \u0026 [\n\t\t\t\"turn on 1,2 through 2,3\",\n\t\t\t\"turn off 0,200 through 99,499\",\n\t\t\t\"toggle 10,1 through 89,78\",\n\t\t];\n\n\t\t#[ test ]\n\t\tfn step_parse () {\n\t\t\tassert_eq_ok! (STEPS [0], Step::parse (STEP_TEXTS [0]));\n\t\t\tassert_eq_ok! (STEPS [1], Step::parse (STEP_TEXTS [1]));\n\t\t\tassert_eq_ok! (STEPS [2], Step::parse (STEP_TEXTS [2]));\n\t\t\tassert_err! (\"Invalid input: col 4: on 1,2 through 2,3\",\n\t\t\t\tStep::parse (\"go on 1,2 through 2,3\"));\n\t\t\tassert_err! (\"Invalid input: col 10: 1,2 through 2,3\",\n\t\t\t\tStep::parse (\"turn red 1,2 through 2,3\"));\n\t\t\tassert_err! (\"Invalid input: col 9: 1:2 through 2,3\",\n\t\t\t\tStep::parse (\"turn on 1:2 through 2,3\"));\n\t\t}\n\n\t\t#[ test ]\n\t\tfn parse_input () {\n\t\t\tassert_eq_ok! (STEPS, model::parse_input (STEP_TEXTS));\n\t\t\tassert_err! (\"Invalid input: line 2: col 9: 1:2 through 2,3\",\n\t\t\t\tmodel::parse_input (\u0026 [STEP_TEXTS [0], \"turn on 1:2 through 2,3\" ]));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\t\"turn on 0,0 through 999,999\",\n\t\t\"toggle 0,0 through 999,0\",\n\t\t\"turn off 499,499 through 500,500\",\n\t];\n\n\tconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\t\"turn on 0,0 through 0,0\",\n\t\t\"toggle 0,0 through 999,999\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"998996\", puzzle.part_one (EXAMPLE_0));\n\t\tassert_eq_ok! (\"999999\", puzzle.part_one (EXAMPLE_1));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"1001996\", puzzle.part_two (EXAMPLE_0));\n\t\tassert_eq_ok! (\"2000001\", puzzle.part_two (EXAMPLE_1));\n\t}\n\n}\n","traces":[{"line":11,"address":[200219,199467],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[199568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[200320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[181184,181293],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":29,"address":[181268,181209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[181437,181328],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":33,"address":[181353,181412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[181472],"length":1,"stats":{"Line":1},"fn_name":"mode_fn_one"},{"line":37,"address":[181494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[181528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[181535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[181546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[181584],"length":1,"stats":{"Line":1},"fn_name":"mode_fn_two"},{"line":45,"address":[181606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[181644,181783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[181698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[181708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[181824,184033,185449],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":53,"address":[181917],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[103517,103504],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":58,"address":[182094,182174],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[103552,103561],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":64,"address":[182352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[182400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[182411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[182421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[182432,182551],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[182566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[182618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[184952,182662,182762],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[183225,182982],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[183151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[182996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[183112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[103616,103629],"length":1,"stats":{"Line":6},"fn_name":"{closure#2}"},{"line":79,"address":[183348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[183428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[185268,183489],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[103664,103677],"length":1,"stats":{"Line":8},"fn_name":"{closure#3}"},{"line":84,"address":[183530],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[183537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[183607,184142],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[183701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[183766,183716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[184008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[183953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[183798,183759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[183806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[183892,184023,183984],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[184044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[184154,183652,184634],"length":1,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[184226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[184285,184241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[184523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[184393],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[184318,184278],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[184437,184326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[184462,184538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[184548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[184160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[184887],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[184655,184184,184769,184930],"length":1,"stats":{"Line":6},"fn_name":null},{"line":139,"address":[108192,108216,108369],"length":1,"stats":{"Line":6},"fn_name":"{closure#4}"},{"line":140,"address":[108405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[108248],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[108386],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[108488,108432],"length":1,"stats":{"Line":6},"fn_name":"{closure#5}"},{"line":145,"address":[122496,122515],"length":1,"stats":{"Line":8},"fn_name":"{closure#6}"},{"line":147,"address":[185334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":232,"address":[46229,46224],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":233,"address":[160523,160737,160407],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[160781,160691,161087,160853],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[174416],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":261,"address":[174450,174485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[156608,156946],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":263,"address":[156651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[174528],"length":1,"stats":{"Line":2},"fn_name":"parse_real"},{"line":268,"address":[174566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[174689,174582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[174852,174805,174977,174661],"length":1,"stats":{"Line":6},"fn_name":null},{"line":271,"address":[174949,175102,175141],"length":1,"stats":{"Line":6},"fn_name":null},{"line":272,"address":[175179,175118,175152],"length":1,"stats":{"Line":6},"fn_name":null},{"line":273,"address":[175163,175211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[174821,175261,175291],"length":1,"stats":{"Line":6},"fn_name":null},{"line":276,"address":[177007,175272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[175397,175298,175191],"length":1,"stats":{"Line":4},"fn_name":null},{"line":280,"address":[175833,175715,175518,175364],"length":1,"stats":{"Line":6},"fn_name":null},{"line":283,"address":[175797,175967,176164,176401],"length":1,"stats":{"Line":6},"fn_name":null},{"line":284,"address":[176972,176628,176373,176431],"length":1,"stats":{"Line":6},"fn_name":null},{"line":286,"address":[176861],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[177056],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":295,"address":[156988,157079,156960],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":296,"address":[157006,157059],"length":1,"stats":{"Line":4},"fn_name":null},{"line":297,"address":[157523,157032,157088,157271,157181],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":298,"address":[157297,157140,157207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[157335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[43509,43504],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":334,"address":[200983,201112,201388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":335,"address":[201513,201794,201435,201342],"length":1,"stats":{"Line":3},"fn_name":null},{"line":336,"address":[202197,201748,201841,201919],"length":1,"stats":{"Line":3},"fn_name":null},{"line":337,"address":[202594,202244],"length":1,"stats":{"Line":2},"fn_name":null},{"line":338,"address":[202154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":[202640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":[202613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[203025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[202998],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[43536,43541],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":347,"address":[203596,203495],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[203976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[203891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":373,"address":[37286,36816,37793],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":374,"address":[36823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[36928,36994,36854],"length":1,"stats":{"Line":3},"fn_name":null},{"line":376,"address":[37297,37409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":380,"address":[37824,38801,38294],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":381,"address":[37831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[38002,37862,37936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":383,"address":[38417,38305],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":144,"coverable":146},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-07","src","lib.rs"],"content":"//! Advent of Code 2015: Day 7: Some Assembly Required\n//!\n//! [https://adventofcode.com/2015/day/7](https://adventofcode.com/2015/day/7)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Some Assembly Required\";\n\tyear = 2015;\n\tday = 7;\n\tparse = |input| model::Input::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::WireId;\n\tuse model::WireInput;\n\tuse model::WireVal;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu16\u003e {\n\t\tlet resolved = resolve (\u0026 input, default ());\n\t\tlet a_id: WireId = \"a\".try_into ().unwrap ();\n\t\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\t\tOk (a_val)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu16\u003e {\n\t\tlet resolved = resolve (\u0026 input, default ());\n\t\tlet a_id: WireId = \"a\".try_into ().unwrap ();\n\t\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\t\tlet b_id: WireId = \"b\".try_into ().unwrap ();\n\t\tlet resolved = resolve (\u0026 input, HashMap::from_iter ([ (b_id, a_val) ]));\n\t\tlet a_val = resolved.get (\u0026 a_id).copied ().ok_or (\"No value found for a\") ?;\n\t\tOk (a_val)\n\t}\n\n\tfn resolve (\n\t\tinput: \u0026 Input,\n\t\tmut resolved: HashMap \u003cWireId, WireVal\u003e,\n\t) -\u003e HashMap \u003cWireId, WireVal\u003e {\n\n\t\t// setup data about each wire and their inter-dependencies\n\n\t\t#[ derive (Debug) ]\n\t\tstruct Wire {\n\t\t\tid: WireId,\n\t\t\tinput: WireInput,\n\t\t\tinputs: ArrayVec \u003cWireId, 2\u003e,\n\t\t\toutputs: Vec \u003cWireId\u003e,\n\t\t}\n\n\t\tlet mut wires: HashMap \u003cWireId, Wire\u003e =\n\t\t\tinput.iter ()\n\t\t\t\t.map (|wire| (wire.id.clone (), Wire {\n\t\t\t\t\tid: wire.id.clone (),\n\t\t\t\t\tinput: wire.input.clone (),\n\t\t\t\t\tinputs: ArrayVec::from_iter (wire.input.inputs ().iter ().copied ().cloned ()),\n\t\t\t\t\toutputs: default (),\n\t\t\t\t}))\n\t\t\t\t.collect ();\n\n\t\t// work out which wires we can handle now and later\n\n\t\tlet mut queue = VecDeque::new ();\n\n\t\tfor wire in input.iter () {\n\n\t\t\tfor inpt_id in wire.input.inputs () {\n\t\t\t\tlet inpt_wire = wires.get_mut (inpt_id).unwrap ();\n\t\t\t\tinpt_wire.outputs.push (wire.id.clone ());\n\t\t\t}\n\n\t\t\tif wire.input.inputs ().is_empty () {\n\t\t\t\tqueue.push_back (wire.id.clone ());\n\t\t\t}\n\n\t\t}\n\n\t\t// iterate the ready wires\n\n\t\twhile let Some (id) = queue.pop_front () {\n\t\t\tlet wire = wires.get_mut (\u0026 id).unwrap ();\n\t\t\tlet val = if let Some (\u0026 val) = resolved.get (\u0026 wire.id) {\n\t\t\t    val\n\t\t\t} else {\n\t\t\t\tmatch wire.input.clone () {\n\t\t\t\t\tWireInput::Static (val) =\u003e Some (val),\n\t\t\t\t\tWireInput::Wire (arg) =\u003e resolved.get (\u0026 arg).copied (),\n\t\t\t\t\tWireInput::Not (arg) =\u003e resolved.get (\u0026 arg).copied ().map (|arg| ! arg),\n\t\t\t\t\tWireInput::And (arg_0, arg_1) =\u003e\n\t\t\t\t\t\tresolved.get (\u0026 arg_0)\n\t\t\t\t\t\t\t.and_then (|\u0026 arg_0| resolved.get (\u0026 arg_1)\n\t\t\t\t\t\t\t\t.map (|\u0026 arg_1| arg_0 \u0026 arg_1)),\n\t\t\t\t\tWireInput::AndOne (arg) =\u003e resolved.get (\u0026 arg).map (|\u0026 arg| 1 \u0026 arg),\n\t\t\t\t\tWireInput::Or (arg_0, arg_1) =\u003e\n\t\t\t\t\t\tresolved.get (\u0026 arg_0)\n\t\t\t\t\t\t\t.and_then (|\u0026 arg_0| resolved.get (\u0026 arg_1)\n\t\t\t\t\t\t\t\t.map (|\u0026 arg_1| arg_0 | arg_1)),\n\t\t\t\t\tWireInput::LeftShift (arg_0, arg_1) =\u003e\n\t\t\t\t\t\tresolved.get (\u0026 arg_0).map (|\u0026 arg_0| arg_0 \u003c\u003c arg_1),\n\t\t\t\t\tWireInput::RightShift (arg_0, arg_1) =\u003e\n\t\t\t\t\t\tresolved.get (\u0026 arg_0).map (|\u0026 arg_0| arg_0 \u003e\u003e arg_1),\n\t\t\t\t}.expect (\"Error resolving wire, should not be possible\")\n\t\t\t};\n\t\t\tresolved.insert (wire.id.clone (), val);\n\t\t\tlet wire_id = wire.id.clone ();\n\t\t\tlet wire_outputs = mem::take (\u0026 mut wire.outputs);\n\t\t\tfor outp in wire_outputs {\n\t\t\t\tlet other = wires.get_mut (\u0026 outp).unwrap ();\n\t\t\t\tother.inputs.retain (|other_id| * other_id != wire_id);\n\t\t\t\tif ! other.inputs.is_empty () { continue }\n\t\t\t\tqueue.push_back (other.id.clone ());\n\t\t\t}\n\t\t}\n\n\t\tresolved\n\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn test_resolve () -\u003e GenResult \u003c()\u003e {\n\t\t\tlet wires = Input::parse (\u0026 [\n\t\t\t\t\"123 -\u003e x\",\n\t\t\t\t\"456 -\u003e y\",\n\t\t\t\t\"x AND y -\u003e d\",\n\t\t\t\t\"x OR y -\u003e e\",\n\t\t\t\t\"x LSHIFT 2 -\u003e f\",\n\t\t\t\t\"y RSHIFT 2 -\u003e g\",\n\t\t\t\t\"NOT x -\u003e h\",\n\t\t\t\t\"NOT y -\u003e i\",\n\t\t\t]) ?;\n\t\t\tlet resolved = resolve (\u0026 wires, default ());\n\t\t\tassert_eq! (resolved.len (), 8);\n\t\t\tlet resolve = |id_str: \u0026 str| resolved [\u0026 id_str.try_into ().unwrap ()];\n\t\t\tassert_eq! (resolve (\"d\"), 72);\n\t\t\tassert_eq! (resolve (\"e\"), 507);\n\t\t\tassert_eq! (resolve (\"f\"), 492);\n\t\t\tassert_eq! (resolve (\"g\"), 114);\n\t\t\tassert_eq! (resolve (\"h\"), 65412);\n\t\t\tassert_eq! (resolve (\"i\"), 65079);\n\t\t\tassert_eq! (resolve (\"x\"), 123);\n\t\t\tassert_eq! (resolve (\"y\"), 456);\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\tuse parser::*;\n\n\tpub type WireVal = u16;\n\n\t#[ derive (Clone) ]\n\tpub struct Input (Vec \u003cWire\u003e);\n\n\timpl Deref for Input {\n\t\ttype Target = [Wire];\n\t\tfn deref (\u0026 self) -\u003e \u0026 [Wire] { \u0026 self.0 }\n\t}\n\n\timpl Input {\n\t\tpub fn new (input: Vec \u003cWire\u003e) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet all_wire_ids =\n\t\t\t\tinput.iter ()\n\t\t\t\t\t.map (|wire| wire.id.clone ())\n\t\t\t\t\t.collect::\u003cHashSet \u003c_\u003e\u003e ();\n\t\t\tif all_wire_ids.len () \u003c input.len () {\n\t\t\t\tErr (format! (\"Duplicate wire ids\")) ?;\n\t\t\t}\n\t\t\tif let Some ((wire, input)) =\n\t\t\t\tinput.iter ()\n\t\t\t\t\t.flat_map (|wire| {\n\t\t\t\t\t\tlet wire_id = wire.id.clone ();\n\t\t\t\t\t\twire.input.inputs ().clone ().iter ()\n\t\t\t\t\t\t\t.map (move |\u0026 input| (wire_id.clone (), input.clone ()))\n\t\t\t\t\t\t\t.collect::\u003cArrayVec \u003c_, 2\u003e\u003e ()\n\t\t\t\t\t})\n\t\t\t\t\t.find (|(_, input)| ! all_wire_ids.contains (input)) {\n\t\t\t\tErr (format! (\"Wire {} refers to non-existant input {}\", wire, input)) ?;\n\t\t\t}\n\t\t\tif let Some ((wire, msg)) =\n\t\t\t\tinput.iter ()\n\t\t\t\t\t.filter_map (|wire| match wire.input {\n\t\t\t\t\t\tWireInput::LeftShift (_, val) if WireVal::BITS \u003c= val.as_u32 () =\u003e\n\t\t\t\t\t\t\tSome ((wire.id.clone (), format! (\"Left shift by {} is invalid\", val))),\n\t\t\t\t\t\tWireInput::RightShift (_, val) if WireVal::BITS \u003c= val.as_u32 () =\u003e\n\t\t\t\t\t\t\tSome ((wire.id.clone (), format! (\"Right shift by {} is invalid\", val))),\n\t\t\t\t\t\t_ =\u003e None,\n\t\t\t\t\t})\n\t\t\t\t\t.next () {\n\t\t\t\tErr (format! (\"Wire {} has invalid input: {}\", wire, msg)) ?;\n\t\t\t}\n\t\t\tOk (Input (input))\n\t\t}\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet wires =\n\t\t\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\t\t\tParser::wrap (line, Wire::parse_real)\n\t\t\t\t\t\t.map_parse_err (|col_idx| format! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\t\t\tline_idx + 1, col_idx + 1,\n\t\t\t\t\t\t\t\u0026 line [line.chars ().take (col_idx).map (char::len_utf8).sum () .. ]))\n\t\t\t\t).collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\t\tSelf::new (wires)\n\t\t}\n\t}\n\n\t#[ derive (Clone, Eq, Hash, PartialEq) ]\n\tpub struct WireId (Rc \u003cstr\u003e);\n\n\timpl Wire {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cWire\u003e {\n\t\t\tParser::wrap (input, Self::parse_real)\n\t\t\t\t.map_parse_err (|col_idx| format! (\"Invalid input: col {}\", col_idx + 1))\n\t\t}\n\t\tfn parse_real (parser: \u0026 mut Parser) -\u003e ParseResult \u003cWire\u003e {\n\t\t\tparser.set_ignore_whitespace (true);\n\t\t\tlet valid_id = |word: \u0026 str| word.chars ().all (char::is_lowercase);\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet val = parser.int () ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::Static (val)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg = parser.word_if (valid_id) ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::Wire (arg.try_into () ?)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.expect_word (\"NOT\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::Not (arg_0.try_into () ?)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.word_if (valid_id) ?;\n\t\t\t\t\tlet arg_1 = parser.expect_word (\"AND\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::And (arg_0.try_into () ?, arg_1.try_into () ?)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.expect_word (\"1\") ?.expect_word (\"AND\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::AndOne (arg_0.try_into () ?)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.word_if (valid_id) ?;\n\t\t\t\t\tlet arg_1 = parser.expect_word (\"OR\") ?.confirm ().word_if (valid_id) ?;\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::Or (arg_0.try_into () ?, arg_1.try_into () ?)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.word_if (valid_id) ?;\n\t\t\t\t\tlet arg_1: u16 = parser.expect_word (\"LSHIFT\") ?.confirm ().int () ?;\n\t\t\t\t\tif WireVal::BITS \u003c= arg_1.as_u32 () { Err (parser.err ()) ?; }\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::LeftShift (arg_0.try_into () ?, arg_1)))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tlet arg_0 = parser.word_if (valid_id) ?;\n\t\t\t\t\tlet arg_1: u16 = parser.expect_word (\"RSHIFT\") ?.confirm ().int () ?;\n\t\t\t\t\tif WireVal::BITS \u003c= arg_1.as_u32 () { Err (parser.err ()) ?; }\n\t\t\t\t\tlet id = parser.expect_word (\"-\u003e\") ?.word_if (valid_id) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk ((id.try_into () ?, WireInput::RightShift (arg_0.try_into () ?, arg_1)))\n\t\t\t\t})\n\t\t\t\t.done ()\n\t\t\t\t.map (|(id, input)| Wire { id, input })\n\t\t}\n\t}\n\n\timpl Deref for WireId {\n\t\ttype Target = str;\n\t\tfn deref (\u0026 self) -\u003e \u0026 str { self.0.deref () }\n\t}\n\n\timpl TryFrom \u003c\u0026 str\u003e for WireId {\n\t\ttype Error = GenError;\n\t\tfn try_from (src: \u0026 str) -\u003e GenResult \u003cWireId\u003e {\n\t\t\tif ! src.chars ().all (char::is_lowercase) {\n\t\t\t\tErr (\"Wire ID must be lowercase\") ?;\n\t\t\t}\n\t\t\tOk (WireId (src.to_string ().into ()))\n\t\t}\n\t}\n\n\timpl Display for WireId {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tDisplay::fmt (\u0026 self.0, formatter)\n\t\t}\n\t}\n\n\timpl Debug for WireId {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"WireId ({:?})\", self.0) ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl PartialOrd for WireId {\n\t\tfn partial_cmp (\u0026 self, other: \u0026 WireId) -\u003e Option \u003ccmp::Ordering\u003e {\n\t\t\tPartialOrd::partial_cmp (\u0026 self.0, \u0026 other.0)\n\t\t}\n\t}\n\n\timpl Ord for WireId {\n\t\tfn cmp (\u0026 self, other: \u0026 WireId) -\u003e cmp::Ordering {\n\t\t\tOrd::cmp (\u0026 self.0, \u0026 other.0)\n\t\t}\n\t}\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Wire {\n\t\tpub id: WireId,\n\t\tpub input: WireInput,\n\t}\n\n\t#[ derive (Clone) ]\n\tpub enum WireInput {\n\t\tStatic (WireVal),\n\t\tWire (WireId),\n\t\tNot (WireId),\n\t\tAnd (WireId, WireId),\n\t\tAndOne (WireId),\n\t\tOr (WireId, WireId),\n\t\tLeftShift (WireId, WireVal),\n\t\tRightShift (WireId, WireVal),\n\t}\n\n\timpl Debug for WireInput {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tuse WireInput::*;\n\t\t\tmatch self {\n\t\t\t\tStatic (val) =\u003e write! (formatter, \"Static ({:?})\", val) ?,\n\t\t\t\tWire (arg) =\u003e write! (formatter, \"Wire ({:?})\", arg) ?,\n\t\t\t\tNot (arg) =\u003e write! (formatter, \"Not ({:?})\", arg) ?,\n\t\t\t\tAnd (arg_0, arg_1) =\u003e write! (formatter, \"And ({:?}, {:?})\", arg_0, arg_1) ?,\n\t\t\t\tAndOne (arg) =\u003e write! (formatter, \"AndOne ({:?})\", arg) ?,\n\t\t\t\tOr (arg_0, arg_1) =\u003e write! (formatter, \"Or ({:?}, {:?})\", arg_0, arg_1) ?,\n\t\t\t\tLeftShift (arg_0, arg_1) =\u003e write! (formatter, \"LeftShift ({:?}, {:?})\", arg_0, arg_1) ?,\n\t\t\t\tRightShift (arg_0, arg_1) =\u003e write! (formatter, \"RightShift ({:?}, {:?})\", arg_0, arg_1) ?,\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl WireInput {\n\t\tpub fn inputs (\u0026 self) -\u003e ArrayVec \u003c\u0026 WireId, 2\u003e {\n\t\t\tmatch self {\n\t\t\t\tWireInput::Static (_) =\u003e array_vec! [],\n\t\t\t\tWireInput::Wire (arg) =\u003e array_vec! [ arg ],\n\t\t\t\tWireInput::Not (arg) =\u003e array_vec! [ arg ],\n\t\t\t\tWireInput::And (arg_0, arg_1) =\u003e array_vec! [ arg_0, arg_1 ],\n\t\t\t\tWireInput::AndOne (arg) =\u003e array_vec! [ arg ],\n\t\t\t\tWireInput::Or (arg_0, arg_1) =\u003e array_vec! [ arg_0, arg_1 ],\n\t\t\t\tWireInput::LeftShift (arg_0, _) =\u003e array_vec! [ arg_0 ],\n\t\t\t\tWireInput::RightShift (arg_0, _) =\u003e array_vec! [ arg_0 ],\n\t\t\t}\n\t\t}\n\t}\n\n}\n","traces":[{"line":11,"address":[212251,213019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[212352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[213120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[162814,162744,162240],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":25,"address":[162267,162326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[162394,162333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[162465,162522,162683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[162654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[162832,163818,163903],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":32,"address":[162862,162924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[162992,162931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[163063,163120,163284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[163350,163252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[163413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[163536,163754,163593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[163725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[164914,168151,163920],"length":1,"stats":{"Line":1},"fn_name":"resolve"},{"line":56,"address":[163978],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[143920,143438,144259,143392,143705],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":59,"address":[143474,143547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[143563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[143688,143624,143766],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[143868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[164175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[164230,164306,164498],"length":1,"stats":{"Line":3},"fn_name":null},{"line":72,"address":[164522],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[164774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[164843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[164933],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[165053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[165128,165244,168119,164472],"length":1,"stats":{"Line":3},"fn_name":null},{"line":86,"address":[165218,165391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[165437,165521],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[165513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[165534,166355,167336],"length":1,"stats":{"Line":3},"fn_name":null},{"line":91,"address":[165595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[167227,165642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[144304,144313],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":94,"address":[165774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[166945,165846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[144320,144339,144382],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":97,"address":[144372,144432,144445],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":98,"address":[144489,144480],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":99,"address":[165938],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[166010,166624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[144574,144531,144512],"length":1,"stats":{"Line":4},"fn_name":"{closure#4}"},{"line":102,"address":[144624,144637,144564],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":103,"address":[166036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[144686,144672],"length":1,"stats":{"Line":3},"fn_name":"{closure#5}"},{"line":105,"address":[166118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[144798,144784],"length":1,"stats":{"Line":3},"fn_name":"{closure#6}"},{"line":109,"address":[167352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[167410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[167461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[167520,168012,168084],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[167878,167821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[144923,144896],"length":1,"stats":{"Line":3},"fn_name":"{closure#7}"},{"line":115,"address":[167950],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[168062,167980],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[165267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[49023,48994,46592],"length":1,"stats":{"Line":3},"fn_name":"test_resolve"},{"line":131,"address":[46599,46778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[46900,46736],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[46915,46975,47173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[47083],"length":1,"stats":{"Line":3},"fn_name":null},{"line":144,"address":[47091,47413,47231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[47331,47651,47468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[47706,47886,47569],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[48105,47807,47938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[48157,48324,48032],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[48376,48544,48251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[48471,48763,48596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[48690,48815,48947],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[48910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[117584,117593],"length":1,"stats":{"Line":2},"fn_name":"deref"},{"line":176,"address":[120666,119172,117632],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":177,"address":[117674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[57312,57337],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":181,"address":[117966,117903,118210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[118036,118223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[118529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[57531,57875,57376],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":187,"address":[57422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[57740,57679,57458,57596,57524],"length":1,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[57888,57706,57925],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":192,"address":[58080,58094],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":193,"address":[118775,119044,118643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[119600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[58144,58673,58182],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":198,"address":[58234,58716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[58743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[58277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[58340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[58217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[120113,119829,119714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[120443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[120704,121100,121127],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":210,"address":[59093,59187,59056],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":212,"address":[59114,59167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[59293,59383,59140,59635,59200],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":214,"address":[59409,59252,59319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[59447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[120943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[121152],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":226,"address":[121176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[59824,59854],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":229,"address":[121216],"length":1,"stats":{"Line":1},"fn_name":"parse_real"},{"line":230,"address":[121252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[60061,60016],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":232,"address":[121419,121587,121377,121461,121335,121267,121293,121503,121545],"length":1,"stats":{"Line":9},"fn_name":null},{"line":233,"address":[60112,61218,60371],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":234,"address":[60263,60158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[60230,60579,60379,60716],"length":1,"stats":{"Line":3},"fn_name":null},{"line":236,"address":[60695,60837,60914],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[61228,60894,61035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[61280,62485,62672,61572],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}"},{"line":240,"address":[61458,61326],"length":1,"stats":{"Line":2},"fn_name":null},{"line":241,"address":[61580,61918,61425,61780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[62039,61897,62117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[62097,62238,62511,62413,62682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[64219,62800,63324,64406],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":246,"address":[63072,62846,63207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":247,"address":[63332,63171,63653,63529],"length":1,"stats":{"Line":3},"fn_name":null},{"line":248,"address":[63632,63774,63851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[63831,63972,64245,64416,64147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[66669,64820,64528,66183],"length":1,"stats":{"Line":4},"fn_name":"{closure#4}"},{"line":252,"address":[64574,64706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[64828,65028,64673,65178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":254,"address":[65145,65496,65620,65299],"length":1,"stats":{"Line":3},"fn_name":null},{"line":255,"address":[65599,65741,65818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[66404,65798,66209,65939,66679,66114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[68666,66848,67582,68479],"length":1,"stats":{"Line":3},"fn_name":"{closure#5}"},{"line":259,"address":[66894,67465,67130,67330],"length":1,"stats":{"Line":1},"fn_name":null},{"line":260,"address":[67429,67590,67787,67912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[68033,67891,68111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[68407,68091,68505,68232,68676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[68784,69076,70439,70925],"length":1,"stats":{"Line":4},"fn_name":"{closure#6}"},{"line":265,"address":[68830,68962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[68929,69434,69284,69084],"length":1,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[69555,69401,69752,69876],"length":1,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[69855,69997,70074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[70465,70660,70054,70935,70195,70370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":271,"address":[73009,71396,73209,71104],"length":1,"stats":{"Line":4},"fn_name":"{closure#7}"},{"line":272,"address":[71282,71150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[71404,71249,71706,71604],"length":1,"stats":{"Line":3},"fn_name":null},{"line":274,"address":[71686,71831,71881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[71845,72443,72319,72122],"length":1,"stats":{"Line":3},"fn_name":null},{"line":276,"address":[72564,72641,72422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[72621,72762,72937,73035,73219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[73620,75233,75433,73328],"length":1,"stats":{"Line":4},"fn_name":"{closure#8}"},{"line":280,"address":[73506,73374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[73628,73828,73930,73473],"length":1,"stats":{"Line":3},"fn_name":null},{"line":282,"address":[73910,74055,74105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[74667,74069,74346,74543],"length":1,"stats":{"Line":3},"fn_name":null},{"line":284,"address":[74646,74865,74788],"length":1,"stats":{"Line":2},"fn_name":null},{"line":285,"address":[75443,75259,74986,75161,74845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[75569,75552],"length":1,"stats":{"Line":2},"fn_name":"{closure#9}"},{"line":294,"address":[121727,121664],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":299,"address":[121744],"length":1,"stats":{"Line":1},"fn_name":"try_from"},{"line":300,"address":[121803],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[121864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[121852,121988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[122064],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":309,"address":[122078],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[122112],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":315,"address":[122269,122134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[122262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[122320],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":327,"address":[122448],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":328,"address":[122462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[122480],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":353,"address":[122519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[124476,122564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[124302,122618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[124128,122672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[123889,122726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[122795,123731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[123492,122849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[123272,122918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[123230,122984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[123220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[124640,125127],"length":1,"stats":{"Line":1},"fn_name":"inputs"},{"line":369,"address":[124670],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[124706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[124721,125735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[124758,125633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":373,"address":[124798,125508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":374,"address":[125403,124858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[124898,125278],"length":1,"stats":{"Line":2},"fn_name":null},{"line":376,"address":[124958,125179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":377,"address":[124998],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":134,"coverable":191},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-08","src","lib.rs"],"content":"//! Advent of Code 2015: Day 8: Matchsticks\n//!\n//! [https://adventofcode.com/2015/day/8](https://adventofcode.com/2015/day/8)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Matchsticks\";\n\tyear = 2015;\n\tday = 8;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cusize\u003e {\n\t\tOk (\n\t\t\tinput.iter ()\n\t\t\t\t.map (|(code, value)|\n\t\t\t\t\tcode.chars ().count () - value.chars ().count ())\n\t\t\t\t.sum ()\n\t\t)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cusize\u003e {\n\t\tOk (\n\t\t\tinput.iter ()\n\t\t\t\t.map (|(code, _)| (model::encode (code), code))\n\t\t\t\t.map (|(code, value)|\n\t\t\t\t\tcode.chars ().count () - value.chars ().count ())\n\t\t\t\t.sum ()\n\t\t)\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\tpub type Input = Vec \u003c(String, String)\u003e;\n\n\tpub fn encode (input: \u0026 str) -\u003e String {\n\t\titer::once ('\"')\n\t\t\t.chain (input.chars ().flat_map::\u003cArrayVec \u003cchar, 2\u003e, _\u003e (|ch|\n\t\t\t\tmatch ch {\n\t\t\t\t\t'\\\\' =\u003e array_vec! [ '\\\\', '\\\\' ],\n\t\t\t\t\t'\"' =\u003e array_vec! [ '\\\\', '\"' ],\n\t\t\t\t\tch =\u003e array_vec! [ ch ],\n\t\t\t\t}))\n\t\t\t.chain (iter::once ('\"'))\n\t\t\t.collect ()\n\t}\n\n\tpub fn decode (input: \u0026 str) -\u003e GenResult \u003cString\u003e {\n\t\tParser::wrap (input, decode_real)\n\t\t\t.map_parse_err (|col_idx| format! (\"Invalid input: col {}: {}\", col_idx + 1, input))\n\t}\n\n\tfn decode_real (parser: \u0026 mut Parser) -\u003e ParseResult \u003cString\u003e {\n\t\tparser.expect (\"\\\"\") ?;\n\t\tlet mut result = String::new ();\n\t\tloop {\n\t\t\tmatch parser.expect_next () ? {\n\t\t\t\t'\"' =\u003e break,\n\t\t\t\t'\\\\' =\u003e match parser.expect_next () ? {\n\t\t\t\t\t'x' =\u003e {\n\t\t\t\t\t\tlet digit_high = parser.expect_next () ?.to_digit (16)\n\t\t\t\t\t\t\t.ok_or_else (|| parser.err ()) ?;\n\t\t\t\t\t\tlet digit_low = parser.expect_next () ?.to_digit (16)\n\t\t\t\t\t\t\t.ok_or_else (|| parser.err ()) ?;\n\t\t\t\t\t\tlet ch_code = digit_high \u003c\u003c 4 | digit_low;\n\t\t\t\t\t\tlet ch = char::from_u32 (ch_code).ok_or_else (|| parser.err ()) ?;\n\t\t\t\t\t\tresult.push (ch);\n\t\t\t\t\t},\n\t\t\t\t\t'\\\\' =\u003e result.push ('\\\\'),\n\t\t\t\t\t'\"' =\u003e result.push ('\"'),\n\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t},\n\t\t\t\tch =\u003e result.push (ch),\n\t\t\t}\n\t\t}\n\t\tOk (result)\n\t}\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tinput.iter ().enumerate ()\n\t\t\t.map (|(line_idx, line)|\n\t\t\t\tParser::wrap (line, |parser| Ok ((line.to_string (), decode_real (parser) ?)))\n\t\t\t\t\t.map_parse_err (|col_idx| format! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\t\tline_idx + 1, col_idx + 1, line)))\n\t\t\t.collect ()\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"\\\"\\\"\",\n\t\t\"\\\"abc\\\"\",\n\t\t\"\\\"aaa\\\\\\\"aaa\\\"\",\n\t\t\"\\\"\\\\x27\\\"\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"12\", puzzle.part_one (EXAMPLE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"19\", puzzle.part_two (EXAMPLE));\n\t}\n\n}\n","traces":[{"line":11,"address":[26411,27179],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[26512],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[27280],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[68040,67856],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[67883,67941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[56209,56192,56389],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":25,"address":[56397,56234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[68291,68080],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[68107,68165],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[56474,56432],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":34,"address":[56874,56588,56576],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":35,"address":[56627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[81040,81323,81293],"length":1,"stats":{"Line":1},"fn_name":"encode"},{"line":50,"address":[81083,81157,81281,81240],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[81115],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[53595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[53633,53853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[53648,53769],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[53669,53617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[81273,81191,81316],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[81360],"length":1,"stats":{"Line":0},"fn_name":"decode"},{"line":62,"address":[81417,81383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[53936,53974],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":66,"address":[81456,83865],"length":1,"stats":{"Line":2},"fn_name":"decode_real"},{"line":67,"address":[81573,81486],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[81553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[82143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[81969,81700,81779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[82164,82366,82122],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[82705,82910,83092,82402,82882],"length":1,"stats":{"Line":6},"fn_name":null},{"line":75,"address":[83114,82855,82902,83028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[83367,83538,83004,83162,83339],"length":1,"stats":{"Line":6},"fn_name":null},{"line":77,"address":[54257,54240],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":78,"address":[83460,83600],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[54288,54305],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":80,"address":[83730,83860],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[82437,82687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[82460,82685],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[82378,82470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[81994,82141],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[82021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[83904],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":93,"address":[83954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[54466,54370,54336],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":95,"address":[54480,54441,54380,54518],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":96,"address":[55008,54421,55176,55086,55237],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":97,"address":[55202,55051,55112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[21189,21184],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":117,"address":[72423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[72520,72586,72446],"length":1,"stats":{"Line":3},"fn_name":null},{"line":122,"address":[21221,21216],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":123,"address":[72951],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[73048,72974,73114],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":47,"coverable":53},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-09","src","lib.rs"],"content":"//! Advent of Code 2015: Day 9: All in a Single Night\n//!\n//! [https://adventofcode.com/2015/day/9](https://adventofcode.com/2015/day/9)\n//!\n//! # Input\n//!\n//! Each line represents the distance between two locations in the form \"$0 to $1 = $2\". The first\n//! two parameters are alphanumeric strings representing the locations, tand the third is a\n//! integer representing the distance.\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"All in a Single Night\";\n\tyear = 2015;\n\tday = 9;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::Place;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tsanity_check (\u0026 input) ?;\n\t\tOk (distances (\u0026 input).min ().unwrap ())\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tsanity_check (\u0026 input) ?;\n\t\tOk (distances (\u0026 input).max ().unwrap ())\n\t}\n\n\tfn sanity_check (input: \u0026 Input) -\u003e GenResult \u003c()\u003e {\n\t\tif input.len () \u003e 60 { Err (\"Refusing to handle more than 60 distances\") ?; }\n\t\tlet num_places =\n\t\t\tinput.iter ()\n\t\t\t\t.flat_map (|(from, to, _)| [from, to])\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.count ();\n\t\tif num_places \u003e 10 {\n\t\t\tErr (\"Refusing to handle more than 10 places\") ?;\n\t\t}\n\t\tif input.len () != num_places * (num_places - 1) / 2 {\n\t\t\tErr (\"Wrong number of distances for given number of places\") ?;\n\t\t}\n\t\tOk (())\n\t}\n\n\tfn distances (input: \u0026 Input) -\u003e impl Iterator \u003cItem = u32\u003e {\n\t\tlet (num_places, distances) = gen_dist_table (input);\n\t\tlet mut route = Vec::new ();\n\t\tlet mut used = iter::repeat (false).take (num_places).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut finished = false;\n\t\titer::from_fn (move || {\n\t\t\tif finished { return None }\n\n\t\t\t// find the next free place\n\n\t\t\t#[ inline ]\n\t\t\tfn next (used: \u0026 [bool], start: usize) -\u003e Option \u003cusize\u003e {\n\t\t\t\tused.iter ().copied ().enumerate ()\n\t\t\t\t\t.skip (start)\n\t\t\t\t\t.filter (|\u0026 (_, used)| ! used)\n\t\t\t\t\t.map (|(idx, _)| idx)\n\t\t\t\t\t.next ()\n\t\t\t}\n\n\t\t\t// find a place index we can increment (except first time)\n\n\t\t\tif ! route.is_empty () {\n\t\t\t\tloop {\n\t\t\t\t\tif let Some (val) = route.pop () {\n\t\t\t\t\t\tused [val] = false;\n\t\t\t\t\t\tif let Some (val) = next (\u0026 used, val + 1) {\n\t\t\t\t\t\t\troute.push (val);\n\t\t\t\t\t\t\tused [val] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { finished = true; return None }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// fill in the rest with the minimum possible\n\n\t\t\twhile route.len () \u003c num_places {\n\t\t\t\tlet val = next (\u0026 used, 0).unwrap ();\n\t\t\t\troute.push (val);\n\t\t\t\tused [val] = true;\n\t\t\t}\n\n\t\t\t// return\n\n\t\t\tSome (\n\t\t\t\troute.iter ()\n\t\t\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t\t.map (|(place_0, place_1)| distances [place_0 * num_places + place_1])\n\t\t\t\t\t.sum::\u003cu32\u003e ()\n\t\t\t)\n\n\t\t})\n\t}\n\n\tfn gen_dist_table (input: \u0026 Input) -\u003e (usize, Vec \u003cu32\u003e) {\n\t\tlet place_indexes: HashMap \u003cPlace, usize\u003e =\n\t\t\tinput.iter ()\n\t\t\t\t.flat_map (|(place_0, place_1, _)| [ Rc::clone (place_0), Rc::clone (place_1) ])\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(idx, place)| (place, idx))\n\t\t\t\t.collect ();\n\t\tlet num_places = place_indexes.len ();\n\t\tlet mut distances = iter::repeat (0).take (num_places * num_places).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tfor \u0026 (ref place_0, ref place_1, dist) in input {\n\t\t\tlet place_0 = place_indexes [place_0];\n\t\t\tlet place_1 = place_indexes [place_1];\n\t\t\tdistances [place_0 * num_places + place_1] = dist;\n\t\t\tdistances [place_1 * num_places + place_0] = dist;\n\t\t}\n\t\t(num_places, distances)\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\tpub type Place = Rc \u003cstr\u003e;\n\tpub type Input = Vec \u003c(Place, Place, u32)\u003e;\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tparser.set_ignore_whitespace (true);\n\t\t\t\tlet place_0 = parser.word () ?;\n\t\t\t\tlet place_1 = parser.expect_word (\"to\") ?.word () ?;\n\t\t\t\tlet distance = parser.expect_word (\"=\") ?.int () ?;\n\t\t\t\tif distance \u003c 1 { Err (\"Distance must be at least one\") ?; }\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk ((place_0.into (), place_1.into (), distance))\n\t\t\t}).map_parse_err (|col_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, col_idx + 1, line)\n\t\t\t)\n\t\t).collect ()\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"London to Dublin = 464\",\n\t\t\"London to Belfast = 518\",\n\t\t\"Dublin to Belfast = 141\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"605\", puzzle.part_one (EXAMPLE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"982\", puzzle.part_two (EXAMPLE));\n\t}\n\n}\n\n","traces":[{"line":17,"address":[97467,98219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":18,"address":[97568],"length":1,"stats":{"Line":1},"fn_name":null},{"line":19,"address":[98320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[59117,58768],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":29,"address":[58947,58862,58798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[58935,59042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[59501,59152],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":34,"address":[59331,59246,59182],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[59426,59319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[59536],"length":1,"stats":{"Line":2},"fn_name":"sanity_check"},{"line":39,"address":[59602,59556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[59582,59752],"length":1,"stats":{"Line":4},"fn_name":null},{"line":42,"address":[111968,111952],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":46,"address":[59863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[59889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[60042,59874],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[60180],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[60166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[60336,60810],"length":1,"stats":{"Line":2},"fn_name":"distances"},{"line":56,"address":[60361],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[60433],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[60490,60558],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[60620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[112062,112000,112855],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":61,"address":[112051,112023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[60848],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":67,"address":[60884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[112877,112864],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":70,"address":[112912,112937],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":76,"address":[112037,112091,112480],"length":1,"stats":{"Line":6},"fn_name":null},{"line":78,"address":[112132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[112196,112267],"length":1,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[112270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[112431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[112450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[112231],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[112105,112501,112690],"length":1,"stats":{"Line":6},"fn_name":null},{"line":92,"address":[112544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[112641],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[112660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[112837],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[112515,112705,112779],"length":1,"stats":{"Line":6},"fn_name":null},{"line":102,"address":[112752,112997,112960],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":109,"address":[61040,62264],"length":1,"stats":{"Line":2},"fn_name":"gen_dist_table"},{"line":110,"address":[61090],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[113141,113104],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":116,"address":[113312,113323],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":118,"address":[61353,61290],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[61363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[61769,61574,61507,62259],"length":1,"stats":{"Line":8},"fn_name":null},{"line":121,"address":[61832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[61885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[61946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[62110],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[61664],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[98976],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":140,"address":[99026],"length":1,"stats":{"Line":8},"fn_name":null},{"line":141,"address":[125748,125702,125792,126101,127512],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":142,"address":[125838],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[125987,125854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[125954,126444,126109,126307],"length":1,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[126565,126842,126411,126762],"length":1,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[126987,126826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[127130,126968,127216],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[127188,127347],"length":1,"stats":{"Line":4},"fn_name":null},{"line":149,"address":[127933,125728,127552],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":150,"address":[127595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[95152,95652,95606],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":170,"address":[95159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[95322,95256,95182],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[96180,96134,95680],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":176,"address":[95687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[95784,95850,95710],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":70,"coverable":73},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","src","cycles.rs"],"content":"use super::*;\nuse model::State;\nuse nums::IntConv;\n\n#[ derive (Debug, clap::Parser) ]\npub struct Args {\n\n\t#[ clap (long, default_value = \"20\") ]\n\titerations: usize,\n\n\t#[ clap (long, default_value = \"10\") ]\n\tmax_length: usize,\n\n}\n\n#[ derive (Clone, Eq, Hash, PartialEq) ]\npub struct Span (Rc \u003c[u8]\u003e);\n\nimpl Span {\n\t/*\n\tfn split (\u0026 self) -\u003e Vec \u003cSpan\u003e {\n\t\titer::empty ()\n\t\t\t.chain (iter::once (0))\n\t\t\t.chain (self.iter ().skip (1)\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.filter_map (|(idx, (left, right))| (left != right).then_some (idx + 1)))\n\t\t\t.chain (iter::once (self.len ()))\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.map (|(start, end)| Span::from (\u0026 self [start .. end]))\n\t\t\t.collect ()\n\t}\n\tfn can_split (\u0026 self) -\u003e bool {\n\t\titer::empty ()\n\t\t\t.chain (self.iter ().skip (1)\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.filter_map (|(idx, (left, right))| (left != right).then_some (idx + 1)))\n\t\t\t.next ()\n\t\t\t.is_some ()\n\t}\n\t*/\n}\n\nimpl Debug for Span {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Span (\\\"{}\\\")\", self) ?;\n\t\tOk (())\n\t}\n}\n\nimpl Display for Span {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor \u0026 val in self.0.iter () {\n\t\t\twrite! (formatter, \"{}\", char::from_digit (val.as_u32 (), 10).unwrap ()) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl Borrow \u003c[u8]\u003e for Span {\n\tfn borrow (\u0026 self) -\u003e \u0026 [u8] { \u0026 self.0 }\n}\n\nimpl From \u003c\u0026 [u8]\u003e for Span {\n\tfn from (other: \u0026 [u8]) -\u003e Span {\n\t\tSpan (other.into ())\n\t}\n}\n\nimpl TryFrom \u003c\u0026 str\u003e for Span {\n\ttype Error = GenError;\n\tfn try_from (src: \u0026 str) -\u003e GenResult \u003cSpan\u003e {\n\t\tOk (Span::from (model::State::parse (src) ?.as_slice ()))\n\t}\n}\n\nimpl PartialEq \u003c[u8]\u003e for Span {\n\tfn eq (\u0026 self, other: \u0026 [u8]) -\u003e bool {\n\t\tself.0.as_ref () == other\n\t}\n}\n\nimpl PartialOrd for Span {\n\tfn partial_cmp (\u0026 self, other: \u0026 Span) -\u003e Option \u003cOrdering\u003e {\n\t\tSome (self.cmp (other))\n\t}\n}\n\nimpl Ord for Span {\n\tfn cmp (\u0026 self, other: \u0026 Span) -\u003e Ordering {\n\t\tself.0.len ().cmp (\u0026 other.len ())\n\t\t\t.then (self.0.cmp (\u0026 other.0))\n\t}\n}\n\nimpl Deref for Span {\n\ttype Target = [u8];\n\tfn deref (\u0026 self) -\u003e \u0026 [u8] { self.0.deref () }\n}\n\n#[ derive (Clone, Debug) ]\nenum Destiny {\n\tUnstable (Span),\n\tAtomic (Atomic),\n\tStable (Rc \u003c[Atomic]\u003e),\n}\n\n/*\nstate can be:\n- unstable\n- atomic stable state\n- group of atomic stable states\n*/\n\n#[ derive (Clone, Eq, Hash, PartialEq) ]\nstruct Atomic (Rc \u003cAtomicInner\u003e);\n\nimpl Borrow \u003c[u8]\u003e for Atomic {\n\tfn borrow (\u0026 self) -\u003e \u0026 [u8] { \u0026 self.deref ().key }\n}\n\nimpl Deref for Atomic {\n\ttype Target = AtomicInner;\n\tfn deref (\u0026 self) -\u003e \u0026 AtomicInner { \u0026 self.0 }\n}\n\nimpl From \u003cAtomicInner\u003e for Atomic {\n\tfn from (inner: AtomicInner) -\u003e Atomic {\n\t\tAtomic (Rc::new (inner))\n\t}\n}\n\n#[ derive (Clone) ]\nstruct AtomicInner {\n\tkey: Span,\n\tnext: Rc \u003c[Atomic]\u003e,\n\tfirst: [u8; 3],\n\tlast: u8,\n}\n\nimpl Debug for Atomic {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Atomic ({} next=\", self.key) ?;\n\t\tif self.next.is_empty () { write! (formatter, \"TODO\") ?; }\n\t\tfor (next_idx, next) in self.next.iter ().enumerate () {\n\t\t\tif next_idx \u003e 0 { write! (formatter, \",\") ?; }\n\t\t\twrite! (formatter, \"{}\", next.key) ?;\n\t\t}\n\t\twrite! (formatter, \" first=\") ?;\n\t\tfor item in self.first.iter ().copied () {\n\t\t\twrite! (formatter, \"{}\", char::from_digit (item.as_u32 (), 10).unwrap ()) ?;\n\t\t}\n\t\twrite! (formatter, \" last={})\", self.last) ?;\n\t\tOk (())\n\t}\n}\n\nimpl PartialEq \u003c[u8]\u003e for AtomicInner {\n\tfn eq (\u0026 self, other: \u0026 [u8]) -\u003e bool { self.key == * other }\n}\n\nimpl PartialEq for AtomicInner {\n\tfn eq (\u0026 self, other: \u0026 AtomicInner) -\u003e bool { self.key == other.key }\n}\n\nimpl Eq for AtomicInner {}\n\nimpl Hash for AtomicInner {\n\tfn hash \u003cHr: Hasher\u003e (\u0026 self, hasher: \u0026 mut Hr) {\n\t\tself.key.hash (hasher);\n\t}\n}\n\nimpl PartialOrd \u003c[u8]\u003e for AtomicInner {\n\tfn partial_cmp (\u0026 self, other: \u0026 [u8]) -\u003e Option \u003cOrdering\u003e {\n\t\tself.key.deref ().partial_cmp (other)\n\t}\n}\n\nfn compatible (prev: u8, next: \u0026 [u8]) -\u003e bool {\n\tprev != next [0] \u0026\u0026 prev != next [1] \u0026\u0026 prev != next [2]\n}\n\npub fn run (args: Args) -\u003e GenResult \u003c()\u003e {\n\n\tlet stables = find_stables (args.max_length, args.iterations);\n\tprintln! (\"NUM STABLES: {}\", stables.len ());\n\tprintln! (\"NUM SINGULAR: {}\", stables.values ().filter (|stable|\n\t\tif let Some (stable) = stable { stable.parts.len () == 1 } else { false }).count ());\n\n\tlet mut destinies: HashMap \u003cSpan, Destiny\u003e = HashMap::new ();\n\tlet mut atomics: HashSet \u003cAtomic\u003e = HashSet::new ();\n\n\tfor length in (2 ..= args.max_length).step_by (2) {\n\n\t\t'STATE: for state in (0 .. length).map (|_| (1u8 ..= 3u8))\n\t\t\t.multi_cartesian_product ()\n\t\t\t.map (|nums| State::try_from (nums).unwrap ()) {\n\n\t\t\tlet has_long_run = {\n\t\t\t\tlet group_by_temp =\n\t\t\t\t\tstate.iter ().copied ()\n\t\t\t\t\t\t.group_by (|\u0026 item| item);\n\t\t\t\tgroup_by_temp.into_iter ()\n\t\t\t\t\t.any (|(_, group)| group.count () \u003e 3)\n\t\t\t};\n\t\t\tif has_long_run { continue }\n\n\t\t\tfor prefix_len in (2 ..= length.as_usize () - 2).step_by (2) {\n\t\t\t\tmatch (\n\t\t\t\t\tatomics.get (\u0026 state [ .. prefix_len]),\n\t\t\t\t\tdestinies.get (\u0026 state [prefix_len .. ]).unwrap_or_else (||\n\t\t\t\t\t\tpanic! (\"Can't find destiny for {:?}\", \u0026 state [prefix_len .. ])),\n\t\t\t\t) {\n\t\t\t\t\t(Some (_), Destiny::Unstable (_)) =\u003e continue,\n\t\t\t\t\t(Some (prefix), Destiny::Atomic (suffix)) =\u003e {\n\t\t\t\t\t\tif ! compatible (prefix.last, \u0026 suffix.first) { continue }\n\t\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\t\tDestiny::Stable ([ prefix.clone (), suffix.clone () ].as_slice ().into ()));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t\t(Some (prefix), Destiny::Stable (suffix)) =\u003e {\n\t\t\t\t\t\tif ! compatible (prefix.last, \u0026 suffix [0].first) { continue }\n\t\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\t\tDestiny::Stable (\n\t\t\t\t\t\t\t\titer::once (prefix.clone ())\n\t\t\t\t\t\t\t\t\t.chain (suffix.iter ().cloned ())\n\t\t\t\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t\t\t\t\t\t\t\t\t.into ()));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e continue,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet mut seq_ord = Vec::new ();\n\t\t\tseq_ord.push (state.clone ());\n\t\t\tlet mut seq_set = HashSet::new ();\n\t\t\tseq_set.insert (state.clone ());\n\n\t\t\tlet mut prev_state = state.clone ();\n\t\t\tlet mut left_1 = state [0] == 1;\n\t\t\tlet mut left_2 = state [0] == 2;\n\t\t\tlet mut left_3 = state [0] == 3;\n\n\t\t\tfor _ in 0 .. args.iterations {\n\t\t\t\tlet next_state = logic::one_round (\u0026 prev_state);\n\n\t\t\t\tif let Some (_whatever) = destinies.get (next_state.as_slice ()) {\n\t\t\t\t\t//todo! (\"CHECK FOR EXISTING {} {}\", state, next_state); TODO\n\t\t\t\t}\n\n\t\t\t\tseq_ord.push (next_state.clone ());\n\t\t\t\tseq_set.insert (next_state.clone ());\n\n\t\t\t\tif next_state [0] == 1 { left_1 = true; }\n\t\t\t\tif next_state [0] == 2 { left_2 = true; }\n\t\t\t\tif next_state [0] == 3 { left_3 = true; }\n\n\t\t\t\tif left_1 \u0026\u0026 left_2 \u0026\u0026 left_3 {\n\t\t\t\t\tdestinies.insert (\n\t\t\t\t\t\tstate.as_slice ().into (),\n\t\t\t\t\t\tDestiny::Unstable (seq_ord [1].as_slice ().into ()));\n\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t}\n\n\t\t\t\tprev_state = next_state;\n\t\t\t}\n\n\t\t\tlet mut next_rest = \u0026 seq_ord [1] [ .. ];\n\t\t\tlet mut atomic_next = Vec::new ();\n\t\t\t'OUTER: while ! next_rest.is_empty () {\n\t\t\t\tfor prefix_len in (2 .. next_rest.len ()).step_by (2) {\n\t\t\t\t\tif let Some (prefix_atomic) = atomics.get (\u0026 seq_ord [1] [0 .. prefix_len]) {\n\t\t\t\t\t\tatomic_next.push (prefix_atomic.clone ());\n\t\t\t\t\t\tnext_rest = \u0026 next_rest [ prefix_len .. ];\n\t\t\t\t\t\tcontinue 'OUTER;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//unreachable! (\"Can't find atomics for: {}: {}\", state, seq_ord [1]);\n\t\t\t\tatomic_next.clear ();\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet key: Span = state.as_slice ().into ();\n\t\t\tlet atomic: Atomic = AtomicInner {\n\t\t\t\tkey: key.clone (),\n\t\t\t\tnext: atomic_next.as_slice ().into (),\n\t\t\t\tfirst: [0, 1, 2].map (|idx| seq_ord [idx].first ().copied ().unwrap ()),\n\t\t\t\tlast: seq_ord [0].last ().copied ().unwrap (),\n\t\t\t}.into ();\n\t\t\tatomics.insert (atomic.clone ());\n\t\t\tdestinies.insert (key, Destiny::Atomic (atomic));\n\n\t\t}\n\n\t}\n\n\tprintln! (\"ATOMICS: count={}\", atomics.len ());\n\tfor atomic in atomics.iter ().sorted_by_key (|atomic| atomic.key.clone ()) {\n\t\tprintln! (\" - {:?}\", atomic);\n\t}\n\n\tprintln! (\"DESTINIES: count={}\", destinies.len ());\n\tfor (_key, _destiny) in destinies.iter ().sorted_by_key (|\u0026 (key, _)| key.clone ()) {\n\t\t//println! (\" - {:?}\", atomic);\n\t}\n\n\ttodo! ();\n\n}\n\nstruct Stable {\n\tparts: Vec \u003cSpan\u003e,\n\tfirst: [u8; 3],\n\tlast: u8,\n}\n\nfn find_stables (max_length: usize, iterations: usize) -\u003e HashMap \u003cSpan, Option \u003cStable\u003e\u003e {\n\n\tlet mut stables: HashMap \u003cSpan, Option \u003cStable\u003e\u003e = HashMap::new ();\n\n\tfor length in (2 ..= max_length).step_by (2) {\n\n\t\t'STATE: for state in (0 .. length).map (|_| (1u8 ..= 3u8))\n\t\t\t.multi_cartesian_product ()\n\t\t\t.map (|nums| State::try_from (nums).unwrap ()) {\n\n\t\t\tlet has_long_run = {\n\t\t\t\tlet group_by_temp =\n\t\t\t\t\tstate.iter ().copied ()\n\t\t\t\t\t\t.group_by (|\u0026 item| item);\n\t\t\t\tgroup_by_temp.into_iter ()\n\t\t\t\t\t.any (|(_, group)| group.count () \u003e 3)\n\t\t\t};\n\t\t\tif has_long_run { continue }\n\n\t\t\tfor prefix_len in (2 ..= length.as_usize () - 2).step_by (2) {\n\t\t\t\tmatch (\n\t\t\t\t\tstables [\u0026 state [ .. prefix_len]].as_ref (),\n\t\t\t\t\tstables [\u0026 state [prefix_len .. ]].as_ref (),\n\t\t\t\t) {\n\t\t\t\t\t(Some (prefix), Some (suffix))\n\t\t\t\t\t\t\tif compatible (prefix.last, \u0026 suffix.first) =\u003e {\n\t\t\t\t\t\tassert_eq! (prefix.parts.len (), 1);\n\t\t\t\t\t\tstables.insert (state.as_slice ().into (), Some (Stable {\n\t\t\t\t\t\t\tparts: prefix.parts.iter ().cloned ()\n\t\t\t\t\t\t\t\t.chain (suffix.parts.iter ().cloned ())\n\t\t\t\t\t\t\t\t.collect (),\n\t\t\t\t\t\t\tfirst: prefix.first,\n\t\t\t\t\t\t\tlast: suffix.last,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e continue,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet mut sequence = Vec::new ();\n\t\t\tsequence.push (state.clone ());\n\n\t\t\tlet mut prev_state = state.clone ();\n\t\t\tlet mut first_seq: ArrayVec \u003cu8, 3\u003e = ArrayVec::new ();\n\t\t\tfirst_seq.push (state.first ().copied ().unwrap ());\n\n\t\t\tlet key = Span::from (state.as_slice ());\n\n\t\t\tfor step_idx in 0 .. iterations {\n\t\t\t\tlet next_state = logic::one_round (\u0026 prev_state);\n\t\t\t\tlet next_first = next_state.first ().copied ().unwrap ();\n\n\t\t\t\t/*\n\t\t\t\tif let Some (whatever) = stables.get (next_state.as_slice ()) {\n\t\t\t\t\ttodo! (\"CHECK FOR EXISTING {} {}\", state, next_state);\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\tsequence.push (next_state.clone ());\n\n\t\t\t\tif ! first_seq.is_full () {\n\t\t\t\t\tfirst_seq.push (next_first);\n\t\t\t\t\tif [1, 2, 3].into_iter ()\n\t\t\t\t\t\t.all (|num_0| first_seq.iter ().copied ()\n\t\t\t\t\t\t\t.any (|num_1| num_0 == num_1)) {\n\t\t\t\t\t\tstables.insert (key.clone (), None);\n\t\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t\t}\n\t\t\t\t} else if first_seq [(step_idx + 1) % 3] != next_first {\n\t\t\t\t\tstables.insert (key.clone (), None);\n\t\t\t\t\tcontinue 'STATE;\n\t\t\t\t}\n\n\t\t\t\tprev_state = next_state;\n\t\t\t}\n\n\t\t\tstables.insert (key.clone (), Some (Stable {\n\t\t\t\tparts: vec! [ key ],\n\t\t\t\tfirst: [ first_seq [0], first_seq [1], first_seq [2] ],\n\t\t\t\tlast: state.last ().copied ().unwrap (),\n\t\t\t}));\n\n\t\t}\n\n\t}\n\n\tstables\n\n}\n\npub trait Intern \u003cItem\u003e where Item: Eq + Hash {\n\ttype Shared;\n\tfn intern (self, item: Item) -\u003e Self::Shared;\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cSelf::Shared\u003e;\n}\n\nimpl \u003cItem\u003e Intern \u003cItem\u003e for \u0026 RefCell \u003cHashSet \u003cRc \u003cItem\u003e\u003e\u003e where Item: Eq + Hash {\n\ttype Shared = Rc \u003cItem\u003e;\n\tfn intern (self, item: Item) -\u003e Rc \u003cItem\u003e {\n\t\tlet mut lock = self.borrow_mut ();\n\t\tuse std::ops::DerefMut;\n\t\tlock.deref_mut ().intern (item)\n\t}\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cRc \u003cItem\u003e\u003e {\n\t\tlet lock = self.borrow ();\n\t\tlock.deref ().get (item).cloned ()\n\t}\n}\n\nimpl \u003cItem\u003e Intern \u003cItem\u003e for \u0026 mut HashSet \u003cRc \u003cItem\u003e\u003e where Item: Eq + Hash {\n\ttype Shared = Rc \u003cItem\u003e;\n\tfn intern (self, item: Item) -\u003e Rc \u003cItem\u003e {\n\t\tif let Some (shared) = self.get (\u0026 item) {\n\t\t\treturn Rc::clone (shared);\n\t\t}\n\t\tlet shared = Rc::new (item);\n\t\t(* self).insert (Rc::clone (\u0026 shared));\n\t\tshared\n\t}\n\tfn intern_get (self, item: \u0026 Item) -\u003e Option \u003cRc \u003cItem\u003e\u003e {\n\t\tself.get (item).cloned ()\n\t}\n}\n","traces":[{"line":46,"address":[380128],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":47,"address":[380290,380150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[380283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[380336],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":54,"address":[380435,380545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[380559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[380535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[380816,380879],"length":1,"stats":{"Line":0},"fn_name":"borrow"},{"line":66,"address":[380896],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":67,"address":[380910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[380960,381292],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":74,"address":[380993,381206],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[381328],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":80,"address":[381347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[381408],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":86,"address":[381422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[381456],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":92,"address":[381531,381602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[381585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[381695,381632],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":120,"address":[381712,381721],"length":1,"stats":{"Line":0},"fn_name":"borrow"},{"line":125,"address":[381776,381820],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":129,"address":[381840],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":130,"address":[381847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[381904],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":144,"address":[382157,381943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[382142,382349,382298,382207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[382809,382331,382503,382594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[382881,382849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[382863,383035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[382767,383332,383242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[383320,383364,383538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[383552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[383972,383802,383523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[383959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[384019,384000],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":164,"address":[384062,384048],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[384096],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":177,"address":[384125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[384192],"length":1,"stats":{"Line":0},"fn_name":"compatible"},{"line":182,"address":[384226],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[384464,385940,393748],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":187,"address":[384506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[384583,384646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[230009,229936],"length":1,"stats":{"Line":0},"fn_name":"{closure#8}"},{"line":190,"address":[230028,229955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[385001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[385016],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[385153,385071,385317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[226016,226040],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":199,"address":[226131,226112],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":202,"address":[385750,385671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[226208,226221],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":205,"address":[385879,385816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[226249,226240],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":208,"address":[385958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[386017,386277,385972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[386632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[386301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[226352],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":214,"address":[226369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[386743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[386795,387835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[388377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[387926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[388059,388432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[386813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[386865,386981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[387720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[387117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[387692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[387314,387620,387250,387653,387565],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[387430,387635,387596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[387265,387775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[386267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[388544,388607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[388622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[388705,388645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[388728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[388743,388803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[388861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[388942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[390620,389024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[389259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[389282,389346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[389482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[389528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[389566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[389648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[389730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[389804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[390290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[389952],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[390077,390345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[389886,390489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[390651,389205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[390748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[390838,390757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[390870,391168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[391192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[391433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[391479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[391158,391582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[391595,390852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[391705,391785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[391809,391885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[226560,226574],"length":1,"stats":{"Line":0},"fn_name":"{closure#5}"},{"line":293,"address":[392120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[392511,392445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[392518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[385299,392764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[226720,226734],"length":1,"stats":{"Line":0},"fn_name":"{closure#6}"},{"line":304,"address":[393160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[393276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[226784,226798],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":322,"address":[394741,399616,393776],"length":1,"stats":{"Line":0},"fn_name":"find_stables"},{"line":324,"address":[393834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[393964,393879,394118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[226848,226872],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":330,"address":[226963,226944],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":333,"address":[394472,394551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[227053,227040],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":336,"address":[394680,394617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[227072,227081],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":339,"address":[394759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[395078,394773,394818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[395430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[395110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[395264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[395597,395514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[395538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[395807,395645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[396378,395866,395776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[395976,396056,396299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[396158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[396353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[396375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[395068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[396649,396586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[396672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[396679,396739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[396771,396831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[397003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[397256,397136,398681,397392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[397432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[397455,397519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[397688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[397726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[397794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[397812,397888,397980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[227184,227200,227283],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":387,"address":[227343,227273,227328],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":388,"address":[398052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[397761,398175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[398351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[397986,398550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[398720,397366,399336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[398754,398812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[398871,398933,399187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[399218,399170],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":176},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","src","lib.rs"],"content":"//! Advent of Code 2015: Day 10: Elves Look, Elves Say\n//!\n//! [https://adventofcode.com/2015/day/10](https://adventofcode.com/2015/day/10)\n\n#![ deny (bindings_with_variant_name) ]\n#![ deny (non_camel_case_types) ]\n#![ deny (non_snake_case) ]\n#![ deny (non_upper_case_globals) ]\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Elves Look, Elves Say\";\n\tyear = 2015;\n\tday = 10;\n\tpart_one = |input| logic::part_one (input [0]);\n\tpart_two = |input| logic::part_two (input [0]);\n\tcommands = [\n\t\t( name = \"internals\"; method = cli::internals; ),\n\t\t( name = \"run\"; method = cli::run; ),\n\t\t( name = \"tracking\"; method = tracking::run; ),\n\t\t( name = \"cycles\"; method = cycles::run; ),\n\t];\n}\n\nmod cycles;\nmod tracking;\n\nmod logic {\n\n\tuse super::*;\n\tuse model::State;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003cu32\u003e {\n\t\tlet input = State::parse (input) ?;\n\t\tOk (\n\t\t\titer::successors (\n\t\t\t\t\tSome (input),\n\t\t\t\t\t|state| Some (one_round (state)))\n\t\t\t\t.nth (40)\n\t\t\t\t.unwrap ()\n\t\t\t\t.len ().as_u32 ()\n\t\t)\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003cu32\u003e {\n\t\tlet input = State::parse (input) ?;\n\t\tOk (\n\t\t\titer::successors (\n\t\t\t\t\tSome (input),\n\t\t\t\t\t|state| Some (one_round (state)))\n\t\t\t\t.nth (50)\n\t\t\t\t.unwrap ()\n\t\t\t\t.len ().as_u32 ()\n\t\t)\n\t}\n\n\tpub fn one_round (state: \u0026 State) -\u003e State {\n\t\tlet group_by =\n\t\t\tstate.iter ().copied ()\n\t\t\t\t.group_by (|\u0026 val| val);\n\t\tgroup_by.into_iter ()\n\t\t\t.flat_map (|(val, group)| [ group.count ().as_u8 (), val ])\n\t\t\t.collect ()\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\t#[ derive (Clone, Eq, Hash, PartialEq) ]\n\tpub struct State (Vec \u003cu8\u003e);\n\n\timpl State {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cState\u003e {\n\t\t\tinput.chars ().map (|ch|\n\t\t\t\tOk (ch.to_digit (10).ok_or (\"Invalid input\") ?.as_u8 ())\n\t\t\t).collect::\u003cGenResult \u003c_\u003e\u003e ()\n\t\t}\n\t\tpub fn iter (\u0026 self) -\u003e SliceIter \u003c'_, u8\u003e {\n\t\t\tself.0.iter ()\n\t\t}\n\t}\n\n\timpl Borrow \u003c[u8]\u003e for State {\n\t\tfn borrow (\u0026 self) -\u003e \u0026 [u8] {\n\t\t\tself.0.as_slice ()\n\t\t}\n\t}\n\n\timpl Deref for State {\n\t\ttype Target = Vec \u003cu8\u003e;\n\t\tfn deref (\u0026 self) -\u003e \u0026 Vec \u003cu8\u003e {\n\t\t\t\u0026 self.0\n\t\t}\n\t}\n\n\timpl FromIterator \u003cu8\u003e for State {\n\t\tfn from_iter \u003cIntoIter\u003e (iter: IntoIter) -\u003e State\n\t\t\t\twhere IntoIter: IntoIterator \u003cItem = u8\u003e {\n\t\t\tState (iter.into_iter ().collect ())\n\t\t}\n\t}\n\n\timpl TryFrom \u003cVec \u003cu8\u003e\u003e for State {\n\t\ttype Error = GenError;\n\t\tfn try_from (nums: Vec \u003cu8\u003e) -\u003e GenResult \u003cState\u003e {\n\t\t\tif nums.iter ().copied ().any (|num| (1 ..= 9).contains (\u0026 num)) {\n\t\t\t\tErr (\"Digits must be 1-9\") ?;\n\t\t\t}\n\t\t\tOk (State (nums))\n\t\t}\n\t}\n\n\timpl Debug for State {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"State (len={}, {})\", self.0.len (), self) ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl Display for State {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfor \u0026 val in self.0.iter () {\n\t\t\t\twrite! (formatter, \"{}\", char::from_digit (val.as_u32 (), 10).unwrap ()) ?;\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl PartialOrd for State {\n\t\tfn partial_cmp (\u0026 self, other: \u0026 State) -\u003e Option \u003cOrdering\u003e {\n\t\t\tSome (Ord::cmp (self, other))\n\t\t}\n\t}\n\n\timpl Ord for State {\n\t\tfn cmp (\u0026 self, other: \u0026 State) -\u003e Ordering {\n\t\t\tOrd::cmp (\u0026 self.0.len (), \u0026 other.0.len ())\n\t\t\t\t.then (Ord::cmp (\u0026 self.0, \u0026 other.0))\n\t\t}\n\t}\n\n}\n\nmod cli {\n\n\tuse super::*;\n\tuse model::State;\n\n\t#[ derive (Debug, clap::Parser) ]\n\tpub struct RunArgs {\n\n\t\t#[ clap (long, default_value = \"inputs/day-10\") ]\n\t\tinput: String,\n\n\t\t#[ clap (conflicts_with = \"input\") ]\n\t\tstate: Option \u003cString\u003e,\n\n\t\t#[ clap (long) ]\n\t\tverbose: bool,\n\n\t\t#[ clap (long, default_value = \"15\") ]\n\t\tloops: u32,\n\n\t\t#[ clap (long, default_value = \"0\") ]\n\t\tkeep_end: usize,\n\n\t\t#[ clap (long, default_value = \"0\") ]\n\t\tkeep_start: usize,\n\n\t}\n\n\tpub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet mut state = if let Some (state) = args.state.as_ref () {\n\t\t\tState::parse (state) ?\n\t\t} else {\n\t\t\tState::parse (\n\t\t\t\tfs::read_to_string (\u0026 args.input) ?\n\t\t\t\t\t.trim ()\n\t\t\t\t\t.split ('\\n')\n\t\t\t\t\t.next ().unwrap ()\n\t\t\t) ?\n\t\t};\n\t\tfor idx in 0 .. {\n\t\t\tprintln! (\"{:2} {:4} {}\", idx, state.len (), state);\n\t\t\tif idx == args.loops { break }\n\t\t\tstate = logic::one_round (\u0026 state);\n\t\t\tif (args.keep_start \u003e 0 || args.keep_end \u003e 0)\n\t\t\t\t\t\u0026\u0026 state.len () \u003e (args.keep_start + args.keep_end) {\n\t\t\t\tstate =\n\t\t\t\t\tstate [ .. args.keep_start].iter ().copied ()\n\t\t\t\t\t\t.chain (state [state.len () - args.keep_end .. ].iter ().copied ())\n\t\t\t\t\t\t.collect ();\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n\n\t#[ derive (Debug, clap::Parser) ]\n\tpub struct InternalsArgs {}\n\n\tpub fn internals (_args: InternalsArgs) -\u003e GenResult \u003c()\u003e {\n\t\tprintln! (\"Data structures:\");\n\t\tfn show_struct \u003cType\u003e () {\n\t\t\tlet name = std::any::type_name::\u003cType\u003e ();\n\t\t\tlet size = mem::size_of::\u003cType\u003e ();\n\t\t\tlet align = mem::align_of::\u003cType\u003e ();\n\t\t\tprintln! (\" - {} {} bytes (align = {})\", name, size, align);\n\t\t}\n\t\tshow_struct::\u003ctracking::Item\u003e ();\n\t\tOk (())\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\tuse model::State;\n\n\t#[ test ]\n\tfn basic () -\u003e GenResult \u003c()\u003e {\n\t\tlet mut state = State::parse (\"1\") ?;\n\t\tfor expect in [ \"11\", \"21\", \"1211\", \"111221\", \"312211\" ] {\n\t\t\tstate = logic::one_round (\u0026 state);\n\t\t\tlet expect = State::parse (expect) ?;\n\t\t\tassert_eq! (expect, state);\n\t\t}\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":12,"address":[131513,130985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[131080,131101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[131608,131629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[370448,370808,370835],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":36,"address":[370481,370687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[370675,370801,370883,370975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[370593],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[96997,96960],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":47,"address":[371072,371432,371459],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":48,"address":[371105,371311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[371507,371299,371425,371599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[371217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[97056,97093],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":59,"address":[371696,371898],"length":1,"stats":{"Line":1},"fn_name":"one_round"},{"line":60,"address":[371734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[97152,97165],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":63,"address":[371800,371859],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[97193,97184],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":79,"address":[416112],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":80,"address":[416162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[453410,453565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[416240],"length":1,"stats":{"Line":1},"fn_name":"iter"},{"line":85,"address":[416249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[416304],"length":1,"stats":{"Line":0},"fn_name":"borrow"},{"line":91,"address":[416313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[416352],"length":1,"stats":{"Line":0},"fn_name":"deref"},{"line":103,"address":[453584,453824,453696],"length":1,"stats":{"Line":2},"fn_name":"from_iter\u003ccore::iter::adapters::GenericShunt\u003ccore::iter::adapters::map::Map\u003ccore::str::iter::Chars, aoc_2015_day_10::model::{impl#0}::parse::{closure_env#0}\u003e, core::result::Result\u003ccore::convert::Infallible, alloc::boxed::Box\u003cdyn std::error::Error, alloc::alloc::Global\u003e\u003e\u003e\u003e"},{"line":105,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[416368,416875],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":112,"address":[416470,416398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[416713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[416582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[416928],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":121,"address":[416953,417165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[417158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[417216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":128,"address":[417380,417244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[417394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[417370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[417648],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":137,"address":[417662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[417696],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":143,"address":[417720,417794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[417776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[318896,315904,316854],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":179,"address":[315990,315919,316883,317089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[316944,317203,316040,317094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[316082,316400,316322],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[316885,317407,317295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[317429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[317845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[317877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[318030,318198,318873,318241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[318209,318103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[318743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[318263,318705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[318446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[317377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[318912],"length":1,"stats":{"Line":0},"fn_name":"internals"},{"line":208,"address":[318916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[318961],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[318966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[451529,451520],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":229,"address":[499555,499271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[500327,499670,499397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[499882],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[500011,500212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[500427,500393,500135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[500484],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":19,"coverable":74},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-10","src","tracking.rs"],"content":"use super::*;\nuse nums::IntConv;\n\n#[ derive (Debug, clap::Parser) ]\npub struct Args {\n\n\t#[ clap (required = true) ]\n\tstate: String,\n\n\t#[ clap (long, default_value = \"1000\") ]\n\tloops: u16,\n\n\t#[ clap (long, default_value = \"65536\") ]\n\tmax_length: usize,\n\n\t#[ clap (long, default_value = \"10\") ]\n\tmin_points: u16,\n\n}\n\npub fn run (args: Args) -\u003e GenResult \u003c()\u003e {\n\tlet mut states = Vec::new ();\n\tstates.push (State::parse (\u0026 args.state) ?);\n\tfor cur_gen in 0u16 .. {\n\t\tif cur_gen == args.loops { break }\n\t\tlet cur_state = states.last ().unwrap ();\n\t\tlet next_state = {\n\t\t\tlet mut items_iter = cur_state.items.iter ().copied ().enumerate ().multipeek ();\n\t\t\tlet mut buffer = None;\n\t\t\tlet mut item_idx = 0;\n\t\t\titer::from_fn (move || {\n\t\t\t\titems_iter.reset_peek ();\n\t\t\t\tlet item_0 = items_iter.peek ().copied ();\n\t\t\t\tlet item_1 = items_iter.peek ().copied ();\n\t\t\t\t// deterine num to output\n\t\t\t\tlet num = match (buffer, item_0) {\n\t\t\t\t\t(Some (buf), _) =\u003e buf,\n\t\t\t\t\t(None, Some ((_, Item { run, .. }))) =\u003e run,\n\t\t\t\t\t(None, None) =\u003e return None,\n\t\t\t\t};\n\t\t\t\t// measure size of run\n\t\t\t\tlet (next_0, next_1) = match item_0 {\n\t\t\t\t\tSome ((_, Item { run, num, .. })) =\u003e (Some (run), Some (num)),\n\t\t\t\t\tNone =\u003e (None, None),\n\t\t\t\t};\n\t\t\t\tlet (next_2, next_3) = match item_1 {\n\t\t\t\t\tSome ((_, Item { run, num, .. })) =\u003e (Some (run), Some (num)),\n\t\t\t\t\tNone =\u003e (None, None),\n\t\t\t\t};\n\t\t\t\tlet buffer_run = buffer.iter ().count ();\n\t\t\t\tlet next_run =\n\t\t\t\t\t[next_0, next_1, next_2, next_3].into_iter ()\n\t\t\t\t\t\t.take_while (|\u0026 next| next == Some (num))\n\t\t\t\t\t\t.count ();\n\t\t\t\tlet run: u8 = (buffer_run + next_run).try_into ().unwrap ();\n\t\t\t\t//println! (\"buf={:?} next=[{:?} {:?} {:?} {:?}] num={} run={}+{}={}\", buffer, next_0, next_1, next_2, next_3, num, buffer_run, next_run, run);\n\t\t\t\t// work out gen and index\n\t\t\t\tlet (gen, idx) = if buffer.is_some () {\n\t\t\t\t\t(cur_gen + 1, item_idx)\n\t\t\t\t} else {\n\t\t\t\t\tlet (_, item_0) = item_0.unwrap ();\n\t\t\t\t\t(item_0.gen, item_0.idx)\n\t\t\t\t};\n\t\t\t\t// update state\n\t\t\t\tlet (iter_adv, buffer_new) = match next_run {\n\t\t\t\t\t0 =\u003e (0, None),\n\t\t\t\t\t1 =\u003e (1, Some (next_1.unwrap ())),\n\t\t\t\t\t2 =\u003e (1, None),\n\t\t\t\t\t3 =\u003e (2, Some (next_3.unwrap ())),\n\t\t\t\t\t_ =\u003e panic! (\"Found run of {} + {} = {}\", buffer_run, next_run, run),\n\t\t\t\t};\n\t\t\t\tfor _ in 0 .. iter_adv { items_iter.next ().unwrap (); }\n\t\t\t\tbuffer = buffer_new;\n\t\t\t\titem_idx += 1;\n\t\t\t\t// produce value\n\t\t\t\tSome (Item { run, num, gen, idx })\n\t\t\t})\n\t\t}.take (args.max_length * 2 / 3).collect ();\n\t\tstates.push (next_state);\n\t}\n\t// print states\n\tfor (state_gen, state) in states.iter ().enumerate () {\n\t\tlet state_gen = state_gen.as_u16 ();\n\t\tlet mut align_iter =\n\t\t\tstates.last ().unwrap ().items.iter ().copied ()\n\t\t\t\t.map (|Item { gen, idx, .. }| (gen, idx))\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(col, (gen, idx))| ((gen, idx), col * 3))\n\t\t\t\t.filter (|\u0026 ((gen, _), _)| gen \u003c= state_gen);\n\t\tlet (mut align_key, mut align_col) = align_iter.next ().unwrap ();\n\t\tlet mut col = 0;\n\t\tfor \u0026 Item { gen, idx, run, num } in state.items.iter () {\n\t\t\tlet item_key = (gen, idx);\n\t\t\tif item_key == align_key {\n\t\t\t\twhile col \u003c align_col { print! (\" \"); col += 1; }\n\t\t\t\tprint! (\"|\"); col += 1;\n\t\t\t\t(align_key, align_col) = align_iter.next ().unwrap_or (((0, 0), 0));\n\t\t\t}\n\t\t\t//print! (\"[{}:{}]\", gen, idx);\n\t\t\tprint! (\"{}{}\", run, num); col += 2;\n\t\t}\n\t\tprint! (\"\\n\");\n\t}\n\tOk (())\n}\n\npub struct State {\n\titems: Vec \u003cItem\u003e,\n}\n\nimpl State {\n\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cSelf\u003e {\n\t\tlet state = model::State::parse (input) ?.try_into () ?;\n\t\tOk (state)\n\t}\n}\n\nimpl FromIterator \u003cItem\u003e for State {\n\tfn from_iter \u003cIntoIter\u003e (iter: IntoIter) -\u003e State\n\t\t\twhere IntoIter: IntoIterator \u003cItem = Item\u003e {\n\t\tState {\n\t\t\titems: iter.into_iter ().collect (),\n\t\t}\n\t}\n}\n\nimpl TryFrom \u003cmodel::State\u003e for State {\n\ttype Error = GenError;\n\tfn try_from (state: model::State) -\u003e GenResult \u003cState\u003e {\n\t\tif state.len () % 2 != 0 {\n\t\t\tErr (\"TrackingState requires an even numbers of items\") ?;\n\t\t}\n\t\tOk (State {\n\t\t\titems: state.iter ().copied ()\n\t\t\t\t.tuples::\u003c(_, _)\u003e ()\n\t\t\t\t.enumerate ()\n\t\t\t\t.map (|(idx, (run, num))|\n\t\t\t\t\tOk (Item {\n\t\t\t\t\t\tgen: 0,\n\t\t\t\t\t\tidx: idx.try_into () ?,\n\t\t\t\t\t\trun,\n\t\t\t\t\t\tnum,\n\t\t\t\t\t}))\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?,\n\t\t})\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub struct Item { run: u8, num: u8, gen: u16, idx: u32 }\n","traces":[{"line":21,"address":[208590,205312,206641],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":22,"address":[205327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[205398,205482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[205798,205971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[205995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[206009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[206616,206492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[206109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[206272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[206280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[459246,458928,461473,461433],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":32,"address":[458978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[458991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[459033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[459075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[459194],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[459251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[459240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[459274,459476,459215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[459356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[459276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[459548,459775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[459647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[459567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[459853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[460035,459922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[460019,461502,461488],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":55,"address":[460085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[460403,460528,460208,460371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[460373,460320],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[460482,460231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[460498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[461003,460442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[460559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[460622,461107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[460656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[460719,460946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[460530,460753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[461056,461177,461291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[461252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[461261,461435,461365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[461368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[206631,206441,206523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[206652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[206971,205937,206728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[207011],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[207054,207356],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[461568,461591],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":88,"address":[461632,461653],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":89,"address":[207348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[207403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[207494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[208510,207709,207506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[207782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[208311,207813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[207866,207926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[207884,208059,208138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[208131,208171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[207834,208336,208515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[208548,207667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[206941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[208608],"length":1,"stats":{"Line":0},"fn_name":"parse"},{"line":113,"address":[208850,208640,209054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[208966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[461824],"length":1,"stats":{"Line":0},"fn_name":"from_iter\u003ccore::iter::adapters::take::Take\u003ccore::iter::sources::from_fn::FromFn\u003caoc_2015_day_10::tracking::run::{closure_env#0}\u003e\u003e\u003e"},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[209120,209869],"length":1,"stats":{"Line":0},"fn_name":"try_from"},{"line":130,"address":[209150,209204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[209260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[209688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[209240,209422,209823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[461936,461955,462092,462116],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":138,"address":[462057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[462099,461985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[209791],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":75},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-11","src","lib.rs"],"content":"//! Advent of Code 2015: Day 11: Corporate Policy\n//!\n//! [https://adventofcode.com/2015/day/11](https://adventofcode.com/2015/day/11)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Corporate Policy\";\n\tyear = 2015;\n\tday = 11;\n\tpart_one = |input| logic::part_one (input [0]);\n\tpart_two = |input| logic::part_two (input [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tconst ALL_CHARS: \u0026 [char] = \u0026 [\n\t\t'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\n\t\t's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n\t];\n\n\tconst DISALLOWED_CHARS: \u0026 [char] = \u0026 [ 'i', 'l', 'o' ];\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003cString\u003e {\n\t\tlet password = next_password (input) ?;\n\t\tOk (password)\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003cString\u003e {\n\t\tlet password_0 = next_password (input) ?;\n\t\tlet password_1 = next_password (\u0026 password_0) ?;\n\t\tOk (password_1)\n\t}\n\n\tpub fn next_password (input: \u0026 str) -\u003e GenResult \u003cString\u003e {\n\t\tlet disallowed_idxs =\n\t\t\tDISALLOWED_CHARS.iter ().copied ()\n\t\t\t\t.map (|ch| ALL_CHARS.iter ().copied ()\n\t\t\t\t\t.position (|other_ch| ch == other_ch)\n\t\t\t\t\t.unwrap ())\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut char_idxs: Vec \u003cusize\u003e =\n\t\t\tinput.chars ()\n\t\t\t\t.map (|ch| ALL_CHARS.iter ().copied ()\n\t\t\t\t\t.position (|valid_ch| ch == valid_ch)\n\t\t\t\t\t.ok_or_else (|| format! (\"Input contains invalid character: {}\", ch).into ()))\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\tfn idxs_to_chars (char_idxs: \u0026 [usize]) -\u003e impl Iterator \u003cItem = char\u003e + '_ + Clone {\n\t\t\tchar_idxs.iter ().copied ().map (|idx| ALL_CHARS [idx])\n\t\t}\n\t\tif let Some (idx) =\n\t\t\tchar_idxs.iter ().copied ()\n\t\t\t\t.position (|idx| disallowed_idxs.contains (\u0026 idx)) {\n\t\t\tchar_idxs [idx] += 1;\n\t\t\tchar_idxs.iter_mut ().skip (idx + 1).for_each (|ch| * ch = 0);\n\t\t}\n\t\tlet new_password = loop {\n\t\t\tfor idx in (0 .. char_idxs.len ()).rev () {\n\t\t\t\tchar_idxs [idx] += 1;\n\t\t\t\tif char_idxs [idx] \u003c ALL_CHARS.len () \u0026\u0026 (idx \u003c char_idxs.len () - 2\n\t\t\t\t\t\t|| find_pair (idxs_to_chars (\u0026 char_idxs [ .. char_idxs.len () - 2]))\n\t\t\t\t\t\t\t.is_some ())\n\t\t\t\t\t{ break }\n\t\t\t\tif disallowed_idxs.contains (\u0026 char_idxs [idx]) { char_idxs [idx] += 1; }\n\t\t\t\tchar_idxs [idx] = 0;\n\t\t\t}\n\t\t\tif is_valid (idxs_to_chars (\u0026 char_idxs)) {\n\t\t\t\tbreak char_idxs.iter ().copied ()\n\t\t\t\t\t.map (|idx| ALL_CHARS [idx])\n\t\t\t\t\t.collect::\u003cString\u003e ();\n\t\t\t}\n\t\t};\n\t\tOk (new_password)\n\t}\n\n\tpub fn is_valid \u003cInpt\u003e (input: Inpt) -\u003e bool\n\t\t\twhere Inpt: Iterator \u003cItem = char\u003e + Clone {\n\t\tif ! input.clone ()\n\t\t\t.tuple_windows::\u003c(_, _, _)\u003e ()\n\t\t\t.any (|(a, b, c)| a.as_u32 () + 1 == b.as_u32 () \u0026\u0026 b.as_u32 () + 1 == c.as_u32 ())\n\t\t\t{ return false }\n\t\tif input.clone ()\n\t\t\t.any (|ch| DISALLOWED_CHARS.contains (\u0026 ch))\n\t\t\t{ return false }\n\t\tif input.fold ((0, None, None), |(sum, last, prev), next|\n\t\t\tif last == Some (next) \u0026\u0026 prev != Some (next) {\n\t\t\t\t(sum + 1, None, Some (next))\n\t\t\t} else {\n\t\t\t\t(sum, Some (next), prev)\n\t\t\t}\n\t\t).0 \u003c 2 { return false }\n\t\ttrue\n\t}\n\n\tpub fn find_pair \u003cInpt\u003e (input: Inpt) -\u003e Option \u003c(usize, char)\u003e\n\t\t\twhere Inpt: Iterator \u003cItem = char\u003e + Clone {\n\t\tinput\n\t\t\t.tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t.filter (|(a, b)| a == b)\n\t\t\t.map (|(a, _)| a)\n\t\t\t.enumerate ()\n\t\t\t.next ()\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn is_valid () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (false, logic::is_valid (\"hijklmmn\".chars ()));\n\t\t\tassert_eq! (false, logic::is_valid (\"abbceffg\".chars ()));\n\t\t\tassert_eq! (false, logic::is_valid (\"abbcegjk\".chars ()));\n\t\t\tOk (())\n\t\t}\n\n\t\t#[ test ]\n\t\tfn next_password () -\u003e GenResult \u003c()\u003e {\n\t\t\tassert_eq! (\"abcdffaa\", logic::next_password (\"abcdefgh\") ?);\n\t\t\tassert_eq! (\"ghjaabcc\", logic::next_password (\"ghijklmn\") ?);\n\t\t\tOk (())\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":7,"address":[90409,91065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[90504,90525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[91160,91181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[43152],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":28,"address":[43381,43184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[43293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[44062,43440],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":33,"address":[43593,43473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[43704,43973,43572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[43861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[44096,46910,46940],"length":1,"stats":{"Line":1},"fn_name":"next_password"},{"line":39,"address":[44151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[86416,86429,86493],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":42,"address":[86560,86572,86483],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":45,"address":[44626,44388,44305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[86729,86615,86679,86592],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":48,"address":[86752,86764,86669],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":49,"address":[86784,86719,86796],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":51,"address":[46960],"length":1,"stats":{"Line":1},"fn_name":"idxs_to_chars"},{"line":52,"address":[46974],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[44942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[44863],"length":1,"stats":{"Line":3},"fn_name":null},{"line":57,"address":[45049,45125,44977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[87136,87149],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":61,"address":[45585,45323,45011,46611],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[45734,45609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[45775,45700,45986,46273],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[45959,46023],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[46301,46496],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[46457,46604],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[46632,45547],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[46683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[87187,87168],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":76,"address":[46828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[87264,87712,88101,87653],"length":1,"stats":{"Line":2},"fn_name":"is_valid\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003cusize\u003e\u003e, aoc_2015_day_11::logic::next_password::idxs_to_chars::{closure_env#0}\u003e\u003e"},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[89344,89472],"length":1,"stats":{"Line":1},"fn_name":"find_pair\u003ccore::iter::adapters::map::Map\u003ccore::iter::adapters::copied::Copied\u003ccore::slice::iter::Iter\u003cusize\u003e\u003e, aoc_2015_day_11::logic::next_password::idxs_to_chars::{closure_env#0}\u003e\u003e"},{"line":100,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[39840],"length":1,"stats":{"Line":3},"fn_name":"is_valid"},{"line":115,"address":[40012,39847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[39973,40070,40210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[40268,40404,40171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[40368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[40847,40464],"length":1,"stats":{"Line":3},"fn_name":"next_password"},{"line":123,"address":[40471,40730],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[41152,40873],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[41278],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":61},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-12","src","lib.rs"],"content":"//! Advent of Code 2015: Day 12: JSAbacusFramework.io\n//!\n//! [https://adventofcode.com/2015/day/12](https://adventofcode.com/2015/day/12)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"JSAbacusFramework.io\";\n\tyear = 2015;\n\tday = 12;\n\tpart_one = |input| logic::part_one (input [0]);\n\tpart_two = |input| logic::part_two (input [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::*;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003ci32\u003e {\n\t\tlet input = Json::parse (input) ?;\n\t\tlet sum = calc_sum (\u0026 input);\n\t\tOk (sum)\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003ci32\u003e {\n\t\tlet input = Json::parse (input) ?;\n\t\tlet sum = calc_sum_no_red (\u0026 input);\n\t\tOk (sum)\n\t}\n\n\tpub fn calc_sum (value: \u0026 Json) -\u003e i32 {\n\t\tmatch value {\n\t\t\tJson::Array (items) =\u003e items.iter ().map (calc_sum).sum (),\n\t\t\tJson::Object (items) =\u003e items.iter ().map (|(_, item)| calc_sum (item)).sum (),\n\t\t\t\u0026 Json::Number (value) =\u003e value.as_i32 (),\n\t\t\tJson::String (_) =\u003e 0,\n\t\t}\n\t}\n\n\tpub fn calc_sum_no_red (value: \u0026 Json) -\u003e i32 {\n\t\tmatch value {\n\t\t\tJson::Array (items) =\u003e items.iter ().map (calc_sum_no_red).sum (),\n\t\t\tJson::Object (items) =\u003e {\n\t\t\t\tif ! items.iter ().any (|(_, value)|\n\t\t\t\t\tif let Json::String (value) = value {\n\t\t\t\t\t\tvalue == \"red\"\n\t\t\t\t\t} else { false }\n\t\t\t\t) {\n\t\t\t\t\titems.iter ().map (|(_, item)| calc_sum_no_red (item)).sum ()\n\t\t\t\t} else { 0 }\n\t\t\t},\n\t\t\t\u0026 Json::Number (value) =\u003e value.as_i32 (),\n\t\t\tJson::String (_) =\u003e 0,\n\t\t}\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\t#[ derive (Debug) ]\n\tpub enum Json {\n\t\tArray (Vec \u003cJson\u003e),\n\t\tObject (Vec \u003c(String, Json)\u003e),\n\t\tNumber (i32),\n\t\tString (String),\n\t}\n\n\timpl Json {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cJson\u003e {\n\t\t\tuse parser::*;\n\t\t\tfn parse_item (parser: \u0026 mut Parser) -\u003e ParseResult \u003cJson\u003e {\n\t\t\t\tparser.any ()\n\t\t\t\t\t.of (|parser| {\n\t\t\t\t\t\tlet mut items = Vec::new ();\n\t\t\t\t\t\tparser.skip_whitespace ().expect (\"[\") ?;\n\t\t\t\t\t\tif parser.skip_whitespace ().peek () == Some (']') {\n\t\t\t\t\t\t\tparser.next ();\n\t\t\t\t\t\t\treturn Ok (Json::Array (items));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\titems.push (parse_item (parser) ?);\n\t\t\t\t\t\t\tmatch parser.skip_whitespace ().next () {\n\t\t\t\t\t\t\t\tSome (',') =\u003e continue,\n\t\t\t\t\t\t\t\tSome (']') =\u003e break,\n\t\t\t\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOk (Json::Array (items))\n\t\t\t\t\t})\n\t\t\t\t\t.of (|parser| {\n\t\t\t\t\t\tlet mut items = Vec::new ();\n\t\t\t\t\t\tparser.skip_whitespace ().expect (\"{\") ?;\n\t\t\t\t\t\tif parser.skip_whitespace ().peek () == Some ('}') {\n\t\t\t\t\t\t\tparser.next ();\n\t\t\t\t\t\t\treturn Ok (Json::Object (items));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloop {\n\t\t\t\t\t\t\tlet name = parse_string (parser) ?;\n\t\t\t\t\t\t\tparser.skip_whitespace ().expect (\":\") ?;\n\t\t\t\t\t\t\tlet value = parse_item (parser) ?;\n\t\t\t\t\t\t\titems.push ((name, value));\n\t\t\t\t\t\t\tmatch parser.skip_whitespace ().next () {\n\t\t\t\t\t\t\t\tSome (',') =\u003e continue,\n\t\t\t\t\t\t\t\tSome ('}') =\u003e break,\n\t\t\t\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tOk (Json::Object (items))\n\t\t\t\t\t})\n\t\t\t\t\t.of (|parser| {\n\t\t\t\t\t\tlet value = parser.skip_whitespace ().int () ?;\n\t\t\t\t\t\tOk (Json::Number (value))\n\t\t\t\t\t})\n\t\t\t\t\t.of (|parser| {\n\t\t\t\t\t\tlet value = parse_string (parser) ?;\n\t\t\t\t\t\tOk (Json::String (value))\n\t\t\t\t\t})\n\t\t\t\t\t.done ()\n\t\t\t}\n\t\t\tfn parse_string (parser: \u0026 mut Parser) -\u003e ParseResult \u003cString\u003e {\n\t\t\t\tparser.skip_whitespace ().expect (\"\\\"\") ?;\n\t\t\t\tlet mut value = String::new ();\n\t\t\t\tloop {\n\t\t\t\t\tmatch parser.next () {\n\t\t\t\t\t\tSome ('\\\\') =\u003e todo! (),\n\t\t\t\t\t\tSome ('\"') =\u003e break,\n\t\t\t\t\t\tSome (ch) =\u003e value.push (ch),\n\t\t\t\t\t\tNone =\u003e Err (parser.err ()) ?,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tOk (value)\n\t\t\t}\n\t\t\tParser::wrap (input, |parser| {\n\t\t\t\tlet item = parse_item (parser) ?;\n\t\t\t\tparser.skip_whitespace ().end () ?;\n\t\t\t\tOk (item)\n\t\t\t}).map_parse_err (|char_idx| format! (\"Invalid input: col {}\", char_idx + 1))\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (6, logic::part_one (\"[1,2,3]\") ?);\n\t\tassert_eq! (6, logic::part_one (\"{\\\"a\\\":2,\\\"b\\\":4}\") ?);\n\t\tassert_eq! (3, logic::part_one (\"[[[3]]]\") ?);\n\t\tassert_eq! (3, logic::part_one (\"{\\\"a\\\":{\\\"b\\\":4},\\\"c\\\":-1}\") ?);\n\t\tassert_eq! (0, logic::part_one (\"{\\\"a\\\":[-1,1]}\") ?);\n\t\tassert_eq! (0, logic::part_one (\"[-1,{\\\"a\\\":1}]\") ?);\n\t\tassert_eq! (0, logic::part_one (\"[]\") ?);\n\t\tassert_eq! (0, logic::part_one (\"{}\") ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (6, logic::part_two (\"[1,2,3]\") ?);\n\t\tassert_eq! (4, logic::part_two (\"[1,{\\\"c\\\":\\\"red\\\",\\\"b\\\":2},3]\") ?);\n\t\tassert_eq! (0, logic::part_two (\"{\\\"d\\\":\\\"red\\\",\\\"e\\\":[1,2,3,4],\\\"f\\\":5}\") ?);\n\t\tassert_eq! (6, logic::part_two (\"[1,\\\"red\\\",5]\") ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[21465,21993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[21560,21581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[22088,22109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[58847,58576],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[58609,58723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[58819,58707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[58826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[58880,59151],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":28,"address":[58913,59027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[59011,59123],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[59130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[59184],"length":1,"stats":{"Line":1},"fn_name":"calc_sum"},{"line":34,"address":[59201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[59236,59430],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[47033,47008],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":37,"address":[59307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[59329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[59504],"length":1,"stats":{"Line":1},"fn_name":"calc_sum_no_red"},{"line":43,"address":[59527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[59571,59882],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[59611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[47156,47072,47086],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":47,"address":[47103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[47126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[47151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[47184,47209],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":52,"address":[59762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[59653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[59678],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[71424],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":76,"address":[71488],"length":1,"stats":{"Line":2},"fn_name":"parse_item"},{"line":77,"address":[71513],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[54508,54455,54237,54489,53024],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":79,"address":[53062],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[53151,53260,53093],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[53236,53393],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[53487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[53503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[54327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[53472,53685],"length":1,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[53923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[54242,54337,54041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[54068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[56867,54528,56834,56909,56890,56566],"length":1,"stats":{"Line":7},"fn_name":"{closure#1}"},{"line":96,"address":[54566],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[54780,54613,54671],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[54756,54913],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[55007],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[55023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[56672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[55205,54992,55332],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[55308,55623,55506],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[56049,55776,55608],"length":1,"stats":{"Line":3},"fn_name":null},{"line":106,"address":[55877],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[56221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[56333,56571,56682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[56397],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[57214,57124,56928],"length":1,"stats":{"Line":5},"fn_name":"{closure#2}"},{"line":116,"address":[56972,57131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":117,"address":[57051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[57558,57666,57232],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":120,"address":[57565,57278],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[57405],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[72429,71632],"length":1,"stats":{"Line":2},"fn_name":"parse_string"},{"line":126,"address":[71670,71773],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[71753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[72005,71882,71945],"length":1,"stats":{"Line":6},"fn_name":null},{"line":132,"address":[72032,72195],"length":1,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[71983,72202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[72099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[57696,57977,58210,58348],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":139,"address":[57742,57863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[58026,58220,57840],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[58103],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[58414,58333,58384,57990],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":154,"address":[49568,49577],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":155,"address":[40663,40969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[41013,41267,40929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[41565,41230,41311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[41609,41863,41528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[42161,41826,41907],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[42124,42459,42205],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[42503,42422,42757],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[43045,42801,42720],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[43018],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[43104],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":168,"address":[43369,43111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[43413,43332,43661],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[43705,43953,43624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[44232,43997,43916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[44208],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":79,"coverable":91},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-13","src","lib.rs"],"content":"//! Advent of Code 2015: Day 13: Knights of the Dinner Table\n//!\n//! [https://adventofcode.com/2015/day/13](https://adventofcode.com/2015/day/13)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Knights of the Dinner Table\";\n\tyear = 2015;\n\tday = 13;\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\n\tpub fn part_one (input: \u0026 [\u0026 str]) -\u003e GenResult \u003ci32\u003e {\n\t\tlet input = model::parse_input (input) ?;\n\t\tlet best = calc_best (\u0026 input);\n\t\tOk (best)\n\t}\n\n\tpub fn part_two (input: \u0026 [\u0026 str]) -\u003e GenResult \u003ci32\u003e {\n\t\tlet mut input = model::parse_input (input) ?;\n\t\tlet my_scores =\n\t\t\tinput.iter ()\n\t\t\t\t.map (|(name, _, _)| name)\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.flat_map (|name| [\n\t\t\t\t\t(\"Myself\".to_string (), name.to_string (), 0),\n\t\t\t\t\t(name.to_string (), \"Myself\".to_string (), 0),\n\t\t\t\t])\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tinput.extend (my_scores);\n\t\tlet best = calc_best (\u0026 input);\n\t\tOk (best)\n\t}\n\n\tpub fn calc_best (input: \u0026 Input) -\u003e i32 {\n\t\tlet names: Vec \u003c_\u003e =\n\t\t\tinput.iter ()\n\t\t\t\t.map (|(name, _, _)| name)\n\t\t\t\t.sorted ()\n\t\t\t\t.dedup ()\n\t\t\t\t.map (String::to_owned)\n\t\t\t\t.collect ();\n\t\tlet scores =\n\t\t\tinput.iter ().cloned ()\n\t\t\t\t.chain (names.iter ().map (|name| (name.to_string (), name.to_string (), 0)))\n\t\t\t\t.sorted ()\n\t\t\t\t.map (|(_, _, score)| score)\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\t(0 .. names.len ())\n\t\t\t.permutations (names.len ())\n\t\t\t.map (|plan| plan.iter ()\n\t\t\t\t.circular_tuple_windows::\u003c(_, _)\u003e ()\n\t\t\t\t.map (|indexes| {\n\t\t\t\t\tlet score_0 = scores [indexes.0 * names.len () + indexes.1];\n\t\t\t\t\tlet score_1 = scores [indexes.1 * names.len () + indexes.0];\n\t\t\t\t\tscore_0 + score_1\n\t\t\t\t})\n\t\t\t\t.sum ())\n\t\t\t.max ()\n\t\t\t.unwrap ()\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Item = (String, String, i32);\n\tpub type Input = Vec \u003cItem\u003e;\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tparser\n\t\t\t\t\t.set_word_pred (char::is_alphabetic)\n\t\t\t\t\t.set_ignore_whitespace (true);\n\t\t\t\tlet name_0 = parser.word () ?;\n\t\t\t\tlet verb = parser.expect_word (\"would\") ?.word () ?;\n\t\t\t\tlet amount: i32 = parser.int () ?;\n\t\t\t\tlet amount = match verb {\n\t\t\t\t\t\"gain\" =\u003e amount,\n\t\t\t\t\t\"lose\" =\u003e - amount,\n\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t};\n\t\t\t\tlet name_1 = parser.expect (\"happiness units by sitting next to \") ?.word () ?;\n\t\t\t\tparser.expect (\".\") ?.end () ?;\n\t\t\t\tOk ((name_0.into (), name_1.into (), amount))\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, char_idx + 1, line)\n\t\t\t)\n\t\t).collect ()\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"Alice would gain 54 happiness units by sitting next to Bob.\",\n\t\t\"Alice would lose 79 happiness units by sitting next to Carol.\",\n\t\t\"Alice would lose 2 happiness units by sitting next to David.\",\n\t\t\"Bob would gain 83 happiness units by sitting next to Alice.\",\n\t\t\"Bob would lose 7 happiness units by sitting next to Carol.\",\n\t\t\"Bob would lose 63 happiness units by sitting next to David.\",\n\t\t\"Carol would lose 62 happiness units by sitting next to Alice.\",\n\t\t\"Carol would gain 60 happiness units by sitting next to Bob.\",\n\t\t\"Carol would gain 55 happiness units by sitting next to David.\",\n\t\t\"David would gain 46 happiness units by sitting next to Alice.\",\n\t\t\"David would lose 7 happiness units by sitting next to Bob.\",\n\t\t\"David would gain 41 happiness units by sitting next to Carol.\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (330, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[161561,161097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[161182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[161646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[79200,79471],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[79347,79233],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[79331,79443],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[79450],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[80015,79504],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":27,"address":[79537,79666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[79769,79644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[162304,162320],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":33,"address":[162762,162522,162336],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":34,"address":[162374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[162582,162515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[79907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[79964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[79991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[80048,80925,80898],"length":1,"stats":{"Line":1},"fn_name":"calc_best"},{"line":44,"address":[80071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[162832,162848],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":51,"address":[80349,80266,80534],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[162899,162864],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":55,"address":[163078,163056],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":57,"address":[80610,80679,80728,80791],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[80699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[163288,163353,163104,163214,163142],"length":1,"stats":{"Line":5},"fn_name":"{closure#3}"},{"line":61,"address":[163673,163392,163265],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":62,"address":[163435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[163548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[163681,163656],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[163168,163345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[92032],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":82,"address":[92082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[93068,93152,93114,93490,95672],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":84,"address":[93198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[93237,93376],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[93696,93498,93820,93343],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[94043,93800,93941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[94211,94015,94168],"length":1,"stats":{"Line":3},"fn_name":null},{"line":92,"address":[94184,94258,94289],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[94348,94269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[94796,94223,94932,94598],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[95330,94899,95251,95053],"length":1,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[95309,95460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[93094,95712,96093],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":99,"address":[95755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[61152,61161],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":128,"address":[128119,128352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[128332],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":34,"coverable":49},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-14","src","lib.rs"],"content":"//! Advent of Code 2015: Day 14: Reindeer Olympics\n//!\n//! [https://adventofcode.com/2015/day/14](https://adventofcode.com/2015/day/14)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Reindeer Olympics\";\n\tyear = 2015;\n\tday = 14;\n\tpart_one = |input| logic::part_one (input, 2503);\n\tpart_two = |input| logic::part_two (input, 2503);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Reindeer;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 [\u0026 str], time: u32) -\u003e GenResult \u003cu32\u003e {\n\t\tlet deers = model::parse_input (input) ?;\n\t\tlet max_dist =\n\t\t\tdeers.iter ()\n\t\t\t\t.map (|deer| calc_distance (deer, time))\n\t\t\t\t.max ()\n\t\t\t\t.unwrap_or (0);\n\t\tOk (max_dist)\n\t}\n\n\tpub fn part_two (input: \u0026 [\u0026 str], time: u32) -\u003e GenResult \u003cu32\u003e {\n\t\tlet deers = model::parse_input (input) ?;\n\t\tlet mut iters = deers.iter ().map (iter_distance).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut dists = iter::repeat (0).take (input.len ()).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut scores = iter::repeat (0).take (input.len ()).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tfor _ in 0 .. time {\n\t\t\tdists.clear ();\n\t\t\tdists.extend (iters.iter_mut ().map (|iter| iter.next ().unwrap ()));\n\t\t\tlet (idx, _) = dists.iter ().copied ().enumerate ()\n\t\t\t\t.max_by_key (|\u0026 (_, dist)| dist)\n\t\t\t\t.unwrap ();\n\t\t\tscores [idx] += 1;\n\t\t}\n\t\tlet best_score = scores.iter ().copied ().max ().unwrap ();\n\t\tOk (best_score)\n\t}\n\n\tpub fn iter_distance (deer: \u0026 Reindeer) -\u003e impl Iterator \u003cItem = u32\u003e + '_ {\n\t\tlet mut flying = false;\n\t\tlet mut time = 0;\n\t\tlet mut dist = 0;\n\t\titer::from_fn (move || {\n\t\t\tif time == 0 {\n\t\t\t\tif flying {\n\t\t\t\t\ttime = deer.rest_time;\n\t\t\t\t\tflying = false;\n\t\t\t\t} else {\n\t\t\t\t\ttime = deer.fly_time;\n\t\t\t\t\tflying = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttime -= 1;\n\t\t\tif flying { dist += deer.fly_speed; }\n\t\t\tSome (dist)\n\t\t})\n\t}\n\n\tpub fn calc_distance (deer: \u0026 Reindeer, time: u32) -\u003e u32 {\n\t\titer_distance (deer).nth (time.as_usize ()).unwrap ()\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Input = Vec \u003cReindeer\u003e;\n\n\tpub struct Reindeer {\n\t\tpub name: String,\n\t\tpub fly_speed: u32,\n\t\tpub fly_time: u32,\n\t\tpub rest_time: u32,\n\t}\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tlet name = parser.word () ?.to_string ();\n\t\t\t\tlet fly_speed = parser.expect (\" can fly \") ?.int () ?;\n\t\t\t\tlet fly_time = parser.expect (\" km/s for \") ?.int () ?;\n\t\t\t\tlet rest_time = parser.expect (\" seconds, but then must rest for \") ?.int () ?;\n\t\t\t\tparser.expect (\" seconds.\") ?.end () ?;\n\t\t\t\tOk (Reindeer { name, fly_speed, fly_time, rest_time })\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, char_idx + 1, line)\n\t\t\t)\n\t\t).collect ()\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds.\",\n\t\t\"Dancer can fly 16 km/s for 11 seconds, but then must rest for 162 seconds.\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (1120, logic::part_one (EXAMPLE, 1000) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (689, logic::part_two (EXAMPLE, 1000) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[93865,94329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[93950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[94414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[21232,20816],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[20982,20853],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[21125,20960,21085],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[21117],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[21208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[22821,21264,22880],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[21333,21489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[21607,21458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[21702,21772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[21856,21926],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[22122,22626,22015],"length":1,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[22253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[22268],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[22408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[85600,85613],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":42,"address":[22567,22631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[22679,22219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[22797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[22896],"length":1,"stats":{"Line":1},"fn_name":"iter_distance"},{"line":49,"address":[22912],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[22917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[22925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[22933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[85646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[85657,85707,85727],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[85714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[85723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[85694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[85703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[85749,85670,85738],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[85741,85817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[85784],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[22992],"length":1,"stats":{"Line":1},"fn_name":"calc_distance"},{"line":69,"address":[23014],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[56176],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":89,"address":[56226],"length":1,"stats":{"Line":8},"fn_name":null},{"line":90,"address":[61908,61862,62198,63988,64116,61952],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":91,"address":[61998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[62299,62591,62497,62211],"length":1,"stats":{"Line":6},"fn_name":null},{"line":93,"address":[62552,62939,62741,63030],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[63164,63453,63362,62994],"length":1,"stats":{"Line":6},"fn_name":null},{"line":95,"address":[63773,63587,63417,63998],"length":1,"stats":{"Line":6},"fn_name":null},{"line":96,"address":[63846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[64525,62242,61888,62709,64144],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":98,"address":[64187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[56080,56089],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":117,"address":[82087,82325],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[82305],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[56128,56137],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":123,"address":[82375,82613],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[82593],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":50,"coverable":54},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-15","src","lib.rs"],"content":"//! Advent of Code 2015: Day 15: Science for Hungry People\n//!\n//! [https://adventofcode.com/2015/day/15](https://adventofcode.com/2015/day/15)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Science for Hungry People\";\n\tyear = 2015;\n\tday = 15;\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Ingredient;\n\tuse nums::IntConv;\n\n\t/// Part one: Find the combination of ingredients which gives the maximum possible score.\n\t///\n\t/// Uses [`find_start_ingredients`] to work out which ingredients to include as a minimum, and\n\t/// [`calc_score`] to work out the score for a given combination of ingredients.\n\t///\n\tpub fn part_one (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\n\t\tlet all_ingrs = model::parse_input (input) ?;\n\t\tlet start_ingrs = find_start_ingredients (\u0026 all_ingrs);\n\n\t\t// keep adding one ingredient at a time, maximising the score each time, until we have the\n\t\t// right number\n\n\t\tlet mixed_ingrs =\n\t\t\titer::successors (Some (start_ingrs), |ingrs| Some (iter::empty ()\n\t\t\t\t\t.chain (ingrs.iter_vals ())\n\t\t\t\t\t.chain (iter::once ((all_ingrs).iter ()\n\t\t\t\t\t\t.map (|ingr| (ingr, calc_score (\n\t\t\t\t\t\t\tingrs.iter_vals ().chain (iter::once (ingr)))))\n\t\t\t\t\t\t.max_by_key (|\u0026 (_, score)| score)\n\t\t\t\t\t\t.map (|(ingr, _)| ingr)\n\t\t\t\t\t\t.unwrap ()))\n\t\t\t\t\t.collect ()))\n\t\t\t\t.find (|ingrs| ingrs.len () == 100)\n\t\t\t\t.unwrap ();\n\n\t\t// work out the final score\n\n\t\tlet max_score = calc_score (mixed_ingrs.iter_vals ());\n\t\tOk (max_score)\n\n\t}\n\n\t/// Part two: Find the combination of ingredients which gives the maximum score and exactly 500\n\t/// calories in total.\n\t///\n\t/// This first iterates all combinations of ingredients which total 500 calories. This builds\n\t/// up the number of each ingredient iteratively, starting with [0, ..., 0], then [0, ..., 1],\n\t/// etc. At any point, if the number of calories exceeds 500 we short circuit to prevent\n\t/// needless iteration.\n\t///\n\t/// If the number of calories is exactly 500, and the number of ingredients is exactly 100, we\n\t/// note the score, and once iteration is complete the highest score is returned.\n\t///\n\t/// Uses [`calc_score`] to work out the score for a given combination of ingredients.\n\t///\n\tpub fn part_two (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\n\t\tlet all_ingrs = {\n\t\t\tlet mut ingrs = model::parse_input (input) ?;\n\t\t\tingrs.sort_by_key (|ingr| cmp::Reverse (ingr.calories));\n\t\t\tingrs\n\t\t};\n\n\t\tlet mut stack: Vec \u003ci32\u003e = vec! [];\n\t\tlet ingr_combos = iter::from_fn (|| {\n\n\t\t\t// pop off the last element, it only has one possible value. or, if the stack isn't\n\t\t\t// full this must be our first iteration and it's empty, so add a zero to start us off.\n\n\t\t\tif stack.len () == all_ingrs.len () {\n\t\t\t\tstack.pop ().unwrap ();\n\t\t\t} else if stack.is_empty () {\n\t\t\t\tstack.push (0);\n\t\t\t} else { unreachable! () }\n\n\t\t\tloop {\n\n\t\t\t\t// increment the ingredient counts\n\n\t\t\t\t* stack.last_mut ().unwrap () += 1;\n\n\t\t\t\t// short circuit if calories is over 500\n\n\t\t\t\tlet calories: i32 =\n\t\t\t\t\tstack.iter ().copied ().enumerate ()\n\t\t\t\t\t\t.map (|(idx, num)| all_ingrs [idx].calories * num)\n\t\t\t\t\t\t.sum ();\n\n\t\t\t\tif calories \u003e 500 {\n\t\t\t\t\tstack.pop ();\n\t\t\t\t\tif stack.is_empty () { return None }\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// fill in rest of stack with zeros...\n\n\t\t\t\twhile stack.len () + 1 \u003c all_ingrs.len () {\n\t\t\t\t\tstack.push (0);\n\t\t\t\t}\n\n\t\t\t\t// ...execpt for last place which we pick to get 100 ingredients total\n\n\t\t\t\tlet num_final = 100 - stack.iter ().copied ().sum::\u003ci32\u003e ();\n\t\t\t\tif num_final \u003c 0 { continue }\n\t\t\t\tlet calories = calories + num_final * all_ingrs.last ().unwrap ().calories;\n\n\t\t\t\t// if the total calories is exactly 500, return the list of ingredients\n\n\t\t\t\tif calories == 500 {\n\t\t\t\t\tstack.push (num_final);\n\t\t\t\t\treturn Some (\n\t\t\t\t\t\tstack.iter ().copied ().enumerate ()\n\t\t\t\t\t\t\t.flat_map (|(idx, num)|\n\t\t\t\t\t\t\t\titer::repeat (\u0026 all_ingrs [idx])\n\t\t\t\t\t\t\t\t\t.take (num.as_usize ()))\n\t\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t});\n\n\t\t// go through the list and pick the highest score\n\n\t\tlet max_score = ingr_combos\n\t\t\t.map (|ingrs| calc_score (ingrs.iter_vals ()))\n\t\t\t.max ()\n\t\t\t.unwrap ();\n\n\t\tOk (max_score)\n\n\t}\n\n\t/// Find a minimum number of ingredients to get a positive score.\n\t///\n\t/// Goes through all combinations of ingredients totaling 1, then 2, etc, until it finds the\n\t/// minimum number of ingredients needed for a positive score. It then returns the combination\n\t/// which gives the max score for that number of ingredients.\n\t///\n\tpub fn find_start_ingredients (all_ingrs: \u0026 [Ingredient]) -\u003e Vec \u003c\u0026 Ingredient\u003e {\n\t\t(1 ..= 100)\n\t\t\t.flat_map (|num| all_ingrs.iter ()\n\t\t\t\t.combinations_with_replacement (num)\n\t\t\t\t.map (|ingrs: Vec \u003c\u0026 Ingredient\u003e| (ingrs.clone (),\n\t\t\t\t\tcalc_score (ingrs.iter_vals ())))\n\t\t\t\t.max_by_key (|\u0026 (_, score)| score)\n\t\t\t\t.filter (|\u0026 (_, score)| score \u003e 0)\n\t\t\t\t.map (|(ingrs, _)| ingrs))\n\t\t\t.next ()\n\t\t\t.unwrap ()\n\t}\n\n\t/// Works out the score for a given combination of ingredients.\n\t///\n\t/// As per the puzzle description, this adds together each ingredient's value for capacity,\n\t/// durability, flavour and texture, then multiplies them all together. If any total is below\n\t/// zero, then the score is always zero.\n\t///\n\tpub fn calc_score \u003c'a\u003e (ingrs: impl IntoIterator \u003cItem = \u0026 'a Ingredient\u003e) -\u003e u64 {\n\t\tlet (cap, dur, fla, tex) = ingrs.into_iter ()\n\t\t\t.fold ((0, 0, 0, 0), |sums, ingr| (\n\t\t\t\tsums.0 + ingr.capacity,\n\t\t\t\tsums.1 + ingr.durability,\n\t\t\t\tsums.2 + ingr.flavour,\n\t\t\t\tsums.3 + ingr.texture,\n\t\t\t));\n\t\tif cap \u003c 0 || dur \u003c 0 || fla \u003c 0 || tex \u003c 0 { return 0 }\n\t\tcap.as_u64 () * dur.as_u64 () * fla.as_u64 () * tex.as_u64 ()\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\n\tpub type Input = Vec \u003cIngredient\u003e;\n\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct Ingredient {\n\t\tpub name: String,\n\t\tpub capacity: i32,\n\t\tpub durability: i32,\n\t\tpub flavour: i32,\n\t\tpub texture: i32,\n\t\tpub calories: i32,\n\t}\n\n\t/// Parse a list of ingredients and their properties, according to the defined format.\n\t///\n\t/// ```\n\t/// # use aoc_2015_day_15::model::{ Ingredient, parse_input };\n\t/// let ingrs = parse_input (\u0026 [\n\t///   \"Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8\",\n\t/// ]).unwrap ();\n\t/// assert_eq! (ingrs.len (), 1);\n\t/// assert_eq! (ingrs [0], Ingredient {\n\t///   name: \"Butterscotch\".to_string (),\n\t///   capacity: -1,\n\t///   durability: -2,\n\t///   flavour: 6,\n\t///   texture: 3,\n\t///   calories: 8,\n\t/// });\n\t/// ```\n\t///\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tparser.set_ignore_whitespace (true)\n\t\t\t\t\t.set_word_pred (char::is_alphanumeric);\n\t\t\t\tlet name = parser.word () ?.to_string ();\n\t\t\t\tlet capacity = parser.expect (\": capacity\") ?.int () ?;\n\t\t\t\tlet durability = parser.expect (\", durability\") ?.int () ?;\n\t\t\t\tlet flavour = parser.expect (\", flavor\") ?.int () ?;\n\t\t\t\tlet texture = parser.expect (\", texture\") ?.int () ?;\n\t\t\t\tlet calories = parser.expect (\", calories\") ?.int () ?;\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk (Ingredient { name, capacity, durability, flavour, texture, calories })\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, char_idx + 1, line)\n\t\t\t)\n\t\t).collect ()\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8\",\n\t\t\"Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (62842880, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (57600000, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[50681,50217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[50302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[50766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[51831,51184,51674],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":30,"address":[51343,51217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[51321,51451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[78140,77950,77872,77915],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":38,"address":[77925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[77968,78034],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[78026,78240,78317],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":41,"address":[78259],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[78368,78381],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":43,"address":[78400,78417],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":46,"address":[78459,78432],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":51,"address":[51733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[51790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[51856,52190],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":72,"address":[51889,52036],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[52014,52142],"length":1,"stats":{"Line":4},"fn_name":null},{"line":74,"address":[52149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[52183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[78528,79269],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":83,"address":[78567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[78662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[78637,78752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[78796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[78758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[78942,78824,78719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[78916,78988,79095],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[80054,79083,80032],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":102,"address":[79158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[79199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[79215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[79173,79285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[79424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[79390,79455,79558],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[79547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[79760,79596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[79748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[79802],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[79985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[79927,79818],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[80144,79915,80258,80166],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":127,"address":[80235,80175],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[80214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[52375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[80272,80299],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":144,"address":[52470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[52512,52724],"length":1,"stats":{"Line":1},"fn_name":"find_start_ingredients"},{"line":155,"address":[52554,52693,52603],"length":1,"stats":{"Line":3},"fn_name":null},{"line":156,"address":[52587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":158,"address":[80629,80592,80754,80791],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":159,"address":[80641,80784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[80832,80845],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":161,"address":[80873,80864],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":162,"address":[80916,80912],"length":1,"stats":{"Line":2},"fn_name":"{closure#3}"},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":223,"address":[38608],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":225,"address":[33109,32992,33027],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":226,"address":[33084,35979,33405,33037,35851,33120],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":227,"address":[33166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[33205],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[33704,33418,33798,33506],"length":1,"stats":{"Line":3},"fn_name":null},{"line":231,"address":[33759,34237,33948,34146],"length":1,"stats":{"Line":3},"fn_name":null},{"line":232,"address":[34569,34201,34371,34660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[34992,34624,35083,34794],"length":1,"stats":{"Line":3},"fn_name":null},{"line":234,"address":[35217,35047,35494,35415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":235,"address":[35861,35612,35470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[35694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[36016,36397,33449,33064,33916],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":238,"address":[36059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[83024,83033],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":257,"address":[134455,134215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[134435],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[83081,83072],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":263,"address":[134503,134743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[134723],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":79,"coverable":85},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-16","src","lib.rs"],"content":"//! Advent of Code 2015: Day 16: Aunt Sue\n//!\n//! [https://adventofcode.com/2015/day/16](https://adventofcode.com/2015/day/16)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Aunt Sue\";\n\tyear = 2015;\n\tday = 16;\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Attr;\n\n\tpub fn part_one (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cu16\u003e {\n\t\tlet all_sues = model::parse_input (input) ?;\n\t\tfn ticker (attr: Attr) -\u003e u8 {\n\t\t\tmatch attr {\n\t\t\t\tAttr::Children =\u003e 3,\n\t\t\t\tAttr::Cats =\u003e 7,\n\t\t\t\tAttr::Samoyeds =\u003e 2,\n\t\t\t\tAttr::Pomeranians =\u003e 3,\n\t\t\t\tAttr::Akitas =\u003e 0,\n\t\t\t\tAttr::Vizslas =\u003e 0,\n\t\t\t\tAttr::Goldfish =\u003e 5,\n\t\t\t\tAttr::Trees =\u003e 3,\n\t\t\t\tAttr::Cars =\u003e 2,\n\t\t\t\tAttr::Perfumes =\u003e 1,\n\t\t\t}\n\t\t}\n\t\tlet the_sue = all_sues.iter ()\n\t\t\t.filter (|sue| sue.attrs.iter ().copied ().all (|(attr, num)|\n\t\t\t\tnum == ticker (attr)))\n\t\t\t.exactly_one ().map_err (|iter| format! (\"Expected exactly one match but found {}\",\n\t\t\t\titer.count ())) ?;\n\t\tOk (the_sue.number)\n\t}\n\n\tpub fn part_two (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cu16\u003e {\n\t\tlet all_sues = model::parse_input (input) ?;\n\t\tfn ticker (attr: Attr, num: u8) -\u003e bool {\n\t\t\tmatch attr {\n\t\t\t\tAttr::Children =\u003e num == 3,\n\t\t\t\tAttr::Cats =\u003e num \u003e 7,\n\t\t\t\tAttr::Samoyeds =\u003e num == 2,\n\t\t\t\tAttr::Pomeranians =\u003e num \u003c 3,\n\t\t\t\tAttr::Akitas =\u003e num == 0,\n\t\t\t\tAttr::Vizslas =\u003e num == 0,\n\t\t\t\tAttr::Goldfish =\u003e num \u003c 5,\n\t\t\t\tAttr::Trees =\u003e num \u003e 3,\n\t\t\t\tAttr::Cars =\u003e num == 2,\n\t\t\t\tAttr::Perfumes =\u003e num == 1,\n\t\t\t}\n\t\t}\n\t\tlet the_sue = all_sues.iter ()\n\t\t\t.filter (|sue| sue.attrs.iter ().copied ()\n\t\t\t\t.all (|(attr, num)| ticker (attr, num)))\n\t\t\t.exactly_one ().map_err (|iter| format! (\"Expected exactly one match but found {}\",\n\t\t\t\titer.count ())) ?;\n\t\tOk (the_sue.number)\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\n\tpub type Input = Vec \u003cAuntSue\u003e;\n\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct AuntSue {\n\t\tpub number: u16,\n\t\tpub attrs: ArrayVec \u003c(Attr, u8), 10\u003e,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Attr {\n\t\tChildren,\n\t\tCats,\n\t\tSamoyeds,\n\t\tPomeranians,\n\t\tAkitas,\n\t\tVizslas,\n\t\tGoldfish,\n\t\tTrees,\n\t\tCars,\n\t\tPerfumes,\n\t}\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tuse parser::*;\n\t\tinput.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tparser.set_ignore_whitespace (true)\n\t\t\t\t\t.set_word_pred (char::is_alphanumeric);\n\t\t\t\tlet number = parser.expect (\"Sue\") ?.int () ?;\n\t\t\t\tparser.expect (\":\") ?;\n\t\t\t\tlet mut attrs = ArrayVec::new ();\n\t\t\t\twhile parser.peek ().is_some () {\n\t\t\t\t\tlet attr = match parser.word () ? {\n\t\t\t\t\t\t\"children\" =\u003e Attr::Children,\n\t\t\t\t\t\t\"cats\" =\u003e Attr::Cats,\n\t\t\t\t\t\t\"samoyeds\" =\u003e Attr::Samoyeds,\n\t\t\t\t\t\t\"pomeranians\" =\u003e Attr::Pomeranians,\n\t\t\t\t\t\t\"akitas\" =\u003e Attr::Akitas,\n\t\t\t\t\t\t\"vizslas\" =\u003e Attr::Vizslas,\n\t\t\t\t\t\t\"goldfish\" =\u003e Attr::Goldfish,\n\t\t\t\t\t\t\"trees\" =\u003e Attr::Trees,\n\t\t\t\t\t\t\"cars\" =\u003e Attr::Cars,\n\t\t\t\t\t\t\"perfumes\" =\u003e Attr::Perfumes,\n\t\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t\t};\n\t\t\t\t\tlet num = parser.expect (\":\") ?.int () ?;\n\t\t\t\t\tattrs.push ((attr, num));\n\t\t\t\t\tmatch parser.next () {\n\t\t\t\t\t\tSome (',') =\u003e continue,\n\t\t\t\t\t\tNone =\u003e break,\n\t\t\t\t\t\tSome (_) =\u003e Err (parser.err ()) ?,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk (AuntSue { number, attrs })\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\", line_idx + 1, char_idx + 1, line)\n\t\t\t)\n\t\t).collect ()\n\t}\n\n}\n","traces":[{"line":7,"address":[74377,74841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[74462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[74926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[48912,49493],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":23,"address":[48945,49071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[49520],"length":1,"stats":{"Line":0},"fn_name":"ticker"},{"line":25,"address":[49531],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[49562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[49569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[49576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[49583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[49590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[49597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[49604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[49611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[49618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[49625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[49049,49171,49429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[71456,71470,71568,71594,71627],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":40,"address":[71602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[49365,49451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[49332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[49648,50229],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":47,"address":[49681,49807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[50256],"length":1,"stats":{"Line":0},"fn_name":"ticker"},{"line":49,"address":[50278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[50315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[50335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[50355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[50372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[50389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[50406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[50423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[50440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[50457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[50474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[50165,49785,49907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[71822,71808],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":64,"address":[71920,71942],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":66,"address":[50187,50101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[50068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[61376],"length":1,"stats":{"Line":0},"fn_name":"parse_input"},{"line":102,"address":[52029,51920,51948],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":103,"address":[52568,54961,55089,52048,51958,52004],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":104,"address":[52094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[52353,52133,52451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[52652,52576,52415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[52632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[54611,52778,52837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[53157,52909,53044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[53016,53207,53168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[53297,53184,53258],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[53274,53350,53311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[53367,53406,53327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[53423,53462,53383],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[53439,53518,53479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[53574,53495,53535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[53591,53630,53551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[53686,53607,53647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[53663,53703,53733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[53746,53714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[53220,54208,54311,54010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[54254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[54434],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[54507,54621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[54971,54739,52882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[54805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[55120,52801,53976,51984,55501],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":134,"address":[55163],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":69},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-17","src","lib.rs"],"content":"//! Advent of Code 2015: Day 17: No Such Thing as Too Much\n//!\n//! [https://adventofcode.com/2015/day/17](https://adventofcode.com/2015/day/17)\n//!\n//! # Input\n//!\n//! Each line is a decimal integer, representing the size of an available container.\n//!\n//! # Part one\n//!\n//! Work out the number of combinations of containers so that the size adds up to exactly 150. The\n//! containers count separately, even if they are the same size.\n//!\n//! # Part two\n//!\n//! Work out the minimum number of containers to hold exactly 150, then work out the total number\n//! of combinations of that many containers which can hold exactly 150.\n//!\n//! # Algorithm\n//!\n//! The private function `combos` provides an iterator over a list of combinations of container\n//! sizes to match a given target. TODO how does this work?\n//!\n//! For part one, we just use [`count`](Iterator::count). For part two, we invoke `combos` twice,\n//! the first time using [`min`](Iterator::min) to work out the minimum number of containers, then\n//! using [`filter`](Iterator::filter) and [`count`](Iterator::count) to determine the number of\n//! combinations with that specific number of containers.\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"No Such Thing as Too Much\";\n\tyear = 2015;\n\tday = 17;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tlet (mut sizes, target) = input;\n\t\tsanity_checks (\u0026 sizes, target) ?;\n\n\t\tsizes.sort_by_key (|\u0026 size| cmp::Reverse (size));\n\t\tlet num_combos = combos (\u0026 sizes, target).count ();\n\t\tOk (num_combos.as_u32 ())\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tlet (mut sizes, target) = input;\n\t\tsanity_checks (\u0026 sizes, target) ?;\n\n\t\t// sort first, this makes the algorithm more efficient\n\n\t\tsizes.sort_by_key (|\u0026 size| cmp::Reverse (size));\n\n\t\t// work out smallest number of containers\n\n\t\tlet smallest =\n\t\t\tcombos (\u0026 sizes, target)\n\t\t\t\t.min_by_key (|combo| combo.len ())\n\t\t\t\t.map (|combo| combo.len ())\n\t\t\t\t.unwrap_or (0);\n\n\t\t// count combinations with this number\n\n\t\tlet num_smallest =\n\t\t\tcombos (\u0026 sizes, target)\n\t\t\t\t.filter (|combo| combo.len () == smallest)\n\t\t\t\t.count ();\n\n\t\t// return\n\n\t\tOk (num_smallest.as_u32 ())\n\n\t}\n\n\tfn sanity_checks (sizes: \u0026 [u32], target: u32) -\u003e GenResult \u003c()\u003e {\n\t\tif sizes.len () \u003e 20 { Err (\"Refusing to deal with more than 20 containers\") ?; }\n\t\tif sizes.iter ().copied ().sum::\u003cu32\u003e () \u003c target { Err (\"No solution found\") ?; }\n\t\tOk (())\n\t}\n\n\t/// Iterate over combinations of provided container given a specific total.\n\t///\n\t/// Returns an [`Iterator`] over [`Vec`]s of the sizes of each container. Note that these can\n\t/// appear to be duplicates, if there is more than one container with the same size.\n\t///\n\tfn combos (sizes: \u0026 [u32], target: u32) -\u003e impl Iterator \u003cItem = Vec \u003cu32\u003e\u003e + '_ {\n\t\tlet mut state = iter::repeat (false).take (sizes.len ()).collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tlet mut sum = 0;\n\t\titer::from_fn (move || loop {\n\t\t\tif state.is_empty () { return None }\n\t\t\tlet mut idx = state.len () - 1;\n\t\t\tloop {\n\t\t\t\tif state [idx] {\n\t\t\t\t\tstate [idx] = false;\n\t\t\t\t\tsum -= sizes [idx];\n\t\t\t\t\tif idx \u003e 0 { idx -= 1 } else { return None }\n\t\t\t\t} else if 150 \u003c sum\n\t\t\t\t\t\t|| sum + sizes.iter ().copied ().skip (idx).sum::\u003cu32\u003e () \u003c target {\n\t\t\t\t\tif idx \u003e 0 { idx -= 1 } else { return None }\n\t\t\t\t} else { break }\n\t\t\t}\n\t\t\tstate [idx] = true;\n\t\t\tsum += sizes [idx];\n\t\t\tif sum == target {\n\t\t\t\treturn Some (\n\t\t\t\t\tIterator::zip (sizes.iter ().copied (), state.iter ().copied ())\n\t\t\t\t\t\t.filter (|\u0026 (_, state)| state)\n\t\t\t\t\t\t.map (|(size, _)| size)\n\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ()\n\t\t\t\t);\n\t\t\t}\n\t\t})\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\tuse parser::*;\n\n\tpub type Input = (Vec \u003cu32\u003e, u32);\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tlet (input, target) = if let Some (target_str) = input [0].strip_prefix (\"TARGET=\") {\n\t\t\t(\u0026 input [ 1 .. ], target_str.parse () ?)\n\t\t} else { (input, 150) };\n\t\tlet buckets = input.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tlet val = parser.int::\u003cu8\u003e () ?.as_u32 ();\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk (val)\n\t\t\t}).map_parse_err (|char_idx| format! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\tline_idx + 1, char_idx + 1, line))\n\t\t).collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\tOk (( buckets, target ))\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tlet input = model::parse_input (\u0026 [\"TARGET=25\", \"20\", \"15\", \"10\", \"5\", \"5\"]) ?;\n\t\tassert_eq_ok! (4, logic::part_one (input));\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tlet input = model::parse_input (\u0026 [\"TARGET=25\", \"20\", \"15\", \"10\", \"5\", \"5\"]) ?;\n\t\tassert_eq_ok! (3, logic::part_two (input));\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":35,"address":[40075,40827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[40176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[40928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[63028,62512],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":49,"address":[62529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[62574,62774,62645],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[62752,62883],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[62898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[62977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[63794,63056],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":58,"address":[63076],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[63124,63210,63339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[63317,63451],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[63466],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[68928,68955],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":70,"address":[68976,68984],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":75,"address":[63614,63679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[63671],"length":1,"stats":{"Line":3},"fn_name":null},{"line":82,"address":[63743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[63824],"length":1,"stats":{"Line":1},"fn_name":"sanity_checks"},{"line":87,"address":[63904,63868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[64048,64105,63884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[64094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[64240],"length":1,"stats":{"Line":1},"fn_name":"combos"},{"line":98,"address":[64294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[64378],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[69152,69270],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":101,"address":[69255,69199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[69232,69286,69323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[69321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[69361,69728,70120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":105,"address":[69438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[69486,69635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[69733,69685,69622,69673],"length":1,"stats":{"Line":3},"fn_name":null},{"line":108,"address":[69972,69812,69411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[69855,69986,69771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[70083,70052,70125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[70168,70024],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[70171,70297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[70284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":116,"address":[70558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[70335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[70608,70621],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":119,"address":[70656,70679],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":138,"address":[52976],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":139,"address":[53446,53019,53252],"length":1,"stats":{"Line":3},"fn_name":null},{"line":140,"address":[53324,53456,53180],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[53234],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[53508,53911,53293],"length":1,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[49814,49556,49510,49600,49907],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":144,"address":[49646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[49827,49914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[49898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[50277,50216,49536,50126,50048],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":148,"address":[50091,50152,50242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[53711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[59376,59385],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":162,"address":[82903,83089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[83032,83518,83208,83277],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[83478],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[59424,59433],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":169,"address":[83639,83825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[84013,84254,83768,83944],"length":1,"stats":{"Line":3},"fn_name":null},{"line":171,"address":[84214],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":59,"coverable":64},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-18","src","lib.rs"],"content":"//! Advent of Code 2015: Day 18: Like a GIF For Your Yard\n//!\n//! [https://adventofcode.com/2015/day/18](https://adventofcode.com/2015/day/18)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Like a GIF For Your Yard\";\n\tyear = 2015;\n\tday = 18;\n\tparse = |input| model::parse_input (input);\n\tpart_one = |input, steps: u32| logic::part_one (input, steps);\n\tpart_two = |input, steps: u32| logic::part_two (input, steps);\n\tparams = [\n\t\tsteps: u32 = 100;\n\t];\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: Input, loops: u32) -\u003e GenResult \u003cu32\u003e {\n\t\tlet num_active = calc_result (input, loops, \u0026 HashMap::new ());\n\t\tOk (num_active)\n\t}\n\n\tpub fn part_two (input: Input, loops: u32) -\u003e GenResult \u003cu32\u003e {\n\t\tlet Pos { y: y0, x: x0 } = input.origin ();\n\t\tlet Pos { y: y1, x: x1 } = input.peak ();\n\t\tlet overrides = [\n\t\t\tPos { y: y0, x: x0 }, Pos { y: y0, x: x1 },\n\t\t\tPos { y: y1, x: x0 }, Pos { y: y1, x: x1 },\n\t\t].into_iter ().map (|pos| (pos, true)).collect ();\n\t\tlet num_active = calc_result (input, loops, \u0026 overrides);\n\t\tOk (num_active)\n\t}\n\n\tfn calc_result (lights: Input, loops: u32, overrides: \u0026 HashMap \u003cPos, bool\u003e) -\u003e u32 {\n\t\tlet mut lights = lights;\n\n\t\t// make sure overrides start in the correct state\n\n\t\tfor (\u0026 pos, \u0026 val) in overrides.iter () {\n\t\t\tlights.set (pos, val);\n\t\t}\n\n\t\t// apply rules specified number of times\n\n\t\tfor _ in 0 .. loops {\n\t\t\tlet new_data = lights.iter ().map (|(pos, val)| {\n\t\t\t\tif let Some (\u0026 val) = overrides.get (\u0026 pos) { val } else {\n\t\t\t\t\tlet num_adjacent =\n\t\t\t\t\t\tpos.adjacent_8 ().iter ().copied ()\n\t\t\t\t\t\t\t.filter (|\u0026 adj_pos| lights.get (adj_pos).unwrap_or (false))\n\t\t\t\t\t\t\t.count ();\n\t\t\t\t\tmatches! ((val, num_adjacent), (true, 2) | (_, 3))\n\t\t\t\t}\n\t\t\t}).collect ();\n\t\t\tlights = Input::wrap (new_data, lights.raw_origin (), lights.raw_size ());\n\t\t}\n\n\t\t// count active lights\n\n\t\tlet num_active =\n\t\t\tlights.values ()\n\t\t\t\t.filter (|\u0026 val| val)\n\t\t\t\t.count ().to_u32 ().unwrap ();\n\n\t\tnum_active\n\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse grid::Grid;\n\tuse pos::PosYX;\n\n\tpub type Coord = u16;\n\tpub type Pos = PosYX \u003cCoord\u003e;\n\tpub type Input = Grid \u003cVec \u003cbool\u003e, Pos\u003e;\n\n\tpub fn parse_input (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\tlet grid_size = [ input.len (), input [0].chars ().count () ];\n\t\tif grid_size [1] == 0 { Err (\"Invalid input\") ? }\n\t\tif let Some ((line_idx, line_len)) =\n\t\t\tinput.iter ().enumerate ()\n\t\t\t\t.map (|(idx, line)| (idx, line.chars ().count ()))\n\t\t\t\t.find (|\u0026 (_, len)| len != grid_size [1]) {\n\t\t\tErr (format! (\"Invalid input: line {}: Expected {} chars, not {}\",\n\t\t\t\tline_idx + 1, grid_size [1], line_len)) ?\n\t\t}\n\t\tlet grid_data = input.iter ().enumerate ().flat_map (|(line_idx, line)|\n\t\t\tline.chars ().enumerate ().map (move |(char_idx, ch)| Ok (match ch {\n\t\t\t\t'#' =\u003e true,\n\t\t\t\t'.' =\u003e false,\n\t\t\t\t_ =\u003e Err (format! (\"Invalid input: line {}: col {}: {}\", line_idx + 1,\n\t\t\t\t\tchar_idx + 1, ch)) ?,\n\t\t\t}))\n\t\t).collect::\u003cGenResult \u003cVec \u003c_\u003e\u003e\u003e () ?;\n\t\tlet grid = Grid::wrap (grid_data, [0, 0], grid_size);\n\t\tOk (grid)\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\".#.#.#\", \"...##.\", \"#....#\", \"..#...\", \"#.#..#\", \"####..\"\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet mut puzzle = puzzle_metadata ();\n\t\tpuzzle.set_param (\"steps\", 4.to_string ());\n\t\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet mut puzzle = puzzle_metadata ();\n\t\tpuzzle.set_param (\"steps\", 5.to_string ());\n\t\tassert_eq_ok! (\"17\", puzzle.part_two (EXAMPLE));\n\t}\n\n}\n","traces":[{"line":11,"address":[72595,73603],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[72785],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[73793],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[103590,103456],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":29,"address":[103621,103484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[103685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[104339,103712,104363],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":34,"address":[103842,103753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[103874],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[103991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[103927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[103959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[64761,64736],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":40,"address":[104188,104311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[104318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[104400,105434,105223],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":45,"address":[104443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[104563,104503,104723,104741,104734],"length":1,"stats":{"Line":5},"fn_name":null},{"line":50,"address":[104787,104737,104731],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[104807,105307,104676],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[64800,65191,64856,65289],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":57,"address":[64893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[65057,64964,65128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[65116,65312,65326],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":61,"address":[65015,65176],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[65225],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[105234,105017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[105322,104889],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[65408,65421],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":93,"address":[70192,71757,71791],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":94,"address":[70241],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[70470,70365],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[70623,70452,70573],"length":1,"stats":{"Line":6},"fn_name":null},{"line":98,"address":[33544,33520],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":99,"address":[70607],"length":1,"stats":{"Line":6},"fn_name":null},{"line":100,"address":[70757,70813,71250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[70783,70749,70695,71154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[33805,33680,33714],"length":1,"stats":{"Line":10},"fn_name":"{closure#2}"},{"line":104,"address":[33727,33824,34554,33874],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":105,"address":[33938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[33948],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[34117,34534,33917,34061,33963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[34087,34431,34032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[71455],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[71673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[41741,41184,41787],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":128,"address":[41191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[41300,41214],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[41325,41431],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[42427,42381,41824],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":135,"address":[41831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[41940,41854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[42071,41965],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":49,"coverable":53},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-19","src","lib.rs"],"content":"//! Advent of Code 2015: Day 19: Medicine for Rudolph\n//!\n//! [https://adventofcode.com/2015/day/19](https://adventofcode.com/2015/day/19)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Medicine for Rudolph\";\n\tyear = 2015;\n\tday = 19;\n\tparse = |input| model::Input::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse list::CharList;\n\tuse list::List;\n\tuse model::Input;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu32\u003e {\n\t\tlet mut results = HashSet::new ();\n\t\tfor (from, to) in input.replacements.iter () {\n\t\t\tlet mut last_pos = 0;\n\t\t\twhile let Some (pos) = input.medicine [last_pos .. ].find (from) {\n\t\t\t\tlet pos = last_pos + pos;\n\t\t\t\tlet new_molecule = format! (\"{}{}{}\",\n\t\t\t\t\t\u0026 input.medicine [ .. pos],\n\t\t\t\t\tto,\n\t\t\t\t\t\u0026 input.medicine [pos + from.len () .. ],\n\t\t\t\t);\n\t\t\t\tresults.insert (new_molecule);\n\t\t\t\tlast_pos = pos + from.len ();\n\t\t\t}\n\t\t}\n\t\tOk (results.len ().as_u32 ())\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu32\u003e {\n\n\t\t// sanity checks\n\n\t\tif ! input.replacements.iter ().any (|(from, _)| from == \"e\") {\n\t\t\tErr (\"Must have at least one replacement from \\\"e\\\"\") ?;\n\t\t}\n\n\t\tif input.medicine.len () \u003e 512 {\n\t\t\tErr (\"Medicine must be 512 chars or less\") ?;\n\t\t}\n\n\t\tif ! input.medicine.chars ().all (|ch| ch.is_ascii_alphanumeric ()) {\n\t\t\tErr (\"Medicine must be ASCII alphanumeric\") ?;\n\t\t}\n\n\t\tfor (from, to) in input.replacements.iter () {\n\n\t\t\tif ! from.chars ().all (|ch| ch.is_ascii_alphanumeric ())\n\t\t\t\t\t|| ! to.chars ().all (|ch| ch.is_ascii_alphanumeric ()) {\n\t\t\t\tErr (\"All replacements must be ASCII alphanumeric\") ?;\n\t\t\t}\n\n\t\t\tif from.chars ()\n\t\t\t\t\t.filter (|ch| ch.is_ascii_uppercase () || ch.is_ascii_digit ())\n\t\t\t\t\t.count ()\n\t\t\t\t\u003e= to.chars ()\n\t\t\t\t\t.filter (|ch| ch.is_ascii_uppercase () || ch.is_ascii_digit ())\n\t\t\t\t\t.count () {\n\t\t\t\tErr (\"Replacements must always increase number of more ASCII uppercase/digits\") ?;\n\t\t\t}\n\n\t\t}\n\n\t\t// list of continuations to handle branching without recursion\n\n\t\tlet mut todo: VecDeque \u003c(u32, List \u003cString\u003e, CharList)\u003e = VecDeque::new ();\n\t\ttodo.push_back ((0, List::new (), CharList::from (\u0026 input.medicine)));\n\n\t\t// set of previous iterations to short circuit repeated evaluation of the same state\n\n\t\tlet mut seen: HashSet \u003c(List \u003cString\u003e, CharList)\u003e = HashSet::new ();\n\n\t\t// iterate over items from todo\n\n\t\tlet mut min_match = None;\n\t\t'OUTER: while let Some ((todo_steps, todo_prefix, todo_suffix)) = todo.pop_back () {\n\n\t\t\t// abort if it looks too complex, this is mostly to make fuzzing more practical\n\n\t\t\tif todo.len () \u003e= 1500 { Err (\"1500 states pending, giving up\") ?; }\n\t\t\tif seen.len () \u003e= 3000 { Err (\"3000 unique states seen, giving up\") ?; }\n\n\t\t\t// skip duplicated items\n\n\t\t\tif ! seen.insert ((todo_prefix.clone (), todo_suffix.clone ())) { continue }\n\n\t\t\t// output a message, disabled for now but could be added as a flag\n\n\t\t\tconst VERBOSE: bool = false;\n\t\t\tif VERBOSE {\n\t\t\t\tif todo_prefix.is_empty () {\n\t\t\t\t\tprintln! (\"queue={} steps={} {}\", todo.len (), todo_steps, todo_suffix);\n\t\t\t\t} else {\n\t\t\t\t\tprintln! (\"queue={} steps={} {} | {}\", todo.len (), todo_steps,\n\t\t\t\t\t\ttodo_prefix.iter ().join (\" | \"), todo_suffix);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add todo items for any replacements at the start of the suffix, also detect success\n\n\t\t\tfor (from, to) in input.replacements.iter () {\n\t\t\t\tif from == \"e\" {\n\n\t\t\t\t\t// detect success\n\n\t\t\t\t\tif todo_prefix.is_empty () \u0026\u0026 to == todo_suffix {\n\t\t\t\t\t\t// TODO I am not entirely convinced that this is so simple, but I got the\n\t\t\t\t\t\t// right answer, so... I am /guessing/ that this has something to do with\n\t\t\t\t\t\t// this being an implementation of a greedy matcher, always trying to match\n\t\t\t\t\t\t// on the left first then recursing. But i would like to think about this a\n\t\t\t\t\t\t// bit more.\n\t\t\t\t\t\tmin_match = Some (todo_steps + 1);\n\t\t\t\t\t\tbreak 'OUTER;\n\t\t\t\t\t}\n\n\t\t\t\t\t// never reduce a partial match to \"e\", it's only valid if it replaces the\n\t\t\t\t\t// entire molecule\n\n\t\t\t\t} else if let Some (suffix) = todo_suffix.strip_prefix (to) {\n\t\t\t\t\tif todo_prefix.is_empty () {\n\n\t\t\t\t\t\t// no prefix: add the split with no prefix also\n\n\t\t\t\t\t\ttodo.push_back ((\n\t\t\t\t\t\t\ttodo_steps + 1,\n\t\t\t\t\t\t\tList::new (),\n\t\t\t\t\t\t\tsuffix.prepend (from),\n\t\t\t\t\t\t));\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// some prefix: continue with the last item removed\n\n\t\t\t\t\t\ttodo.push_back ((\n\t\t\t\t\t\t\ttodo_steps + 1,\n\t\t\t\t\t\t\ttodo_prefix.tail ().cloned ().unwrap (),\n\t\t\t\t\t\t\tsuffix.prepend (from)\n\t\t\t\t\t\t\t\t.prepend (todo_prefix.head ().unwrap ()),\n\t\t\t\t\t\t));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add todo items for possible splits: at some point we have to match a replacement at\n\t\t\t// the start of the molecule, so we must be able to reduce some suffix of the current\n\t\t\t// molecule into something so that we can reduce the new combined prefix and suffix.\n\t\t\t// so, we iterate over prefixes but stop when our prefix is not itself a prefix of any\n\t\t\t// replacements, since we know that it can't possibly be reduced further whatever the\n\t\t\t// suffix changes into.\n\n\t\t\tlet mut prefix = String::new ();\n\t\t\tlet mut suffix = \u0026 todo_suffix;\n\t\t\twhile let Some ((\u0026 head, tail)) = suffix.cons () {\n\t\t\t\tprefix.push (head);\n\t\t\t\tsuffix = tail;\n\t\t\t\tif ! input.replacements.iter ()\n\t\t\t\t\t\t.any (|(_, to)| to.starts_with (\u0026 prefix)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttodo.push_back ((\n\t\t\t\t\ttodo_steps,\n\t\t\t\t\ttodo_prefix.push_front (prefix.clone ()),\n\t\t\t\t\tsuffix.clone (),\n\t\t\t\t));\n\t\t\t}\n\n\t\t}\n\n\t\t// return result or error\n\n\t\tOk (min_match.ok_or (\"No solution found\") ?)\n\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn part_two () {\n\t\t\tassert_err! (\"Must have at least one replacement from \\\"e\\\"\",\n\t\t\t\tlogic::part_two (Input::parse (\u0026 [\"a =\u003e b\", \"c =\u003e d\", \"\", \"whatever\"]).unwrap ()));\n\t\t}\n\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Input {\n\t\tpub replacements: Replacements,\n\t\tpub medicine: String,\n\t}\n\n\tpub type Replacements = Vec \u003cReplacement\u003e;\n\tpub type Replacement = (String, String);\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tif input.len () \u003c 3 { Err (\"Invalid input\") ?; }\n\t\t\tif ! input [input.len () - 2].is_empty () { Err (\"Invalid input\") ?; }\n\t\t\tlet is_chem = |input: \u0026 str| input.chars ().all (|ch| ch.is_ascii_alphanumeric ());\n\t\t\tlet replacements = input [0 .. input.len () - 2].iter ().enumerate ()\n\t\t\t\t.map (|(line_idx, line)|\n\t\t\t\t\tParser::wrap (line, |parser| {\n\t\t\t\t\t\tparser.set_ignore_whitespace (true);\n\t\t\t\t\t\tlet from = parser.word_if (is_chem) ?;\n\t\t\t\t\t\tlet to = parser.expect_word (\"=\u003e\") ?.word_if (is_chem) ?;\n\t\t\t\t\t\tparser.end () ?;\n\t\t\t\t\t\tif to.len () \u003c from.len () { Err (parser.err ()) ?; }\n\t\t\t\t\t\tOk ((from.to_string (), to.to_string ()))\n\t\t\t\t\t}).map_parse_err (|col_idx| format! (\n\t\t\t\t\t\t\"Invalid input: line {}: col {}: {}\", line_idx + 1, col_idx + 1, line))\n\t\t\t\t).collect::\u003cGenResult \u003cReplacements\u003e\u003e () ?;\n\t\t\tlet medicine = input.last ().unwrap ().to_string ();\n\t\t\tif medicine.is_empty () { Err (\"Medicine must be at least one character\") ?; }\n\t\t\tOk (Input { replacements, medicine })\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn input_parse () {\n\t\t\tassert_err! (\"Invalid input: line 1: col 5: a =\u003e\",\n\t\t\t\tmodel::Input::parse (\u0026 [ \"a =\u003e\", \"\", \"whatever\" ]));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_ONE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"H =\u003e HO\",\n\t\t\"H =\u003e OH\",\n\t\t\"O =\u003e HH\",\n\t\t\"\",\n\t\t\"HOH\",\n\t];\n\n\tconst EXAMPLE_TWO: \u0026 [\u0026 str] = \u0026 [\n\t\t\"e =\u003e H\",\n\t\t\"e =\u003e O\",\n\t\t\"H =\u003e HO\",\n\t\t\"H =\u003e OH\",\n\t\t\"O =\u003e HH\",\n\t\t\"\",\n\t\t\"HOH\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"4\", puzzle.part_one (EXAMPLE_ONE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"3\", puzzle.part_two (EXAMPLE_TWO));\n\t}\n\n}\n","traces":[{"line":11,"address":[120523,121323],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[120662],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[121462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[89168,90645,90619],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":27,"address":[89207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[89262,89338,89522],"length":1,"stats":{"Line":3},"fn_name":null},{"line":29,"address":[89566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[89586,90522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[89851,89754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[90205,89915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[89801,89899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[90047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[90406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[90527,90469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[89504,90568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[96834,93137,90688],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":48,"address":[41792,41806],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":49,"address":[90945],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[91154,90923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[91200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[41869,41856],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":57,"address":[91526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[91904,91500,91728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[41917,41904],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":63,"address":[41952,41965],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":64,"address":[92290],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[92492,92741,92264],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[42000,42032],"length":1,"stats":{"Line":2},"fn_name":"{closure#4}"},{"line":70,"address":[92593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[42144,42112],"length":1,"stats":{"Line":2},"fn_name":"{closure#5}"},{"line":73,"address":[92750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[91894],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[93007,92936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[93156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[93163],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[93190,94830,96637,93947,94254,93356,94900,93237],"length":1,"stats":{"Line":6},"fn_name":null},{"line":94,"address":[93428,93462,93341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[93709,93444,93675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[93691,94031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[94197,94467,94291],"length":1,"stats":{"Line":3},"fn_name":null},{"line":116,"address":[94503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[94587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[94780,94691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[94545,95252],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[95345],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[95618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[95412,95444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[95429,95485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[95588,95493],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[96092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[95379,95700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[95741,95685],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[96068,95913,95818],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[95952,96009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[94457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[96212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[96311,96228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[96399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[96441],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[96449,96535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[42256,42224],"length":1,"stats":{"Line":3},"fn_name":"{closure#6}"},{"line":175,"address":[96775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[96576,96674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[96699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[95024,95103,94858],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[64320,64664,64688],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":197,"address":[64392,64675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[64327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[54912,56465,56436],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":223,"address":[54958,54994],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[54969,55303,55158],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[99149,99104,99213,99200],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":226,"address":[55461,55829,55278,55616],"length":1,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[55600],"length":1,"stats":{"Line":4},"fn_name":null},{"line":228,"address":[100858,99700,99295,99392,99354],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":229,"address":[99438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[99454,99586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[99708,100030,99905,99553],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[100226,100151,100009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[100209,100357,100413],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[100390,100672],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[101064,101125,100896,100974,99334],"length":1,"stats":{"Line":5},"fn_name":"{closure#1}"},{"line":236,"address":[100939,101000,101090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[55780,55891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[55946,56005,56251],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[56020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[84816,85143,85119],"length":1,"stats":{"Line":3},"fn_name":"input_parse"},{"line":251,"address":[84845,85130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[84823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[30288,30742,30788],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":284,"address":[30295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[30392,30458,30318],"length":1,"stats":{"Line":3},"fn_name":null},{"line":289,"address":[31316,30816,31270],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":290,"address":[30823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[30920,30846,30986],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":91,"coverable":95},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-20","src","lib.rs"],"content":"//! Advent of Code 2015: Day 20: Infinite Elves and Infinite Houses\n//!\n//! [https://adventofcode.com/2015/day/20](https://adventofcode.com/2015/day/20)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Infinite Elves and Infinite Houses\";\n\tyear = 2015;\n\tday = 20;\n\tparse = |input| input [0].parse::\u003cu32\u003e ();\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse nums::{ Int, IntConv, NumResult };\n\n\tpub type Val = u32;\n\n\tpub fn part_one (input: Val) -\u003e GenResult \u003cVal\u003e {\n\t\tOk (calc_result (input, 10, Val::MAX) ?)\n\t}\n\n\tpub fn part_two (input: Val) -\u003e GenResult \u003cVal\u003e {\n\t\tOk (calc_result (input, 11, 50) ?)\n\t}\n\n\tpub fn calc_result (input: Val, mul: Val, lim: Val) -\u003e NumResult \u003cVal\u003e {\n\n\t\tlet mut divs = Vec::new ();\n\t\tlet mut extend_sqrt = Val::ONE;\n\t\tlet mut extend = Val::ONE;\n\n\t\tfor house in Val::ONE .. {\n\t\t\tlet mut total = Val::ZERO;\n\n\t\t\t// decrement all the values in `divs`, or if they are at zero then include the\n\t\t\t// corresponding \"elf\" and its complement in the total and reset to the elf's number\n\t\t\t// minus one\n\n\t\t\tlet mut div = Val::ZERO;\n\t\t\tfor next in divs.iter_mut () {\n\t\t\t\tdiv = Val::add_2 (div, Val::ONE) ?;\n\t\t\t\tif * next == Val::ZERO {\n\t\t\t\t\t* next = Val::sub_2 (div, 1) ?;\n\t\t\t\t\tlet comp =\n\t\t\t\t\t\tif div == Val::ONE { house }\n\t\t\t\t\t\telse if div == 2 { house \u003e\u003e 1 }\n\t\t\t\t\t\telse { Val::div_2 (house, div) ? };\n\t\t\t\t\tif comp \u003c= lim {\n\t\t\t\t\t\ttotal = Val::add_2 (total, Val::mul_2 (div, mul) ?) ?;\n\t\t\t\t\t}\n\t\t\t\t\tif comp != div \u0026\u0026 div \u003c= lim {\n\t\t\t\t\t\ttotal = Val::add_2 (total, Val::mul_2 (comp, mul) ?) ?;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t* next = Val::sub_2 (* next, Val::ONE) ?;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// once the house square root reaches a new integer we add it to divs, also we have to\n\t\t\t// include the corresponding elf in our total\n\n\t\t\tif house == extend {\n\t\t\t\tif divs.is_empty () {\n\t\t\t\t\tdivs.push (Val::ZERO);\n\t\t\t\t} else {\n\t\t\t\t\tdivs.push (Val::from_usize (divs.len ()) ?);\n\t\t\t\t}\n\t\t\t\ttotal = Val::add_2 (total, Val::mul_2 (extend_sqrt, mul) ?) ?;\n\t\t\t\textend_sqrt = Val::add_2 (extend_sqrt, Val::ONE) ?;\n\t\t\t\textend = Val::mul_2 (extend_sqrt, extend_sqrt) ?;\n\t\t\t}\n\n\t\t\t// return when we find a solution\n\n\t\t\tif total \u003e= input { return Ok (house) }\n\n\t\t}\n\n\t\tunreachable! ();\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"1\" ]));\n\t\tassert_eq_ok! (\"1\", puzzle.part_one (\u0026 [ \"10\" ]));\n\t\tassert_eq_ok! (\"6\", puzzle.part_one (\u0026 [ \"100\" ]));\n\t\tassert_eq_ok! (\"48\", puzzle.part_one (\u0026 [ \"1000\" ]));\n\t\tassert_eq_ok! (\"360\", puzzle.part_one (\u0026 [ \"10000\" ]));\n\t\tassert_eq_ok! (\"3120\", puzzle.part_one (\u0026 [ \"100000\" ]));\n\t\tassert_eq_ok! (\"27720\", puzzle.part_one (\u0026 [ \"1000000\" ]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [ \"1\" ]));\n\t\tassert_eq_ok! (\"1\", puzzle.part_two (\u0026 [ \"10\" ]));\n\t\tassert_eq_ok! (\"6\", puzzle.part_two (\u0026 [ \"100\" ]));\n\t\tassert_eq_ok! (\"36\", puzzle.part_two (\u0026 [ \"1000\" ]));\n\t\tassert_eq_ok! (\"336\", puzzle.part_two (\u0026 [ \"10000\" ]));\n\t\tassert_eq_ok! (\"2880\", puzzle.part_two (\u0026 [ \"100000\" ]));\n\t\tassert_eq_ok! (\"25200\", puzzle.part_two (\u0026 [ \"1000000\" ]));\n\t}\n\n}\n","traces":[{"line":11,"address":[51491,52035],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[51636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[52180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[45984],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":26,"address":[46105,46013],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[46128],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":30,"address":[46157,46249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[46272,49736],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":35,"address":[46321],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[46334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[46345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[46356,46550,46435],"length":1,"stats":{"Line":6},"fn_name":null},{"line":40,"address":[46571],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[46582],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[46823,46601],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[47001,46847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[48658,46994],"length":1,"stats":{"Line":4},"fn_name":null},{"line":50,"address":[47272,47118],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[47356,47260],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[47551,47395,47337,47628],"length":1,"stats":{"Line":8},"fn_name":null},{"line":54,"address":[47417,47556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[47370,48012],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[47672,48017],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[48479,48082,47640],"length":1,"stats":{"Line":4},"fn_name":null},{"line":59,"address":[48139,48484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[48563,47087,48663],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[46805,49624],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[48761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[48821],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[48796,48881],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[49058,49318,48837],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[49379,49483,49291],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[49629,49544,49459],"length":1,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[48735,49689],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[33552,34135,36996],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":99,"address":[33559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[33636,33795,33720],"length":1,"stats":{"Line":3},"fn_name":null},{"line":101,"address":[34268,34146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[34603,34719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[35158,35042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[35481,35597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[36036,35920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[36475,36359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[32677,32672],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":111,"address":[37031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[37267,37192,37108],"length":1,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[37740,37618],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[38075,38191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[38630,38514],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[38953,39069],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[39508,39392],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[39947,39831],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":52},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-21","src","lib.rs"],"content":"//! Advent of Code 2015: Day 21: RPG Simulator 20XX\n//!\n//! [https://adventofcode.com/2015/day/21](https://adventofcode.com/2015/day/21)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"RPG Simulator 20XX\";\n\tyear = 2015;\n\tday = 21;\n\tparse = |input| model::Stats::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Stats;\n\n\tpub fn part_one (boss: Stats) -\u003e GenResult \u003cu32\u003e {\n\t\tOk (\n\t\t\tchoices ()\n\t\t\t\t.filter (|\u0026 (_, player)| outcome (player, boss))\n\t\t\t\t.map (|(gold, _)| gold)\n\t\t\t\t.min ()\n\t\t\t\t.unwrap ()\n\t\t)\n\t}\n\n\tpub fn part_two (boss: Stats) -\u003e GenResult \u003cu32\u003e {\n\t\tOk (\n\t\t\tchoices ()\n\t\t\t\t.filter (|\u0026 (_, player)| ! outcome (player, boss))\n\t\t\t\t.map (|(gold, _)| gold)\n\t\t\t\t.max ()\n\t\t\t\t.unwrap ()\n\t\t)\n\t}\n\n\tfn choices () -\u003e impl Iterator \u003cItem = (u32, Stats)\u003e {\n\t\tPLAYER_STATS [0].iter ()\n\t\t\t.cartesian_product (PLAYER_STATS [1].iter ())\n\t\t\t.cartesian_product (PLAYER_STATS [2].iter ())\n\t\t\t.map (|((a, b), c)| (a, b, c))\n\t\t\t.map (|((gld_0, dmg_0, arm_0), (gld_1, dmg_1, arm_1), (gld_2, dmg_2, arm_2))|\n\t\t\t\t(\n\t\t\t\t\tgld_0 + gld_1 + gld_2,\n\t\t\t\t\tStats {\n\t\t\t\t\t\thit_points: 100,\n\t\t\t\t\t\tdamage: dmg_0 + dmg_1 + dmg_2,\n\t\t\t\t\t\tarmor: arm_0 + arm_1 + arm_2,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t)\n\t}\n\n\tfn outcome (player: Stats, boss: Stats) -\u003e bool {\n\n\t\tlet mut player_hp = player.hit_points;\n\t\tlet mut boss_hp = boss.hit_points;\n\n\t\tlet player_attack = if player.damage \u003e boss.armor {\n\t\t\tplayer.damage - boss.armor\n\t\t} else { 1 };\n\n\t\tlet boss_attack = if boss.damage \u003e player.armor {\n\t\t\tboss.damage - player.armor\n\t\t} else { 1 };\n\n\t\tloop {\n\n\t\t\tif boss_hp \u003c= player_attack { return true }\n\t\t\tboss_hp -= player_attack;\n\n\t\t\tif player_hp \u003c= boss_attack { return false }\n\t\t\tplayer_hp -= boss_attack;\n\n\t\t}\n\n\t}\n\n\tconst PLAYER_STATS: \u0026 [\u0026 [(u32, u32, u32)]] = \u0026 [\n\n\t\t// weapons\n\t\t\u0026 [ (8, 4, 0), (10, 5, 0), (25, 6, 0), (40, 7, 0), (74, 8, 0) ],\n\n\t\t// armor\n\t\t\u0026 [ (0, 0, 0), (13, 0, 1), (31, 0, 2), (53, 0, 3), (75, 0, 4), (102, 0, 5) ],\n\n\t\t// rings\n\t\t\u0026 [\n\t\t\t(0, 0, 0), (25, 1, 0), (50, 2, 0), (100, 3, 0), (20, 0, 1), (40, 0, 2), (80, 0, 3),\n\t\t\t(75, 3, 0), (125, 4, 0), (45, 1, 1), (65, 1, 2), (105, 1, 3), (150, 5, 0), (70, 2, 1),\n\t\t\t(90, 2, 2), (130, 2, 3), (120, 3, 1), (140, 3, 2), (180, 3, 3), (60, 0, 3),\n\t\t\t(100, 0, 4), (120, 0, 5),\n\t\t],\n\n\t];\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Stats {\n\t\tpub hit_points: u32,\n\t\tpub damage: u32,\n\t\tpub armor: u32,\n\t}\n\n\timpl Stats {\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cStats\u003e {\n\t\t\tif input.len () != 3 { Err (\"Invalid input\") ?; }\n\t\t\tfn parse_line (line_idx: usize, line: \u0026 str, expect: \u0026 str) -\u003e GenResult \u003cu32\u003e {\n\t\t\t\tParser::wrap (line, |parser| {\n\t\t\t\t\tlet value = parser.expect (expect) ?.int () ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (value)\n\t\t\t\t}).map_parse_err (|_| format! (\"Invalid input: line {}: {}\", line_idx + 1, line))\n\t\t\t}\n\t\t\tlet hit_points = parse_line (0, input [0], \"Hit Points: \") ?;\n\t\t\tlet damage = parse_line (1, input [1], \"Damage: \") ?;\n\t\t\tlet armor = parse_line (2, input [2], \"Armor: \") ?;\n\t\t\tOk (Stats { hit_points, damage, armor })\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse super::*;\n\n\tconst EXAMPLES: \u0026 [\u0026 [\u0026 str]] = \u0026 [\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 3\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 4\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 3\", \"Armor: 5\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 3\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 4\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 4\", \"Armor: 5\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 3\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 4\" ],\n\t\t\u0026 [ \"Hit Points: 100\", \"Damage: 5\", \"Armor: 5\" ],\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"23\", puzzle.part_one (EXAMPLES [0]));\n\t\tassert_eq_ok! (\"38\", puzzle.part_one (EXAMPLES [1]));\n\t\tassert_eq_ok! (\"39\", puzzle.part_one (EXAMPLES [2]));\n\t\tassert_eq_ok! (\"38\", puzzle.part_one (EXAMPLES [3]));\n\t\tassert_eq_ok! (\"53\", puzzle.part_one (EXAMPLES [4]));\n\t\tassert_eq_ok! (\"59\", puzzle.part_one (EXAMPLES [5]));\n\t\tassert_eq_ok! (\"53\", puzzle.part_one (EXAMPLES [6]));\n\t\tassert_eq_ok! (\"71\", puzzle.part_one (EXAMPLES [7]));\n\t\tassert_eq_ok! (\"79\", puzzle.part_one (EXAMPLES [8]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"33\", puzzle.part_two (EXAMPLES [0]));\n\t\tassert_eq_ok! (\"58\", puzzle.part_two (EXAMPLES [1]));\n\t\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [2]));\n\t\tassert_eq_ok! (\"58\", puzzle.part_two (EXAMPLES [3]));\n\t\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [4]));\n\t\tassert_eq_ok! (\"133\", puzzle.part_two (EXAMPLES [5]));\n\t\tassert_eq_ok! (\"108\", puzzle.part_two (EXAMPLES [6]));\n\t\tassert_eq_ok! (\"133\", puzzle.part_two (EXAMPLES [7]));\n\t\tassert_eq_ok! (\"158\", puzzle.part_two (EXAMPLES [8]));\n\t}\n\n}\n","traces":[{"line":11,"address":[44003,43411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[43493],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[44085],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[73152],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":25,"address":[73200,73174],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[38000,38014],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":27,"address":[38112,38120],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":33,"address":[73328],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":35,"address":[73376,73350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[38144,38158],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":37,"address":[38264,38256],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":43,"address":[73504],"length":1,"stats":{"Line":2},"fn_name":"choices"},{"line":44,"address":[73521,73600,73651],"length":1,"stats":{"Line":6},"fn_name":null},{"line":45,"address":[73550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[73613],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[38288,38302],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":48,"address":[38382,38352,38709],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":50,"address":[38546],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[38669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[38583],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[38620],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[73728],"length":1,"stats":{"Line":2},"fn_name":"outcome"},{"line":62,"address":[73742],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[73748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[73807,73754,73770],"length":1,"stats":{"Line":6},"fn_name":null},{"line":66,"address":[73782,73809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[73762],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[73902,73849,73865],"length":1,"stats":{"Line":6},"fn_name":null},{"line":70,"address":[73877,73904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[73857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[74072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[73934,73967],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[74006,73944,73990],"length":1,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[73994,74058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[74036,74068,74077],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[61632],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":121,"address":[61707,61675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[62480],"length":1,"stats":{"Line":2},"fn_name":"parse_line"},{"line":123,"address":[62518,62582],"length":1,"stats":{"Line":10},"fn_name":null},{"line":124,"address":[63252,63171,62974],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[63450,63377,63228],"length":1,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[63434],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[62562],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[61978,61686,61836],"length":1,"stats":{"Line":4},"fn_name":null},{"line":130,"address":[61956,62176,62026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[62154,62230,62430],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[62371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[25286,20816,21417],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":157,"address":[20823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[21002,21077,20916],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[21553,21428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[21894,22019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[22360,22485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[22939,22820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[23381,23262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[23823,23704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[24146,24265],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[24588,24713],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[25312,29782,25913],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":171,"address":[25319],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[25573,25498,25412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":173,"address":[26049,25924],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[26515,26390],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[26856,26981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[27316,27435],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[27877,27758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[28319,28200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[28642,28761],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[29084,29209],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":69,"coverable":69},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-22","src","lib.rs"],"content":"//! Advent of Code 2015: Day 22: Wizard Simulator 20XX\n//!\n//! [https://adventofcode.com/2015/day/22](https://adventofcode.com/2015/day/22)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Wizard Simulator 20XX\";\n\tyear = 2015;\n\tday = 22;\n\tparse = |input| model::Input::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Boss;\n\tuse model::Input;\n\tuse model::Player;\n\tuse search::PrioritySearch;\n\tuse search::PrioritySearchAdder;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu16\u003e {\n\t\tOk (calc_result (input, Difficulty::Easy).ok_or (\"No solution found\") ?)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu16\u003e {\n\t\tOk (calc_result (input, Difficulty::Hard).ok_or (\"No solution found\") ?)\n\t}\n\n\tfn calc_result (input: Input, difficulty: Difficulty) -\u003e Option \u003cu16\u003e {\n\t\toutcomes (input, difficulty)\n\t\t\t.filter (|outcome| outcome.winner == Contender::Player)\n\t\t\t.map (|outcome| outcome.mana)\n\t\t\t.next ()\n\t}\n\n\tfn outcomes (input: Input, difficulty: Difficulty) -\u003e impl Iterator \u003cItem = Outcome\u003e {\n\n\t\tlet mut search = PrioritySearch::with_hash_map (\n\t\t\t|state: State, _, mut adder: PrioritySearchAdder \u003c'_, _, _, _\u003e| {\n\t\t\t\tif state.boss.hit_points == 0 {\n\t\t\t\t\tSome (Outcome { winner: Contender::Player, mana: state.mana })\n\t\t\t\t} else if state.player.hit_points == 0 {\n\t\t\t\t\tSome (Outcome { winner: Contender::Boss, mana: state.mana })\n\t\t\t\t} else {\n\t\t\t\t\tfor next_state in next_states (state) {\n\t\t\t\t\t\tadder.add (next_state, next_state.mana);\n\t\t\t\t\t}\n\t\t\t\t\tNone\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tsearch.push (State {\n\t\t\tplayer: input.player,\n\t\t\tboss: input.boss,\n\t\t\teffects: Effects { shield: 0, poison: 0, recharge: 0 },\n\t\t\tturn: Contender::Player,\n\t\t\tdifficulty,\n\t\t\tmana: 0,\n\t\t}, 0);\n\n\t\tsearch.flatten ()\n\n\t}\n\n\tfn next_states (mut state: State) -\u003e ArrayVec \u003cState, 5\u003e {\n\n\t\tif state.effects.shield \u003e 0 {\n\t\t\tstate.effects.shield -= 1;\n\t\t}\n\n\t\tif state.effects.poison \u003e 0 {\n\t\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 3);\n\t\t\tif state.boss.hit_points == 0 { return array_vec! [ state ] }\n\t\t\tstate.effects.poison -= 1;\n\t\t}\n\n\t\tif state.effects.recharge \u003e 0 {\n\t\t\tstate.player.mana += 101;\n\t\t\tstate.effects.recharge -= 1;\n\t\t}\n\n\t\tif state.turn == Contender::Player {\n\n\t\t\tstate.turn = Contender::Boss;\n\n\t\t\tif state.player.mana \u003c 53 {\n\t\t\t\tstate.player.hit_points = 0;\n\t\t\t\treturn array_vec! [ state ];\n\t\t\t}\n\n\t\t\tif state.difficulty == Difficulty::Hard {\n\t\t\t\tstate.player.hit_points -= 1;\n\t\t\t\tif state.player.hit_points == 0 {\n\t\t\t\t\treturn array_vec! [ state ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet mut results = ArrayVec::new ();\n\n\t\t\tif state.player.mana \u003e= 53 {\n\t\t\t\tlet mut state = state;\n\t\t\t\tstate.player.mana -= 53;\n\t\t\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 4);\n\t\t\t\tstate.mana += 53;\n\t\t\t\tresults.push (state);\n\t\t\t}\n\n\t\t\tif state.player.mana \u003e= 73 {\n\t\t\t\tlet mut state = state;\n\t\t\t\tstate.player.hit_points += 2;\n\t\t\t\tstate.player.mana -= 73;\n\t\t\t\tstate.boss.hit_points -= cmp::min (state.boss.hit_points, 2);\n\t\t\t\tstate.mana += 73;\n\t\t\t\tresults.push (state);\n\t\t\t}\n\n\t\t\tif state.player.mana \u003e= 113 \u0026\u0026 state.effects.shield == 0 {\n\t\t\t\tlet mut state = state;\n\t\t\t\tstate.player.mana -= 113;\n\t\t\t\tstate.effects.shield = 6;\n\t\t\t\tstate.mana += 113;\n\t\t\t\tresults.push (state);\n\t\t\t}\n\n\t\t\tif state.player.mana \u003e= 173 \u0026\u0026 state.effects.poison == 0 {\n\t\t\t\tlet mut state = state;\n\t\t\t\tstate.player.mana -= 173;\n\t\t\t\tstate.effects.poison = 6;\n\t\t\t\tstate.mana += 173;\n\t\t\t\tresults.push (state);\n\t\t\t}\n\n\t\t\tif state.player.mana \u003e= 229 \u0026\u0026 state.effects.recharge == 0 {\n\t\t\t\tlet mut state = state;\n\t\t\t\tstate.player.mana -= 229;\n\t\t\t\tstate.effects.recharge = 5;\n\t\t\t\tstate.mana += 229;\n\t\t\t\tresults.push (state);\n\t\t\t}\n\n\t\t\tresults\n\n\t\t} else {\n\n\t\t\tstate.turn = Contender::Player;\n\n\t\t\tlet armor = if state.effects.shield \u003e 0 { 7 } else { 0 };\n\t\t\tlet attack = if state.boss.damage \u003c= armor { 1 } else { state.boss.damage - armor };\n\t\t\tstate.player.hit_points -= cmp::min (state.player.hit_points, attack);\n\t\t\tarray_vec! [ state ]\n\n\t\t}\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tstruct Outcome {\n\t\twinner: Contender,\n\t\tmana: u16,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tstruct Effects {\n\t\tshield: u8,\n\t\tpoison: u8,\n\t\trecharge: u8,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tstruct State {\n\t\tplayer: Player,\n\t\tboss: Boss,\n\t\teffects: Effects,\n\t\tturn: Contender,\n\t\tdifficulty: Difficulty,\n\t\tmana: u16,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tenum Contender { Player, Boss }\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tenum Difficulty { Easy, Hard }\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Input {\n\t\tpub player: Player,\n\t\tpub boss: Boss,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Player {\n\t\tpub hit_points: u16,\n\t\tpub mana: u16,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Boss {\n\t\tpub hit_points: u16,\n\t\tpub damage: u16,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet player = Player { hit_points: 50, mana: 500 };\n\t\t\tif input.len () != 2 { Err (\"Invalid input\") ?; }\n\t\t\tfn parse_line (line_idx: usize, line: \u0026 str, expect: \u0026 str) -\u003e GenResult \u003cu16\u003e {\n\t\t\t\tParser::wrap (line, |parser| {\n\t\t\t\t\tlet value = parser.expect (expect) ?.int () ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (value)\n\t\t\t\t}).map_parse_err (|_| format! (\"Invalid input: line {}: {}\", line_idx + 1, line))\n\t\t\t}\n\t\t\tlet hit_points = parse_line (0, input [0], \"Hit Points: \") ?;\n\t\t\tlet damage = parse_line (1, input [1], \"Damage: \") ?;\n\t\t\tif hit_points \u003e 100 { Err (\"Boss hit points are limited to 100\") ?; }\n\t\t\tif damage \u003e 15 { Err (\"Boss damage is limited to 15\") ?; }\n\t\t\tOk (Input { player, boss: Boss { hit_points, damage }})\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"491\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"787\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"1249\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"734\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"900\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"1269\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"754\", puzzle.part_one (\u0026 [ \"Hit Points: 40\", \"Damage: 10\" ]));\n\t\tassert_eq_ok! (\"900\", puzzle.part_one (\u0026 [ \"Hit Points: 50\", \"Damage: 10\" ]));\n\t\tassert_eq_ok! (\"1309\", puzzle.part_one (\u0026 [ \"Hit Points: 60\", \"Damage: 10\" ]));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"734\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"900\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"1309\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 8\" ]));\n\t\tassert_eq_ok! (\"754\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"920\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"1309\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 9\" ]));\n\t\tassert_eq_ok! (\"794\", puzzle.part_two (\u0026 [ \"Hit Points: 40\", \"Damage: 10\" ]));\n\t\tassert_eq_ok! (\"1256\", puzzle.part_two (\u0026 [ \"Hit Points: 50\", \"Damage: 10\" ]));\n\t\tassert_eq_ok! (\"1442\", puzzle.part_two (\u0026 [ \"Hit Points: 60\", \"Damage: 10\" ]));\n\t}\n\n}\n","traces":[{"line":11,"address":[41171,40611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[40672],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[41232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[32672],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":28,"address":[32704,32852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[32912],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[33092,32944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[33152,33330],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":36,"address":[33189],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[69787,69760],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":38,"address":[69849,69824],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":42,"address":[33748,33775,33376],"length":1,"stats":{"Line":2},"fn_name":"outcomes"},{"line":45,"address":[70280,69856,70249],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":46,"address":[69891,69936],"length":1,"stats":{"Line":3},"fn_name":null},{"line":47,"address":[69902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[69945,69989],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[69955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[69998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[70200],"length":1,"stats":{"Line":2},"fn_name":null},{"line":54,"address":[70275],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[33497],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[33453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[33463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[33473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[33639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[33792,34196],"length":1,"stats":{"Line":2},"fn_name":"next_states"},{"line":74,"address":[33814,33866],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[33838,33868],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[34069,33825],"length":1,"stats":{"Line":4},"fn_name":null},{"line":79,"address":[33994,33923],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[33985,34109,34024],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[34074,34041],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[34364,33903],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[34322,34270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[34304,34361,34369],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[34403,36827,36254,34240],"length":1,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[34438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[34442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[34484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[34489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[34454,34613],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[34682,34642],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[34674],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[34712],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[34619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[34837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[34870],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[34893,34955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[34930,35032,35094],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[35129,35176,35068],"length":1,"stats":{"Line":4},"fn_name":null},{"line":112,"address":[35209,35137],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[34849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[35240],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[35326,35263],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[35300,35364,35397],"length":1,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[35435,35497,35372],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[35535,35582,35471],"length":1,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[35543,35615],"length":1,"stats":{"Line":4},"fn_name":null},{"line":124,"address":[35219,35620],"length":1,"stats":{"Line":4},"fn_name":null},{"line":125,"address":[35688],"length":1,"stats":{"Line":2},"fn_name":null},{"line":126,"address":[35711,35782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[35748],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[35867,35820,35756],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[35900,35828],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[35666,35905],"length":1,"stats":{"Line":3},"fn_name":null},{"line":133,"address":[35973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[35996,36067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[36033],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[36152,36041,36105],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[36113,36185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[36190,35951],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[36264],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[36287,36358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[36324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[36332,36443,36396],"length":1,"stats":{"Line":4},"fn_name":null},{"line":145,"address":[36404,36476],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[36236],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[34414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[34418,36481],"length":1,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[36599,36508],"length":1,"stats":{"Line":4},"fn_name":null},{"line":156,"address":[36695,36649,36568],"length":1,"stats":{"Line":4},"fn_name":null},{"line":157,"address":[36680,36730],"length":1,"stats":{"Line":4},"fn_name":null},{"line":220,"address":[52224],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":221,"address":[52267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[52313,52281],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[53264],"length":1,"stats":{"Line":2},"fn_name":"parse_line"},{"line":224,"address":[51065,50544,50990],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":225,"address":[50787,50590,50873],"length":1,"stats":{"Line":4},"fn_name":null},{"line":226,"address":[51072,50849,50998],"length":1,"stats":{"Line":4},"fn_name":null},{"line":227,"address":[51056],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[51200,51238],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":230,"address":[52442,52589,52292],"length":1,"stats":{"Line":4},"fn_name":null},{"line":231,"address":[52793,52567,52637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":232,"address":[52862,52780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[52847,53116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":234,"address":[53020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[24917,24912],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":247,"address":[79687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[79780,79939,79864],"length":1,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[80290,80412],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[80753,80875],"length":1,"stats":{"Line":2},"fn_name":null},{"line":251,"address":[81338,81216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[81673,81789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[82228,82112],"length":1,"stats":{"Line":2},"fn_name":null},{"line":254,"address":[82667,82551],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[82990,83106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":256,"address":[83545,83429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":260,"address":[24944,24949],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":261,"address":[84151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[84244,84403,84328],"length":1,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[84754,84876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[85217,85339],"length":1,"stats":{"Line":2},"fn_name":null},{"line":265,"address":[85680,85802],"length":1,"stats":{"Line":2},"fn_name":null},{"line":266,"address":[86137,86253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[86692,86576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[87015,87131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[87570,87454],"length":1,"stats":{"Line":2},"fn_name":null},{"line":270,"address":[88009,87893],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":118,"coverable":118},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-23","src","lib.rs"],"content":"//! Advent of Code 2015: Day 23: Opening the Turing Lock\n//!\n//! [https://adventofcode.com/2015/day/23](https://adventofcode.com/2015/day/23)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Opening the Turing Lock\";\n\tyear = 2015;\n\tday = 23;\n\tparse = |input| model::Input::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::Instr;\n\tuse model::Reg;\n\tuse model::Val;\n\tuse nums::Int;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cVal\u003e {\n\t\tlet (_, reg_b) = emulate (input, 0, 0, 0, 0x10000) ?;\n\t\tOk (reg_b)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cVal\u003e {\n\t\tlet (_, reg_b) = emulate (input, 1, 0, 0, 0x10000) ?;\n\t\tOk (reg_b)\n\t}\n\n\tfn emulate (\n\t\tinput: Input,\n\t\tmut reg_a: Val,\n\t\tmut reg_b: Val,\n\t\tmut next: Val,\n\t\tmut max_loops: usize,\n\t) -\u003e Result \u003c(Val, Val), EmulateError\u003e {\n\n\t\t// main loop\n\n\t\tlet mut seen = HashSet::new ();\n\t\twhile next \u003c Val::from_usize (input.instrs.len ()).map_err (|_| EmulateError::Overflow) ? {\n\n\t\t\t// abort when we reach max_loops\n\n\t\t\tif max_loops == 0 { return Err (EmulateError::MaxLoops) }\n\t\t\tmax_loops -= 1;\n\n\t\t\t// detect infinite loops and abort\n\n\t\t\tif ! seen.insert ((reg_a, reg_b, next)) { return Err (EmulateError::InfiniteLoop) }\n\n\t\t\t// execute next instruction\n\n\t\t\tlet instr = input.instrs [next.as_usize ()];\n\t\t\tmatch instr {\n\t\t\t\tInstr::Hlf (Reg::A) =\u003e reg_a /= 2,\n\t\t\t\tInstr::Hlf (Reg::B) =\u003e reg_b /= 2,\n\t\t\t\tInstr::Tpl (Reg::A) =\u003e\n\t\t\t\t\treg_a = Val::mul_2 (reg_a, 3).map_err (|_| EmulateError::Overflow) ?,\n\t\t\t\tInstr::Tpl (Reg::B) =\u003e\n\t\t\t\t\treg_b = Val::mul_2 (reg_b, 3).map_err (|_| EmulateError::Overflow) ?,\n\t\t\t\tInstr::Inc (Reg::A) =\u003e\n\t\t\t\t\treg_a = Val::add_2 (reg_a, 1).map_err (|_| EmulateError::Overflow) ?,\n\t\t\t\tInstr::Inc (Reg::B) =\u003e\n\t\t\t\t\treg_b = Val::add_2 (reg_b, 1).map_err (|_| EmulateError::Overflow) ?,\n\t\t\t\tInstr::Jmp (offset) =\u003e {\n\t\t\t\t\tnext = Val::add_signed (next, offset).map_err (|_| EmulateError::Overflow) ?;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tInstr::Jie (Reg::A, offset) =\u003e if reg_a \u0026 1 == 0 {\n\t\t\t\t\tnext = Val::add_signed (next, offset).map_err (|_| EmulateError::Overflow) ?;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tInstr::Jie (Reg::B, offset) =\u003e if reg_b \u0026 1 == 0 {\n\t\t\t\t\tnext = Val::add_signed (next, offset).map_err (|_| EmulateError::Overflow) ?;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tInstr::Jio (Reg::A, offset) =\u003e if reg_a == 1 {\n\t\t\t\t\tnext = Val::add_signed (next, offset).map_err (|_| EmulateError::Overflow) ?;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tInstr::Jio (Reg::B, offset) =\u003e if reg_b == 1 {\n\t\t\t\t\tnext = Val::add_signed (next, offset).map_err (|_| EmulateError::Overflow) ?;\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t}\n\n\t\t\t// move to next instruction, jump instructions skip this bit\n\n\t\t\tnext += 1;\n\n\t\t}\n\n\t\t// return the two registers\n\n\t\tOk ((reg_a, reg_b))\n\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tenum EmulateError {\n\t\tInfiniteLoop,\n\t\tOverflow,\n\t\tMaxLoops,\n\t}\n\n\timpl Error for EmulateError {\n\t}\n\n\timpl Display for EmulateError {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tmatch self {\n\t\t\t\tEmulateError::InfiniteLoop =\u003e write! (formatter, \"Infinite loop\") ?,\n\t\t\t\tEmulateError::Overflow =\u003e write! (formatter, \"Arithmetic overflow\") ?,\n\t\t\t\tEmulateError::MaxLoops =\u003e write! (formatter, \"Max loops reached\") ?,\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn emulate () {\n\t\t\tuse Instr::*;\n\t\t\tuse Reg::*;\n\t\t\t// inc, hlf, tpl\n\t\t\tassert_eq_ok! ((2, 0), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Tpl (A), Inc (A), Hlf (A) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((0, 2), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (B), Tpl (B), Inc (B), Hlf (B) ] }, 0, 0, 0, 10));\n\t\t\t// jmp\n\t\t\tassert_eq_ok! ((1, 1), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Jmp (2), Tpl (A), Inc (B) ] }, 0, 0, 0, 10));\n\t\t\t// jio\n\t\t\tassert_eq_ok! ((1, 1), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Jio (A, 2), Inc (B), Inc (B) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((0, 2), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Jio (A, 2), Inc (B), Inc (B) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((1, 1), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (B), Jio (B, 2), Inc (A), Inc (A) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((2, 0), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Jio (B, 2), Inc (A), Inc (A) ] }, 0, 0, 0, 10));\n\t\t\t// jie\n\t\t\tassert_eq_ok! ((1, 2), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Jie (A, 2), Inc (B), Inc (B) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((0, 1), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Jie (A, 2), Inc (B), Inc (B) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((2, 1), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (B), Jie (B, 2), Inc (A), Inc (A) ] }, 0, 0, 0, 10));\n\t\t\tassert_eq_ok! ((1, 0), logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Jie (B, 2), Inc (A), Inc (A) ] }, 0, 0, 0, 10));\n\t\t\t// errors\n\t\t\tassert_err! (\"Infinite loop\", logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Jmp (0) ] }, 0, 0, 0, 10));\n\t\t\tassert_err! (\"Max loops reached\", logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Jmp (-1) ] }, 0, 0, 0, 10));\n\t\t\tassert_err! (\"Arithmetic overflow\", logic::emulate (\n\t\t\t\tInput { instrs: vec! [ Inc (A), Tpl (A), Jmp (-1) ] }, 0, 0, 0, 100));\n\t\t}\n\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\tpub type Val = u32;\n\tpub type Offset = i32;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Input {\n\t\tpub instrs: Vec \u003cInstr\u003e,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Instr {\n\t\tHlf (Reg),\n\t\tTpl (Reg),\n\t\tInc (Reg),\n\t\tJmp (Offset),\n\t\tJie (Reg, Offset),\n\t\tJio (Reg, Offset),\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Reg { A, B }\n\n\timpl Instr {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cInstr\u003e {\n\t\t\tParser::wrap (input, Self::parse_real)\n\t\t\t\t.map_parse_err (|col_idx|\n\t\t\t\t\tformat! (\"Invalid input: col {}: {}\", col_idx + 1, input))\n\t\t}\n\t\tfn parse_real (parser: \u0026 mut Parser) -\u003e ParseResult \u003cInstr\u003e {\n\t\t\tparser\n\t\t\t\t.set_ignore_whitespace (true)\n\t\t\t\t.set_word_pred (|ch| ch.is_ascii_alphanumeric ());\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"hlf\") ?.confirm ();\n\t\t\t\t\tlet reg = Reg::parse_real (parser) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Hlf (reg))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"tpl\") ?.confirm ();\n\t\t\t\t\tlet reg = Reg::parse_real (parser) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Tpl (reg))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"inc\") ?.confirm ();\n\t\t\t\t\tlet reg = Reg::parse_real (parser) ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Inc (reg))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"jmp\") ?.confirm ();\n\t\t\t\t\tlet offset = parser.int () ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Jmp (offset))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"jio\") ?.confirm ();\n\t\t\t\t\tlet reg = Reg::parse_real (parser) ?;\n\t\t\t\t\tlet offset = parser.expect (\",\") ?.int () ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Jio (reg, offset))\n\t\t\t\t})\n\t\t\t\t.of (|parser| {\n\t\t\t\t\tparser.expect_word (\"jie\") ?.confirm ();\n\t\t\t\t\tlet reg = Reg::parse_real (parser) ?;\n\t\t\t\t\tlet offset = parser.expect (\",\") ?.int () ?;\n\t\t\t\t\tparser.end () ?;\n\t\t\t\t\tOk (Instr::Jie (reg, offset))\n\t\t\t\t})\n\t\t\t\t.done ()\n\t\t}\n\t}\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet instrs =\n\t\t\t\tinput.iter ().enumerate ()\n\t\t\t\t\t.map (|(line_idx, line)|\n\t\t\t\t\t\tParser::wrap (line, Instr::parse_real)\n\t\t\t\t\t\t\t.map_parse_err (|col_idx|\n\t\t\t\t\t\t\t\tformat! (\"Invalid input: line {}: col {}: {}\",\n\t\t\t\t\t\t\t\t\tline_idx + 1, col_idx + 1, line)))\n\t\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\t\tOk (Input { instrs })\n\t\t}\n\t}\n\n\timpl Reg {\n\t\tfn parse_real (parser: \u0026 mut Parser) -\u003e ParseResult \u003cReg\u003e {\n\t\t\tparser.any ()\n\t\t\t\t.of (|parser| { parser.expect_word (\"a\") ?; Ok (Reg::A) })\n\t\t\t\t.of (|parser| { parser.expect_word (\"b\") ?; Ok (Reg::B) })\n\t\t\t\t.done ()\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn input_parse () {\n\t\t\tassert_err! (\"Invalid input: line 2: col 8: jio a, +-5\",\n\t\t\t\tInput::parse (\u0026 [ \"inc a\", \"jio a, +-5\" ]));\n\t\t}\n\n\t\t#[ test ]\n\t\tfn instr_parse () {\n\t\t\tuse { Instr::*, Reg::* };\n\t\t\tassert_eq_ok! (Hlf (A), Instr::parse (\"hlf a\"));\n\t\t\tassert_eq_ok! (Tpl (B), Instr::parse (\"tpl b\"));\n\t\t\tassert_eq_ok! (Inc (A), Instr::parse (\"inc a\"));\n\t\t\tassert_eq_ok! (Jmp (-1), Instr::parse (\"jmp -1\"));\n\t\t\tassert_eq_ok! (Jio (B, 0), Instr::parse (\"jio b, 0\"));\n\t\t\tassert_eq_ok! (Jie (A, 1), Instr::parse (\"jie a, +1\"));\n\t\t\tassert_err! (\"Invalid input: col 5: inc abc\", Instr::parse (\"inc abc\"));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"jio a, +5\",\n\t\t\"inc a\",\n\t\t\"tpl a\",\n\t\t\"tpl a\",\n\t\t\"jmp +3\",\n\t\t\"inc a\",\n\t\t\"tpl a\",\n\t\t\"jio a, +4\",\n\t\t\"hlf a\",\n\t\t\"inc b\",\n\t\t\"jmp -3\",\n\t];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"3\", puzzle.part_one (EXAMPLE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"2\", puzzle.part_two (EXAMPLE));\n\t}\n\n}\n","traces":[{"line":11,"address":[82619,83371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":12,"address":[82720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":13,"address":[83472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[88448],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":29,"address":[88462,88589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[88573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[88624],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":34,"address":[88767,88638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[88751],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[88800,92116,92171],"length":1,"stats":{"Line":1},"fn_name":"emulate"},{"line":48,"address":[88869,88916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[89000,88926,92078],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[89323],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[89466,89351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[89561,89394,89505],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[89527,89589],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[89786,89630],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[92020],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[92042],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[91589,91841],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[91619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[91158,91410],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[91188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[89741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[90979,91121,89755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[90406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[90738,90928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[90451],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[90498,90694],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[89825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[90173,90369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[89862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[89900,89975,90129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[92071,92083,89928],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[89254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[92192],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":120,"address":[92220],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[92252,92565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[92291,92484],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[92330,92443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[92436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[88197,88192],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":139,"address":[109594,109904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[109383],"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[110446,110136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[109863,109956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[110681,110991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[110498,110405],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[111544,111234],"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":[111043,110950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":149,"address":[111759,112069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[111503,111596],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[112312,112622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[112028,112121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[112837,113147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[112581,112674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[113390,113700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[113199,113106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[113915,114225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[113659,113752],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[114468,114778],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[114277,114184],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[115276,114993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[114737,114830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[115424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[115244,115325],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[115893],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[115741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[116368],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[116188],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[62112],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":207,"address":[62135,62169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[33056,33298],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":209,"address":[33094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[62208],"length":1,"stats":{"Line":1},"fn_name":"parse_real"},{"line":212,"address":[62244],"length":1,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[33312,33325],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":215,"address":[62282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[33360,33582,33919],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":217,"address":[33406],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[33705,33595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[33684,33929,33826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[33883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[34064,34623,34286],"length":1,"stats":{"Line":3},"fn_name":"{closure#2}"},{"line":223,"address":[34110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[34299,34409],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[34530,34633,34388],"length":1,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[34587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[34990,35327,34768],"length":1,"stats":{"Line":3},"fn_name":"{closure#3}"},{"line":229,"address":[34814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[35003,35113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[35092,35234,35337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[35291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[35472,36021,35694],"length":1,"stats":{"Line":3},"fn_name":"{closure#4}"},{"line":235,"address":[35518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[35707,35810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":237,"address":[36031,35789,35931],"length":1,"stats":{"Line":2},"fn_name":null},{"line":238,"address":[35988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":[37150,36382,36160],"length":1,"stats":{"Line":3},"fn_name":"{closure#5}"},{"line":241,"address":[36206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[36517,36395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":[36484,36835,36925,36638],"length":1,"stats":{"Line":4},"fn_name":null},{"line":244,"address":[37046,37160,36904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":245,"address":[37107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[37518,38286,37296],"length":1,"stats":{"Line":3},"fn_name":"{closure#6}"},{"line":248,"address":[37342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[37531,37653],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[37774,37620,38061,37971],"length":1,"stats":{"Line":3},"fn_name":null},{"line":251,"address":[38182,38040,38296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[38243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[62448],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":260,"address":[62507,62865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[38541,38460,38432],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":263,"address":[38470,38516],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[38496,38560,38941],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":265,"address":[38789,38638,38728],"length":1,"stats":{"Line":3},"fn_name":null},{"line":266,"address":[38603,38664,38754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[62702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[62896],"length":1,"stats":{"Line":1},"fn_name":"parse_real"},{"line":274,"address":[62914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[38960,39006],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":276,"address":[39246,39200],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":287,"address":[54709,54704],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":288,"address":[102109,102383],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[102087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[54736,54741],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":295,"address":[102590,102879,102439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[102836,102926,103004,103294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":297,"address":[103341,103251,103419,103709],"length":1,"stats":{"Line":3},"fn_name":null},{"line":298,"address":[103834,103666,103756,104124],"length":1,"stats":{"Line":3},"fn_name":null},{"line":299,"address":[104243,104081,104171,104509],"length":1,"stats":{"Line":3},"fn_name":null},{"line":300,"address":[104556,104472,104628,104894],"length":1,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[104941,105291,104857],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[57392,57397],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":329,"address":[96279],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[96302,96442,96376],"length":1,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[57424,57429],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":335,"address":[96807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":[96970,96830,96904],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":139,"coverable":139},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-24","src","lib.rs"],"content":"//! Advent of Code 2015: Day 24: It Hangs in the Balance\n//!\n//! [https://adventofcode.com/2015/day/24](https://adventofcode.com/2015/day/24)\n//!\n//! # Input\n//!\n//! Each line contains a decimal integer, representing the weight of a single package.\n//!\n//! # Part one\n//!\n//! Split the packages into three piles of equal weight. Optimise so that one pile has the fewest\n//! possible number of packages. Further optimize so that the product of the weights of the\n//! packages in the first pile is as small as possible. Produce that product as a result.\n//!\n//! # Part two\n//!\n//! The same as part one, but with four piles instead of three.\n//!\n//! # Algorithm\n//!\n//! - Iteratively build up a list of items to assign to each pile, always in order from heavier to\n//!   lighter. This ensures that we find a solution with the smallest possible number of packages\n//!   in the first pile before any other.\n//! - Once we find a solution for all three piles, record the size and product of the first pile,\n//!   and only consider solutions with a first pile which would signify an improvement.\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"It Hangs in the Balance\";\n\tyear = 2015;\n\tday = 24;\n\tparse = |input| model::Input::parse (input);\n\tpart_one = |input| logic::part_one (input);\n\tpart_two = |input| logic::part_two (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse nums::Int;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result::\u003c3\u003e (input)\n\t}\n\n\tpub fn part_two (input: Input) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result::\u003c4\u003e (input)\n\t}\n\n\tfn calc_result \u003cconst PILES: usize\u003e (input: Input) -\u003e GenResult \u003cu64\u003e {\n\n\t\t// make sure the weights are in reverse order\n\n\t\tlet weights: Vec \u003cu32\u003e =\n\t\t\tinput.weights.into_iter ()\n\t\t\t\t.sorted_by_key (|\u0026 weight| cmp::Reverse (weight))\n\t\t\t\t.collect ();\n\n\t\t// sanity check (mainly for fuzzing)\n\n\t\tif weights.len () \u003e 50 {\n\t\t\tErr (\"Refusing to deal with more than 50 items\") ?;\n\t\t}\n\n\t\tif weights.iter ().dedup ().count () != weights.len () {\n\t\t\tErr (\"Refusing to deal with duplicated weights\") ?;\n\t\t}\n\n\t\tif weights.iter ().copied ().any (|weight| weight \u003e 200) {\n\t\t\tErr (\"Refusing to deal with weights over 200\") ?;\n\t\t}\n\n\t\t// work out the balanced weight of each pile\n\n\t\tlet total_weight: u32 =\n\t\t\tweights.iter ().copied ()\n\t\t\t\t.fold (Ok (0), |sum, item| sum\n\t\t\t\t\t.and_then (|sum| u32::add_2 (sum, item))) ?;\n\t\tlet want_pile_weight = total_weight / PILES.as_u32 ();\n\t\tif want_pile_weight * PILES.as_u32 () != total_weight {\n\t\t\tErr (format! (\"Total weight is not a multiple of {}\", PILES)) ?;\n\t\t}\n\n\t\t// once we find one solution we can rule out any first piles which are bigger or have a\n\t\t// higher quantum entanglement\n\n\t\tlet mut max_len_0 = usize::MAX;\n\t\tlet mut max_quantum_0 = u64::MAX;\n\n\t\t// stack holds a list of piles and the indexes of their contents\n\n\t\tlet mut stack: Vec \u003cVec \u003cusize\u003e\u003e = vec! [ vec! [] ];\n\n\t\t// todo holds continuations, first value is number of piles to retain, second is number of\n\t\t// items in top pile, third is new index to push to top pile, for initial state we have a\n\t\t// single pile and branch for the full list of weights as the next item in it\n\n\t\tlet mut todo: Vec \u003c(usize, usize, usize)\u003e =\n\t\t\t(0 .. weights.len ())\n\t\t\t\t.rev ()\n\t\t\t\t.map (|idx| (1, 0, idx))\n\t\t\t\t.collect ();\n\n\t\t// iterate through continuations, shortcircuit allows us to quickly get back to the first\n\t\t// pile when we find a new solution, because we don't really care about the other piles, so\n\t\t// long as we know there's at least one solution for them\n\n\t\tlet mut shortcircuit = false;\n\t\twhile let Some ((trunc_0, trunc_1, idx)) = todo.pop () {\n\t\t\tif shortcircuit \u0026\u0026 trunc_0 \u003e 1 { continue }\n\t\t\tshortcircuit = false;\n\n\t\t\t// truncate the number of piles according to the continuation\n\n\t\t\tstack.truncate (trunc_0);\n\n\t\t\t// truncate the items in the top pile according to the continuation\n\n\t\t\tlet pile_stack = stack.last_mut ().unwrap ();\n\t\t\tpile_stack.truncate (trunc_1);\n\n\t\t\t// add on the next item from the continuation\n\n\t\t\tpile_stack.push (idx);\n\t\t\tlet pile_stack_len = pile_stack.len ();\n\n\t\t\t// work out the top pile's weight, abort if it is too heavy\n\n\t\t\tlet pile_weight: u32 =\n\t\t\t\tpile_stack.iter ().copied ().map (|idx| weights [idx]).sum ();\n\t\t\tif pile_weight \u003e want_pile_weight { continue }\n\n\t\t\t// for the first pile only, check the quantum and abort if it's already too high\n\n\t\t\tif stack.len () == 1 {\n\t\t\t\tif max_len_0 \u003c stack [0].len () { continue }\n\t\t\t\tlet quantum_0 =\n\t\t\t\t\tstack [0].iter ().copied ()\n\t\t\t\t\t\t.map (|idx| weights [idx].as_u64 ())\n\t\t\t\t\t\t.fold (Ok (1), |prod, item| prod\n\t\t\t\t\t\t\t.and_then (|prod| u64::mul_2 (prod, item))) ?;\n\t\t\t\tif max_quantum_0 \u003c= quantum_0 { continue }\n\t\t\t}\n\n\t\t\t// if this pile is now the right weight we start the next pile, or record a solution if\n\t\t\t// this is the last pile\n\n\t\t\tif pile_weight == want_pile_weight {\n\t\t\t\tif stack.len () \u003c PILES {\n\t\t\t\t\tstack.push (vec! []);\n\t\t\t\t\tfor idx in (0 .. weights.len ()).rev () {\n\t\t\t\t\t\tif stack.iter ()\n\t\t\t\t\t\t\t.any (|pile_stack| pile_stack.iter ().copied ()\n\t\t\t\t\t\t\t\t.any (|existing_idx| idx == existing_idx))\n\t\t\t\t\t\t\t{ continue }\n\t\t\t\t\t\ttodo.push ((stack.len (), 0, idx));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmax_len_0 = stack [0].len ();\n\t\t\t\t\tmax_quantum_0 =\n\t\t\t\t\t\tstack [0].iter ().copied ()\n\t\t\t\t\t\t\t.map (|idx| weights [idx].as_u64 ())\n\t\t\t\t\t\t\t.fold (Ok (1), |prod, item| prod\n\t\t\t\t\t\t\t\t.and_then (|prod| u64::mul_2 (prod, item))) ?;\n\t\t\t\t\tshortcircuit = true;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// branch out for every possible next weight to add to the top pile\n\n\t\t\tlet min_idx =\n\t\t\t\tstack.last ().unwrap ().iter ().copied ()\n\t\t\t\t\t.map (|idx| idx + 1).max ().unwrap_or (0);\n\t\t\tfor idx in (min_idx .. weights.len ()).rev () {\n\t\t\t\tif stack.iter ()\n\t\t\t\t\t.any (|pile_stack| pile_stack.iter ().copied ()\n\t\t\t\t\t\t.any (|existing_idx| idx == existing_idx))\n\t\t\t\t\t{ continue }\n\t\t\t\ttodo.push ((stack.len (), pile_stack_len, idx));\n\t\t\t}\n\n\t\t}\n\n\t\tif max_quantum_0 == u64::MAX { Err (\"No solution found\") ?; }\n\t\tOk (max_quantum_0)\n\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn calc_result () {\n\t\t\tassert_eq_ok! (5, logic::calc_result::\u003c3\u003e (Input { weights: (1 ..= 5).collect () }));\n\t\t\tassert_err! (\"No solution found\",\n\t\t\t\tlogic::calc_result::\u003c3\u003e (Input { weights: (1 ..= 3).collect () }));\n\t\t\tassert_err! (\"Refusing to deal with more than 50 items\",\n\t\t\t\tlogic::calc_result::\u003c3\u003e (Input { weights: (0 ..= 50).collect () }));\n\t\t\tassert_err! (\"Refusing to deal with duplicated weights\",\n\t\t\t\tlogic::calc_result::\u003c3\u003e (Input { weights: vec! [ 1, 1, 1 ] }));\n\t\t\tassert_err! (\"Total weight is not a multiple of 3\",\n\t\t\t\tlogic::calc_result::\u003c3\u003e (Input { weights: vec! [ 1, 2, 3, 4 ] }));\n\t\t}\n\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Input {\n\t\tpub weights: Vec \u003cu32\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet weights = input.iter ().enumerate ()\n\t\t\t\t.map (|(line_idx, line)| Ok (\n\t\t\t\t\tline.parse ().map_err (|_|\n\t\t\t\t\t\tformat! (\"Invalid input: line {}: {}\", line_idx + 1, line)) ?))\n\t\t\t\t.collect::\u003cGenResult \u003cVec \u003c_\u003e\u003e\u003e () ?;\n\t\t\tOk (Input { weights })\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn input_parse () {\n\t\t\tassert_err! (\"Invalid input: line 2: 456X\", Input::parse (\u0026 [ \"123\", \"456X\" ]));\n\t\t}\n\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [ \"1\", \"2\", \"3\", \"4\", \"5\", \"7\", \"8\", \"9\", \"10\", \"11\" ];\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"99\", puzzle.part_one (EXAMPLE));\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tassert_eq_ok! (\"44\", puzzle.part_two (EXAMPLE));\n\t}\n\n}\n","traces":[{"line":33,"address":[143531,142763],"length":1,"stats":{"Line":2},"fn_name":null},{"line":34,"address":[142864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[143632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[130624],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":48,"address":[130636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[130688],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":52,"address":[130700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[83504,83509],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":202,"address":[149175,149374,149633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[150138,149758],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[149696,149610],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[150257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[150172],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[150743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[150631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[151230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[151111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[151856],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":230,"address":[152273,151915],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[141172,141295,140992,141033],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":232,"address":[141275,141560,141312,141043],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":233,"address":[141188,141348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[152110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[78256,78261],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":246,"address":[114663,114959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":261,"address":[47989,47984],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":262,"address":[113607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[113704,113770,113630],"length":1,"stats":{"Line":3},"fn_name":null},{"line":267,"address":[48016,48021],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":268,"address":[114135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":269,"address":[114232,114158,114298],"length":1,"stats":{"Line":3},"fn_name":null}],"covered":92,"coverable":102},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","day-25","src","lib.rs"],"content":"//! Advent of Code 2015: Day 25: Let It Snow\n//!\n//! [https://adventofcode.com/2015/day/25](https://adventofcode.com/2015/day/25)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Let It Snow\";\n\tyear = 2015;\n\tday = 25;\n\tparse = |input| model::Input::parse (input [0]);\n\tpart_one = |input| logic::part_one (input);\n}\n\n/// Logic for solving the puzzles.\n///\npub mod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse nums::Int;\n\n\tpub fn part_one (input: Input) -\u003e GenResult \u003cu64\u003e {\n\t\tlet diag_num = u64::add_2 (input.row, input.col) ?;\n\t\tlet diag_seq = u64::mul_2 (diag_num, u64::add_2 (diag_num, 1) ?) ? / 2;\n\t\tlet mut cell_seq = u64::add_2 (diag_seq, input.col) ?;\n\t\tlet mut code: u64 = 20151125;\n\t\tlet mut mul = 252533;\n\t\twhile cell_seq != 0 {\n\t\t\tif cell_seq \u0026 1 == 1 { code = code * mul % 33554393; }\n\t\t\tcell_seq \u003e\u003e= 1;\n\t\t\tmul = mul * mul % 33554393;\n\t\t}\n\t\tOk (code)\n\t}\n\n}\n\n/// Representation of the puzzle input, etc.\n///\npub mod model {\n\n\tuse super::*;\n\tuse parser::*;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Input {\n\t\tpub row: u64,\n\t\tpub col: u64,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cInput\u003e {\n\t\t\tParser::wrap (input, |parser| {\n\t\t\t\tlet row: u64 = parser\n\t\t\t\t\t.expect (\"To continue, please consult the code grid in the manual.  \") ?\n\t\t\t\t\t.expect (\"Enter the code at row \") ?\n\t\t\t\t\t.int () ?;\n\t\t\t\tlet col: u64 = parser.expect (\", column \") ?.int () ?;\n\t\t\t\tparser.expect (\".\") ?.end () ?;\n\t\t\t\tif row \u003c 1 || col \u003c 1 { Err (\"Row and column start at one\") ?; }\n\t\t\t\tOk (Input { row: row - 1, col: col - 1 })\n\t\t\t}).map_parse_err (|col_idx| format! (\"Invalid input: col {}: {}\", col_idx + 1, input))\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () {\n\t\tlet puzzle = puzzle_metadata ();\n\t\tmacro_rules! ex {\n\t\t\t($row:literal, $col_1:literal, $col_2:literal, $col_3:literal, $col_4:literal,\n\t\t\t\t\t$col_5:literal, $col_6:literal) =\u003e {\n\t\t\t\tex! (@one, $row, \"column 1\", $col_1); ex! (@one, $row, \"column 2\", $col_2);\n\t\t\t\tex! (@one, $row, \"column 3\", $col_3); ex! (@one, $row, \"column 4\", $col_4);\n\t\t\t\tex! (@one, $row, \"column 5\", $col_5); ex! (@one, $row, \"column 6\", $col_6);\n\t\t\t};\n\t\t\t(@one, $row:literal, $col:literal, $expect:literal) =\u003e {\n\t\t\t\tassert_eq_ok! ($expect, puzzle.part_one (\u0026 [ \u0026 format! (\n\t\t\t\t\t\"To continue, please consult the code grid in the manual.  Enter the code at \\\n\t\t\t\t\t{}, {}.\", $row, $col) ]));\n\t\t\t};\n\t\t}\n\t\tex! (\"row 1\", \"20151125\", \"18749137\", \"17289845\", \"30943339\", \"10071777\", \"33511524\");\n\t\tex! (\"row 2\", \"31916031\", \"21629792\", \"16929656\", \"7726640\", \"15514188\", \"4041754\");\n\t\tex! (\"row 3\", \"16080970\", \"8057251\", \"1601130\", \"7981243\", \"11661866\", \"16474243\");\n\t\tex! (\"row 4\", \"24592653\", \"32451966\", \"21345942\", \"9380097\", \"10600672\", \"31527494\");\n\t\tex! (\"row 5\", \"77061\", \"17552253\", \"28094349\", \"6899651\", \"9250759\", \"31663883\");\n\t\tex! (\"row 6\", \"33071741\", \"6796745\", \"25397450\", \"24659492\", \"1534922\", \"27995004\");\n\t}\n\n}\n\n","traces":[{"line":11,"address":[24483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":12,"address":[24621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[37872],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":24,"address":[37931,38056],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[38091,38029,38301],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[38427,38279,38328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[38396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[38408],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[38444,38668,38420],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[38484,38556],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[38611,38532],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[38619,38673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[38460],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[29168],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":54,"address":[29191,29225],"length":1,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[82177,82371,82581,82202,82396,81966],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[82081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[82275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[82601,82494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[82458,82923,82816,82619],"length":1,"stats":{"Line":3},"fn_name":null},{"line":60,"address":[82890,83044,83312,83242],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[83504,83295,83438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[83652,83767,83479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[29215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[21216,21221],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":76,"address":[47709],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[52116,48156,48018,49470,52998,50352,48589,51234],"length":1,"stats":{"Line":8},"fn_name":null},{"line":91,"address":[53880,55644,53360,57408,56526,58290,54762],"length":1,"stats":{"Line":7},"fn_name":null},{"line":92,"address":[62700,63582,60936,59172,60054,58652,61818],"length":1,"stats":{"Line":7},"fn_name":null},{"line":93,"address":[67992,64464,63944,67110,68874,65346,66228],"length":1,"stats":{"Line":7},"fn_name":null},{"line":94,"address":[73284,74166,72402,70638,71520,69236,69756],"length":1,"stats":{"Line":7},"fn_name":null},{"line":95,"address":[75930,75048,76812,74528,77694,78576,79374],"length":1,"stats":{"Line":7},"fn_name":null}],"covered":29,"coverable":32},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-01.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_01::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tif let Ok (input) = model::parse_input (input_str) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-02.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_02::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.split ('\\n').collect ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-03.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_03::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tif let Ok (input) = model::parse_input (\u0026 input_str) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-04.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_04::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input: \u0026 str| {\n\tlet _ = logic::calc_result (input, 2, 1);\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-05.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_05::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-06.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_06::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-07.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_07::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::Input::parse (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_one (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-08.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_08::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tassert_eq! (model::decode (\u0026 model::encode (\u0026 input_str)).unwrap (), input_str);\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-09.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_09::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-17.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_17::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-18.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_18::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::parse_input (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone (), 2);\n\t\tlet _ = logic::part_two (input.clone (), 2);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-19.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_19::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_vec = input_str.trim ().split ('\\n').collect::\u003cVec \u003c_\u003e\u003e ();\n\tif let Ok (input) = model::Input::parse (\u0026 input_vec) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input.clone ());\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-20.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_20::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tif let Ok (input) = input_str.parse::\u003cu32\u003e () {\n\t\tif input \u003c 50000000 {\n\t\t\tlet _ = logic::part_one (input.clone ());\n\t\t\tlet _ = logic::part_two (input.clone ());\n\t\t}\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-21.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_21::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_str.split ('\\n').collect ();\n\tif let Ok (input) = model::Stats::parse (\u0026 input_lines) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-22.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_22::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = model::Input::parse (\u0026 input_lines) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-23.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_23::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = model::Input::parse (\u0026 input_lines) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-24.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_24::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_str.trim ().split ('\\n').collect ();\n\tif let Ok (input) = model::Input::parse (\u0026 input_lines) {\n\t\tlet _ = logic::part_one (input.clone ());\n\t\tlet _ = logic::part_two (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","fuzz","src","day-25.rs"],"content":"#![ no_main ]\n\nuse aoc_2015::day_25::*;\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target! (|input_str: \u0026 str| {\n\tif let Ok (input) = model::Input::parse (\u0026 input_str) {\n\t\tlet _ = logic::part_one (input);\n\t}\n});\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2015","src","lib.rs"],"content":"use aoc_common::*;\n\npub use aoc_2015_day_01 as day_01;\npub use aoc_2015_day_02 as day_02;\npub use aoc_2015_day_03 as day_03;\npub use aoc_2015_day_04 as day_04;\npub use aoc_2015_day_05 as day_05;\npub use aoc_2015_day_06 as day_06;\npub use aoc_2015_day_07 as day_07;\npub use aoc_2015_day_08 as day_08;\npub use aoc_2015_day_09 as day_09;\npub use aoc_2015_day_10 as day_10;\npub use aoc_2015_day_11 as day_11;\npub use aoc_2015_day_12 as day_12;\npub use aoc_2015_day_13 as day_13;\npub use aoc_2015_day_14 as day_14;\npub use aoc_2015_day_15 as day_15;\npub use aoc_2015_day_16 as day_16;\npub use aoc_2015_day_17 as day_17;\npub use aoc_2015_day_18 as day_18;\npub use aoc_2015_day_19 as day_19;\npub use aoc_2015_day_20 as day_20;\npub use aoc_2015_day_21 as day_21;\npub use aoc_2015_day_22 as day_22;\npub use aoc_2015_day_23 as day_23;\npub use aoc_2015_day_24 as day_24;\npub use aoc_2015_day_25 as day_25;\n\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[{"line":29,"address":[11008,14181],"length":1,"stats":{"Line":0},"fn_name":"puzzle_metadata"},{"line":30,"address":[12200,11900,12300,11300,12100,11200,12500,12976,13328,12797,11400,11031,12400,11600,12600,13064,12700,11105,12888,13416,11500,11700,13240,12000,11800,13152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[11070,11157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[11173,11257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[11357,11273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[11373,11457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[11473,11557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[11657,11573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[11757,11673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[9489,9409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[9505,9585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[9601,9681],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[9777,9697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[9793,9873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[12357,12273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[12373,12457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[12473,12557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[10177,10257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[12757,12673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[10443,10369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[10459,10527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[10611,10543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[10627,10695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[10779,10711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[10795,10863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[10947,10879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[10963],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display","src","lib.rs"],"content":"// #![include_doc(\"../../README.md\", start(\"This crate provides derive macro `Display` and `FromStr`.\"))]\n//! This crate provides derive macro `Display` and `FromStr`.\n//! These macros use common helper attributes to specify the format.\n//!\n//! ## Install\n//!\n//! Add this to your Cargo.toml:\n//!\n//! ```toml\n//! [dependencies]\n//! parse-display = \"0.5.5\"\n//! ```\n//!\n//! ## Example\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"{a}-{b}\")]\n//! struct MyStruct {\n//!   a: u32,\n//!   b: u32,\n//! }\n//! assert_eq!(MyStruct { a:10, b:20 }.to_string(), \"10-20\");\n//! assert_eq!(\"10-20\".parse(), Ok(MyStruct { a:10, b:20 }));\n//!\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(style = \"snake_case\")]\n//! enum MyEnum {\n//!   VarA,\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"var_a\");\n//! assert_eq!(\"var_a\".parse(), Ok(MyEnum::VarA));\n//! ```\n//!\n//! ## Helper attributes\n//!\n//! Helper attributes can be written in the following positions.\n//!\n//! | attribute                                                     | struct | enum | variant | field |\n//! | ------------------------------------------------------------- | ------ | ---- | ------- | ----- |\n//! | [`#[display(\"...\")]`](#display)                               |       |     |        |      |\n//! | [`#[display(style = \"...\")]`](#displaystyle--)                |        |     |        |       |\n//! | [`#[display(bound(...))]`](#displaybound)                     |       |     |        |      |\n//! | [`#[from_str(bound(...))]`](#from_strbound)                   |       |     |        |      |\n//! | [`#[from_str(regex = \"...\")]`](#from_strregex--)              |       |     |        |      |\n//! | [`#[from_str(new = ...)]`](#from_strnew--)                    |       |      |        |       |\n//! | [`#[from_str(default)]`](#from_strdefault)                    |       |      |         |      |\n//! | [`#[from_str(default_fields(...))]`](#from_strdefault_fields) |       |     |        |       |\n//!\n//! `#[derive(Display)]` use `#[display]`.\n//! `#[derive(FromStr)]` use both `#[display]` and `#[from_str]`.\n//!\n//! `key = value` style parameter can be specified only once for each key.\n//! `key(value1, value2, ...)` style parameter can be specified multiple times.\n//!\n//! ## `#[display(\"...\")]`\n//!\n//! Specifies the format using a syntax similar to `std::format!()`.\n//! However, unlike `std::format!()`, field name is specified in `{}`.\n//!\n//! ### Struct format\n//!\n//! By writing `#[display(\"..\")]`, you can specify the format used by `Display` and `FromStr`.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"{a}-{b}\")]\n//! struct MyStruct {\n//!   a: u32,\n//!   b: u32,\n//! }\n//! assert_eq!(MyStruct { a:10, b:20 }.to_string(), \"10-20\");\n//! assert_eq!(\"10-20\".parse(), Ok(MyStruct { a:10, b:20 }));\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"{0}+{1}\")]\n//! struct MyTuple(u32, u32);\n//! assert_eq!(MyTuple(10, 20).to_string(), \"10+20\");\n//! assert_eq!(\"10+20\".parse(), Ok(MyTuple(10, 20)));\n//! ```\n//!\n//! ### Newtype pattern\n//!\n//! If the struct has only one field, the format can be omitted.\n//! In this case, the only field is used.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! struct NewType(u32);\n//! assert_eq!(NewType(10).to_string(), \"10\");\n//! assert_eq!(\"10\".parse(), Ok(NewType(10)));\n//! ```\n//!\n//! ### Enum format\n//!\n//! In enum, you can specify the format for each variant.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! enum MyEnum {\n//!   #[display(\"aaa\")]\n//!   VarA,\n//!   #[display(\"bbb\")]\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"aaa\");\n//! assert_eq!(MyEnum::VarB.to_string(), \"bbb\");\n//! assert_eq!(\"aaa\".parse(), Ok(MyEnum::VarA));\n//! assert_eq!(\"bbb\".parse(), Ok(MyEnum::VarB));\n//! ```\n//!\n//! In enum format, `{}` means variant name.\n//! Variant name style (e.g. snake_case, camelCase, ...) can be specified by [`#[from_str(style = \"...\")]`](#displaystyle--).\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! enum MyEnum {\n//!   #[display(\"aaa-{}\")]\n//!   VarA,\n//!   #[display(\"bbb-{}\")]\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"aaa-VarA\");\n//! assert_eq!(MyEnum::VarB.to_string(), \"bbb-VarB\");\n//! assert_eq!(\"aaa-VarA\".parse(), Ok(MyEnum::VarA));\n//! assert_eq!(\"bbb-VarB\".parse(), Ok(MyEnum::VarB));\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(style = \"snake_case\")]\n//! enum MyEnumSnake {\n//!   #[display(\"{}\")]\n//!   VarA,\n//! }\n//! assert_eq!(MyEnumSnake::VarA.to_string(), \"var_a\");\n//! assert_eq!(\"var_a\".parse(), Ok(MyEnumSnake::VarA));\n//! ```\n//!\n//! By writing a format on enum instead of variant, you can specify the format common to multiple variants.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"xxx-{}\")]\n//! enum MyEnum {\n//!   VarA,\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"xxx-VarA\");\n//! assert_eq!(MyEnum::VarB.to_string(), \"xxx-VarB\");\n//! assert_eq!(\"xxx-VarA\".parse(), Ok(MyEnum::VarA));\n//! assert_eq!(\"xxx-VarB\".parse(), Ok(MyEnum::VarB));\n//! ```\n//!\n//! ### Unit variants\n//!\n//! If all variants has no field, format can be omitted.\n//! In this case, variant name is used.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! enum MyEnum {\n//!   VarA,\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"VarA\");\n//! assert_eq!(MyEnum::VarB.to_string(), \"VarB\");\n//! assert_eq!(\"VarA\".parse(), Ok(MyEnum::VarA));\n//! assert_eq!(\"VarB\".parse(), Ok(MyEnum::VarB));\n//! ```\n//!\n//! ### Field format\n//!\n//! You can specify the format of the field.\n//! In field format, `{}` means the field itself.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"{a}, {b}\")]\n//! struct MyStruct {\n//!   #[display(\"a is {}\")]\n//!   a: u32,\n//!   #[display(\"b is {}\")]\n//!   b: u32,\n//! }\n//! assert_eq!(MyStruct { a:10, b:20 }.to_string(), \"a is 10, b is 20\");\n//! assert_eq!(\"a is 10, b is 20\".parse(), Ok(MyStruct { a:10, b:20 }));\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(\"{0}, {1}\")]\n//! struct MyTuple(#[display(\"first is {}\")] u32, #[display(\"next is {}\")] u32);\n//! assert_eq!(MyTuple(10, 20).to_string(), \"first is 10, next is 20\");\n//! assert_eq!(\"first is 10, next is 20\".parse(), Ok(MyTuple(10, 20)));\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! enum MyEnum {\n//!   #[display(\"this is A {0}\")]\n//!   VarA(#[display(\"___{}___\")] u32),\n//! }\n//! assert_eq!(MyEnum::VarA(10).to_string(), \"this is A ___10___\");\n//! assert_eq!(\"this is A ___10___\".parse(), Ok(MyEnum::VarA(10)));\n//! ```\n//!\n//! ### Display field chain\n//!\n//! You can use \"field chain\", e.g. `{x.a}` .\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(PartialEq, Debug, Default)]\n//! struct MyStruct {\n//!   a: u32,\n//!   b: u32,\n//! }\n//!\n//! #[derive(FromStr, Display, PartialEq, Debug)]\n//! #[display(\"{x.a}\")]\n//! struct FieldChain {\n//!   #[from_str(default)]\n//!   x: MyStruct,\n//! }\n//! assert_eq!(FieldChain { x:MyStruct { a:10, b:20 } }.to_string(), \"10\");\n//! assert_eq!(\"10\".parse(), Ok(FieldChain { x:MyStruct { a:10, b:0 } }));\n//! ```\n//!\n//! When using \"field chain\", you need to use [`#[from_str(default)]`](#from_strdefault) to implement `FromStr`.\n//!\n//! ### Format parameter\n//!\n//! Like `std::format!()`, format parameter can be specified.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, PartialEq, Debug)]\n//! #[display(\"{a:\u003e04}\")]\n//! struct WithFormatParameter {\n//!   a: u32,\n//! }\n//! assert_eq!(WithFormatParameter { a:5 }.to_string(), \"0005\");\n//! ```\n//!\n//! ## `#[display(style = \"...\")]`\n//!\n//! By writing `#[display(style = \"...\")]`, you can specify the variant name style.\n//! The following styles are available.\n//!\n//! - `none`\n//! - `lowercase`\n//! - `UPPERCASE`\n//! - `snake_case`\n//! - `SNAKE_CASE`\n//! - `camelCase`\n//! - `CamelCase`\n//! - `kebab-case`\n//! - `KEBAB-CASE`\n//! - `Title Case`\n//! - `Title case`\n//! - `title case`\n//! - `TITLE CASE`\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(style = \"snake_case\")]\n//! enum MyEnum {\n//!   VarA,\n//!   VarB,\n//! }\n//! assert_eq!(MyEnum::VarA.to_string(), \"var_a\");\n//! assert_eq!(\"var_a\".parse(), Ok(MyEnum::VarA));\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! enum StyleExample {\n//!   #[display(style = \"none\")]\n//!   VarA1,\n//!   #[display(style = \"none\")]\n//!   varA2,\n//!   #[display(style = \"lowercase\")]\n//!   VarB,\n//!   #[display(style = \"UPPERCASE\")]\n//!   VarC,\n//!   #[display(style = \"snake_case\")]\n//!   VarD,\n//!   #[display(style = \"SNAKE_CASE\")]\n//!   VarE,\n//!   #[display(style = \"camelCase\")]\n//!   VarF,\n//!   #[display(style = \"CamelCase\")]\n//!   VarG1,\n//!   #[display(style = \"CamelCase\")]\n//!   varG2,\n//!   #[display(style = \"kebab-case\")]\n//!   VarH,\n//!   #[display(style = \"KEBAB-CASE\")]\n//!   VarI,\n//!   #[display(style = \"Title Case\")]\n//!   VarJ,\n//!   #[display(style = \"Title case\")]\n//!   VarK,\n//!   #[display(style = \"title case\")]\n//!   VarL,\n//!   #[display(style = \"TITLE CASE\")]\n//!   VarM,\n//! }\n//! assert_eq!(StyleExample::VarA1.to_string(), \"VarA1\");\n//! assert_eq!(StyleExample::varA2.to_string(), \"varA2\");\n//! assert_eq!(StyleExample::VarB.to_string(), \"varb\");\n//! assert_eq!(StyleExample::VarC.to_string(), \"VARC\");\n//! assert_eq!(StyleExample::VarD.to_string(), \"var_d\");\n//! assert_eq!(StyleExample::VarE.to_string(), \"VAR_E\");\n//! assert_eq!(StyleExample::VarF.to_string(), \"varF\");\n//! assert_eq!(StyleExample::VarG1.to_string(), \"VarG1\");\n//! assert_eq!(StyleExample::varG2.to_string(), \"VarG2\");\n//! assert_eq!(StyleExample::VarH.to_string(), \"var-h\");\n//! assert_eq!(StyleExample::VarI.to_string(), \"VAR-I\");\n//! assert_eq!(StyleExample::VarJ.to_string(), \"Var J\");\n//! assert_eq!(StyleExample::VarK.to_string(), \"Var k\");\n//! assert_eq!(StyleExample::VarL.to_string(), \"var l\");\n//! assert_eq!(StyleExample::VarM.to_string(), \"VAR M\");\n//! ```\n//!\n//! ## `#[display(bound(...))]`\n//!\n//! By default, the type of field used in the format is added to the trait bound.\n//!\n//! In Rust prior to 1.59, this behavior causes a compile error if you use fields of non public type in public struct.\n//!\n//! ```rust\n//! #![deny(private_in_public)]\n//! use parse_display::Display;\n//!\n//! // private type `Inner\u003cT\u003e` in public interface (error E0446)\n//! #[derive(Display)]\n//! pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n//!\n//! #[derive(Display)]\n//! struct Inner\u003cT\u003e(T);\n//! ```\n//!\n//! By writing `#[display(bound(...))]`, you can override the default behavior.\n//!\n//! ### Specify trait bound type\n//!\n//! By specifying the type, you can specify the type that need to implement `Display` and `FromStr`.\n//!\n//! ```rust\n//! use parse_display::{Display, FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(bound(T))]\n//! pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! struct Inner\u003cT\u003e(T);\n//!\n//! assert_eq!(Outer(Inner(10)).to_string(), \"10\");\n//! assert_eq!(\"10\".parse(), Ok(Outer(Inner(10))));\n//! ```\n//!\n//! ### Specify where predicate\n//!\n//! You can also specify the where predicate.\n//!\n//! ```rust\n//! use parse_display::Display;\n//!\n//! #[derive(Display)]\n//! #[display(bound(T : std::fmt::Debug))]\n//! pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n//!\n//! #[derive(Display)]\n//! #[display(\"{0:?}\")]\n//! struct Inner\u003cT\u003e(T);\n//!\n//! assert_eq!(Outer(Inner(10)).to_string(), \"10\");\n//! ```\n//!\n//! ### No trait bounds\n//!\n//! You can also remove all trait bounds.\n//!\n//! ```rust\n//! use parse_display::Display;\n//!\n//! #[derive(Display)]\n//! #[display(bound())]\n//! pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n//!\n//! #[derive(Display)]\n//! #[display(\"ABC\")]\n//! struct Inner\u003cT\u003e(T);\n//!\n//! assert_eq!(Outer(Inner(10)).to_string(), \"ABC\");\n//! ```\n//!\n//! ### Default trait bounds\n//!\n//! `..` means default (automatically generated) trait bounds.\n//!\n//! The following example specifies `T1` as a trait bound in addition to the default trait bound `T2`.\n//!\n//! ```rust\n//! use parse_display::Display;\n//!\n//! pub struct Inner\u003cT\u003e(T);\n//!\n//! #[derive(Display)]\n//! #[display(\"{0.0}, {1}\", bound(T1, ..))]\n//! pub struct Outer\u003cT1, T2\u003e(Inner\u003cT1\u003e, T2);\n//!\n//! assert_eq!(Outer(Inner(10), 20).to_string(), \"10, 20\");\n//! ```\n//!\n//! ## `#[from_str(bound(...))]`\n//!\n//! You can use a different trait bound for `Display` and `FromStr` by specifying both `#[display(bound(...))]` and `#[from_str(bound(...))]`.\n//!\n//! ```rust\n//! use parse_display::*;\n//! use std::{fmt::Display, str::FromStr};\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! #[display(bound(\"T : Display\"))]\n//! #[from_str(bound(\"T : FromStr\"))]\n//! pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n//!\n//! #[derive(Display, FromStr, PartialEq, Debug)]\n//! struct Inner\u003cT\u003e(T);\n//!\n//! assert_eq!(Outer(Inner(10)).to_string(), \"10\");\n//! assert_eq!(\"10\".parse(), Ok(Outer(Inner(10))));\n//! ```\n//!\n//! ## `#[from_str(new = ...)]`\n//!\n//! If `#[from_str(new = ...)]` is specified, the value will be initialized with the specified expression instead of the constructor.\n//!\n//! The expression must return a value that implement [`IntoResult`] (e.g. `Self`, `Option\u003cSelf\u003e`, `Result\u003cSelf, E\u003e`).\n//!\n//! In the expression, you can use a variable with the same name as the field name.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//! #[derive(FromStr, Debug, PartialEq)]\n//! #[from_str(new = Self::new(value))]\n//! struct MyNonZeroUSize {\n//!     value: usize,\n//! }\n//!\n//! impl MyNonZeroUSize {\n//!     fn new(value: usize) -\u003e Option\u003cSelf\u003e {\n//!         if value == 0 {\n//!             None\n//!         } else {\n//!             Some(Self { value })\n//!         }\n//!     }\n//! }\n//!\n//! assert_eq!(\"1\".parse(), Ok(MyNonZeroUSize { value: 1 }));\n//! assert_eq!(\"0\".parse::\u003cMyNonZeroUSize\u003e().is_err(), true);\n//! ```\n//!\n//! In tuple struct, variables are named with a leading underscore and their index. (e.g. `_0`, `_1`).\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//! #[derive(FromStr, Debug, PartialEq)]\n//! #[from_str(new = Self::new(_0))]\n//! struct MyNonZeroUSize(usize);\n//!\n//! impl MyNonZeroUSize {\n//!     fn new(value: usize) -\u003e Option\u003cSelf\u003e {\n//!         if value == 0 {\n//!             None\n//!         } else {\n//!             Some(Self(value))\n//!         }\n//!     }\n//! }\n//!\n//! assert_eq!(\"1\".parse(), Ok(MyNonZeroUSize(1)));\n//! assert_eq!(\"0\".parse::\u003cMyNonZeroUSize\u003e().is_err(), true);\n//! ```\n//!\n//! ## `#[from_str(regex = \"...\")]`\n//!\n//! Specify the format of the string to be input with `FromStr`.\n//! `#[display(\"...\")]` is ignored, when this attribute is specified.\n//!\n//! ### Capture name\n//!\n//! The capture name corresponds to the field name.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[from_str(regex = \"(?P\u003ca\u003e[0-9]+)__(?P\u003cb\u003e[0-9]+)\")]\n//! struct MyStruct {\n//!   a: u8,\n//!   b: u8,\n//! }\n//!\n//! assert_eq!(\"10__20\".parse(), Ok(MyStruct { a:10, b:20 }));\n//! ```\n//!\n//! ### Field regex\n//!\n//! Set `#[display(\"...\")]` to struct and set `#[from_str(regex = \"...\")]` to field, regex is used in the position where field name is specified in `#[display(\"...\")]`.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[display(\"{a}__{b}\")]\n//! struct MyStruct {\n//!   #[from_str(regex = \"[0-9]+\")]\n//!   a: u8,\n//!\n//!   #[from_str(regex = \"[0-9]+\")]\n//!   b: u8,\n//! }\n//! assert_eq!(\"10__20\".parse(), Ok(MyStruct { a:10, b:20 }));\n//! ```\n//!\n//! If `#[from_str(regex = \"...\")]` is not set to field ,\n//! it operates in the same way as when `#[from_str(regex = \".*?\")]` is set.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[display(\"{a}{b}\")]\n//! struct MyStruct {\n//!   a: String,\n//!   b: String,\n//! }\n//! assert_eq!(\"abcdef\".parse(), Ok(MyStruct { a:\"\".into(), b:\"abcdef\".into() }));\n//! ```\n//!\n//! ### Variant name\n//!\n//! In the regex specified for enum or variant, empty name capture means variant name.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[from_str(regex = \"___(?P\u003c\u003e)___\")]\n//! enum MyEnum {\n//!   VarA,\n//!\n//!   #[from_str(regex = \"xxx(?P\u003c\u003e)xxx\")]\n//!   VarB,\n//! }\n//! assert_eq!(\"___VarA___\".parse(), Ok(MyEnum::VarA));\n//! assert_eq!(\"xxxVarBxxx\".parse(), Ok(MyEnum::VarB));\n//! ```\n//!\n//! ### Regex field chain\n//!\n//! You can use \"field chain\" in regex.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(PartialEq, Debug, Default)]\n//! struct MyStruct {\n//!   a: u32,\n//! }\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[from_str(regex = \"___(?P\u003cx.a\u003e[0-9]+)\")]\n//! struct FieldChain {\n//!   #[from_str(default)]\n//!   x: MyStruct,\n//! }\n//! assert_eq!(\"___10\".parse(), Ok(FieldChain { x:MyStruct { a:10 } }));\n//! ```\n//!\n//! When using \"field chain\", you need to use [`#[from_str(default)]`](#from_strdefault).\n//!\n//! ## `#[from_str(default)]`\n//!\n//! If this attribute is specified, the default value is used for fields not included in the input.\n//!\n//! If an attribute is specified for struct, the struct's default value is used.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[display(\"{b}\")]\n//! #[from_str(default)]\n//! struct MyStruct {\n//!   a: u32,\n//!   b: u32,\n//! }\n//!\n//! impl Default for MyStruct {\n//!   fn default() -\u003e Self {\n//!     Self { a:99, b:99 }\n//!   }\n//! }\n//! assert_eq!(\"10\".parse(), Ok(MyStruct { a:99, b:10 }));\n//! ```\n//!\n//! If an attribute is specified for field, the field type's default value is used.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[display(\"{b}\")]\n//! struct MyStruct {\n//!   #[from_str(default)]\n//!   a: u32,\n//!   b: u32,\n//! }\n//!\n//! impl Default for MyStruct {\n//!   fn default() -\u003e Self {\n//!     Self { a:99, b:99 }\n//!   }\n//! }\n//! assert_eq!(\"10\".parse(), Ok(MyStruct { a:0, b:10 }));\n//! ```\n//!\n//! ## `#[from_str(default_fields(...))]`\n//!\n//! You can use `#[from_str(default_fields(...))]` if you want to set default values for the same-named fields of multiple variants.\n//!\n//! ```rust\n//! use parse_display::FromStr;\n//!\n//! #[derive(FromStr, PartialEq, Debug)]\n//! #[display(\"{}-{a}\")]\n//! #[from_str(default_fields(\"b\", \"c\"))]\n//! enum MyEnum {\n//!   VarA { a:u8, b:u8, c:u8 },\n//!   VarB { a:u8, b:u8, c:u8 },\n//! }\n//!\n//! assert_eq!(\"VarA-10\".parse(), Ok(MyEnum::VarA { a:10, b:0, c:0 }));\n//! assert_eq!(\"VarB-10\".parse(), Ok(MyEnum::VarB { a:10, b:0, c:0 }));\n//! ```\n// #![include_doc(\"../../README.md\", end(\"## License\"))]\n#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse core::convert::Infallible;\nuse core::fmt::{Display, Formatter, Result};\n\n#[cfg(feature = \"regex\")]\npub mod helpers {\n    pub use once_cell;\n    pub use regex;\n}\n\npub use parse_display_derive::{Display, FromStr};\n\n#[derive(Debug, Eq, PartialEq)]\npub struct ParseError(\u0026'static str);\nimpl ParseError {\n    pub fn with_message(message: \u0026'static str) -\u003e Self {\n        Self(message)\n    }\n    pub fn new() -\u003e Self {\n        Self::with_message(\"parse failed.\")\n    }\n}\nimpl Default for ParseError {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl Display for ParseError {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n#[cfg(feature = \"std\")]\nimpl std::error::Error for ParseError {\n    fn description(\u0026self) -\u003e \u0026str {\n        self.0\n    }\n}\n\npub trait IntoResult\u003cT\u003e {\n    type Err;\n    fn into_result(self) -\u003e core::result::Result\u003cT, Self::Err\u003e;\n}\n\nimpl\u003cT\u003e IntoResult\u003cT\u003e for T {\n    type Err = Infallible;\n    fn into_result(self) -\u003e core::result::Result\u003cT, Self::Err\u003e {\n        Ok(self)\n    }\n}\n\nimpl\u003cT\u003e IntoResult\u003cT\u003e for Option\u003cT\u003e {\n    type Err = ParseError;\n    fn into_result(self) -\u003e core::result::Result\u003cT, Self::Err\u003e {\n        self.ok_or_else(ParseError::new)\n    }\n}\n\nimpl\u003cT, E\u003e IntoResult\u003cT\u003e for core::result::Result\u003cT, E\u003e {\n    type Err = E;\n    fn into_result(self) -\u003e core::result::Result\u003cT, E\u003e {\n        self\n    }\n}\n","traces":[{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-benches","benches","bench.rs"],"content":"#![feature(test)]\n\nextern crate test;\n\nuse parse_display::{Display, FromStr, ParseError};\nuse std::{hint::black_box, str::FromStr};\n\n#[bench]\nfn parse_simple_enum_derive(b: \u0026mut test::Bencher) {\n    #[derive(FromStr)]\n    enum SimpleEnumDerive {\n        ItemA,\n        ItemB,\n        ItemC,\n        ItemD,\n    }\n\n    let inputs = [\"ItemA\", \"ItemB\", \"ItemC\", \"ItemD\"];\n    b.iter(|| {\n        for \u0026input in \u0026inputs {\n            black_box(input.parse::\u003cSimpleEnumDerive\u003e().unwrap());\n        }\n    });\n}\n#[bench]\nfn parse_simple_enum_by_hand(b: \u0026mut test::Bencher) {\n    enum SimpleEnumByHand {\n        ItemA,\n        ItemB,\n        ItemC,\n        ItemD,\n    }\n\n    impl FromStr for SimpleEnumByHand {\n        type Err = ParseError;\n\n        fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n            match s {\n                \"ItemA\" =\u003e Ok(Self::ItemA),\n                \"ItemB\" =\u003e Ok(Self::ItemB),\n                \"ItemC\" =\u003e Ok(Self::ItemC),\n                \"ItemD\" =\u003e Ok(Self::ItemD),\n                _ =\u003e Err(ParseError::new()),\n            }\n        }\n    }\n\n    let inputs = [\"ItemA\", \"ItemB\", \"ItemC\", \"ItemD\"];\n    b.iter(|| {\n        for \u0026input in \u0026inputs {\n            black_box(input.parse::\u003cSimpleEnumByHand\u003e().unwrap());\n        }\n    });\n}\n\n#[bench]\nfn parse_non_regex_format_struct_derive(b: \u0026mut test::Bencher) {\n    #[derive(Display, FromStr)]\n    #[display(\"{a},{b},{c}\")]\n    struct TestInput {\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n\n    let input = TestInput {\n        a: 10,\n        b: 20,\n        c: 30,\n    }\n    .to_string();\n    b.iter(|| {\n        black_box(input.parse::\u003cTestInput\u003e().unwrap());\n    });\n}\n\n#[bench]\nfn parse_non_regex_format_struct_by_hand(b: \u0026mut test::Bencher) {\n    #[derive(Display)]\n    #[display(\"{a},{b},{c}\")]\n    struct TestInput {\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n    impl FromStr for TestInput {\n        type Err = ParseError;\n\n        fn from_str(s: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n            let idx1 = s.find(\",\").ok_or_else(ParseError::new)?;\n            let idx2 = idx1 + 1 + s[idx1 + 1..].find(\",\").ok_or_else(ParseError::new)?;\n            let a = s[0..idx1].parse().map_err(|_| ParseError::new())?;\n            let b = s[idx1 + 1..idx2].parse().map_err(|_| ParseError::new())?;\n            let c = s[idx2 + 1..].parse().map_err(|_| ParseError::new())?;\n            Ok(Self { a, b, c })\n        }\n    }\n\n    let input = TestInput {\n        a: 10,\n        b: 20,\n        c: 30,\n    }\n    .to_string();\n\n    b.iter(|| {\n        black_box(input.parse::\u003cTestInput\u003e().unwrap());\n    });\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-benches","src","lib.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-derive","src","format_syntax.rs"],"content":"use once_cell::sync::Lazy;\nuse regex::*;\n\nuse std::fmt::{Display, Formatter};\nuse std::str::FromStr;\n\n#[derive(Debug, PartialEq, Eq)]\npub enum Sign {\n    Plus,\n    Minus,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum Align {\n    Left,\n    Right,\n    Center,\n}\n\n#[derive(Debug, PartialEq, Eq, Default)]\npub struct FormatSpec\u003c'a\u003e {\n    pub fill: Option\u003cchar\u003e,\n    pub align: Option\u003cAlign\u003e,\n    pub sign: Option\u003cSign\u003e,\n    pub is_alternate: bool,\n    pub is_zero: bool,\n    pub width: Option\u003cSubArg\u003c'a, usize\u003e\u003e,\n    pub precision: Option\u003cSubArg\u003c'a, usize\u003e\u003e,\n    pub format_type: FormatType,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum SubArg\u003c'a, T\u003e {\n    Value(T),\n    Index(usize),\n    Name(\u0026'a str),\n    Input,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub enum FormatType {\n    Display,\n    Debug,\n    DebugUpperHex,\n    DebugLowerHex,\n    Octal,\n    LowerHex,\n    UpperHex,\n    Pointer,\n    Binary,\n    LowerExp,\n    UpperExp,\n}\nimpl FormatType {\n    pub fn trait_name(\u0026self) -\u003e \u0026str {\n        match self {\n            FormatType::Display =\u003e \"Display\",\n            FormatType::Debug | FormatType::DebugUpperHex | FormatType::DebugLowerHex =\u003e \"Debug\",\n            FormatType::Octal =\u003e \"Octal\",\n            FormatType::LowerHex =\u003e \"LowerHex\",\n            FormatType::UpperHex =\u003e \"UpperHex\",\n            FormatType::Pointer =\u003e \"Pointer\",\n            FormatType::Binary =\u003e \"Binary\",\n            FormatType::LowerExp =\u003e \"LowerExp\",\n            FormatType::UpperExp =\u003e \"UpperExp\",\n        }\n    }\n}\n\nimpl Default for FormatType {\n    fn default() -\u003e Self {\n        FormatType::Display\n    }\n}\n\n#[derive(Debug, Eq, PartialEq)]\npub struct FormatParseError;\n\nimpl FormatParseError {\n    const ERROR_MESSAGE: \u0026'static str = \"FormatSpec parse failed.\";\n}\n\nimpl std::error::Error for FormatParseError {\n    fn description(\u0026self) -\u003e \u0026str {\n        FormatParseError::ERROR_MESSAGE\n    }\n}\nimpl Display for FormatParseError {\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e std::fmt::Result {\n        write!(f, \"{}\", FormatParseError::ERROR_MESSAGE)\n    }\n}\n\nimpl\u003c'a\u003e FormatSpec\u003c'a\u003e {\n    pub fn parse(s: \u0026'a str) -\u003e std::result::Result\u003cSelf, FormatParseError\u003e {\n        static RE: Lazy\u003cRegex\u003e = lazy_regex!(\n            \"^\\\n             ((?P\u003cfill\u003e.)?\\\n             (?P\u003calign\u003e[\u003c\u003e^]))??\\\n             (?P\u003csign\u003e[+-])?\\\n             (?P\u003cis_alternate\u003e#)?\\\n             (?P\u003cis_zero\u003e0)?\\\n             (\\\n             (?P\u003cwidth_integer\u003e[0-9]+)|\\\n             ((?P\u003cwidth_arg\u003e[a-zA-Z0-9_]+)\\\\$)\\\n             )?\\\n             (\\\\.(\\\n             (?P\u003cprecision_input\u003e\\\\*)|\\\n             (?P\u003cprecision_integer\u003e[0-9]+)|\\\n             ((?P\u003cprecision_arg\u003e[a-zA-Z0-9_]+)\\\\$)\\\n             ))?\\\n             (?P\u003cformat_type\u003e[a-zA-Z0-9_]*\\\\??)\\\n             $\"\n        );\n\n        let c = RE.captures(s).ok_or(FormatParseError)?;\n        let fill = c.name(\"fill\").map(|m| m.as_str().chars().next().unwrap());\n        let align = c.name(\"align\").map(|m| m.as_str().parse().unwrap());\n        let sign = c.name(\"sign\").map(|m| match m.as_str() {\n            \"+\" =\u003e Sign::Plus,\n            \"-\" =\u003e Sign::Minus,\n            _ =\u003e unreachable!(),\n        });\n        let is_alternate = c.name(\"is_alternate\").is_some();\n        let is_zero = c.name(\"is_zero\").is_some();\n        let width = if let Some(m) = c.name(\"width_integer\") {\n            let value = m.as_str().parse().map_err(|_| FormatParseError)?;\n            Some(SubArg::Value(value))\n        } else if let Some(m) = c.name(\"width_arg\") {\n            let s = m.as_str();\n            Some(if let Ok(idx) = s.parse() {\n                SubArg::Index(idx)\n            } else {\n                SubArg::Name(s)\n            })\n        } else {\n            None\n        };\n\n        let precision = if let Some(m) = c.name(\"precision_integer\") {\n            let value = m.as_str().parse().map_err(|_| FormatParseError)?;\n            Some(SubArg::Value(value))\n        } else if let Some(m) = c.name(\"precision_arg\") {\n            let s = m.as_str();\n            Some(if let Ok(idx) = s.parse() {\n                SubArg::Index(idx)\n            } else {\n                SubArg::Name(s)\n            })\n        } else if c.name(\"precision_input\").is_some() {\n            Some(SubArg::Input)\n        } else {\n            None\n        };\n        let format_type = c.name(\"format_type\").unwrap().as_str().parse()?;\n\n        Ok(FormatSpec {\n            fill,\n            align,\n            sign,\n            is_alternate,\n            is_zero,\n            width,\n            precision,\n            format_type,\n        })\n    }\n}\n\nimpl FromStr for Align {\n    type Err = FormatParseError;\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        Ok(match s {\n            \"\u003c\" =\u003e Align::Left,\n            \"\u003e\" =\u003e Align::Right,\n            \"^\" =\u003e Align::Center,\n            _ =\u003e return Err(FormatParseError),\n        })\n    }\n}\n\nimpl FromStr for FormatType {\n    type Err = FormatParseError;\n    fn from_str(s: \u0026str) -\u003e std::result::Result\u003cSelf, Self::Err\u003e {\n        Ok(match s {\n            \"\" =\u003e FormatType::Display,\n            \"?\" =\u003e FormatType::Debug,\n            \"x?\" =\u003e FormatType::DebugLowerHex,\n            \"X?\" =\u003e FormatType::DebugUpperHex,\n            \"o\" =\u003e FormatType::Octal,\n            \"x\" =\u003e FormatType::LowerHex,\n            \"X\" =\u003e FormatType::UpperHex,\n            \"p\" =\u003e FormatType::Pointer,\n            \"b\" =\u003e FormatType::Binary,\n            \"e\" =\u003e FormatType::LowerExp,\n            \"E\" =\u003e FormatType::UpperExp,\n            _ =\u003e return Err(FormatParseError),\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn align() {\n        assert_ps(\n            \"\u003c\",\n            FormatSpec {\n                align: Some(Align::Left),\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"^\",\n            FormatSpec {\n                align: Some(Align::Center),\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"\u003e\",\n            FormatSpec {\n                align: Some(Align::Right),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn fill_align() {\n        assert_ps(\n            \"x\u003c\",\n            FormatSpec {\n                fill: Some('x'),\n                align: Some(Align::Left),\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"0\u003e\",\n            FormatSpec {\n                fill: Some('0'),\n                align: Some(Align::Right),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn sign() {\n        assert_ps(\n            \"+\",\n            FormatSpec {\n                sign: Some(Sign::Plus),\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"-\",\n            FormatSpec {\n                sign: Some(Sign::Minus),\n                ..Default::default()\n            },\n        );\n    }\n    #[test]\n    fn alternate() {\n        assert_ps(\n            \"#\",\n            FormatSpec {\n                is_alternate: true,\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn zero() {\n        assert_ps(\n            \"0\",\n            FormatSpec {\n                is_zero: true,\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn width_value() {\n        assert_ps(\n            \"5\",\n            FormatSpec {\n                width: Some(SubArg::Value(5)),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn width_arg_index() {\n        assert_ps(\n            \"5$\",\n            FormatSpec {\n                width: Some(SubArg::Index(5)),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn width_arg_name() {\n        assert_ps(\n            \"field$\",\n            FormatSpec {\n                width: Some(SubArg::Name(\"field\")),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn zero_width() {\n        assert_ps(\n            \"05\",\n            FormatSpec {\n                is_zero: true,\n                width: Some(SubArg::Value(5)),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn precision_value() {\n        assert_ps(\n            \".5\",\n            FormatSpec {\n                precision: Some(SubArg::Value(5)),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn precision_arg_index() {\n        assert_ps(\n            \".5$\",\n            FormatSpec {\n                precision: Some(SubArg::Index(5)),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn precision_arg_name() {\n        assert_ps(\n            \".field$\",\n            FormatSpec {\n                precision: Some(SubArg::Name(\"field\")),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn precision_arg_input() {\n        assert_ps(\n            \".*\",\n            FormatSpec {\n                precision: Some(SubArg::Input),\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn format_type() {\n        assert_ps(\n            \"?\",\n            FormatSpec {\n                format_type: FormatType::Debug,\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"x?\",\n            FormatSpec {\n                format_type: FormatType::DebugLowerHex,\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"x\",\n            FormatSpec {\n                format_type: FormatType::LowerHex,\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"X\",\n            FormatSpec {\n                format_type: FormatType::UpperHex,\n                ..Default::default()\n            },\n        );\n        assert_ps(\n            \"b\",\n            FormatSpec {\n                format_type: FormatType::Binary,\n                ..Default::default()\n            },\n        );\n    }\n\n    #[test]\n    fn all() {\n        assert_ps(\n            \"_\u003e+#05$.name$x?\",\n            FormatSpec {\n                fill: Some('_'),\n                align: Some(Align::Right),\n                sign: Some(Sign::Plus),\n                is_alternate: true,\n                is_zero: true,\n                width: Some(SubArg::Index(5)),\n                precision: Some(SubArg::Name(\"name\")),\n                format_type: FormatType::DebugLowerHex,\n            },\n        );\n    }\n\n    fn assert_ps\u003c'a\u003e(s: \u0026'a str, ps: FormatSpec\u003c'a\u003e) {\n        assert_eq!(FormatSpec::parse(s), Ok(ps), \"input : {}\", s);\n    }\n}\n","traces":[{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":60},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-derive","src","lib.rs"],"content":"#![recursion_limit = \"128\"]\n#![allow(clippy::large_enum_variant)]\n\n//! The documentation for this crate is found in the parse-display crate.\n\nextern crate proc_macro;\n\n#[macro_use]\nmod regex_utils;\n\n#[macro_use]\nmod syn_utils;\n\nmod format_syntax;\n\nuse crate::{format_syntax::*, regex_utils::*, syn_utils::*};\nuse once_cell::sync::Lazy;\nuse proc_macro2::{Span, TokenStream};\nuse quote::{format_ident, quote};\nuse regex::{Captures, Regex};\nuse regex_syntax::hir::Hir;\nuse std::{\n    collections::BTreeMap,\n    fmt::{Display, Formatter},\n    ops::{Deref, DerefMut},\n};\nuse structmeta::{Flag, StructMeta, ToTokens};\nuse syn::{\n    ext::IdentExt,\n    parse::{discouraged::Speculative, Parse, ParseStream},\n    parse_macro_input, parse_quote, parse_str,\n    spanned::Spanned,\n    Attribute, Data, DataEnum, DataStruct, DeriveInput, Expr, Field, Fields, FieldsNamed,\n    FieldsUnnamed, Ident, LitStr, Member, Path, Result, Token, Type, Variant, WherePredicate,\n};\n\n#[proc_macro_derive(Display, attributes(display))]\npub fn derive_display(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    into_macro_output(match \u0026input.data {\n        Data::Struct(data) =\u003e derive_display_for_struct(\u0026input, data),\n        Data::Enum(data) =\u003e derive_display_for_enum(\u0026input, data),\n        _ =\u003e panic!(\"`#[derive(Display)]` supports only enum or struct.\"),\n    })\n}\n\nfn derive_display_for_struct(input: \u0026DeriveInput, data: \u0026DataStruct) -\u003e Result\u003cTokenStream\u003e {\n    let hattrs = HelperAttributes::from(\u0026input.attrs)?;\n    let ctx = DisplayContext::Struct { data };\n    let generics = GenericParamSet::new(\u0026input.generics);\n\n    let mut format = hattrs.format;\n    if format.is_none() {\n        format = DisplayFormat::from_newtype_struct(data);\n    }\n    let format = match format {\n        Some(x) =\u003e x,\n        None =\u003e bail!(\n            input.span(),\n            \"`#[display(\\\"format\\\")]` is required except newtype pattern.\",\n        ),\n    };\n    let mut bounds = Bounds::from_data(hattrs.bound_display);\n    let args = format.format_args(ctx, \u0026mut bounds, \u0026generics)?;\n    let trait_path = parse_quote!(core::fmt::Display);\n    let wheres = bounds.build_wheres(\u0026trait_path);\n    impl_trait_result(\n        input,\n        \u0026trait_path,\n        \u0026wheres,\n        quote! {\n            fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter) -\u003e core::fmt::Result {\n                core::write!(f, #args)\n            }\n        },\n        hattrs.dump_display,\n    )\n}\nfn derive_display_for_enum(input: \u0026DeriveInput, data: \u0026DataEnum) -\u003e Result\u003cTokenStream\u003e {\n    fn make_arm(\n        hattrs_enum: \u0026HelperAttributes,\n        variant: \u0026Variant,\n        bounds: \u0026mut Bounds,\n        generics: \u0026GenericParamSet,\n    ) -\u003e Result\u003cTokenStream\u003e {\n        let fields = match \u0026variant.fields {\n            Fields::Named(fields) =\u003e {\n                let fields = FieldKey::from_fields_named(fields).map(|(key, ..)| {\n                    let var = key.binding_var();\n                    quote! { #key : ref #var }\n                });\n                quote! { { #(#fields,)* } }\n            }\n            Fields::Unnamed(fields) =\u003e {\n                let fields = FieldKey::from_fields_unnamed(fields).map(|(key, ..)| {\n                    let var = key.binding_var();\n                    quote! { ref #var }\n                });\n                quote! { ( #(#fields,)* ) }\n            }\n            Fields::Unit =\u003e quote! {},\n        };\n        let hattrs_variant = HelperAttributes::from(\u0026variant.attrs)?;\n        let style = DisplayStyle::from_helper_attributes(hattrs_enum, \u0026hattrs_variant);\n        let mut format = hattrs_variant.format;\n        if format.is_none() {\n            format = hattrs_enum.format.clone();\n        }\n        if format.is_none() {\n            format = DisplayFormat::from_unit_variant(variant)?;\n        }\n        let format = match format {\n            Some(x) =\u003e x,\n            None =\u003e bail!(\n                variant.span(),\n                \"`#[display(\\\"format\\\")]` is required except unit variant.\"\n            ),\n        };\n        let variant_ident = \u0026variant.ident;\n        let args = format.format_args(\n            DisplayContext::Variant { variant, style },\n            \u0026mut bounds.child(hattrs_variant.bound_display),\n            generics,\n        )?;\n        Ok(quote! {\n            \u0026 Self::#variant_ident #fields =\u003e {\n                core::write!(f, #args)\n            },\n        })\n    }\n    let hattrs = HelperAttributes::from(\u0026input.attrs)?;\n    let mut bounds = Bounds::from_data(hattrs.bound_display.clone());\n    let generics = GenericParamSet::new(\u0026input.generics);\n    let mut arms = Vec::new();\n    for variant in \u0026data.variants {\n        arms.push(make_arm(\u0026hattrs, variant, \u0026mut bounds, \u0026generics)?);\n    }\n    let trait_path = parse_quote!(core::fmt::Display);\n    let contents = quote! {\n        fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter) -\u003e core::fmt::Result {\n            match self {\n                #(#arms)*\n            }\n        }\n    };\n    let wheres = bounds.build_wheres(\u0026trait_path);\n    impl_trait_result(input, \u0026trait_path, \u0026wheres, contents, hattrs.dump_display)\n}\n\n#[proc_macro_derive(FromStr, attributes(display, from_str))]\npub fn derive_from_str(input: proc_macro::TokenStream) -\u003e proc_macro::TokenStream {\n    let input = parse_macro_input!(input as DeriveInput);\n    into_macro_output(match \u0026input.data {\n        Data::Struct(data) =\u003e derive_from_str_for_struct(\u0026input, data),\n        Data::Enum(data) =\u003e derive_from_str_for_enum(\u0026input, data),\n        _ =\u003e panic!(\"`#[derive(FromStr)]` supports only enum or struct.\"),\n    })\n}\nfn derive_from_str_for_struct(input: \u0026DeriveInput, data: \u0026DataStruct) -\u003e Result\u003cTokenStream\u003e {\n    let hattrs = HelperAttributes::from(\u0026input.attrs)?;\n    let p = ParserBuilder::from_struct(\u0026hattrs, data)?;\n    let body = p.build_from_str_body(parse_quote!(Self))?;\n    let generics = GenericParamSet::new(\u0026input.generics);\n    let mut bounds = Bounds::from_data(hattrs.bound_from_str_resolved());\n    p.build_bounds(\u0026generics, \u0026mut bounds);\n    let trait_path = parse_quote!(core::str::FromStr);\n    let wheres = bounds.build_wheres(\u0026trait_path);\n    impl_trait_result(\n        input,\n        \u0026trait_path,\n        \u0026wheres,\n        quote! {\n            type Err = parse_display::ParseError;\n            fn from_str(s: \u0026str) -\u003e core::result::Result\u003cSelf, Self::Err\u003e {\n                #body\n            }\n        },\n        hattrs.dump_from_str,\n    )\n}\nfn derive_from_str_for_enum(input: \u0026DeriveInput, data: \u0026DataEnum) -\u003e Result\u003cTokenStream\u003e {\n    let hattrs_enum = HelperAttributes::from(\u0026input.attrs)?;\n    if let Some(span) = hattrs_enum.default_self {\n        bail!(span, \"`#[from_str(default)]` cannot be specified for enum.\");\n    }\n    let mut bounds = Bounds::from_data(hattrs_enum.bound_from_str_resolved());\n    let generics = GenericParamSet::new(\u0026input.generics);\n    let mut bodys = Vec::new();\n    let mut arms = Vec::new();\n    for variant in data.variants.iter() {\n        let variant_ident = \u0026variant.ident;\n        let constructor = parse_quote!(Self::#variant_ident);\n        let hattrs_variant = HelperAttributes::from(\u0026variant.attrs)?;\n        let p = ParserBuilder::from_variant(\u0026hattrs_variant, \u0026hattrs_enum, variant)?;\n        let mut bounds = bounds.child(hattrs_variant.bound_from_str_resolved());\n        p.build_bounds(\u0026generics, \u0026mut bounds);\n        match p.build_parse_variant_code(constructor)? {\n            ParseVariantCode::MatchArm(arm) =\u003e arms.push(arm),\n            ParseVariantCode::Statement(body) =\u003e bodys.push(body),\n        }\n    }\n    let match_body = if arms.is_empty() {\n        quote! {}\n    } else {\n        quote! {\n            match s {\n                #(#arms,)*\n                _ =\u003e { }\n            }\n        }\n    };\n    let trait_path = parse_quote!(core::str::FromStr);\n    let wheres = bounds.build_wheres(\u0026trait_path);\n    impl_trait_result(\n        input,\n        \u0026trait_path,\n        \u0026wheres,\n        quote! {\n            type Err = parse_display::ParseError;\n            fn from_str(s: \u0026str) -\u003e core::result::Result\u003cSelf, Self::Err\u003e {\n                #match_body\n                #({ #bodys })*\n                Err(parse_display::ParseError::new())\n            }\n        },\n        hattrs_enum.dump_from_str,\n    )\n}\n\nstruct ParserBuilder\u003c'a\u003e {\n    capture_next: usize,\n    parse_format: ParseFormat,\n    fields: BTreeMap\u003cFieldKey, FieldEntry\u003c'a\u003e\u003e,\n    source: \u0026'a Fields,\n    use_default: bool,\n    span: Span,\n    new_expr: Option\u003cExpr\u003e,\n}\nstruct FieldEntry\u003c'a\u003e {\n    hattrs: HelperAttributes,\n    deep_captures: BTreeMap\u003cVec\u003cFieldKey\u003e, usize\u003e,\n    source: \u0026'a Field,\n    capture: Option\u003cusize\u003e,\n    use_default: bool,\n}\n\nimpl\u003c'a\u003e ParserBuilder\u003c'a\u003e {\n    fn new(source: \u0026'a Fields) -\u003e Result\u003cSelf\u003e {\n        let mut fields = BTreeMap::new();\n        for (key, field) in field_map(source) {\n            fields.insert(key, FieldEntry::new(field)?);\n        }\n        Ok(Self {\n            source,\n            capture_next: 1,\n            parse_format: ParseFormat::new(),\n            fields,\n            use_default: false,\n            span: Span::call_site(),\n            new_expr: None,\n        })\n    }\n    fn from_struct(hattrs: \u0026HelperAttributes, data: \u0026'a DataStruct) -\u003e Result\u003cSelf\u003e {\n        let mut s = Self::new(\u0026data.fields)?;\n        let context = DisplayContext::Struct { data };\n        s.new_expr = hattrs.new_expr.clone();\n        s.apply_attrs(hattrs)?;\n        s.push_attrs(hattrs, \u0026context)?;\n        Ok(s)\n    }\n    fn from_variant(\n        hattrs_variant: \u0026HelperAttributes,\n        hattrs_enum: \u0026HelperAttributes,\n        variant: \u0026'a Variant,\n    ) -\u003e Result\u003cSelf\u003e {\n        let mut s = Self::new(\u0026variant.fields)?;\n        let style = DisplayStyle::from_helper_attributes(hattrs_enum, hattrs_variant);\n        let context = DisplayContext::Variant { variant, style };\n        s.new_expr = hattrs_variant.new_expr.clone();\n        s.apply_attrs(hattrs_enum)?;\n        s.apply_attrs(hattrs_variant)?;\n        if !s.try_push_attrs(hattrs_variant, \u0026context)? {\n            s.push_attrs(hattrs_enum, \u0026context)?;\n        }\n        Ok(s)\n    }\n    fn apply_attrs(\u0026mut self, hattrs: \u0026HelperAttributes) -\u003e Result\u003c()\u003e {\n        if hattrs.default_self.is_some() {\n            self.use_default = true;\n        }\n        for field in \u0026hattrs.default_fields {\n            let key = FieldKey::from_member(\u0026field.0);\n            let span = field.span();\n            self.field(\u0026key, span)?.use_default = true;\n        }\n        if let Some(span) = hattrs.from_str_format_span() {\n            self.span = span;\n        }\n        Ok(())\n    }\n    fn field(\u0026mut self, key: \u0026FieldKey, span: Span) -\u003e Result\u003c\u0026mut FieldEntry\u003c'a\u003e\u003e {\n        field_of(\u0026mut self.fields, key, span)\n    }\n    fn set_capture(\n        \u0026mut self,\n        context: \u0026DisplayContext,\n        keys: \u0026[FieldKey],\n        span: Span,\n    ) -\u003e Result\u003cString\u003e {\n        let field_key;\n        let sub_keys;\n        if let DisplayContext::Field { key, .. } = context {\n            field_key = *key;\n            sub_keys = keys;\n        } else {\n            if keys.is_empty() {\n                return Ok(CAPTURE_NAME_EMPTY.into());\n            }\n            field_key = \u0026keys[0];\n            sub_keys = \u0026keys[1..];\n        }\n        let field = field_of(\u0026mut self.fields, field_key, span)?;\n        Ok(field.set_capture(sub_keys, \u0026mut self.capture_next))\n    }\n\n    fn push_regex(\u0026mut self, s: \u0026LitStr, context: \u0026DisplayContext) -\u003e Result\u003c()\u003e {\n        static REGEX_CAPTURE: Lazy\u003cRegex\u003e = lazy_regex!(r\"\\(\\?P\u003c([_0-9a-zA-Z.]*)\u003e\");\n        static REGEX_NUMBER: Lazy\u003cRegex\u003e = lazy_regex!(\"^[0-9]+$\");\n        let text = s.value();\n        let text_debug = REGEX_CAPTURE.replace_all(\u0026text, |c: \u0026Captures| {\n            let key = c.get(1).unwrap().as_str();\n            let key = if key.is_empty() {\n                \"self\".into()\n            } else {\n                key.replace('.', \"_\")\n            };\n            let key = REGEX_NUMBER.replace(\u0026key, \"_$0\");\n            format!(\"(?P\u003c{}\u003e\", key)\n        });\n        if let Err(e) = regex_syntax::ast::parse::Parser::new().parse(\u0026text_debug) {\n            bail!(s.span(), \"{}\", e)\n        }\n\n        let mut has_capture = false;\n        let mut has_capture_empty = false;\n        let mut text = try_replace_all(\u0026REGEX_CAPTURE, \u0026text, |c: \u0026Captures| -\u003e Result\u003cString\u003e {\n            has_capture = true;\n            let keys = FieldKey::from_str_deep(c.get(1).unwrap().as_str());\n            let name = self.set_capture(context, \u0026keys, s.span())?;\n            if name == CAPTURE_NAME_EMPTY {\n                has_capture_empty = true;\n            }\n            Ok(format!(\"(?P\u003c{}\u003e\", name))\n        })?;\n\n        if has_capture_empty {\n            if let DisplayContext::Variant { variant, style } = context {\n                let value = style.apply(\u0026variant.ident);\n                self.parse_format\n                    .push_hir(to_hir_with_expand(\u0026text, CAPTURE_NAME_EMPTY, \u0026value));\n                return Ok(());\n            } else {\n                bail!(\n                    s.span(),\n                    \"`(?P\u003c\u003e)` (empty capture name) is not allowed in struct's regex.\"\n                );\n            }\n        }\n        if let DisplayContext::Field { .. } = context {\n            if !has_capture {\n                let name = self.set_capture(context, \u0026[], s.span())?;\n                text = format!(\"(?P\u003c{}\u003e{})\", name, \u0026text);\n            }\n        }\n        self.parse_format.push_hir(to_hir(\u0026text));\n        Ok(())\n    }\n    fn push_format(\u0026mut self, format: \u0026DisplayFormat, context: \u0026DisplayContext) -\u003e Result\u003c()\u003e {\n        for p in \u0026format.parts {\n            match p {\n                DisplayFormatPart::Str(s) =\u003e self.push_str(s),\n                DisplayFormatPart::EscapedBeginBracket =\u003e self.push_str(\"{\"),\n                DisplayFormatPart::EscapedEndBracket =\u003e self.push_str(\"}\"),\n                DisplayFormatPart::Var { arg, .. } =\u003e {\n                    let keys = FieldKey::from_str_deep(arg);\n                    if let DisplayContext::Variant { variant, style } = context {\n                        if keys.is_empty() {\n                            self.push_str(\u0026style.apply(\u0026variant.ident));\n                            continue;\n                        }\n                    }\n                    if keys.len() == 1 {\n                        self.push_field(context, \u0026keys[0], format.span)?;\n                        continue;\n                    }\n                    let c = self.set_capture(context, \u0026keys, format.span)?;\n                    self.parse_format\n                        .push_hir(to_hir(\u0026format!(\"(?P\u003c{}\u003e.*?)\", c)));\n                }\n            }\n        }\n        Ok(())\n    }\n    fn push_str(\u0026mut self, string: \u0026str) {\n        self.parse_format.push_str(string)\n    }\n    fn push_field(\u0026mut self, context: \u0026DisplayContext, key: \u0026FieldKey, span: Span) -\u003e Result\u003c()\u003e {\n        let e = self.field(key, span)?;\n        let hattrs = e.hattrs.clone();\n        let parent = context;\n        let field = e.source;\n        self.push_attrs(\u0026hattrs, \u0026DisplayContext::Field { parent, key, field })\n    }\n    fn push_attrs(\u0026mut self, hattrs: \u0026HelperAttributes, context: \u0026DisplayContext) -\u003e Result\u003c()\u003e {\n        if !self.try_push_attrs(hattrs, context)? {\n            self.push_format(\u0026context.default_from_str_format()?, context)?;\n        }\n        Ok(())\n    }\n    fn try_push_attrs(\n        \u0026mut self,\n        hattrs: \u0026HelperAttributes,\n        context: \u0026DisplayContext,\n    ) -\u003e Result\u003cbool\u003e {\n        Ok(if let Some(regex) = \u0026hattrs.regex {\n            self.push_regex(regex, context)?;\n            true\n        } else if let Some(format) = \u0026hattrs.format {\n            self.push_format(format, context)?;\n            true\n        } else {\n            false\n        })\n    }\n\n    fn build_from_str_body(\u0026self, constructor: Path) -\u003e Result\u003cTokenStream\u003e {\n        let code = self.build_parse_code(constructor)?;\n        Ok(quote! {\n            #code\n            Err(parse_display::ParseError::new())\n        })\n    }\n    fn build_parse_variant_code(\u0026self, constructor: Path) -\u003e Result\u003cParseVariantCode\u003e {\n        match \u0026self.parse_format {\n            ParseFormat::Hirs(_) =\u003e {\n                let fn_ident: Ident = format_ident!(\"parse_variant\");\n                let code = self.build_from_str_body(constructor)?;\n                let code = quote! {\n                    let #fn_ident = |s: \u0026str| -\u003e core::result::Result\u003cSelf, parse_display::ParseError\u003e {\n                        #code\n                    };\n                    if let Ok(value) = #fn_ident(s) {\n                        return Ok(value);\n                    }\n                };\n                Ok(ParseVariantCode::Statement(code))\n            }\n            ParseFormat::String(s) =\u003e {\n                let code = self.build_construct_code(constructor)?;\n                let code = quote! { #s  =\u003e { #code }};\n                Ok(ParseVariantCode::MatchArm(code))\n            }\n        }\n    }\n\n    fn build_construct_code(\u0026self, constructor: Path) -\u003e Result\u003cTokenStream\u003e {\n        let code = if let Some(new_expr) = \u0026self.new_expr {\n            let mut code = TokenStream::new();\n            for (key, field) in \u0026self.fields {\n                let expr = field.build_field_init_expr(key, self.span)?;\n                let var = key.new_arg_var();\n                code.extend(quote! { let #var = #expr; });\n            }\n            code.extend(quote! {\n                if let Ok(value) = ::parse_display::IntoResult::into_result(#new_expr) {\n                    return Ok(value);\n                }\n            });\n            code\n        } else if self.use_default {\n            let mut setters = Vec::new();\n            for (key, field) in \u0026self.fields {\n                let left_expr = quote! { value . #key };\n                setters.push(field.build_setters(key, left_expr, true));\n            }\n            quote! {\n                let mut value = \u003cSelf as core::default::Default\u003e::default();\n                #(#setters)*\n                return Ok(value);\n            }\n        } else {\n            let ps = match \u0026self.source {\n                Fields::Named(..) =\u003e {\n                    let mut fields_code = Vec::new();\n                    for (key, field) in \u0026self.fields {\n                        let expr = field.build_field_init_expr(key, self.span)?;\n                        fields_code.push(quote! { #key : #expr })\n                    }\n                    quote! { { #(#fields_code,)* } }\n                }\n                Fields::Unnamed(..) =\u003e {\n                    let mut fields_code = Vec::new();\n                    for (key, field) in \u0026self.fields {\n                        fields_code.push(field.build_field_init_expr(key, self.span)?);\n                    }\n                    quote! { ( #(#fields_code,)* ) }\n                }\n                Fields::Unit =\u003e quote! {},\n            };\n            quote! { return Ok(#constructor #ps); }\n        };\n        Ok(code)\n    }\n    fn build_parse_code(\u0026self, constructor: Path) -\u003e Result\u003cTokenStream\u003e {\n        let code = self.build_construct_code(constructor)?;\n        let code = match \u0026self.parse_format {\n            ParseFormat::Hirs(hirs) =\u003e {\n                let regex = to_regex_string(hirs);\n                quote! {\n                    #[allow(clippy::trivial_regex)]\n                    static RE: parse_display::helpers::once_cell::sync::Lazy\u003cparse_display::helpers::regex::Regex\u003e =\n                        parse_display::helpers::once_cell::sync::Lazy::new(|| parse_display::helpers::regex::Regex::new(#regex).unwrap());\n                    if let Some(c) = RE.captures(\u0026s) {\n                         #code\n                    }\n                }\n            }\n            ParseFormat::String(s) =\u003e {\n                quote! {\n                    if s == #s {\n                        #code\n                    }\n                }\n            }\n        };\n        Ok(code)\n    }\n\n    fn build_bounds(\u0026self, generics: \u0026GenericParamSet, bounds: \u0026mut Bounds) {\n        if !bounds.can_extend {\n            return;\n        }\n        for field in self.fields.values() {\n            let mut bounds = bounds.child(field.hattrs.bound_from_str_resolved());\n            if bounds.can_extend \u0026\u0026 field.capture.is_some() {\n                let ty = \u0026field.source.ty;\n                if generics.contains_in_type(ty) {\n                    bounds.ty.push(ty.clone());\n                }\n            }\n        }\n    }\n}\nimpl\u003c'a\u003e FieldEntry\u003c'a\u003e {\n    fn new(source: \u0026'a Field) -\u003e Result\u003cSelf\u003e {\n        let hattrs = HelperAttributes::from(\u0026source.attrs)?;\n        let use_default = hattrs.default_self.is_some();\n        Ok(Self {\n            hattrs,\n            deep_captures: BTreeMap::new(),\n            capture: None,\n            use_default,\n            source,\n        })\n    }\n    #[allow(clippy::collapsible_else_if)]\n    fn set_capture(\u0026mut self, keys: \u0026[FieldKey], capture_next: \u0026mut usize) -\u003e String {\n        let idx = if keys.is_empty() {\n            if let Some(idx) = self.capture {\n                idx\n            } else {\n                let idx = *capture_next;\n                self.capture = Some(idx);\n                *capture_next += 1;\n                idx\n            }\n        } else {\n            if let Some(\u0026idx) = self.deep_captures.get(keys) {\n                idx\n            } else {\n                let idx = *capture_next;\n                self.deep_captures.insert(keys.to_vec(), idx);\n                *capture_next += 1;\n                idx\n            }\n        };\n        capture_name(idx)\n    }\n    fn capture(\u0026self) -\u003e Option\u003cString\u003e {\n        self.capture.map(capture_name)\n    }\n    fn build_expr(\u0026self, key: \u0026FieldKey) -\u003e Option\u003cTokenStream\u003e {\n        if let Some(capture_name) = self.capture() {\n            Some(build_parse_capture_expr(\u0026key.to_string(), \u0026capture_name))\n        } else if self.use_default {\n            Some(quote! { core::default::Default::default() })\n        } else {\n            None\n        }\n    }\n    fn build_setters(\n        \u0026self,\n        key: \u0026FieldKey,\n        left_expr: TokenStream,\n        include_self: bool,\n    ) -\u003e TokenStream {\n        let mut setters = Vec::new();\n        if include_self {\n            if let Some(expr) = self.build_expr(key) {\n                setters.push(quote! { #left_expr = #expr; });\n            }\n        }\n        for (keys, idx) in \u0026self.deep_captures {\n            let field_name = key.to_string() + \u0026join(keys, \".\");\n            let expr = build_parse_capture_expr(\u0026field_name, \u0026capture_name(*idx));\n            setters.push(quote! { #left_expr #(.#keys)* = #expr; });\n        }\n        quote! { #(#setters)* }\n    }\n\n    fn build_field_init_expr(\u0026self, key: \u0026FieldKey, span: Span) -\u003e Result\u003cTokenStream\u003e {\n        if let Some(mut expr) = self.build_expr(key) {\n            if !self.deep_captures.is_empty() {\n                let setters = self.build_setters(key, quote!(field_value), false);\n                let ty = \u0026self.source.ty;\n                expr = quote! {\n                    {\n                        let mut field_value : #ty = #expr;\n                        #setters\n                        field_value\n                    }\n                };\n            }\n            return Ok(expr);\n        }\n        bail!(span, \"field `{}` is not appear in format.\", key);\n    }\n}\n\nfn get_newtype_field(data: \u0026DataStruct) -\u003e Option\u003cString\u003e {\n    let fields: Vec\u003c_\u003e = data.fields.iter().collect();\n    if fields.len() == 1 {\n        if let Some(ident) = \u0026fields[0].ident {\n            Some(ident.to_string())\n        } else {\n            Some(\"0\".into())\n        }\n    } else {\n        None\n    }\n}\n\n#[derive(StructMeta)]\nstruct DisplayArgs {\n    #[struct_meta(unnamed)]\n    format: Option\u003cLitStr\u003e,\n    style: Option\u003cLitStr\u003e,\n    bound: Option\u003cVec\u003cQuotable\u003cBound\u003e\u003e\u003e,\n    dump: bool,\n}\n\n#[derive(Clone, ToTokens)]\nstruct DefaultField(Member);\n\nimpl Parse for DefaultField {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        if input.peek(Ident::peek_any) {\n            Ok(Self(Member::Named(Ident::parse_any(input)?)))\n        } else {\n            Ok(Self(input.parse()?))\n        }\n    }\n}\n\n#[derive(StructMeta)]\nstruct FromStrArgs {\n    regex: Option\u003cLitStr\u003e,\n    new: Option\u003cExpr\u003e,\n    bound: Option\u003cVec\u003cQuotable\u003cBound\u003e\u003e\u003e,\n    default: Flag,\n    default_fields: Option\u003cVec\u003cQuotable\u003cDefaultField\u003e\u003e\u003e,\n    dump: bool,\n}\n\n#[derive(Clone)]\nstruct HelperAttributes {\n    format: Option\u003cDisplayFormat\u003e,\n    style: Option\u003cDisplayStyle\u003e,\n    bound_display: Option\u003cVec\u003cBound\u003e\u003e,\n    bound_from_str: Option\u003cVec\u003cBound\u003e\u003e,\n    regex: Option\u003cLitStr\u003e,\n    default_self: Option\u003cSpan\u003e,\n    default_fields: Vec\u003cDefaultField\u003e,\n    new_expr: Option\u003cExpr\u003e,\n    dump_display: bool,\n    dump_from_str: bool,\n}\nimpl HelperAttributes {\n    fn from(attrs: \u0026[Attribute]) -\u003e Result\u003cSelf\u003e {\n        let mut hattrs = Self {\n            format: None,\n            style: None,\n            bound_display: None,\n            bound_from_str: None,\n            regex: None,\n            new_expr: None,\n            default_self: None,\n            default_fields: Vec::new(),\n            dump_display: false,\n            dump_from_str: false,\n        };\n        for a in attrs {\n            if a.path.is_ident(\"display\") {\n                hattrs.set_display_args(a.parse_args()?)?;\n            }\n            if a.path.is_ident(\"from_str\") {\n                hattrs.set_from_str_args(a.parse_args()?);\n            }\n        }\n        Ok(hattrs)\n    }\n    fn set_display_args(\u0026mut self, args: DisplayArgs) -\u003e Result\u003c()\u003e {\n        if let Some(format) = \u0026args.format {\n            self.format = Some(DisplayFormat::parse_lit_str(format)?);\n        }\n        if let Some(style) = \u0026args.style {\n            self.style = Some(DisplayStyle::parse_lit_str(style)?);\n        }\n        if let Some(bounds) = args.bound {\n            let list = self.bound_display.get_or_insert(Vec::new());\n            for bound in bounds {\n                for bound in bound.into_iter() {\n                    list.push(bound);\n                }\n            }\n        }\n        self.dump_from_str |= args.dump;\n        self.dump_display |= args.dump;\n        Ok(())\n    }\n    fn set_from_str_args(\u0026mut self, args: FromStrArgs) {\n        if let Some(regex) = args.regex {\n            self.regex = Some(regex);\n        }\n        if let Some(new) = args.new {\n            self.new_expr = Some(new);\n        }\n        if let Some(bound) = args.bound {\n            let list = self.bound_from_str.get_or_insert(Vec::new());\n            for bound in bound {\n                for bound in bound.into_iter() {\n                    list.push(bound);\n                }\n            }\n        }\n        if let Some(span) = args.default.span {\n            self.default_self = Some(span);\n        }\n        if let Some(fields) = args.default_fields {\n            for field in fields {\n                for field in field.into_iter() {\n                    self.default_fields.push(field);\n                }\n            }\n        }\n        self.dump_from_str |= args.dump;\n    }\n    fn from_str_format_span(\u0026self) -\u003e Option\u003cSpan\u003e {\n        if let Some(lit) = \u0026self.regex {\n            return Some(lit.span());\n        }\n        if let Some(format) = \u0026self.format {\n            return Some(format.span);\n        }\n        None\n    }\n    fn bound_from_str_resolved(\u0026self) -\u003e Option\u003cVec\u003cBound\u003e\u003e {\n        self.bound_from_str\n            .clone()\n            .or_else(|| self.bound_display.clone())\n    }\n}\n\n#[derive(Copy, Clone)]\nenum DisplayStyle {\n    None,\n    LowerCase,\n    UpperCase,\n    LowerSnakeCase,\n    UpperSnakeCase,\n    LowerCamelCase,\n    UpperCamelCase,\n    LowerKebabCase,\n    UpperKebabCase,\n    TitleCase,\n    TitleCaseHead,\n    TitleCaseLower,\n    TitleCaseUpper,\n}\n\nimpl DisplayStyle {\n    fn parse_lit_str(s: \u0026LitStr) -\u003e Result\u003cSelf\u003e {\n        const ERROR_MESSAGE: \u0026str = \"Invalid display style. \\\n        The following values are available: \\\n        \\\"none\\\", \\\n        \\\"lowercase\\\", \\\n        \\\"UPPERCASE\\\", \\\n        \\\"snake_case\\\", \\\n        \\\"SNAKE_CASE\\\", \\\n        \\\"camelCase\\\", \\\n        \\\"CamelCase\\\", \\\n        \\\"kebab-case\\\", \\\n        \\\"KEBAB-CASE\\\", \\\n        \\\"Title Case\\\", \\\n        \\\"Title case\\\", \\\n        \\\"title case\\\", \\\n        \\\"TITLE CASE\\\"\";\n        match Self::parse(\u0026s.value()) {\n            Err(_) =\u003e bail!(s.span(), ERROR_MESSAGE),\n            Ok(value) =\u003e Ok(value),\n        }\n    }\n    fn parse(s: \u0026str) -\u003e std::result::Result\u003cSelf, ParseDisplayStyleError\u003e {\n        use DisplayStyle::*;\n        Ok(match s {\n            \"none\" =\u003e None,\n            \"lowercase\" =\u003e LowerCase,\n            \"UPPERCASE\" =\u003e UpperCase,\n            \"snake_case\" =\u003e LowerSnakeCase,\n            \"SNAKE_CASE\" =\u003e UpperSnakeCase,\n            \"camelCase\" =\u003e LowerCamelCase,\n            \"CamelCase\" =\u003e UpperCamelCase,\n            \"kebab-case\" =\u003e LowerKebabCase,\n            \"KEBAB-CASE\" =\u003e UpperKebabCase,\n            \"Title Case\" =\u003e TitleCase,\n            \"Title case\" =\u003e TitleCaseHead,\n            \"title case\" =\u003e TitleCaseLower,\n            \"TITLE CASE\" =\u003e TitleCaseUpper,\n            _ =\u003e return Err(ParseDisplayStyleError),\n        })\n    }\n    fn from_helper_attributes(\n        hattrs_enum: \u0026HelperAttributes,\n        hattrs_variant: \u0026HelperAttributes,\n    ) -\u003e Self {\n        hattrs_variant\n            .style\n            .or(hattrs_enum.style)\n            .unwrap_or(DisplayStyle::None)\n    }\n    fn apply(self, ident: \u0026Ident) -\u003e String {\n        fn convert_case(c: char, to_upper: bool) -\u003e char {\n            if to_upper {\n                c.to_ascii_uppercase()\n            } else {\n                c.to_ascii_lowercase()\n            }\n        }\n\n        let s = ident.to_string();\n        let (line_head, word_head, normal, sep) = match self {\n            DisplayStyle::None =\u003e {\n                return s;\n            }\n            DisplayStyle::LowerCase =\u003e (false, false, false, \"\"),\n            DisplayStyle::UpperCase =\u003e (true, true, true, \"\"),\n            DisplayStyle::LowerSnakeCase =\u003e (false, false, false, \"_\"),\n            DisplayStyle::UpperSnakeCase =\u003e (true, true, true, \"_\"),\n            DisplayStyle::LowerCamelCase =\u003e (false, true, false, \"\"),\n            DisplayStyle::UpperCamelCase =\u003e (true, true, false, \"\"),\n            DisplayStyle::LowerKebabCase =\u003e (false, false, false, \"-\"),\n            DisplayStyle::UpperKebabCase =\u003e (true, true, true, \"-\"),\n            DisplayStyle::TitleCase =\u003e (true, true, false, \" \"),\n            DisplayStyle::TitleCaseUpper =\u003e (true, true, true, \" \"),\n            DisplayStyle::TitleCaseLower =\u003e (false, false, false, \" \"),\n            DisplayStyle::TitleCaseHead =\u003e (true, false, false, \" \"),\n        };\n        let mut is_line_head = true;\n        let mut is_word_head = true;\n        let mut last = '\\0';\n\n        let mut r = String::new();\n        for c in s.chars() {\n            if !c.is_alphanumeric() \u0026\u0026 !c.is_digit(10) {\n                is_word_head = true;\n                continue;\n            }\n            is_word_head = is_word_head || (!last.is_ascii_uppercase() \u0026\u0026 c.is_ascii_uppercase());\n            last = c;\n            let (to_upper, sep) = match (is_line_head, is_word_head) {\n                (true, _) =\u003e (line_head, \"\"),\n                (false, true) =\u003e (word_head, sep),\n                (false, false) =\u003e (normal, \"\"),\n            };\n            r.push_str(sep);\n            r.push(convert_case(c, to_upper));\n            is_word_head = false;\n            is_line_head = false;\n        }\n        r\n    }\n}\n\n#[derive(Clone)]\nstruct DisplayFormat {\n    parts: Vec\u003cDisplayFormatPart\u003e,\n    span: Span,\n}\nimpl DisplayFormat {\n    fn parse_lit_str(s: \u0026LitStr) -\u003e Result\u003cDisplayFormat\u003e {\n        Self::parse(\u0026s.value(), s.span())\n    }\n    fn parse(mut s: \u0026str, span: Span) -\u003e Result\u003cDisplayFormat\u003e {\n        static REGEX_STR: Lazy\u003cRegex\u003e = lazy_regex!(r\"^[^{}]+\");\n        static REGEX_VAR: Lazy\u003cRegex\u003e = lazy_regex!(r\"^\\{([^:{}]*)(?::([^}]*))?\\}\");\n        let mut parts = Vec::new();\n        while !s.is_empty() {\n            if s.starts_with(\"{{\") {\n                parts.push(DisplayFormatPart::EscapedBeginBracket);\n                s = \u0026s[2..];\n                continue;\n            }\n            if s.starts_with(\"}}\") {\n                parts.push(DisplayFormatPart::EscapedEndBracket);\n                s = \u0026s[2..];\n                continue;\n            }\n            if let Some(m) = REGEX_STR.find(s) {\n                parts.push(DisplayFormatPart::Str(m.as_str().into()));\n                s = \u0026s[m.end()..];\n                continue;\n            }\n            if let Some(c) = REGEX_VAR.captures(s) {\n                let arg = c.get(1).unwrap().as_str().into();\n                let format_spec = c.get(2).map_or(\"\", |x| x.as_str()).into();\n                parts.push(DisplayFormatPart::Var { arg, format_spec });\n                s = \u0026s[c.get(0).unwrap().end()..];\n                continue;\n            }\n            bail!(span, \"invalid display format.\");\n        }\n        Ok(Self { parts, span })\n    }\n    fn from_newtype_struct(data: \u0026DataStruct) -\u003e Option\u003cSelf\u003e {\n        let p = DisplayFormatPart::Var {\n            arg: get_newtype_field(data)?,\n            format_spec: String::new(),\n        };\n        Some(Self {\n            parts: vec![p],\n            span: data.fields.span(),\n        })\n    }\n    fn from_unit_variant(variant: \u0026Variant) -\u003e Result\u003cOption\u003cSelf\u003e\u003e {\n        Ok(if let Fields::Unit = \u0026variant.fields {\n            Some(Self::parse(\"{}\", variant.span())?)\n        } else {\n            None\n        })\n    }\n\n    fn format_args(\n        \u0026self,\n        context: DisplayContext,\n        bounds: \u0026mut Bounds,\n        generics: \u0026GenericParamSet,\n    ) -\u003e Result\u003cTokenStream\u003e {\n        let mut format_str = String::new();\n        let mut format_args = Vec::new();\n        for p in \u0026self.parts {\n            use DisplayFormatPart::*;\n            match p {\n                Str(s) =\u003e format_str.push_str(s.as_str()),\n                EscapedBeginBracket =\u003e format_str.push_str(\"{{\"),\n                EscapedEndBracket =\u003e format_str.push_str(\"}}\"),\n                Var { arg, format_spec } =\u003e {\n                    format_str.push('{');\n                    if !format_spec.is_empty() {\n                        format_str.push(':');\n                        format_str.push_str(format_spec);\n                    }\n                    format_str.push('}');\n                    format_args.push(context.format_arg(\n                        arg,\n                        format_spec,\n                        self.span,\n                        bounds,\n                        generics,\n                    )?);\n                }\n            }\n        }\n        let format_str = LitStr::new(\u0026format_str, self.span);\n        Ok(quote! { #format_str #(,#format_args)* })\n    }\n}\n\n#[derive(Clone)]\nenum DisplayFormatPart {\n    Str(String),\n    EscapedBeginBracket,\n    EscapedEndBracket,\n    Var { arg: String, format_spec: String },\n}\n\nenum DisplayContext\u003c'a\u003e {\n    Struct {\n        data: \u0026'a DataStruct,\n    },\n    Variant {\n        variant: \u0026'a Variant,\n        style: DisplayStyle,\n    },\n    Field {\n        parent: \u0026'a DisplayContext\u003c'a\u003e,\n        field: \u0026'a Field,\n        key: \u0026'a FieldKey,\n    },\n}\n\nimpl\u003c'a\u003e DisplayContext\u003c'a\u003e {\n    fn format_arg(\n        \u0026self,\n        arg: \u0026str,\n        format_spec: \u0026str,\n        span: Span,\n        bounds: \u0026mut Bounds,\n        generics: \u0026GenericParamSet,\n    ) -\u003e Result\u003cTokenStream\u003e {\n        let keys = FieldKey::from_str_deep(arg);\n        if keys.is_empty() {\n            return Ok(match self {\n                DisplayContext::Struct { .. } =\u003e bail!(span, \"{} is not allowed in struct format.\"),\n                DisplayContext::Field { parent, field, key } =\u003e parent.format_arg_by_field_expr(\n                    key,\n                    field,\n                    format_spec,\n                    span,\n                    bounds,\n                    generics,\n                )?,\n                DisplayContext::Variant { variant, style } =\u003e {\n                    let s = style.apply(\u0026variant.ident);\n                    quote! { #s }\n                }\n            });\n        }\n\n        if keys.len() == 1 {\n            if let Some(fields) = self.fields() {\n                let key = \u0026keys[0];\n                let m = field_map(fields);\n                let field = if let Some(field) = m.get(key) {\n                    field\n                } else {\n                    bail!(span, \"unknown field '{}'.\", key);\n                };\n                return self.format_arg_of_field(key, field, format_spec, span, bounds, generics);\n            }\n        }\n        let mut expr = self.field_expr(\u0026keys[0]);\n        for key in \u0026keys[1..] {\n            expr.extend(quote! { .#key });\n        }\n        Ok(expr)\n    }\n    fn format_arg_of_field(\n        \u0026self,\n        key: \u0026FieldKey,\n        field: \u0026Field,\n        parameters: \u0026str,\n        span: Span,\n        bounds: \u0026mut Bounds,\n        generics: \u0026GenericParamSet,\n    ) -\u003e Result\u003cTokenStream\u003e {\n        let hattrs = HelperAttributes::from(\u0026field.attrs)?;\n        let mut bounds = bounds.child(hattrs.bound_display);\n        Ok(if let Some(format) = hattrs.format {\n            let args = format.format_args(\n                DisplayContext::Field {\n                    parent: self,\n                    field,\n                    key,\n                },\n                \u0026mut bounds,\n                generics,\n            )?;\n            quote! { format_args!(#args) }\n        } else {\n            self.format_arg_by_field_expr(key, field, parameters, span, \u0026mut bounds, generics)?\n        })\n    }\n    fn format_arg_by_field_expr(\n        \u0026self,\n        key: \u0026FieldKey,\n        field: \u0026Field,\n        format_spec: \u0026str,\n        span: Span,\n        bounds: \u0026mut Bounds,\n        generics: \u0026GenericParamSet,\n    ) -\u003e Result\u003cTokenStream\u003e {\n        let ty = \u0026field.ty;\n        if generics.contains_in_type(ty) {\n            let ps = match FormatSpec::parse(format_spec) {\n                Ok(ps) =\u003e ps,\n                Err(_) =\u003e bail!(span, \"invalid format parameters \\\"{}\\\".\", format_spec),\n            };\n            let tr = ps.format_type.trait_name();\n            let tr: Ident = parse_str(tr).unwrap();\n            if bounds.can_extend {\n                bounds.pred.push(parse_quote!(#ty : core::fmt::#tr));\n            }\n        }\n        Ok(self.field_expr(key))\n    }\n\n    fn field_expr(\u0026self, key: \u0026FieldKey) -\u003e TokenStream {\n        match self {\n            DisplayContext::Struct { .. } =\u003e quote! { self.#key },\n            DisplayContext::Variant { .. } =\u003e {\n                let var = key.binding_var();\n                quote! { #var }\n            }\n            DisplayContext::Field {\n                parent,\n                key: parent_key,\n                ..\n            } =\u003e {\n                let expr = parent.field_expr(parent_key);\n                quote! { #expr.#key }\n            }\n        }\n    }\n\n    fn default_from_str_format(\u0026self) -\u003e Result\u003cDisplayFormat\u003e {\n        const ERROR_MESSAGE_FOR_STRUCT:\u0026str=\"`#[display(\\\"format\\\")]` or `#[from_str(regex = \\\"regex\\\")]` is required except newtype pattern.\";\n        const ERROR_MESSAGE_FOR_VARIANT:\u0026str=\"`#[display(\\\"format\\\")]` or `#[from_str(regex = \\\"regex\\\")]` is required except unit variant.\";\n        Ok(match self {\n            DisplayContext::Struct { data, .. } =\u003e {\n                DisplayFormat::from_newtype_struct(data).expect(ERROR_MESSAGE_FOR_STRUCT)\n            }\n            DisplayContext::Variant { variant, .. } =\u003e {\n                DisplayFormat::from_unit_variant(variant)?.expect(ERROR_MESSAGE_FOR_VARIANT)\n            }\n            DisplayContext::Field { field, .. } =\u003e DisplayFormat::parse(\"{}\", field.span())?,\n        })\n    }\n    fn fields(\u0026self) -\u003e Option\u003c\u0026Fields\u003e {\n        match self {\n            DisplayContext::Struct { data, .. } =\u003e Some(\u0026data.fields),\n            DisplayContext::Variant { variant, .. } =\u003e Some(\u0026variant.fields),\n            DisplayContext::Field { .. } =\u003e None,\n        }\n    }\n}\n\n#[derive(Debug)]\nstruct ParseDisplayStyleError;\nimpl std::error::Error for ParseDisplayStyleError {}\n\nimpl Display for ParseDisplayStyleError {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(f, \"invalid display style\")\n    }\n}\n\nenum ParseFormat {\n    Hirs(Vec\u003cHir\u003e),\n    String(String),\n}\nimpl ParseFormat {\n    fn new() -\u003e Self {\n        Self::String(String::new())\n    }\n    fn as_hirs(\u0026mut self) -\u003e \u0026mut Vec\u003cHir\u003e {\n        match self {\n            Self::Hirs(_) =\u003e {}\n            Self::String(s) =\u003e {\n                let mut hirs = vec![Hir::anchor(regex_syntax::hir::Anchor::StartText)];\n                push_str(\u0026mut hirs, s);\n                std::mem::swap(self, \u0026mut Self::Hirs(hirs));\n            }\n        }\n        if let Self::Hirs(hirs) = self {\n            hirs\n        } else {\n            unreachable!()\n        }\n    }\n    fn push_str(\u0026mut self, string: \u0026str) {\n        match self {\n            Self::Hirs(hirs) =\u003e push_str(hirs, string),\n            Self::String(s) =\u003e s.push_str(string),\n        }\n    }\n    fn push_hir(\u0026mut self, hir: Hir) {\n        self.as_hirs().push(hir);\n    }\n}\n\nenum ParseVariantCode {\n    MatchArm(TokenStream),\n    Statement(TokenStream),\n}\n\n#[derive(Clone, ToTokens)]\nenum Bound {\n    Type(Type),\n    Pred(WherePredicate),\n    Default(Token![..]),\n}\n\nimpl Parse for Bound {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        if input.peek(Token![..]) {\n            return Ok(Self::Default(input.parse()?));\n        }\n        let fork = input.fork();\n        match fork.parse() {\n            Ok(p) =\u003e {\n                input.advance_to(\u0026fork);\n                Ok(Self::Pred(p))\n            }\n            Err(e) =\u003e {\n                if let Ok(ty) = input.parse() {\n                    Ok(Self::Type(ty))\n                } else {\n                    Err(e)\n                }\n            }\n        }\n    }\n}\n\nstruct Bounds {\n    ty: Vec\u003cType\u003e,\n    pred: Vec\u003cWherePredicate\u003e,\n    can_extend: bool,\n}\nimpl Bounds {\n    fn new(can_extend: bool) -\u003e Self {\n        Bounds {\n            ty: Vec::new(),\n            pred: Vec::new(),\n            can_extend,\n        }\n    }\n    fn from_data(bound: Option\u003cVec\u003cBound\u003e\u003e) -\u003e Self {\n        if let Some(bound) = bound {\n            let mut bs = Self::new(false);\n            for b in bound {\n                bs.push(b);\n            }\n            bs\n        } else {\n            Self::new(true)\n        }\n    }\n    fn push(\u0026mut self, bound: Bound) {\n        match bound {\n            Bound::Type(ty) =\u003e self.ty.push(ty),\n            Bound::Pred(pred) =\u003e self.pred.push(pred),\n            Bound::Default(_) =\u003e self.can_extend = true,\n        }\n    }\n    fn child(\u0026mut self, bounds: Option\u003cVec\u003cBound\u003e\u003e) -\u003e BoundsChild {\n        let bounds = if self.can_extend {\n            Self::from_data(bounds)\n        } else {\n            Self::new(false)\n        };\n        BoundsChild {\n            owner: self,\n            bounds,\n        }\n    }\n    fn build_wheres(self, trait_path: \u0026Path) -\u003e Vec\u003cWherePredicate\u003e {\n        let mut pred = self.pred;\n        for ty in self.ty {\n            pred.push(parse_quote!(#ty : #trait_path));\n        }\n        pred\n    }\n}\nstruct BoundsChild\u003c'a\u003e {\n    owner: \u0026'a mut Bounds,\n    bounds: Bounds,\n}\nimpl\u003c'a\u003e Deref for BoundsChild\u003c'a\u003e {\n    type Target = Bounds;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.bounds\n    }\n}\nimpl\u003c'a\u003e DerefMut for BoundsChild\u003c'a\u003e {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.bounds\n    }\n}\nimpl\u003c'a\u003e Drop for BoundsChild\u003c'a\u003e {\n    fn drop(\u0026mut self) {\n        if self.owner.can_extend {\n            self.owner.ty.append(\u0026mut self.bounds.ty);\n            self.owner.pred.append(\u0026mut self.bounds.pred);\n        }\n    }\n}\n\n#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\nenum FieldKey {\n    Named(String),\n    Unnamed(usize),\n}\n\nimpl FieldKey {\n    fn from_str(s: \u0026str) -\u003e FieldKey {\n        if let Ok(idx) = s.parse() {\n            FieldKey::Unnamed(idx)\n        } else {\n            FieldKey::Named(trim_raw(s).to_string())\n        }\n    }\n    fn from_string(mut s: String) -\u003e FieldKey {\n        if let Ok(idx) = s.parse() {\n            FieldKey::Unnamed(idx)\n        } else {\n            if s.starts_with(\"r#\") {\n                s.drain(0..2);\n            }\n            FieldKey::Named(s)\n        }\n    }\n    fn from_ident(ident: \u0026Ident) -\u003e FieldKey {\n        Self::from_string(ident.to_string())\n    }\n    fn from_str_deep(s: \u0026str) -\u003e Vec\u003cFieldKey\u003e {\n        if s.is_empty() {\n            Vec::new()\n        } else {\n            s.split('.').map(Self::from_str).collect()\n        }\n    }\n    fn from_fields_named(fields: \u0026FieldsNamed) -\u003e impl Iterator\u003cItem = (FieldKey, \u0026Field)\u003e {\n        fields\n            .named\n            .iter()\n            .map(|field| (Self::from_ident(field.ident.as_ref().unwrap()), field))\n    }\n    fn from_fields_unnamed(fields: \u0026FieldsUnnamed) -\u003e impl Iterator\u003cItem = (FieldKey, \u0026Field)\u003e {\n        fields\n            .unnamed\n            .iter()\n            .enumerate()\n            .map(|(idx, field)| (FieldKey::Unnamed(idx), field))\n    }\n    fn from_member(member: \u0026Member) -\u003e Self {\n        match member {\n            Member::Named(ident) =\u003e Self::from_ident(ident),\n            Member::Unnamed(index) =\u003e Self::Unnamed(index.index as usize),\n        }\n    }\n\n    fn to_member(\u0026self) -\u003e Member {\n        match self {\n            FieldKey::Named(s) =\u003e Member::Named(format_ident!(\"r#{}\", s)),\n            FieldKey::Unnamed(idx) =\u003e Member::Unnamed(parse_str(\u0026format!(\"{}\", idx)).unwrap()),\n        }\n    }\n    fn binding_var(\u0026self) -\u003e Ident {\n        parse_str(\u0026format!(\"_value_{}\", self)).unwrap()\n    }\n    fn new_arg_var(\u0026self) -\u003e Ident {\n        match self {\n            Self::Named(s) =\u003e parse_str(s),\n            Self::Unnamed(idx) =\u003e parse_str(\u0026format!(\"_{}\", idx)),\n        }\n        .unwrap()\n    }\n}\nimpl std::fmt::Display for FieldKey {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            FieldKey::Named(s) =\u003e write!(f, \"{}\", s),\n            FieldKey::Unnamed(idx) =\u003e write!(f, \"{}\", idx),\n        }\n    }\n}\nimpl quote::ToTokens for FieldKey {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        self.to_member().to_tokens(tokens)\n    }\n}\n\nfn field_map(fields: \u0026Fields) -\u003e BTreeMap\u003cFieldKey, \u0026Field\u003e {\n    let mut m = BTreeMap::new();\n    for (idx, field) in fields.iter().enumerate() {\n        let key = if let Some(ident) = \u0026field.ident {\n            FieldKey::from_ident(ident)\n        } else {\n            FieldKey::Unnamed(idx)\n        };\n        m.insert(key, field);\n    }\n    m\n}\n\nfn join\u003cT: std::fmt::Display\u003e(s: impl IntoIterator\u003cItem = T\u003e, sep: \u0026str) -\u003e String {\n    use std::fmt::*;\n    let mut sep_current = \"\";\n    let mut buf = String::new();\n    for i in s.into_iter() {\n        write!(\u0026mut buf, \"{}{}\", sep_current, i).unwrap();\n        sep_current = sep;\n    }\n    buf\n}\nfn trim_raw(s: \u0026str) -\u003e \u0026str {\n    if let Some(s) = s.strip_prefix(\"r#\") {\n        s\n    } else {\n        s\n    }\n}\n\nfn field_of\u003c'a, 'b\u003e(\n    fields: \u0026'a mut BTreeMap\u003cFieldKey, FieldEntry\u003c'b\u003e\u003e,\n    key: \u0026FieldKey,\n    span: Span,\n) -\u003e Result\u003c\u0026'a mut FieldEntry\u003c'b\u003e\u003e {\n    if let Some(f) = fields.get_mut(key) {\n        Ok(f)\n    } else {\n        bail!(span, \"field `{}` not found.\", key);\n    }\n}\n\nconst CAPTURE_NAME_EMPTY: \u0026str = \"empty\";\nfn capture_name(idx: usize) -\u003e String {\n    format!(\"value_{}\", idx)\n}\n\nfn build_parse_capture_expr(field_name: \u0026str, capture_name: \u0026str) -\u003e TokenStream {\n    let msg = format!(\"field `{}` parse failed.\", field_name);\n    quote! {\n        c.name(#capture_name)\n            .map_or(\"\", |m| m.as_str())\n            .parse()\n            .map_err(|e| parse_display::ParseError::with_message(#msg))?\n    }\n}\n","traces":[{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":446,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1042,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1043,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1049,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1052,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1054,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1056,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1058,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1061,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1062,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1063,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1065,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1076,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1077,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1078,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1079,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1080,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1081,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1082,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1083,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1085,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1086,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1088,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1090,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":348},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-derive","src","regex_utils.rs"],"content":"use regex::{Captures, Regex};\nuse regex_syntax::ast::Ast;\nuse regex_syntax::hir::Hir;\n\npub fn to_hir(s: \u0026str) -\u003e Hir {\n    regex_syntax::Parser::new().parse(s).unwrap()\n}\npub fn to_hir_with_expand(s: \u0026str, name: \u0026str, value: \u0026str) -\u003e Hir {\n    let mut ast = to_ast(s);\n    expand_capture(\u0026mut ast, |group_name| {\n        if group_name == name {\n            Some(to_ast(\u0026regex_syntax::escape(value)))\n        } else {\n            None\n        }\n    });\n    let s = format!(\"{}\", \u0026ast);\n\n    regex_syntax::hir::translate::Translator::new()\n        .translate(\u0026s, \u0026ast)\n        .unwrap()\n}\n\nfn to_ast(s: \u0026str) -\u003e Ast {\n    regex_syntax::ast::parse::Parser::new().parse(s).unwrap()\n}\n\npub fn push_str(hirs: \u0026mut Vec\u003cHir\u003e, s: \u0026str) {\n    for c in s.chars() {\n        hirs.push(Hir::literal(regex_syntax::hir::Literal::Unicode(c)));\n    }\n}\npub fn to_regex_string(hirs: \u0026[Hir]) -\u003e String {\n    let mut hirs = hirs.to_vec();\n    hirs.push(Hir::anchor(regex_syntax::hir::Anchor::EndText));\n    Hir::concat(hirs).to_string()\n}\n\nfn replace_ast(ast: \u0026mut Ast, f: \u0026mut impl FnMut(\u0026mut Ast) -\u003e bool) {\n    if !f(ast) {\n        return;\n    }\n    use regex_syntax::ast::*;\n    match ast {\n        Ast::Empty(..)\n        | Ast::Flags(..)\n        | Ast::Literal(..)\n        | Ast::Dot(..)\n        | Ast::Assertion(..)\n        | Ast::Class(..) =\u003e {}\n        Ast::Repetition(Repetition { ast, .. }) | Ast::Group(Group { ast, .. }) =\u003e {\n            replace_ast(ast, f)\n        }\n        Ast::Alternation(Alternation { asts, .. }) | Ast::Concat(Concat { asts, .. }) =\u003e {\n            for ast in asts {\n                replace_ast(ast, f)\n            }\n        }\n    }\n}\n\nfn expand_capture(ast: \u0026mut Ast, mut f: impl FnMut(\u0026str) -\u003e Option\u003cAst\u003e) {\n    let f = \u0026mut f;\n    replace_ast(ast, \u0026mut |ast| {\n        use regex_syntax::ast::*;\n        if let Ast::Group(g) = \u0026ast {\n            if let GroupKind::CaptureName(name) = \u0026g.kind {\n                if let Some(ast_new) = f(\u0026name.name) {\n                    *ast = ast_new;\n                    return false;\n                }\n            }\n        }\n        true\n    })\n}\npub fn try_replace_all\u003cR: AsRef\u003cstr\u003e, E\u003e(\n    regex: \u0026Regex,\n    text: \u0026str,\n    mut replacer: impl FnMut(\u0026Captures) -\u003e Result\u003cR, E\u003e,\n) -\u003e Result\u003cString, E\u003e {\n    let mut s = String::new();\n    let mut last_end = 0;\n    for c in regex.captures_iter(text) {\n        let m = c.get(0).unwrap();\n        s.push_str(\u0026text[last_end..m.start()]);\n        s.push_str(replacer(\u0026c)?.as_ref());\n        last_end = m.end();\n    }\n    s.push_str(\u0026text[last_end..]);\n    Ok(s)\n}\n\nmacro_rules! lazy_regex {\n    ($re:expr) =\u003e {\n        once_cell::sync::Lazy::new(|| regex::Regex::new($re).unwrap())\n    };\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-derive","src","syn_utils.rs"],"content":"use proc_macro2::TokenStream;\nuse quote::{quote, quote_spanned, ToTokens};\nuse std::collections::HashSet;\nuse syn::{\n    ext::IdentExt,\n    parse::discouraged::Speculative,\n    parse::Parse,\n    parse::ParseStream,\n    parse2, parse_str,\n    punctuated::Punctuated,\n    visit::{visit_path, visit_type, Visit},\n    DeriveInput, GenericParam, Generics, Ident, LitStr, Path, Result, Token, Type, WherePredicate,\n};\n\nmacro_rules! bail {\n    ($span:expr, $message:literal $(,)?) =\u003e {\n        return std::result::Result::Err(syn::Error::new($span, $message))\n    };\n    ($span:expr, $err:expr $(,)?) =\u003e {\n        return std::result::Result::Err(syn::Error::new($span, $err))\n    };\n    ($span:expr, $fmt:expr, $($arg:tt)*) =\u003e {\n        return std::result::Result::Err(syn::Error::new($span, std::format!($fmt, $($arg)*)))\n    };\n}\n\npub fn into_macro_output(input: Result\u003cTokenStream\u003e) -\u003e proc_macro::TokenStream {\n    match input {\n        Ok(s) =\u003e s,\n        Err(e) =\u003e e.to_compile_error(),\n    }\n    .into()\n}\n\npub struct GenericParamSet {\n    idents: HashSet\u003cIdent\u003e,\n}\n\nimpl GenericParamSet {\n    pub fn new(generics: \u0026Generics) -\u003e Self {\n        let mut idents = HashSet::new();\n        for p in \u0026generics.params {\n            match p {\n                GenericParam::Type(t) =\u003e {\n                    idents.insert(t.ident.unraw());\n                }\n                GenericParam::Const(t) =\u003e {\n                    idents.insert(t.ident.unraw());\n                }\n                _ =\u003e {}\n            }\n        }\n        Self { idents }\n    }\n    fn contains(\u0026self, ident: \u0026Ident) -\u003e bool {\n        self.idents.contains(\u0026ident.unraw())\n    }\n\n    pub fn contains_in_type(\u0026self, ty: \u0026Type) -\u003e bool {\n        struct Visitor\u003c'a\u003e {\n            generics: \u0026'a GenericParamSet,\n            result: bool,\n        }\n        impl\u003c'a, 'ast\u003e Visit\u003c'ast\u003e for Visitor\u003c'a\u003e {\n            fn visit_path(\u0026mut self, i: \u0026'ast syn::Path) {\n                if i.leading_colon.is_none() {\n                    if let Some(s) = i.segments.iter().next() {\n                        if self.generics.contains(\u0026s.ident) {\n                            self.result = true;\n                        }\n                    }\n                }\n                visit_path(self, i);\n            }\n        }\n        let mut visitor = Visitor {\n            generics: self,\n            result: false,\n        };\n        visit_type(\u0026mut visitor, ty);\n        visitor.result\n    }\n}\n\npub enum Quotable\u003cT\u003e {\n    Direct(T),\n    Quoted { s: LitStr, args: ArgsOf\u003cT\u003e },\n}\nimpl\u003cT: Parse\u003e Parse for Quotable\u003cT\u003e {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        let fork = input.fork();\n        if let Ok(s) = fork.parse::\u003cLitStr\u003e() {\n            input.advance_to(\u0026fork);\n            let token: TokenStream = parse_str(\u0026s.value())?;\n            let tokens = quote_spanned!(s.span()=\u003e #token);\n            let args = parse2(tokens)?;\n            Ok(Quotable::Quoted { s, args })\n        } else {\n            Ok(Quotable::Direct(input.parse()?))\n        }\n    }\n}\nimpl\u003cT: ToTokens\u003e ToTokens for Quotable\u003cT\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        match self {\n            Self::Direct(value) =\u003e value.to_tokens(tokens),\n            Self::Quoted { s, .. } =\u003e s.to_tokens(tokens),\n        }\n    }\n}\n\nimpl\u003cT\u003e Quotable\u003cT\u003e {\n    pub fn into_iter(self) -\u003e impl IntoIterator\u003cItem = T\u003e {\n        match self {\n            Self::Direct(item) =\u003e vec![item],\n            Self::Quoted { args, .. } =\u003e args.into_iter().collect(),\n        }\n        .into_iter()\n    }\n}\n\npub struct ArgsOf\u003cT\u003e(Punctuated\u003cT, Token![,]\u003e);\n\nimpl\u003cT: Parse\u003e Parse for ArgsOf\u003cT\u003e {\n    fn parse(input: ParseStream) -\u003e Result\u003cSelf\u003e {\n        Ok(Self(Punctuated::parse_terminated(input)?))\n    }\n}\nimpl\u003cT: ToTokens\u003e ToTokens for ArgsOf\u003cT\u003e {\n    fn to_tokens(\u0026self, tokens: \u0026mut TokenStream) {\n        self.0.to_tokens(tokens)\n    }\n}\n\nimpl\u003cT\u003e ArgsOf\u003cT\u003e {\n    pub fn into_iter(self) -\u003e impl Iterator\u003cItem = T\u003e {\n        self.0.into_iter()\n    }\n}\n\npub fn impl_trait(\n    input: \u0026DeriveInput,\n    trait_path: \u0026Path,\n    wheres: \u0026[WherePredicate],\n    contents: TokenStream,\n) -\u003e TokenStream {\n    let ty = \u0026input.ident;\n    let (impl_g, ty_g, where_clause) = input.generics.split_for_impl();\n    let mut wheres = wheres.to_vec();\n    if let Some(where_clause) = where_clause {\n        wheres.extend(where_clause.predicates.iter().cloned());\n    }\n    let where_clause = if wheres.is_empty() {\n        quote! {}\n    } else {\n        quote! { where #(#wheres,)*}\n    };\n    quote! {\n        #[automatically_derived]\n        impl #impl_g #trait_path for #ty #ty_g #where_clause {\n            #contents\n        }\n    }\n}\npub fn impl_trait_result(\n    input: \u0026DeriveInput,\n    trait_path: \u0026Path,\n    wheres: \u0026[WherePredicate],\n    contents: TokenStream,\n    dump: bool,\n) -\u003e Result\u003cTokenStream\u003e {\n    let ts = impl_trait(input, trait_path, wheres, contents);\n    if dump {\n        panic!(\"macro output:\\n{}\", ts);\n    }\n    Ok(ts)\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","src","lib.rs"],"content":"#[test]\r\nfn test() {\r\n    use parse_display::FromStr;\r\n    #[derive(FromStr, Debug, PartialEq)]\r\n    #[from_str(new = Self::new(value))]\r\n    struct MyNonZeroUSize {\r\n        value: usize,\r\n    }\r\n\r\n    impl MyNonZeroUSize {\r\n        fn new(value: usize) -\u003e Option\u003cSelf\u003e {\r\n            if value == 0 {\r\n                None\r\n            } else {\r\n                Some(Self { value })\r\n            }\r\n        }\r\n    }\r\n\r\n    assert_eq!(\"1\".parse(), Ok(MyNonZeroUSize { value: 1 }));\r\n    assert!(\"0\".parse::\u003cMyNonZeroUSize\u003e().is_err());\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","both.rs"],"content":"use parse_display::*;\nuse std::fmt::Debug;\nuse std::fmt::Display;\nuse std::str::FromStr;\n\n#[test]\nfn both_newtype() {\n    #[derive(Display, FromStr, Debug, PartialEq)]\n    struct TestStruct(u32);\n\n    assert_both(\"12\", TestStruct(12));\n}\n\n#[test]\nfn both_struct_format() {\n    #[derive(Display, FromStr, Debug, PartialEq)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n    assert_both(\"12,50\", TestStruct { a: 12, b: 50 });\n}\n\nfn assert_both\u003cT: Display + FromStr + PartialEq + Debug\u003e(s: \u0026str, value: T)\nwhere\n    \u003cT as FromStr\u003e::Err: Display,\n{\n    let value_display = format!(\"{}\", value);\n    assert_eq!(value_display, s);\n\n    match s.parse::\u003cT\u003e() {\n        Ok(a) =\u003e assert_eq!(a, value, \"input = \\\"{}\\\"\", s),\n        Err(e) =\u003e panic!(\"\\\"{}\\\" parse failed. ({})\", s, e),\n    }\n}\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","clippy_self.rs"],"content":"#![deny(clippy::use_self)]\n\nuse parse_display::*;\n\n#[test]\nfn clippy_use_self() {\n    #[derive(FromStr)]\n    enum Foo {\n        Bar,\n        Baz,\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","display","invalid_format.rs"],"content":"use parse_display::Display;\n#[derive(Display)]\n#[display(\"{x\")]\nstruct TestStruct;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","display","invalid_format_spec.rs"],"content":"use parse_display::Display;\n#[derive(Display)]\n#[display(\"{0:y}\")]\nstruct TestStruct(u32);\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","display","struct_empty_field_ident.rs"],"content":"use parse_display::Display;\n\n#[derive(Display)]\n#[display(\"{}\")]\nstruct TestStruct;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","display","struct_no_display_field.rs"],"content":"use parse_display::Display;\n\n#[derive(Display)]\nstruct TestStruct {\n    x: NoDisplay,\n}\nstruct NoDisplay;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","from_str","enum_default.rs"],"content":"use parse_display::FromStr;\n\n#[derive(FromStr)]\n#[from_str(default)]\nenum TestEnum {}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","from_str","no_field_in_format.rs"],"content":"use parse_display::FromStr;\n\n#[derive(FromStr)]\n#[display(\"abc\")]\nstruct TestStruct {\n    x: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","from_str","no_field_in_regex.rs"],"content":"use parse_display::FromStr;\n\n#[derive(FromStr)]\n#[from_str(regex = \"abc\")]\nstruct TestStruct {\n    x: u8,\n}\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail","from_str","struct_empty_capture_name.rs"],"content":"use parse_display::FromStr;\n\n#[derive(FromStr)]\n#[from_str(regex = \"(?P\u003c\u003e)\")]\nstruct TestStruct;\n\nfn main() {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","compile_fail.rs"],"content":"#[test]\n#[ignore]\nfn compile_fail() {\n    trybuild::TestCases::new().compile_fail(\"tests/compile_fail/*/*.rs\")\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","display.rs"],"content":"#![deny(clippy::pattern_type_mismatch)]\n#![no_std]\nextern crate alloc;\nuse parse_display::*;\n\n#[test]\nfn display_newtype() {\n    #[derive(Display)]\n    struct TestStruct(u8);\n\n    assert_display(TestStruct(10), \"10\");\n}\n\n#[test]\nfn display_str() {\n    #[derive(Display)]\n    #[display(\"abcde\")]\n    struct TestStruct;\n\n    assert_display(TestStruct, \"abcde\");\n}\n\n#[test]\nfn display_struct_field() {\n    #[derive(Display)]\n    #[display(\"{a} --- {b}\")]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n\n    assert_display(TestStruct { a: 1, b: 2 }, \"1 --- 2\");\n}\n\n#[test]\nfn display_struct_field_raw() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        r#a: u32,\n        b: u32,\n    }\n\n    assert_display(TestStruct { a: 1, b: 2 }, \"1,2\");\n}\n\n#[test]\nfn display_struct_field_raw_keyword() {\n    #[derive(Display)]\n    #[display(\"{fn},{b}\")]\n    struct TestStruct {\n        r#fn: u32,\n        b: u32,\n    }\n\n    assert_display(TestStruct { r#fn: 1, b: 2 }, \"1,2\");\n}\n\n#[test]\nfn display_struct_field_with_parameter() {\n    #[derive(Display)]\n    #[display(\"{a:\u003c4},{b}\")]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n\n    assert_display(TestStruct { a: 1, b: 2 }, \"1   ,2\");\n}\n\n#[test]\nfn display_struct_nested_field() {\n    #[derive(Display)]\n    #[display(\"{a.y},{b.x}\")]\n    struct TestStruct {\n        a: TestStruct2,\n        b: TestStruct2,\n    }\n\n    struct TestStruct2 {\n        x: u32,\n        y: u32,\n    }\n\n    let value = TestStruct {\n        a: TestStruct2 { x: 1, y: 2 },\n        b: TestStruct2 { x: 3, y: 4 },\n    };\n\n    assert_display(value, \"2,3\");\n}\n\n#[test]\nfn display_struct_nested_field_raw_keyword() {\n    #[derive(Display)]\n    #[display(\"{fn.fn},{b.y}\")]\n    struct TestStruct {\n        r#fn: TestStruct2,\n        b: TestStruct2,\n    }\n\n    struct TestStruct2 {\n        r#fn: u32,\n        y: u32,\n    }\n\n    let value = TestStruct {\n        r#fn: TestStruct2 { r#fn: 1, y: 2 },\n        b: TestStruct2 { r#fn: 3, y: 4 },\n    };\n\n    assert_display(value, \"1,4\");\n}\n\n#[test]\nfn display_tuple_struct_field() {\n    #[derive(Display)]\n    #[display(\"{1},{0}\")]\n    struct TestStruct(u32, u32);\n\n    assert_display(TestStruct(10, 20), \"20,10\");\n}\n\n#[test]\n#[allow(dead_code)]\nfn display_struct_field_attribute() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[display(\"AAAA\")]\n        a: u32,\n        b: u32,\n    }\n    assert_display(TestStruct { a: 1, b: 2 }, \"AAAA,2\");\n}\n\n#[test]\nfn display_struct_field_attribute_var() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[display(\"{x}+{y}\")]\n        a: TestStruct2,\n        #[display(\"{x}-{y}\")]\n        b: TestStruct2,\n    }\n\n    struct TestStruct2 {\n        x: u32,\n        y: u32,\n    }\n\n    let value = TestStruct {\n        a: TestStruct2 { x: 1, y: 2 },\n        b: TestStruct2 { x: 3, y: 4 },\n    };\n\n    assert_display(value, \"1+2,3-4\");\n}\n\n#[test]\nfn display_struct_field_attribute_var_nested() {\n    #[derive(Display)]\n    #[display(\"__{a}\")]\n    struct TestStruct {\n        #[display(\"{x.l}+{x.m}\")]\n        a: TestStruct2,\n    }\n\n    struct TestStruct2 {\n        x: TestStruct3,\n    }\n    struct TestStruct3 {\n        l: u32,\n        m: u32,\n    }\n\n    let value = TestStruct {\n        a: TestStruct2 {\n            x: TestStruct3 { l: 10, m: 20 },\n        },\n    };\n\n    assert_display(value, \"__10+20\");\n}\n\n#[test]\n#[allow(dead_code)]\nfn display_struct_field_attribute_self() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[display(\"_{}_\")]\n        a: u32,\n        b: u32,\n    }\n    assert_display(TestStruct { a: 1, b: 2 }, \"_1_,2\");\n}\n\n#[test]\nfn display_struct_field_another_attribute() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[allow(dead_code)]\n        a: u32,\n        b: u32,\n    }\n    assert_display(TestStruct { a: 1, b: 2 }, \"1,2\");\n}\n\n#[test]\nfn display_tuple_struct_nested_field() {\n    #[derive(Display)]\n    #[display(\"{1.1},{1.0},{0}\")]\n    struct TestStruct(u32, (u32, u32));\n\n    assert_display(TestStruct(10, (20, 30)), \"30,20,10\");\n}\n\n#[test]\nfn display_tuple_struct_attribute() {\n    #[derive(Display)]\n    #[display(\"{0},{1}\")]\n    struct TestStruct(#[display(\"AAA-{}\")] u32, u32);\n\n    assert_display(TestStruct(10, 20), \"AAA-10,20\");\n}\n\n#[test]\nfn display_enum() {\n    #[derive(Display)]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n    }\n    assert_display(TestEnum::AbcDef, \"AbcDef\");\n    assert_display(TestEnum::XyzXyz, \"XyzXyz\");\n}\n\n#[test]\nfn display_enum_lower_snake_case() {\n    #[derive(Display)]\n    #[display(style = \"snake_case\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"abc_def\");\n    assert_display(TestEnum::XyzXyz, \"xyz_xyz\");\n    assert_display(TestEnum::Abc1, \"abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"abc1_abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"xxx\");\n}\n\n#[test]\nfn display_enum_upper_snake_case() {\n    #[derive(Display)]\n    #[display(style = \"SNAKE_CASE\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"ABC_DEF\");\n    assert_display(TestEnum::XyzXyz, \"XYZ_XYZ\");\n    assert_display(TestEnum::Abc1, \"ABC1\");\n    assert_display(TestEnum::Abc1Abc2, \"ABC1_ABC2\");\n    assert_display(TestEnum::Xxx1xxx, \"XXX1XXX\");\n    assert_display(TestEnum::_Xxx, \"XXX\");\n}\n\n#[test]\nfn display_enum_lower_camel_case() {\n    #[derive(Display)]\n    #[display(style = \"camelCase\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"abcDef\");\n    assert_display(TestEnum::XyzXyz, \"xyzXyz\");\n    assert_display(TestEnum::Abc1, \"abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"abc1Abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"xxx\");\n}\n\n#[test]\nfn display_enum_upper_camel_case() {\n    #[derive(Display)]\n    #[display(style = \"CamelCase\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"AbcDef\");\n    assert_display(TestEnum::XyzXyz, \"XyzXyz\");\n    assert_display(TestEnum::Abc1, \"Abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"Abc1Abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"Xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"Xxx\");\n}\n\n#[test]\nfn display_enum_lower_kebab_case() {\n    #[derive(Display)]\n    #[display(style = \"kebab-case\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"abc-def\");\n    assert_display(TestEnum::XyzXyz, \"xyz-xyz\");\n    assert_display(TestEnum::Abc1, \"abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"abc1-abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"xxx\");\n}\n\n#[test]\nfn display_enum_upper_kebab_case() {\n    #[derive(Display)]\n    #[display(style = \"KEBAB-CASE\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"ABC-DEF\");\n    assert_display(TestEnum::XyzXyz, \"XYZ-XYZ\");\n    assert_display(TestEnum::Abc1, \"ABC1\");\n    assert_display(TestEnum::Abc1Abc2, \"ABC1-ABC2\");\n    assert_display(TestEnum::Xxx1xxx, \"XXX1XXX\");\n    assert_display(TestEnum::_Xxx, \"XXX\");\n}\n\n#[test]\nfn display_enum_upper_title_case() {\n    #[derive(Display)]\n    #[display(style = \"Title Case\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"Abc Def\");\n    assert_display(TestEnum::XyzXyz, \"Xyz Xyz\");\n    assert_display(TestEnum::Abc1, \"Abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"Abc1 Abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"Xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"Xxx\");\n}\n\n#[test]\nfn display_enum_upper_title_case_upper() {\n    #[derive(Display)]\n    #[display(style = \"TITLE CASE\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"ABC DEF\");\n    assert_display(TestEnum::XyzXyz, \"XYZ XYZ\");\n    assert_display(TestEnum::Abc1, \"ABC1\");\n    assert_display(TestEnum::Abc1Abc2, \"ABC1 ABC2\");\n    assert_display(TestEnum::Xxx1xxx, \"XXX1XXX\");\n    assert_display(TestEnum::_Xxx, \"XXX\");\n}\n\n#[test]\nfn display_enum_upper_title_case_lower() {\n    #[derive(Display)]\n    #[display(style = \"title case\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"abc def\");\n    assert_display(TestEnum::XyzXyz, \"xyz xyz\");\n    assert_display(TestEnum::Abc1, \"abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"abc1 abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"xxx\");\n}\n\n#[test]\nfn display_enum_upper_title_case_head() {\n    #[derive(Display)]\n    #[display(style = \"Title case\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"Abc def\");\n    assert_display(TestEnum::XyzXyz, \"Xyz xyz\");\n    assert_display(TestEnum::Abc1, \"Abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"Abc1 abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"Xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"Xxx\");\n}\n\n#[test]\nfn display_enum_lower_case() {\n    #[derive(Display)]\n    #[display(style = \"lowercase\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"abcdef\");\n    assert_display(TestEnum::XyzXyz, \"xyzxyz\");\n    assert_display(TestEnum::Abc1, \"abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"abc1abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"xxx\");\n}\n\n#[test]\nfn display_enum_upper_case() {\n    #[derive(Display)]\n    #[display(style = \"UPPERCASE\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"ABCDEF\");\n    assert_display(TestEnum::XyzXyz, \"XYZXYZ\");\n    assert_display(TestEnum::Abc1, \"ABC1\");\n    assert_display(TestEnum::Abc1Abc2, \"ABC1ABC2\");\n    assert_display(TestEnum::Xxx1xxx, \"XXX1XXX\");\n    assert_display(TestEnum::_Xxx, \"XXX\");\n}\n\n#[test]\nfn display_enum_none() {\n    #[derive(Display)]\n    #[display(style = \"none\")]\n    enum TestEnum {\n        AbcDef,\n        XyzXyz,\n        Abc1,\n        Abc1Abc2,\n        Xxx1xxx,\n        _Xxx,\n    }\n    assert_display(TestEnum::AbcDef, \"AbcDef\");\n    assert_display(TestEnum::XyzXyz, \"XyzXyz\");\n    assert_display(TestEnum::Abc1, \"Abc1\");\n    assert_display(TestEnum::Abc1Abc2, \"Abc1Abc2\");\n    assert_display(TestEnum::Xxx1xxx, \"Xxx1xxx\");\n    assert_display(TestEnum::_Xxx, \"_Xxx\");\n}\n\n#[test]\nfn display_enum_common_format() {\n    #[derive(Display)]\n    #[display(\"{0}\")]\n    enum TestEnum {\n        A(u32),\n        B(bool),\n    }\n\n    assert_display(TestEnum::A(10), \"10\");\n    assert_display(TestEnum::B(true), \"true\");\n}\n\n#[test]\nfn display_enum_common_format_variant_name() {\n    #[derive(Display)]\n    #[display(\"{}-{0}\")]\n    enum TestEnum {\n        A(u32),\n        B(bool),\n    }\n\n    assert_display(TestEnum::A(10), \"A-10\");\n    assert_display(TestEnum::B(false), \"B-false\");\n}\n\n#[test]\nfn display_enum_variant_format() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"AAA\")]\n        A(u32),\n\n        #[display(\"BBB\")]\n        B(bool),\n    }\n\n    assert_display(TestEnum::A(10), \"AAA\");\n    assert_display(TestEnum::B(false), \"BBB\");\n}\n\n#[test]\nfn display_enum_variant_format_typle_var() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"AAA-{0}\")]\n        A(u32),\n\n        #[display(\"BBB+{0}\")]\n        B(bool),\n    }\n\n    assert_display(TestEnum::A(10), \"AAA-10\");\n    assert_display(TestEnum::B(true), \"BBB+true\");\n}\n\n#[test]\nfn display_enum_variant_format_record_var() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"x={x},y={y}\")]\n        A { x: u32, y: u32 },\n    }\n    assert_display(TestEnum::A { x: 10, y: 20 }, \"x=10,y=20\");\n}\n\n#[test]\nfn display_enum_variant_format_record_var_f() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"f={f}\")]\n        A { f: u32 },\n    }\n    assert_display(TestEnum::A { f: 10 }, \"f=10\");\n}\n\n#[test]\nfn display_enum_variant_format_record_var_keyword() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"fn={fn}\")]\n        A { r#fn: u32 },\n    }\n    assert_display(TestEnum::A { r#fn: 10 }, \"fn=10\");\n}\n\n#[test]\nfn display_enum_field_format() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"{} = {x}\")]\n        A {\n            #[display(\"---{}\")]\n            x: u32,\n        },\n    }\n    assert_display(TestEnum::A { x: 10 }, \"A = ---10\");\n}\n\n#[test]\nfn display_enum_field_format_deep() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"{} = {x}\")]\n        A {\n            #[display(\"---{l}\")]\n            x: TestStruct,\n        },\n    }\n\n    struct TestStruct {\n        l: u32,\n    }\n\n    assert_display(\n        TestEnum::A {\n            x: TestStruct { l: 20 },\n        },\n        \"A = ---20\",\n    );\n}\n\n#[test]\nfn display_enum_field_format_deep_noncopy() {\n    #[derive(Display)]\n    enum TestEnum {\n        #[display(\"{} = {x}\")]\n        A {\n            #[display(\"---{l}\")]\n            x: TestStruct,\n        },\n    }\n\n    struct TestStruct {\n        l: bool,\n    }\n    assert_display(\n        TestEnum::A {\n            x: TestStruct { l: true },\n        },\n        \"A = ---true\",\n    );\n}\n\n#[test]\nfn auto_bound_newtype() {\n    #[derive(Display)]\n    struct TestNewType\u003cT\u003e(T);\n    assert_display(TestNewType(10), \"10\");\n}\n\n#[test]\nfn auto_bound_newtype_debug() {\n    #[derive(Display)]\n    #[display(\"{0:?}\")]\n    struct TestNewType\u003cT\u003e(T);\n    assert_display(TestNewType(10), \"10\");\n}\n\n#[test]\nfn auto_bound_newtype_lower_hex() {\n    #[derive(Display)]\n    #[display(\"{0:#x}\")]\n    struct TestNewType\u003cT\u003e(T);\n    assert_display(TestNewType(10), \"0xa\");\n}\n\n#[test]\nfn auto_bound_newtype_upper_hex() {\n    #[derive(Display)]\n    #[display(\"{0:#X}\")]\n    struct TestNewType\u003cT\u003e(T);\n    assert_display(TestNewType(10), \"0xA\");\n}\n\n#[test]\nfn auto_bound_newtype_binary() {\n    #[derive(Display)]\n    #[display(\"{0:#b}\")]\n    struct TestNewType\u003cT\u003e(T);\n    assert_display(TestNewType(10), \"0b1010\");\n}\n\n#[test]\nfn auto_bound_field() {\n    #[derive(Display)]\n    #[display(\"{a}\")]\n    struct TestStruct\u003cT\u003e {\n        #[display(\"___{}___\")]\n        a: T,\n    }\n    assert_display(TestStruct { a: 10 }, \"___10___\");\n}\n\n#[test]\nfn auto_bound_enum() {\n    #[derive(Display)]\n    #[display(\"{0}\")]\n    enum TestEnum\u003cT\u003e {\n        VarA(T),\n    }\n    assert_display(TestEnum::VarA(10), \"10\");\n}\n\n#[test]\nfn private_in_public_non_generic() {\n    assert_display(TestStructPrivateInPublic(TestStructPrivate(5)), \"5\");\n}\n\n#[derive(Display)]\npub struct TestStructPrivateInPublic(TestStructPrivate);\n\n#[derive(Display)]\nstruct TestStructPrivate(u8);\n\n#[test]\nfn private_in_public_generic() {\n    assert_display(\n        TestStructPrivateInPublicGeneric(TestStructPrivateGeneric(5)),\n        \"5\",\n    );\n}\n\n#[derive(Display)]\n#[display(bound(T))]\npub struct TestStructPrivateInPublicGeneric\u003cT\u003e(TestStructPrivateGeneric\u003cT\u003e);\n\n#[derive(Display)]\nstruct TestStructPrivateGeneric\u003cT\u003e(T);\n\n#[test]\nfn bound_predicate_struct() {\n    #[derive(Display)]\n    #[display(bound(T : Copy))]\n    pub struct TestStructBoundPredicate\u003cT\u003e(DisplayIfCopy\u003cT\u003e);\n\n    struct DisplayIfCopy\u003cT\u003e(T);\n\n    impl\u003cT: Copy\u003e core::fmt::Display for DisplayIfCopy\u003cT\u003e {\n        fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n            write!(f, \"this is display\")\n        }\n    }\n    assert_display(\n        TestStructBoundPredicate(DisplayIfCopy(10)),\n        \"this is display\",\n    );\n}\n\n#[test]\nfn bound_predicate_struct_x2() {\n    #[derive(Display)]\n    #[display(\"{a},{b}\", bound(T1 : Copy, T2 : Copy))]\n    pub struct TestStructBoundPredicate\u003cT1, T2\u003e {\n        a: DisplayIfCopy\u003cT1\u003e,\n        b: DisplayIfCopy\u003cT2\u003e,\n    }\n\n    struct DisplayIfCopy\u003cT\u003e(T);\n\n    impl\u003cT: Copy\u003e core::fmt::Display for DisplayIfCopy\u003cT\u003e {\n        fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n            write!(f, \"this is display\")\n        }\n    }\n    assert_display(\n        TestStructBoundPredicate {\n            a: DisplayIfCopy(10),\n            b: DisplayIfCopy(20),\n        },\n        \"this is display,this is display\",\n    );\n}\n\n#[test]\nfn bound_predicate_struct_str() {\n    #[derive(Display)]\n    #[display(bound(\"T : Copy\"))]\n    pub struct TestStructBoundPredicate\u003cT\u003e(DisplayIfCopy\u003cT\u003e);\n\n    struct DisplayIfCopy\u003cT\u003e(T);\n\n    impl\u003cT: Copy\u003e core::fmt::Display for DisplayIfCopy\u003cT\u003e {\n        fn fmt(\u0026self, f: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\n            write!(f, \"this is display\")\n        }\n    }\n    assert_display(\n        TestStructBoundPredicate(DisplayIfCopy(10)),\n        \"this is display\",\n    );\n}\n\n#[test]\nfn bound_type_enum() {\n    assert_display(Outer::A(Inner(10)), \"10\");\n    #[derive(Display)]\n    #[display(\"{0.0}\", bound(T))]\n    enum Outer\u003cT\u003e {\n        A(Inner\u003cT\u003e),\n    }\n    struct Inner\u003cT\u003e(T);\n}\n\n#[test]\nfn bound_type_generic() {\n    assert_display(Outer(Inner(5)), \"5\");\n\n    #[derive(Display)]\n    #[display(bound(Inner\u003cT\u003e))]\n    struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n\n    #[derive(Display)]\n    struct Inner\u003cT\u003e(T);\n}\n\n#[test]\nfn bound_type_generic_x2() {\n    assert_display(Outer(Inner(5), Inner(10)), \"5,10\");\n\n    #[derive(Display)]\n    #[display(\"{0},{1}\",bound(Inner\u003cT1\u003e, Inner\u003cT2\u003e))]\n    struct Outer\u003cT1, T2\u003e(Inner\u003cT1\u003e, Inner\u003cT2\u003e);\n\n    #[derive(Display)]\n    struct Inner\u003cT\u003e(T);\n}\n\n#[test]\nfn bound_type_array() {\n    #[derive(Display)]\n    #[display(bound([T; 1]))]\n    struct TestStruct\u003cT\u003e {\n        x: [T; 1],\n    }\n}\n\n#[test]\nfn auto_bound_unused_field() {\n    #[derive(Display)]\n    #[display(\"{val_u8}\")]\n    #[allow(dead_code)]\n    struct TestStruct\u003cT: Eq\u003e {\n        val_eq: T,\n        val_u8: u8,\n    }\n    assert_display(\n        TestStruct {\n            val_eq: 0,\n            val_u8: 1,\n        },\n        \"1\",\n    )\n}\n\n#[test]\nfn bound_by_hand_with_auto() {\n    pub struct Inner\u003cT\u003e(T);\n\n    #[derive(Display)]\n    #[display(\"{0.0},{1}\", bound(T1, ..))]\n    pub struct Outer\u003cT1, T2\u003e(Inner\u003cT1\u003e, T2);\n\n    assert_display(Outer(Inner(10), 20), \"10,20\");\n}\n\n#[deny(private_in_public)]\n#[test]\nfn bound_struct_field() {\n    #[derive(Display)]\n    struct Inner\u003cT\u003e(T);\n    #[derive(Display)]\n    pub struct Outer\u003cT\u003e(#[display(bound(T))] Inner\u003cT\u003e);\n}\n#[allow(dead_code)]\n#[test]\nfn bound_enum_variant() {\n    #[derive(Display)]\n    #[display(bound(T : core::fmt::Display + Copy ))]\n    pub struct Inner\u003cT\u003e(T);\n    #[derive(Display)]\n    pub enum Outer\u003cT\u003e {\n        #[display(\"{0}\", bound(T : core::fmt::Display + Copy))]\n        A(Inner\u003cT\u003e),\n    }\n}\n\n#[allow(dead_code)]\n#[test]\nfn bound_enum_field() {\n    #[derive(Display)]\n    #[display(bound(T : core::fmt::Display + Copy ))]\n    pub struct Inner\u003cT\u003e(T);\n    #[derive(Display)]\n    pub enum Outer\u003cT\u003e {\n        #[display(\"{0}\")]\n        A(#[display(bound(T : core::fmt::Display + Copy))] Inner\u003cT\u003e),\n    }\n}\n\n#[test]\nfn doc_comment_struct() {\n    /// doc\n    #[derive(Display)]\n    struct TestStruct {\n        a: u8,\n    }\n    assert_display(TestStruct { a: 10 }, \"10\");\n}\n\n#[test]\nfn doc_comment_struct_field() {\n    #[derive(Display)]\n    pub struct TestStruct {\n        /// doc\n        a: u8,\n    }\n    assert_display(TestStruct { a: 10 }, \"10\");\n}\n\n#[test]\nfn doc_comment_enum() {\n    /// doc\n    #[derive(Display)]\n    enum TestEnum {\n        A,\n    }\n    assert_display(TestEnum::A, \"A\");\n}\n\n#[test]\nfn doc_comment_variant() {\n    #[derive(Display)]\n    enum TestEnum {\n        /// doc\n        A,\n    }\n    assert_display(TestEnum::A, \"A\");\n}\n\n#[test]\nfn attr_enum() {\n    #[derive(Display)]\n    #[non_exhaustive]\n    enum TestEnum {\n        A,\n    }\n    assert_display(TestEnum::A, \"A\");\n}\n\nmacro_rules! macro_rule_hygiene_test {\n    () =\u003e {\n        #[derive(Display)]\n        struct HygieneTestType {\n            x: $crate::U8Alias,\n        }\n    };\n}\n\ntype U8Alias = u8;\n#[test]\nfn macro_rule_hygiene() {\n    macro_rule_hygiene_test!();\n    assert_display(HygieneTestType { x: 5 }, \"5\");\n}\n\n#[test]\nfn format_spec_is_empty() {\n    #[derive(Display)]\n    #[display(\"{0}\u003e\")]\n    struct TestStruct(u32);\n}\n\nfn assert_display\u003cT: core::fmt::Display\u003e(value: T, display: \u0026str) {\n    let value_display = alloc::format!(\"{}\", value);\n    assert_eq!(value_display, display);\n}\n","traces":[{"line":740,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","from_str.rs"],"content":"#![deny(clippy::pattern_type_mismatch)]\n\nuse parse_display::*;\nuse std::fmt::Debug;\nuse std::fmt::Display;\nuse std::str::FromStr;\n\n#[test]\nfn from_str_newtype() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    struct TestStruct(u32);\n\n    assert_from_str(\"12\", TestStruct(12));\n    assert_from_str_err::\u003cTestStruct\u003e(\"abc\");\n}\n\n#[test]\nfn from_str_struct_keyword_field() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{fn}\")]\n    struct TestStruct {\n        r#fn: u32,\n    }\n    assert_from_str(\"12\", TestStruct { r#fn: 12 });\n    assert_from_str_err::\u003cTestStruct\u003e(\"aa\");\n}\n\n#[test]\nfn from_str_struct_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"12,50\", TestStruct { a: 12, b: 50 });\n    assert_from_str_err::\u003cTestStruct\u003e(\"aa,50\");\n}\n\n#[test]\nfn from_str_struct_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003ca\u003e.*),(?P\u003cbc\u003e.*)\")]\n    struct TestStruct {\n        a: u32,\n        bc: u32,\n    }\n    assert_from_str(\"12,50\", TestStruct { a: 12, bc: 50 });\n    assert_from_str_err::\u003cTestStruct\u003e(\"aa,50\");\n}\n\n#[test]\nfn from_str_tuple_struct_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003c0\u003e.*),(?P\u003c1\u003e.*)\")]\n    struct TestStruct(u32, u32);\n    assert_from_str(\"12,50\", TestStruct(12, 50));\n    assert_from_str_err::\u003cTestStruct\u003e(\"aa,50\");\n}\n\n#[test]\nfn from_str_struct_regex_keyword() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003cfn\u003e.*)\")]\n    struct TestStruct {\n        r#fn: u32,\n    }\n    assert_from_str(\"12\", TestStruct { r#fn: 12 });\n}\n\n#[test]\nfn from_str_struct_field_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[display(\"--{}--\")]\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"--12--,50\", TestStruct { a: 12, b: 50 });\n}\n\n#[test]\nfn from_str_struct_field_regex_all() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a}{b}\")]\n    struct TestStruct {\n        #[from_str(regex = \"[0-9]+\")]\n        a: u32,\n        b: String,\n    }\n    assert_from_str(\n        \"12abc\",\n        TestStruct {\n            a: 12,\n            b: \"abc\".into(),\n        },\n    );\n}\n\n#[test]\nfn from_str_struct_field_regex_self() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a},{b}\")]\n    struct TestStruct {\n        #[from_str(regex = \"---(?P\u003c\u003e[0-9]+)---\")]\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"---12---,50\", TestStruct { a: 12, b: 50 });\n}\n\n#[test]\nfn from_str_struct_format_chain() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a.x},{a.y}\")]\n    #[from_str(default)]\n    struct TestStruct {\n        a: TestStruct2,\n        b: TestStruct2,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct2 {\n        x: u32,\n        y: u32,\n    }\n    assert_from_str(\n        \"10,50\",\n        TestStruct {\n            a: TestStruct2 { x: 10, y: 50 },\n            b: TestStruct2 { x: 0, y: 0 },\n        },\n    );\n}\n\n#[test]\nfn from_str_struct_format_chain_default_field() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a.x},{a.y}\")]\n    struct TestStruct {\n        #[from_str(default)]\n        a: TestStruct2,\n\n        #[from_str(default)]\n        b: TestStruct2,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct2 {\n        x: u32,\n        y: u32,\n    }\n    assert_from_str(\n        \"10,50\",\n        TestStruct {\n            a: TestStruct2 { x: 10, y: 50 },\n            b: TestStruct2 { x: 0, y: 0 },\n        },\n    );\n}\n\n#[test]\nfn from_str_struct_field_format_chain() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default)]\n    struct TestStruct {\n        #[display(\"{b.x}\")]\n        a: TestStruct2,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct2 {\n        b: TestStruct3,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct3 {\n        x: u32,\n        y: u32,\n    }\n\n    assert_from_str(\n        \"10\",\n        TestStruct {\n            a: TestStruct2 {\n                b: TestStruct3 { x: 10, y: 0 },\n            },\n        },\n    );\n}\n#[test]\nfn from_str_enum_named_field_chain() {\n    #[derive(FromStr, Eq, PartialEq, Debug)]\n    enum TestEnum {\n        #[display(\"{x.0}-{x.1}\")]\n        A {\n            #[from_str(default)]\n            x: (u8, u8),\n        },\n    }\n    assert_from_str(\"5-6\", TestEnum::A { x: (5, 6) });\n}\n\n#[test]\nfn from_str_enum_unnamed_field_chain() {\n    #[derive(FromStr, Eq, PartialEq, Debug)]\n    enum TestEnum {\n        #[display(\"{0.0}-{0.1}\")]\n        A(#[from_str(default)] (u8, u8)),\n    }\n    assert_from_str(\"5-6\", TestEnum::A((5, 6)));\n}\n\n#[test]\nfn from_str_struct_deep_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[from_str(regex = \"(?P\u003ca.x\u003e.*),(?P\u003ca.y\u003e.*)\", default)]\n    struct TestStruct {\n        a: TestStruct2,\n        b: TestStruct2,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct2 {\n        x: u32,\n        y: u32,\n    }\n    assert_from_str(\n        \"10,50\",\n        TestStruct {\n            a: TestStruct2 { x: 10, y: 50 },\n            b: TestStruct2 { x: 0, y: 0 },\n        },\n    );\n}\n\n#[test]\nfn from_str_struct_field_deep_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default)]\n    struct TestStruct {\n        #[from_str(regex = \"(?P\u003cb.x\u003e.*)\")]\n        a: TestStruct2,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct2 {\n        b: TestStruct3,\n    }\n\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct TestStruct3 {\n        x: u32,\n        y: u32,\n    }\n\n    assert_from_str(\n        \"10\",\n        TestStruct {\n            a: TestStruct2 {\n                b: TestStruct3 { x: 10, y: 0 },\n            },\n        },\n    );\n}\n\n#[test]\nfn from_str_struct_default() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default)]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0 });\n}\n\n#[test]\nfn from_str_struct_default_both() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{a}\")]\n    #[from_str(default)]\n    struct TestStruct {\n        a: u32,\n\n        #[from_str(default)]\n        b: u32,\n    }\n    impl Default for TestStruct {\n        fn default() -\u003e Self {\n            Self { a: 100, b: 200 }\n        }\n    }\n\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0 });\n}\n\n#[test]\nfn from_str_struct_field_default() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    struct TestStruct {\n        a: u32,\n\n        #[from_str(default)]\n        b: u32,\n    }\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0 });\n}\n\n#[test]\nfn from_str_tuple_field_default() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{0}\")]\n    struct TestStruct(u32, #[from_str(default)] u32);\n    assert_from_str(\"12\", TestStruct(12, 0));\n}\n\n#[test]\nfn from_str_struct_default_fields_str() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default_fields(\"b\"))]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0 });\n}\n\n#[test]\nfn from_str_struct_default_fields_many() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default_fields(b, \"c\"))]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n        c: u32,\n    }\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0, c: 0 });\n}\n\n#[test]\nfn from_str_struct_default_fields_ident() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{a}\")]\n    #[from_str(default_fields(b))]\n    struct TestStruct {\n        a: u32,\n        b: u32,\n    }\n    assert_from_str(\"12\", TestStruct { a: 12, b: 0 });\n}\n\n#[test]\nfn from_str_struct_default_fields_ident_keyword() {\n    #[derive(FromStr, Debug, Eq, PartialEq, Default)]\n    #[display(\"{fn}\")]\n    #[from_str(default_fields(fn))]\n    struct TestStruct {\n        r#fn: u32,\n    }\n    assert_from_str(\"12\", TestStruct { r#fn: 12 });\n}\n#[test]\nfn from_str_enum_field_default() {\n    #[derive(FromStr, PartialEq, Debug)]\n    #[display(\"{a}\")]\n    enum TestEnum {\n        VerA {\n            a: u8,\n            #[from_str(default)]\n            b: u8,\n        },\n    }\n    assert_from_str(\"10\", TestEnum::VerA { a: 10, b: 0 });\n}\n\n#[test]\nfn from_str_enum_tuple_field_default() {\n    #[derive(FromStr, PartialEq, Debug)]\n    #[display(\"{0}\")]\n    enum TestEnum {\n        VerA(u8, #[from_str(default)] u8),\n    }\n    assert_from_str(\"10\", TestEnum::VerA(10, 0));\n}\n\n#[test]\nfn from_str_enum_default_fields() {\n    #[derive(FromStr, PartialEq, Debug)]\n    #[display(\"{a}\")]\n    #[from_str(default_fields(b))]\n    enum TestEnum {\n        VerA { a: u8, b: u8 },\n    }\n    assert_from_str(\"10\", TestEnum::VerA { a: 10, b: 0 });\n}\n\n#[test]\nfn from_str_tuple() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{0},{1}\")]\n    struct TestStruct(u32, u32);\n    assert_from_str(\"12,50\", TestStruct(12, 50));\n}\n\n#[test]\nfn from_str_unit() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"abc\")]\n    struct TestStruct;\n    assert_from_str(\"abc\", TestStruct);\n}\n\n#[test]\nfn from_str_enum_unit() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        A,\n        Bc,\n    }\n    assert_from_str(\"A\", TestEnum::A);\n    assert_from_str(\"Bc\", TestEnum::Bc);\n}\n\n#[test]\nfn from_str_enum_style() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(style = \"snake_case\")]\n    enum TestEnum {\n        AaaBbb,\n        XyzXyz,\n        #[display(style = \"Title Case\")]\n        TitleAbc,\n    }\n    assert_from_str(\"aaa_bbb\", TestEnum::AaaBbb);\n    assert_from_str(\"xyz_xyz\", TestEnum::XyzXyz);\n    assert_from_str(\"Title Abc\", TestEnum::TitleAbc);\n}\n\n#[test]\nfn from_str_enum_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{}--\")]\n    enum TestEnum {\n        A,\n        Bc,\n    }\n    assert_from_str(\"A--\", TestEnum::A);\n    assert_from_str(\"Bc--\", TestEnum::Bc);\n}\n\n#[test]\nfn from_str_enum_format_struct_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{}--{x}\")]\n    enum TestEnum {\n        A { x: u32 },\n        Bc { x: u32 },\n    }\n    assert_from_str(\"A--10\", TestEnum::A { x: 10 });\n    assert_from_str(\"Bc--20\", TestEnum::Bc { x: 20 });\n}\n\n#[test]\nfn from_str_enum_format_tuple_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{}--{0}\")]\n    enum TestEnum {\n        A(u32),\n        Bc(u32),\n    }\n    assert_from_str(\"A--10\", TestEnum::A(10));\n    assert_from_str(\"Bc--20\", TestEnum::Bc(20));\n}\n\n#[test]\nfn from_str_enum_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003c\u003e)--\")]\n    enum TestEnum {\n        A,\n        Bc,\n    }\n    assert_from_str(\"A--\", TestEnum::A);\n    assert_from_str(\"Bc--\", TestEnum::Bc);\n}\n\n#[test]\nfn from_str_enum_regex_tuple_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003c\u003e)--(?P\u003c0\u003e.*)\")]\n    enum TestEnum {\n        A(u32),\n        Bc(u32),\n    }\n    assert_from_str(\"A--10\", TestEnum::A(10));\n    assert_from_str(\"Bc--20\", TestEnum::Bc(20));\n}\n\n#[test]\nfn from_str_enum_regex_struct_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003c\u003e)--(?P\u003cx\u003e.*)\")]\n    enum TestEnum {\n        A { x: u32 },\n        Bc { x: u32 },\n    }\n    assert_from_str(\"A--10\", TestEnum::A { x: 10 });\n    assert_from_str(\"Bc--20\", TestEnum::Bc { x: 20 });\n}\n\n#[test]\nfn from_str_enum_var_field() {\n    #[derive(FromStr, Debug, PartialEq)]\n    #[display(\"{0}\")]\n    enum TestEnum {\n        A(u32),\n        B(f64),\n    }\n    assert_from_str(\"1.5\", TestEnum::B(1.5));\n}\n\n#[test]\nfn from_str_enum_variant_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        #[display(\"xxx\")]\n        A,\n\n        #[display(\"yyy\")]\n        Bc,\n    }\n    assert_from_str(\"xxx\", TestEnum::A);\n    assert_from_str(\"yyy\", TestEnum::Bc);\n}\n\n#[test]\nfn from_str_enum_variant_format_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        #[display(\"{} - {0}\")]\n        A(u32),\n\n        #[display(\"yyy + {x}\")]\n        Bc { x: u32 },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn from_str_enum_variant_regex_var() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        #[from_str(regex = \"(?P\u003c\u003e) - (?P\u003c0\u003e.*)\")]\n        A(u32),\n\n        #[from_str(regex = r\"yyy \\+ (?P\u003cx\u003e.*)\")]\n        Bc { x: u32 },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n\n    assert_from_str_err::\u003cTestEnum\u003e(\"A - xx\");\n    assert_from_str_err::\u003cTestEnum\u003e(\"yyy - xx\");\n}\n\n#[test]\nfn from_str_enum_format_variant_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"yyy + {x}\")]\n    enum TestEnum {\n        #[display(\"{} - {0}\")]\n        A(u32),\n        Bc {\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn from_str_enum_format_variant_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"yyy + {x}\")]\n    enum TestEnum {\n        #[from_str(regex = \"(?P\u003c\u003e) - (?P\u003c0\u003e.*)\")]\n        A(u32),\n\n        Bc {\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn from_str_enum_regex_variant_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = r\"yyy \\+ (?P\u003cx\u003e.*)\")]\n    enum TestEnum {\n        #[display(\"{} - {0}\")]\n        A(u32),\n\n        Bc {\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn from_str_enum_regex_variant_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[from_str(regex = \"(?P\u003c\u003e) - (?P\u003c0\u003e.*)\")]\n    enum TestEnum {\n        A(u32),\n\n        #[from_str(regex = r\"yyy \\+ (?P\u003cx\u003e.*)\")]\n        Bc {\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - 10\", TestEnum::A(10));\n    assert_from_str(\"yyy + 50\", TestEnum::Bc { x: 50 });\n\n    assert_from_str_err::\u003cTestEnum\u003e(\"A - xx\");\n    assert_from_str_err::\u003cTestEnum\u003e(\"yyy - xx\");\n}\n\n#[test]\nfn from_str_enum_field_format() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        #[display(\"{} - {0}\")]\n        A(#[display(\"nnn{}\")] u32),\n\n        #[display(\"yyy + {x}\")]\n        Bc {\n            #[display(\"mmm{}\")]\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - nnn10\", TestEnum::A(10));\n    assert_from_str(\"yyy + mmm50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn from_str_enum_field_regex() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        #[display(\"{} - {0}\")]\n        A(#[from_str(regex = \"nnn(?P\u003c\u003e.*)\")] u32),\n\n        #[display(\"yyy + {x}\")]\n        Bc {\n            #[from_str(regex = \"mmm(?P\u003c\u003e.*)\")]\n            x: u32,\n        },\n    }\n    assert_from_str(\"A - nnn10\", TestEnum::A(10));\n    assert_from_str(\"yyy + mmm50\", TestEnum::Bc { x: 50 });\n}\n\n#[test]\nfn auto_bound_newtype() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    struct TestNewType\u003cT\u003e(T);\n\n    assert_from_str(\"10\", TestNewType(10));\n}\n\n#[test]\nfn auto_bound_enum() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{0}\")]\n    enum TestEnum\u003cT\u003e {\n        VarA(T),\n    }\n\n    assert_from_str(\"10\", TestEnum::VarA(10));\n}\n\n#[test]\nfn private_in_public_non_generic() {\n    assert_from_str(\"5\", TestStructPrivateInPublic(TestStructPrivate(5)));\n}\n\n#[derive(FromStr, Debug, Eq, PartialEq)]\npub struct TestStructPrivateInPublic(TestStructPrivate);\n\n#[derive(FromStr, Debug, Eq, PartialEq)]\nstruct TestStructPrivate(u8);\n\n#[test]\nfn private_in_public_generic() {\n    assert_from_str(\n        \"5\",\n        TestStructPrivateInPublicGeneric(TestStructPrivateGeneric(5)),\n    );\n}\n\n#[derive(FromStr, Debug, Eq, PartialEq)]\n#[display(bound(T))]\npub struct TestStructPrivateInPublicGeneric\u003cT\u003e(TestStructPrivateGeneric\u003cT\u003e);\n\n#[derive(FromStr, Debug, Eq, PartialEq)]\nstruct TestStructPrivateGeneric\u003cT\u003e(T);\n\n#[test]\nfn bound_predicate_struct() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(bound(\"T : Default\"))]\n    pub struct TestStructBoundPredicate\u003cT\u003e(FromStrIfDefault\u003cT\u003e);\n\n    #[derive(Debug, Eq, PartialEq)]\n    struct FromStrIfDefault\u003cT\u003e(T);\n    impl\u003cT: Default\u003e FromStr for FromStrIfDefault\u003cT\u003e {\n        type Err = ParseError;\n\n        fn from_str(_: \u0026str) -\u003e Result\u003cSelf, Self::Err\u003e {\n            Ok(Self(Default::default()))\n        }\n    }\n}\n\n#[test]\nfn different_bound() {\n    #![deny(private_in_public)]\n\n    #[derive(Display, FromStr, PartialEq, Debug)]\n    #[display(bound(\"T : Display\"))]\n    #[from_str(bound(\"T : FromStr\"))]\n    pub struct Outer\u003cT\u003e(Inner\u003cT\u003e);\n\n    #[derive(Display, FromStr, PartialEq, Debug)]\n    struct Inner\u003cT\u003e(T);\n\n    assert_from_str(\"5\", Outer(Inner(5)));\n}\n\n#[test]\nfn bound_type_enum() {\n    assert_from_str(\"10\", Outer::A(Inner(10)));\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{0.0}\", bound(T))]\n    #[from_str(default_fields(\"0\"))]\n    enum Outer\u003cT: Default\u003e {\n        A(Inner\u003cT\u003e),\n    }\n    #[derive(Debug, Eq, PartialEq, Default)]\n    struct Inner\u003cT: Default\u003e(T);\n}\n\n#[deny(private_in_public)]\n#[test]\nfn bound_struct_field() {\n    #[derive(FromStr)]\n    struct Inner\u003cT\u003e(T);\n    #[derive(FromStr)]\n    pub struct Outer\u003cT\u003e(#[from_str(bound(T))] Inner\u003cT\u003e);\n}\n\n#[allow(dead_code)]\n#[test]\nfn bound_enum_variant() {\n    #[derive(FromStr)]\n    #[from_str(bound(T : core::str::FromStr + Copy ))]\n    pub struct Inner\u003cT\u003e(T);\n    #[derive(FromStr)]\n    pub enum Outer\u003cT\u003e {\n        #[display(\"{0}\")]\n        #[from_str(bound(T : core::str::FromStr + Copy))]\n        A(Inner\u003cT\u003e),\n    }\n}\n\n#[allow(dead_code)]\n#[test]\nfn bound_enum_field() {\n    #[derive(FromStr)]\n    #[from_str(bound(T : core::str::FromStr + Copy ))]\n    pub struct Inner\u003cT\u003e(T);\n    #[derive(FromStr)]\n    pub enum Outer\u003cT\u003e {\n        #[display(\"{0}\")]\n        A(#[from_str(bound(T : core::str::FromStr + Copy))] Inner\u003cT\u003e),\n    }\n}\n\n#[test]\nfn doc_comment_struct() {\n    /// doc\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    struct TestStruct {\n        a: u8,\n    }\n    assert_from_str(\"10\", TestStruct { a: 10 });\n}\n\n#[test]\nfn doc_comment_struct_field() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    pub struct TestStruct {\n        /// doc\n        a: u8,\n    }\n    assert_from_str(\"10\", TestStruct { a: 10 });\n}\n\n#[test]\nfn doc_comment_enum() {\n    /// doc\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        A,\n    }\n    assert_from_str(\"A\", TestEnum::A);\n}\n\n#[test]\nfn doc_comment_variant() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    enum TestEnum {\n        /// doc\n        A,\n    }\n    assert_from_str(\"A\", TestEnum::A);\n}\n\n#[test]\nfn attr_enum() {\n    #[derive(FromStr, Debug, Eq, PartialEq)]\n    #[non_exhaustive]\n    enum TestEnum {\n        A,\n    }\n    assert_from_str(\"A\", TestEnum::A);\n}\n\nmacro_rules! macro_rule_hygiene_test {\n    () =\u003e {\n        #[derive(FromStr, Debug, Eq, PartialEq)]\n        struct HygieneTestType {\n            x: $crate::U8Alias,\n        }\n    };\n}\n\ntype U8Alias = u8;\n#[test]\nfn macro_rule_hygiene() {\n    macro_rule_hygiene_test!();\n    assert_from_str(\"5\", HygieneTestType { x: 5 });\n}\n\n#[test]\nfn new_return_option() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[from_str(new = Self::new(_0))]\n    struct Non1USize(usize);\n\n    impl Non1USize {\n        fn new(value: usize) -\u003e Option\u003cSelf\u003e {\n            if value == 1 {\n                None\n            } else {\n                Some(Self(value))\n            }\n        }\n    }\n\n    assert_from_str(\"0\", Non1USize(0));\n    assert_from_str_err::\u003cNon1USize\u003e(\"1\");\n}\n\n#[test]\nfn new_return_result() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[from_str(new = Self::new(_0))]\n    struct Non1USize(usize);\n    struct ParseNon1UsizeError;\n\n    impl Non1USize {\n        fn new(value: usize) -\u003e core::result::Result\u003cSelf, ParseNon1UsizeError\u003e {\n            if value == 1 {\n                Err(ParseNon1UsizeError)\n            } else {\n                Ok(Self(value))\n            }\n        }\n    }\n\n    assert_from_str(\"0\", Non1USize(0));\n    assert_from_str_err::\u003cNon1USize\u003e(\"1\");\n}\n\n#[test]\nfn new_return_value() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[from_str(new = Self::new(_0))]\n    struct NewTypeUSize(usize);\n    impl NewTypeUSize {\n        fn new(value: usize) -\u003e Self {\n            Self(value)\n        }\n    }\n\n    assert_from_str(\"0\", NewTypeUSize(0));\n}\n\n#[test]\nfn new_tuple() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[from_str(new = Self::new(_0))]\n    struct MyNonZeroUSize(usize);\n\n    impl MyNonZeroUSize {\n        fn new(value: usize) -\u003e Option\u003cSelf\u003e {\n            if value == 0 {\n                None\n            } else {\n                Some(Self(value))\n            }\n        }\n    }\n\n    assert_from_str(\"1\", MyNonZeroUSize(1));\n    assert_from_str_err::\u003cMyNonZeroUSize\u003e(\"0\");\n}\n#[test]\nfn new_tuple_field_x2() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{0}-{1}\")]\n    #[from_str(new = Self::new(_0, _1))]\n    struct TestRange(usize, usize);\n    impl TestRange {\n        fn new(start: usize, end: usize) -\u003e Option\u003cSelf\u003e {\n            if start \u003c= end {\n                Some(TestRange(start, end))\n            } else {\n                None\n            }\n        }\n    }\n\n    assert_from_str(\"1-2\", TestRange(1, 2));\n    assert_from_str_err::\u003cTestRange\u003e(\"2-1\");\n}\n\n#[test]\nfn new_struct() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[from_str(new = Self::new(value))]\n    struct Non1USize {\n        value: usize,\n    }\n\n    impl Non1USize {\n        fn new(value: usize) -\u003e Option\u003cSelf\u003e {\n            if value == 1 {\n                None\n            } else {\n                Some(Self { value })\n            }\n        }\n    }\n\n    assert_from_str(\"0\", Non1USize { value: 0 });\n    assert_from_str_err::\u003cNon1USize\u003e(\"1\");\n}\n\n#[test]\nfn new_struct_field_x2() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{start}-{end}\")]\n    #[from_str(new = Self::new(start, end))]\n    struct TestRange {\n        start: usize,\n        end: usize,\n    }\n    impl TestRange {\n        fn new(start: usize, end: usize) -\u003e Option\u003cSelf\u003e {\n            if start \u003c= end {\n                Some(TestRange { start, end })\n            } else {\n                None\n            }\n        }\n    }\n\n    assert_from_str(\"1-2\", TestRange { start: 1, end: 2 });\n    assert_from_str_err::\u003cTestRange\u003e(\"2-1\");\n}\n\n#[test]\nfn new_enum() {\n    #[derive(Display, FromStr, Debug, Eq, PartialEq)]\n    #[display(\"{} {0}\")]\n    enum NonZeroEnum {\n        #[from_str(new = Self::new_x(_0))]\n        X(usize),\n        #[from_str(new = Self::new_y(_0))]\n        Y(usize),\n    }\n\n    impl NonZeroEnum {\n        fn new_x(value: usize) -\u003e Option\u003cSelf\u003e {\n            if value == 0 {\n                None\n            } else {\n                Some(Self::X(value))\n            }\n        }\n        fn new_y(value: usize) -\u003e Option\u003cSelf\u003e {\n            if value == 0 {\n                None\n            } else {\n                Some(Self::Y(value))\n            }\n        }\n    }\n\n    assert_from_str(\"X 1\", NonZeroEnum::X(1));\n    assert_from_str(\"Y 1\", NonZeroEnum::Y(1));\n    assert_from_str_err::\u003cNonZeroEnum\u003e(\"X 0\");\n    assert_from_str_err::\u003cNonZeroEnum\u003e(\"Y 0\");\n}\n\nfn assert_from_str\u003cT: FromStr + Debug + PartialEq\u003e(s: \u0026str, value: T)\nwhere\n    \u003cT as FromStr\u003e::Err: Display,\n{\n    match s.parse::\u003cT\u003e() {\n        Ok(a) =\u003e assert_eq!(a, value, \"input = \\\"{}\\\"\", s),\n        Err(e) =\u003e panic!(\"\\\"{}\\\" parse failed. ({})\", s, e),\n    }\n}\nfn assert_from_str_err\u003cT: FromStr + Debug\u003e(s: \u0026str) {\n    if let Ok(a) = s.parse::\u003cT\u003e() {\n        panic!(\n            \"from_str(\\\"{}\\\") should return Err. but return `{:?}`.\",\n            s, a\n        );\n    }\n}\n","traces":[{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1044,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1045,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1046,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1049,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1050,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1051,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1053,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","parse-display","parse-display-tests","tests","lib.rs"],"content":"\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day1","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day1_part1;\npub use part2::aoc2018_day1_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day1","part1.rs"],"content":"use std::error::Error;\n\npub fn aoc2018_day1_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet mut total: i64 = 0;\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet delta: i64 = line.parse () ?;\n\t\ttotal += delta;\n\t}\n\tOk (format! (\"{}\", total))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day1","part2.rs"],"content":"use std::collections::HashSet;\nuse std::error::Error;\nuse std::iter;\n\npub fn aoc2018_day1_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet deltas: Result \u003cVec \u003ci64\u003e, Box \u003cdyn Error\u003e\u003e = input.trim ().split (\"\\n\").map (\n\t\t|line| Ok (line.parse () ?),\n\t).collect ();\n\tlet deltas = deltas ?;\n\tlet mut total: i64 = 0;\n\tlet mut seen: HashSet \u003ci64\u003e = HashSet::new ();\n\tfor delta in iter::repeat (deltas).flatten () {\n\t\ttotal += delta;\n\t\tif seen.contains (\u0026 total) { break }\n\t\tseen.insert (total);\n\t}\n\tOk (format! (\"{}\", total))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day2","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day2_part1;\npub use part2::aoc2018_day2_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day2","part1.rs"],"content":"use std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::error::Error;\n\npub fn aoc2018_day2_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet mut num_twos: u64 = 0;\n\tlet mut num_threes: u64 = 0;\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet mut letters: HashMap \u003cchar, u64\u003e = HashMap::new ();\n\t\tfor ch in line.chars () {\n\t\t\t(* letters.entry (ch).or_insert (0)) += 1;\n\t\t}\n\t\tlet nums: HashSet \u003cu64\u003e = letters.into_values ().collect ();\n\t\tif nums.contains (\u0026 2) { num_twos += 1 }\n\t\tif nums.contains (\u0026 3) { num_threes += 1 }\n\t}\n\tprintln! (\"Number of twos: {}\", num_twos);\n\tprintln! (\"Number of threes: {}\", num_threes);\n\tOk (format! (\"{}\", num_twos * num_threes))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day2","part2.rs"],"content":"use std::error::Error;\n\npub fn aoc2018_day2_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet lines: Vec \u003c\u0026 str\u003e = input.trim ().split (\"\\n\").collect ();\n\tfor index_0 in 0 .. lines.len () - 2 {\n\t\tlet line_0 = lines [index_0];\n\t\tfor index_1 in index_0 + 1 .. lines.len () - 1 {\n\t\t\tlet line_1 = lines [index_1];\n\t\t\tlet num_different: u64 = Iterator::zip (line_0.chars (), line_1.chars ()).filter (\n\t\t\t\t|(ch_0, ch_1)| ch_0 != ch_1\n\t\t\t).count () as u64;\n\t\t\tif num_different != 1 { continue }\n\t\t\tlet common_chars: String = Iterator::zip (line_0.chars (), line_1.chars ()).filter (\n\t\t\t\t|(ch_0, ch_1)| ch_0 == ch_1\n\t\t\t).map (\n\t\t\t\t|(ch, _)| ch\n\t\t\t).collect ();\n\t\t\tprintln! (\"First box ID: {}\", line_0);\n\t\t\tprintln! (\"Second box ID: {}\", line_1);\n\t\t\treturn Ok (common_chars);\n\t\t}\n\t}\n\tpanic! ();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day3","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day3_part1;\npub use part2::aoc2018_day3_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day3","part1.rs"],"content":"use std::collections::HashMap;\nuse std::error::Error;\nuse text_io::try_scan;\n\npub fn aoc2018_day3_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet mut usage: HashMap \u003c(u64, u64), u64\u003e = HashMap::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet id: u64;\n\t\tlet (left, top, width, height): (u64, u64, u64, u64);\n\t\ttry_scan! (line.bytes () =\u003e \"#{} @ {},{}: {}x{}\", id, left, top, width, height);\n\t\tfor x in left .. left + width {\n\t\t\tfor y in top .. top + height {\n\t\t\t\t(* usage.entry ((x, y)).or_insert (0)) += 1;\n\t\t\t}\n\t\t}\n\t}\n\tlet num_common = usage.into_values ().filter (|num| * num \u003e 1).count ();\n\tOk (format! (\"{}\", num_common))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day3","part2.rs"],"content":"use std::collections::HashMap;\nuse std::error::Error;\nuse text_io::try_scan;\n\npub fn aoc2018_day3_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet mut usage: HashMap \u003c(u64, u64), u64\u003e = HashMap::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet id: u64;\n\t\tlet (left, top, width, height): (u64, u64, u64, u64);\n\t\ttry_scan! (line.bytes () =\u003e \"#{} @ {},{}: {}x{}\", id, left, top, width, height);\n\t\tfor x in left .. left + width {\n\t\t\tfor y in top .. top + height {\n\t\t\t\t(* usage.entry ((x, y)).or_insert (0)) += 1;\n\t\t\t}\n\t\t}\n\t}\n\t'LINES: for line in input.trim ().split (\"\\n\") {\n\t\tlet id: u64;\n\t\tlet (left, top, width, height): (u64, u64, u64, u64);\n\t\ttry_scan! (line.bytes () =\u003e \"#{} @ {},{}: {}x{}\", id, left, top, width, height);\n\t\tfor x in left .. left + width {\n\t\t\tfor y in top .. top + height {\n\t\t\t\tif usage [\u0026 (x, y)] \u003e 1 { continue 'LINES }\n\t\t\t}\n\t\t}\n\t\tprintln! (\"Non overlapping ID: {}\", id);\n\t\treturn Ok (format! (\"{}\", id));\n\t}\n\tpanic! ();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day4","mod.rs"],"content":"mod part1;\nmod part2;\nmod shared;\n\npub use part1::aoc2018_day4_part1;\npub use part2::aoc2018_day4_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day4","part1.rs"],"content":"use chrono::Duration;\nuse chrono::Timelike as _;\nuse std::collections::HashMap;\nuse std::error::Error;\n\nuse crate::day4::shared;\nuse crate::day4::shared::LineIter;\n\npub fn aoc2018_day4_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet lines = shared::parse_lines (input) ?;\n\n\tlet mut guard_total_mins: HashMap \u003cu32, i32\u003e = HashMap::new ();\n\tlet mut guard_sleep_mins: HashMap \u003cu32, HashMap \u003cu32, u32\u003e\u003e = HashMap::new ();\n\tfor (guard_id, sleep_time, wake_time) in LineIter::new (\u0026 lines) {\n\t\tlet diff_mins = (wake_time - sleep_time).num_minutes () as i32;\n\t\t(* guard_total_mins.entry (guard_id).or_insert (0)) += diff_mins;\n\t\tlet sleep_mins = guard_sleep_mins.entry (guard_id).or_insert (HashMap::new ());\n\t\tfor time in itertools::iterate (sleep_time, |time| * time + Duration::minutes (1))\n\t\t\t\t.take_while (|time| * time \u003c wake_time) {\n\t\t\t(* sleep_mins.entry (time.time ().minute ()).or_insert (0)) += 1;\n\t\t}\n\t}\n\n\tlet (sleepiest_id, _) = guard_total_mins.iter ().max_by_key (|(_, mins)| * mins).unwrap ();\n\tlet (sleepiest_min, _) = guard_sleep_mins [\u0026 sleepiest_id].iter ().max_by_key (\n\t\t|(_, num)| * num,\n\t).unwrap ();\n\n\tprintln! (\"Guard id: {}\", sleepiest_id);\n\tprintln! (\"Time: 00:{:02}\", sleepiest_min);\n\n\tOk (format! (\"{}\", sleepiest_id * sleepiest_min))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day4","part2.rs"],"content":"use chrono::Duration;\nuse chrono::Timelike as _;\nuse std::collections::HashMap;\nuse std::error::Error;\n\nuse crate::day4::shared;\nuse crate::day4::shared::LineIter;\n\npub fn aoc2018_day4_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet lines = shared::parse_lines (input) ?;\n\n\tlet mut sleep_mins: HashMap \u003c(u32, u32), u32\u003e = HashMap::new ();\n\tfor (guard_id, sleep_time, wake_time) in LineIter::new (\u0026 lines) {\n\t\tfor time in itertools::iterate (sleep_time, |time| * time + Duration::minutes (1))\n\t\t\t\t.take_while (|time| * time \u003c wake_time) {\n\t\t\t(* sleep_mins.entry ((guard_id, time.time ().minute ())).or_insert (0)) += 1;\n\t\t}\n\t}\n\n\tlet ((guard_id, minute), _) = sleep_mins.iter ().max_by_key (|(_, num)| * num).unwrap ();\n\n\tprintln! (\"Guard id: {}\", guard_id);\n\tprintln! (\"Time: 00:{:02}\", minute);\n\n\tOk (format! (\"{}\", guard_id * minute))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day4","shared.rs"],"content":"use chrono::NaiveDateTime;\nuse itertools::Itertools as _;\nuse parse_display_derive::FromStr;\nuse std::error::Error;\nuse std::slice::Iter;\n\n#[ derive (Clone, Copy, FromStr) ]\n#[ display (\"[{time}] {event}\") ]\n#[ from_str (new = Ok::\u003c_, Box \u003cdyn Error\u003e\u003e (()).and_then (|_| Ok (Line {\n\ttime: NaiveDateTime::parse_from_str (String::as_str (\u0026 time), \"%Y-%m-%d %H:%M\") ?,\n\tevent,\n}))) ]\npub struct Line {\n\tpub time: NaiveDateTime,\n\tpub event: Event,\n}\n\n#[ derive (Clone, Copy, FromStr) ]\npub enum Event {\n\t#[display (\"Guard #{0} begins shift\")] BeginsShift (u32),\n\t#[display (\"falls asleep\")] FallsAsleep,\n\t#[display (\"wakes up\")] WakesUp,\n}\n\npub struct LineIter \u003c'a\u003e {\n\titer: Iter \u003c'a, Line\u003e,\n\tstate: LineIterState,\n}\n\nimpl \u003c'a\u003e LineIter \u003c'a\u003e {\n\tpub fn new (lines: \u0026 'a [Line]) -\u003e LineIter \u003c'a\u003e {\n\t\tLineIter {\n\t\t\titer: lines.iter (),\n\t\t\tstate: LineIterState::None,\n\t\t}\n\t}\n}\n\nimpl \u003c'a\u003e Iterator for LineIter \u003c'a\u003e {\n\ttype Item = (u32, NaiveDateTime, NaiveDateTime);\n\tfn next (\u0026 mut self) -\u003e Option \u003cSelf::Item\u003e {\n\t\tloop {\n\t\t\tlet line = match self.iter.next () {\n\t\t\t\tSome (line) =\u003e line,\n\t\t\t\tNone =\u003e return None,\n\t\t\t};\n\t\t\tmatch (self.state, line.event) {\n\t\t\t\t(_, Event::BeginsShift (guard_id)) =\u003e {\n\t\t\t\t\tself.state = LineIterState::Awake (guard_id);\n\t\t\t\t},\n\t\t\t\t(LineIterState::Awake (guard_id), Event::FallsAsleep) =\u003e {\n\t\t\t\t\tself.state = LineIterState::Asleep (guard_id, line.time);\n\t\t\t\t},\n\t\t\t\t(LineIterState::Asleep (guard_id, sleep_time), Event::WakesUp) =\u003e {\n\t\t\t\t\tself.state = LineIterState::Awake (guard_id);\n\t\t\t\t\treturn Some ((guard_id, sleep_time, line.time));\n\t\t\t\t},\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t};\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy) ]\nenum LineIterState {\n\tNone,\n\tAwake (u32),\n\tAsleep (u32, NaiveDateTime)\n}\n\npub fn parse_lines (input: \u0026 str) -\u003e Result \u003cVec \u003cLine\u003e, Box \u003cdyn Error\u003e\u003e {\n\tOk (\n\t\tinput.trim ().split (\"\\n\")\n\t\t\t.map (|line| Ok::\u003cLine, Box \u003cdyn Error\u003e\u003e (line.parse () ?))\n\t\t\t.collect::\u003cResult \u003cVec \u003c_\u003e, _\u003e\u003e () ?\n\t\t\t.into_iter ().sorted_by_key (|line| line.time).collect ()\n\t)\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":16},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day5","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day5_part1;\npub use part2::aoc2018_day5_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day5","part1.rs"],"content":"use std::error::Error;\n\npub fn aoc2018_day5_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet mut result = String::new ();\n\tfor ch in input.trim ().chars () {\n\t\tif let Some (last_char) = result.chars ().last () {\n\t\t\tif last_char.to_ascii_lowercase () == ch.to_ascii_lowercase ()\n\t\t\t\t\t\u0026\u0026 last_char.is_ascii_lowercase () != ch.is_ascii_lowercase () {\n\t\t\t\tresult.pop ();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tresult.push (ch);\n\t}\n\n\tprintln! (\"Resulting polymer: {}\", result);\n\n\tOk (format! (\"{}\", result.len ()))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day5","part2.rs"],"content":"use std::collections::HashMap;\nuse std::error::Error;\n\npub fn aoc2018_day5_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet mut results: HashMap \u003cchar, String\u003e = HashMap::new ();\n\tfor remove_ch in 'a' ..= 'z' {\n\t\tlet polymer: String = input.trim ().chars ().filter (\n\t\t\t|ch| ch.to_ascii_lowercase () != remove_ch,\n\t\t).collect ();\n\t\tlet mut result = String::new ();\n\t\tfor ch in polymer.chars () {\n\t\t\tif let Some (last_char) = result.chars ().last () {\n\t\t\t\tif last_char.to_ascii_lowercase () == ch.to_ascii_lowercase ()\n\t\t\t\t\t\t\u0026\u0026 last_char.is_ascii_lowercase () != ch.is_ascii_lowercase () {\n\t\t\t\t\tresult.pop ();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push (ch);\n\t\t}\n\t\tresults.insert (remove_ch, result);\n\t}\n\n\tlet (ch, result) = results.iter ().min_by_key (\n\t\t|(_, result)| result.len (),\n\t).unwrap ();\n\n\tprintln! (\"Most problematic unit type: {}\", ch);\n\tprintln! (\"Resulting polymer: {}\", result);\n\n\tOk (format! (\"{}\", result.len ()))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day6","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day6_part1;\npub use part2::aoc2018_day6_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day6","part1.rs"],"content":"use std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::error::Error;\nuse std::iter;\n\nuse crate::shared::Grid;\nuse crate::shared::Pos;\n\npub fn aoc2018_day6_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\t// collect points and work out size\n\tlet mut width: i64 = 0;\n\tlet mut height: i64 = 0;\n\tlet mut posns: Vec \u003cPos\u003e = Vec::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split (\", \").collect ();\n\t\tif line_parts.len () != 2 { panic! () }\n\t\tlet pos = Pos { x: line_parts [0].parse () ?, y: line_parts [1].parse () ? };\n\t\tif pos.x \u003c 0 || pos.y \u003c 0 { panic! () }\n\t\tif pos.x \u003e= width { width = pos.x + 1 }\n\t\tif pos.y \u003e= height { height = pos.y + 1 }\n\t\tposns.push (pos);\n\t}\n\tprintln! (\"Grid size: {} x {}\", width, height);\n\n\t// initialize grid\n\tlet mut grid: Grid \u003cOption \u003cu8\u003e\u003e = Grid::builder ()\n\t\t.width (width)\n\t\t.height (height)\n\t\t.unbounded ()\n\t\t.default (None)\n\t\t.build ();\n\tlet mut id: u8 = 0;\n\tfor pos in posns.iter ().cloned () {\n\t\tif id == u8::MAX { panic! () }\n\t\tgrid.set (pos, Some (id));\n\t\tid += 1;\n\t}\n\n\t// spread out one square at a time\n\tloop {\n\t\tlet mut grid_temp = grid.clone ();\n\t\tlet mut progress = false;\n\t\tfor pos in grid.posns () {\n\t\t\tif grid.get (pos).is_some () { continue }\n\t\t\tlet mut neighbours: HashSet \u003cu8\u003e = HashSet::new ();\n\t\t\tfor neighbour_pos in pos.four_neighbours () {\n\t\t\t\tif let Some (neighbour_val) = grid.get (neighbour_pos) {\n\t\t\t\t\tif neighbour_val == u8::MAX { continue }\n\t\t\t\t\tneighbours.insert (neighbour_val);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif neighbours.len () == 1 {\n\t\t\t\tgrid_temp.set (pos, Some (neighbours.into_iter ().next ().unwrap ()));\n\t\t\t}  else if neighbours.len () \u003e 1 {\n\t\t\t\tgrid_temp.set (pos, Some (u8::MAX));\n\t\t\t}\n\t\t\tprogress = true;\n\t\t}\n\t\tgrid = grid_temp;\n\t\tif ! progress { break }\n\t}\n\n\t// count areas\n\tlet mut areas: Vec \u003cu64\u003e = iter::repeat (0).take (posns.len () + 1).collect ();\n\tfor value in grid.values () {\n\t\tlet value = value.unwrap ();\n\t\tif value == u8::MAX { continue }\n\t\tareas [value as usize] += 1;\n\t}\n\tlet mut areas: HashMap \u003cu8, u64\u003e = areas.into_iter ().enumerate ().map (\n\t\t|(index, value)| (index as u8, value),\n\t).collect ();\n\n\t// remove areas which reach the edge\n\tfor x in 0 .. width {\n\t\tif let Some (value) = grid.get (Pos::new (x, 0)) {\n\t\t\tareas.remove (\u0026 value);\n\t\t}\n\t\tif let Some (value) = grid.get (Pos::new (x, height - 1)) {\n\t\t\tareas.remove (\u0026 value);\n\t\t}\n\t}\n\tfor y in 0 .. width {\n\t\tif let Some (value) = grid.get (Pos::new (0, y)) {\n\t\t\tareas.remove (\u0026 value);\n\t\t}\n\t\tif let Some (value) = grid.get (Pos::new (width - 1, y)) {\n\t\t\tareas.remove (\u0026 value);\n\t\t}\n\t}\n\n\t// find largest remaining area\n\tlet (index, size) = areas.iter ().max_by_key (|(_, size)| * size).unwrap ();\n\tlet index = * index;\n\n\tprintln! (\"Identified largest finite area\");\n\tprintln! (\"Index: {}\", index);\n\tprintln! (\"Position: {}, {}\", posns [index as usize].x, posns [index as usize].y);\n\n\tOk (format! (\"{}\", size))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day6","part2.rs"],"content":"use std::error::Error;\n\nuse crate::shared::GridPosIter;\nuse crate::shared::Pos;\n\npub fn aoc2018_day6_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\t// collect points and work out size\n\tlet mut width: i64 = 0;\n\tlet mut height: i64 = 0;\n\tlet mut posns: Vec \u003cPos\u003e = Vec::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split (\", \").collect ();\n\t\tif line_parts.len () != 2 { panic! () }\n\t\tlet pos = Pos { x: line_parts [0].parse () ?, y: line_parts [1].parse () ? };\n\t\tif pos.x \u003c 0 || pos.y \u003c 0 { panic! () }\n\t\tif pos.x \u003e= width { width = pos.x + 1 }\n\t\tif pos.y \u003e= height { height = pos.y + 1 }\n\t\tposns.push (pos);\n\t}\n\tprintln! (\"Grid size: {}  {} = {}\", width, height, width * height);\n\tlet extend_size = (10_000 + posns.len () as i64 - 1) / posns.len () as i64;\n\tprintln! (\"Extend by 10000  {} = {} in four directions\", posns.len (), extend_size);\n\tlet new_width = width + extend_size * 2;\n\tlet new_height = height + extend_size * 2;\n\tprintln! (\"New grid size: {}  {} = {}\", new_width, new_height, new_width * new_height);\n\n\tlet mut area: u64 = 0;\n\tfor pos_0 in GridPosIter::new (\n\t\tPos::new (-100, -100),\n\t\tPos::new (width, height),\n\t) {\n\t\tlet distance: i64 = posns.iter ().map (\n\t\t\t|pos_1| (pos_0.x - pos_1.x).abs () + (pos_0.y - pos_1.y).abs (),\n\t\t).sum ();\n\t\tif distance \u003c= 10000 {\n\t\t\tarea += 1;\n\t\t}\n\t}\n\tprintln! (\"Number of nearby squares: {}\", area);\n\n\tOk (format! (\"{}\", area))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day7","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day7_part1;\npub use part2::aoc2018_day7_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day7","part1.rs"],"content":"use parse_display_derive::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::error::Error;\n\npub fn aoc2018_day7_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet mut deps: HashMap \u003cchar, HashSet \u003cchar\u003e\u003e = HashMap::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet line: Line = line.parse () ?;\n\t\tdeps.entry (line.dependency).or_insert (HashSet::new ());\n\t\t(* deps.entry (line.target).or_insert (HashSet::new ())).insert (line.dependency);\n\t}\n\n\tlet mut remaining: HashSet \u003cchar\u003e = deps.keys ().cloned ().collect ();\n\tlet mut completed: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut order = String::new ();\n\twhile ! remaining.is_empty () {\n\t\tlet next_step = remaining.iter ().filter (\n\t\t\t|step| deps [step].iter ().all (|dep| completed.contains (dep)),\n\t\t).cloned ().min ().ok_or (\"No next step\") ?;\n\t\tremaining.remove (\u0026 next_step);\n\t\tcompleted.insert (next_step);\n\t\torder.push (next_step);\n\t}\n\n\tOk (order)\n\n}\n\n#[ derive (FromStr) ]\n#[ display (\"Step {dependency} must be finished before step {target} can begin.\") ]\nstruct Line {\n\ttarget: char,\n\tdependency: char,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day7","part2.rs"],"content":"use parse_display_derive::FromStr;\nuse std::collections::HashMap;\nuse std::collections::HashSet;\nuse std::error::Error;\nuse std::iter;\n\npub fn aoc2018_day7_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet mut deps: HashMap \u003cchar, HashSet \u003cchar\u003e\u003e = HashMap::new ();\n\tfor line in input.trim ().split (\"\\n\") {\n\t\tlet line: Line = line.parse () ?;\n\t\tdeps.entry (line.dependency).or_insert (HashSet::new ());\n\t\t(* deps.entry (line.target).or_insert (HashSet::new ())).insert (line.dependency);\n\t}\n\n\tlet mut remaining: HashSet \u003cchar\u003e = deps.keys ().cloned ().collect ();\n\tlet mut completed: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut queue: HashSet \u003cchar\u003e = HashSet::new ();\n\tlet mut workers: Vec \u003cOption \u003c(char, u8)\u003e\u003e = iter::repeat (None).take (5).collect ();\n\tlet mut elapsed: u64 = 0;\n\n\twhile ! remaining.is_empty ()\n\t\t|| ! queue.is_empty ()\n\t\t|| workers.iter ().any (Option::is_some) {\n\n\t\tfor next_step in remaining.iter ().filter (\n\t\t\t|step| deps [step].iter ().all (|dep| completed.contains (dep)),\n\t\t).cloned () {\n\t\t\tqueue.insert (next_step);\n\t\t}\n\n\t\tfor worker in workers.iter_mut ().filter (|worker| worker.is_none ()) {\n\t\t\tif queue.is_empty () { break }\n\t\t\tlet next_step = queue.iter ().min ().cloned ().unwrap ();\n\t\t\tlet step_time = 61 + (next_step as u32 - 'A' as u32) as u8;\n\t\t\t* worker = Some ((next_step, step_time));\n\t\t\tremaining.remove (\u0026 next_step);\n\t\t\tqueue.remove (\u0026 next_step);\n\t\t}\n\n\t\telapsed += 1;\n\t\tfor worker_opt in workers.iter_mut ().filter (|worker| worker.is_some ()) {\n\t\t\tlet worker = worker_opt.as_mut ().unwrap ();\n\t\t\tworker.1 -= 1;\n\t\t\tif worker.1 \u003e 0 { continue }\n\t\t\tcompleted.insert (worker.0);\n\t\t\t* worker_opt = None;\n\t\t}\n\n\t}\n\n\tOk (format! (\"{}\", elapsed))\n\n}\n\n#[ derive (FromStr) ]\n#[ display (\"Step {dependency} must be finished before step {target} can begin.\") ]\nstruct Line {\n\ttarget: char,\n\tdependency: char,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day8","mod.rs"],"content":"mod part1;\nmod part2;\n\npub use part1::aoc2018_day8_part1;\npub use part2::aoc2018_day8_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day8","part1.rs"],"content":"use std::error::Error;\nuse std::iter;\n\npub fn aoc2018_day8_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet data: Vec \u003cu32\u003e = input.trim ().split (\" \").map (\n\t\t|datum| Ok (datum.parse () ?),\n\t).collect::\u003cResult \u003c_, Box \u003cdyn Error\u003e\u003e\u003e () ?;\n\n\tstruct Frame {\n\t\tnum_children: u32,\n\t\tnum_metadata: u32,\n\t}\n\n\tlet mut stack: Vec \u003cFrame\u003e = vec! [\n\t\tFrame {\n\t\t\tnum_children: 1,\n\t\t\tnum_metadata: 0,\n\t\t},\n\t];\n\n\tlet mut data_iter = data.iter ().cloned ();\n\tlet mut metadata_sum: u32 = 0;\n\n\twhile ! stack.is_empty () {\n\t\tlet frame = stack.last_mut ().unwrap ();\n\t\tif frame.num_children \u003e 0 {\n\t\t\tframe.num_children -= 1;\n\t\t\tstack.push (Frame {\n\t\t\t\tnum_children: data_iter.next ().unwrap (),\n\t\t\t\tnum_metadata: data_iter.next ().unwrap (),\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tmetadata_sum += iter::repeat_with (\n\t\t\t|| data_iter.next ().unwrap (),\n\t\t).take (frame.num_metadata as usize).sum::\u003cu32\u003e ();\n\t\tstack.pop ();\n\t}\n\n\tif data_iter.next ().is_some () {\n\t\tpanic! ();\n\t}\n\n\tOk (format! (\"{}\", metadata_sum))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day8","part2.rs"],"content":"use std::error::Error;\nuse std::iter;\n\npub fn aoc2018_day8_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\n\tlet data: Vec \u003cu64\u003e = input.trim ().split (\" \").map (\n\t\t|datum| Ok (datum.parse () ?),\n\t).collect::\u003cResult \u003c_, Box \u003cdyn Error\u003e\u003e\u003e () ?;\n\n\tstruct Frame {\n\t\tnum_children: u64,\n\t\tnum_metadata: u64,\n\t\tchild_values: Vec \u003cu64\u003e,\n\t}\n\n\tlet mut stack: Vec \u003cFrame\u003e = vec! [\n\t\tFrame {\n\t\t\tnum_children: 1,\n\t\t\tnum_metadata: 1,\n\t\t\tchild_values: Vec::new (),\n\t\t},\n\t];\n\tlet data = {\n\t\tlet mut data = data;\n\t\tdata.push (1);\n\t\tdata\n\t};\n\n\tlet mut data_iter = data.iter ().cloned ();\n\n\tlet value = loop {\n\t\tlet frame = stack.last_mut ().unwrap ();\n\t\tif frame.num_children \u003e 0 {\n\t\t\tframe.num_children -= 1;\n\t\t\tstack.push (Frame {\n\t\t\t\tnum_children: data_iter.next ().unwrap (),\n\t\t\t\tnum_metadata: data_iter.next ().unwrap (),\n\t\t\t\tchild_values: Vec::new (),\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tlet value = if frame.child_values.is_empty () {\n\t\t\titer::repeat_with (\n\t\t\t\t|| data_iter.next ().unwrap (),\n\t\t\t).take (frame.num_metadata as usize).sum::\u003cu64\u003e ()\n\t\t} else {\n\t\t\titer::repeat_with (\n\t\t\t\t|| data_iter.next ().unwrap (),\n\t\t\t).take (frame.num_metadata as usize).map (\n\t\t\t\t|idx| frame.child_values.get (idx as usize - 1).unwrap_or (\u0026 0)\n\t\t\t).sum::\u003cu64\u003e ()\n\t\t};\n\t\tstack.pop ();\n\t\tif let Some (frame) = stack.last_mut () {\n\t\t\tframe.child_values.push (value);\n\t\t} else {\n\t\t\tbreak value;\n\t\t}\n\t};\n\n\tif data_iter.next ().is_some () {\n\t\tpanic! ();\n\t}\n\n\tOk (format! (\"{}\", value))\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day9","mod.rs"],"content":"mod part1;\nmod part2;\nmod shared;\n\npub use part1::aoc2018_day9_part1;\npub use part2::aoc2018_day9_part2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day9","part1.rs"],"content":"use std::error::Error;\n\nuse super::shared;\nuse super::shared::GameParams;\n\npub fn aoc2018_day9_part1 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet params: GameParams = input.trim ().parse () ?;\n\tlet result = shared::play (\u0026 params);\n\tOk (format! (\"{}\", result))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day9","part2.rs"],"content":"use std::error::Error;\n\nuse super::shared;\nuse super::shared::GameParams;\n\npub fn aoc2018_day9_part2 (input: \u0026 str) -\u003e Result \u003cString, Box \u003cdyn Error\u003e\u003e {\n\tlet mut params: GameParams = input.trim ().parse () ?;\n\tparams.last_marble *= 100;\n\tlet result = shared::play (\u0026 params);\n\tOk (format! (\"{}\", result))\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","day9","shared.rs"],"content":"use parse_display_derive::FromStr;\nuse std::collections::VecDeque;\nuse std::iter;\n\n#[ derive (Clone, Copy, FromStr) ]\n#[ display (\"{num_players} players; last marble is worth {last_marble} points\") ]\npub struct GameParams {\n\tpub num_players: u32,\n\tpub last_marble: u32,\n}\n\npub fn play (params: \u0026 GameParams) -\u003e u32 {\n\tlet mut scores: Vec \u003cu32\u003e = vec! [0; params.num_players as usize];\n\tlet mut circle: VecDeque \u003cu32\u003e = vec! [0].into ();\n\tfor (player, marble) in Iterator::zip (\n\t\titer::repeat (0 .. params.num_players).flatten (),\n\t\t1 ..= params.last_marble,\n\t) {\n\t\tif marble % 23 == 0 {\n\t\t\tlet score = \u0026 mut scores [player as usize];\n\t\t\t* score += marble;\n\t\t\tcircle.rotate_right (7);\n\t\t\t* score += circle.pop_front ().unwrap ();\n\t\t} else {\n\t\t\tcircle.rotate_left (2 % circle.len ());\n\t\t\tcircle.push_front (marble);\n\t\t}\n\t}\n\tscores.into_iter ().max ().unwrap ()\n}\n\n#[test]\nfn test_play () {\n\tfor (input, expected) in vec! [\n\t\t(\"9 players; last marble is worth 25 points\", 32),\n\t\t(\"10 players; last marble is worth 1618 points\", 8317),\n\t\t(\"13 players; last marble is worth 7999 points\", 146373),\n\t\t(\"17 players; last marble is worth 1104 points\", 2764),\n\t\t(\"21 players; last marble is worth 6111 points\", 54718),\n\t\t(\"30 players; last marble is worth 5807 points\", 37305),\n\t] {\n\t\tlet params: GameParams = input.parse ().unwrap ();\n\t\tlet actual = play (\u0026 params);\n\t\tassert_eq! (expected, actual);\n\t}\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2018","src","shared","mod.rs"],"content":"use std::fmt::Debug;\nuse std::iter;\nuse std::mem;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub struct Pos {\n\tpub x: i64,\n\tpub y: i64\n}\n\nimpl Pos {\n\n\tpub fn new (x: i64, y: i64) -\u003e Pos {\n\t\tPos { x, y }\n\t}\n\n\tpub fn up (self, num: i64) -\u003e Pos {\n\t\tPos::new (self.x, i64::checked_sub (self.y, num).unwrap ())\n\t}\n\n\tpub fn down (self, num: i64) -\u003e Pos {\n\t\tPos::new (self.x, i64::checked_add (self.y, num).unwrap ())\n\t}\n\n\tpub fn left (self, num: i64) -\u003e Pos {\n\t\tPos::new (i64::checked_sub (self.x, num).unwrap (), self.y)\n\t}\n\n\tpub fn right (self, num: i64) -\u003e Pos {\n\t\tPos::new (i64::checked_add (self.x, num).unwrap (), self.y)\n\t}\n\n\tpub fn four_neighbours (\u0026 self) -\u003e [Pos; 4] {\n\t\t[\n\t\t\tself.up (1),\n\t\t\tself.down (1),\n\t\t\tself.left (1),\n\t\t\tself.right (1),\n\t\t]\n\t}\n\n}\n\nimpl From \u003c(i64, i64)\u003e for Pos {\n\tfn from ((x, y): (i64, i64)) -\u003e Pos {\n\t\tPos { x, y }\n\t}\n}\n\n#[ derive (Clone) ]\npub struct Grid \u003cValue\u003e {\n\ttop: i64,\n\tbottom: i64,\n\tleft: i64,\n\tright: i64,\n\twidth: usize,\n\theight: usize,\n\tdefault: Value,\n\tbounded: bool,\n\tdata: Vec \u003cValue\u003e,\n}\n\nimpl \u003cValue\u003e Grid \u003cValue\u003e where Value: Clone {\n\n\tpub fn builder () -\u003e GridBuilder \u003cValue\u003e {\n\t\tGridBuilder {\n\t\t\ttop: None,\n\t\t\tbottom: None,\n\t\t\tleft: None,\n\t\t\tright: None,\n\t\t\twidth: None,\n\t\t\theight: None,\n\t\t\tdefault: None,\n\t\t\tbounded: None,\n\t\t}\n\t}\n\n\tpub fn set (\u0026 mut self, pos: Pos, mut value: Value) -\u003e Value {\n\t\tlet index = match self.index (pos) {\n\t\t\tSome (index) =\u003e index,\n\t\t\tNone =\u003e panic! (\"out of bounds\"),\n\t\t};\n\t\tmem::swap (\u0026 mut value, \u0026 mut self.data [index]);\n\t\tvalue\n\t}\n\n\tpub fn get (\u0026 self, pos: Pos) -\u003e Value {\n\t\tlet index = match self.index (pos) {\n\t\t\tSome (index) =\u003e index,\n\t\t\tNone =\u003e if self.bounded {\n\t\t\t\tpanic! (\"out of bounds\");\n\t\t\t} else {\n\t\t\t\treturn self.default.clone ();\n\t\t\t},\n\t\t};\n\t\tself.data [index].clone ()\n\t}\n\n\tpub fn index (\u0026 self, pos: Pos) -\u003e Option \u003cusize\u003e {\n\t\tif pos.x \u003c self.left || pos.x \u003e= self.right { return None }\n\t\tif pos.y \u003c self.top || pos.y \u003e= self.bottom { return None }\n\t\tSome ((pos.y - self.top) as usize * self.width + (pos.x - self.left) as usize)\n\t}\n\n\tpub fn posns (\u0026 self) -\u003e GridPosIter {\n\t\tGridPosIter::new (\n\t\t\tPos::new (self.left, self.top),\n\t\t\tPos::new (self.right, self.bottom),\n\t\t)\n\t}\n\n\tpub fn values (\u0026 self) -\u003e impl Iterator \u003cItem = \u0026 Value\u003e {\n\t\tself.data.iter ()\n\t}\n\n}\n\npub struct GridPosIter {\n\tpos: Pos,\n\tbottom: i64,\n\tleft: i64,\n\tright: i64,\n}\n\nimpl GridPosIter {\n\n\tpub fn new (top_left: Pos, bottom_right: Pos) -\u003e GridPosIter {\n\t\tGridPosIter {\n\t\t\tpos: top_left,\n\t\t\tleft: top_left.x,\n\t\t\tright: bottom_right.x,\n\t\t\tbottom: bottom_right.y,\n\t\t}\n\t}\n\n}\n\nimpl Iterator for GridPosIter {\n\n\ttype Item = Pos;\n\n\tfn next (\u0026 mut self) -\u003e Option \u003cPos\u003e {\n\t\tif self.pos.y == self.bottom { return None }\n\t\tlet result = self.pos;\n\t\tself.pos.x += 1;\n\t\tif self.pos.x == self.right {\n\t\t\tself.pos.x = self.left;\n\t\t\tself.pos.y += 1;\n\t\t}\n\t\tSome (result)\n\t}\n\n}\n\npub struct GridBuilder \u003cValue\u003e {\n\ttop: Option \u003ci64\u003e,\n\tbottom: Option \u003ci64\u003e,\n\tleft: Option \u003ci64\u003e,\n\tright: Option \u003ci64\u003e,\n\twidth: Option \u003cusize\u003e,\n\theight: Option \u003cusize\u003e,\n\tdefault: Option \u003cValue\u003e,\n\tbounded: Option \u003cbool\u003e,\n}\n\nimpl \u003cValue\u003e GridBuilder \u003cValue\u003e where Value: Clone {\n\n\t/*\n\tpub fn top (mut self, top: i64) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.top.is_some () { panic! () }\n\t\tself.top = Some (top);\n\t\tself\n\t}\n\n\tpub fn bottom (mut self, bottom: i64) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.top.is_none () { panic! () }\n\t\tif self.bottom.is_some () { panic! () }\n\t\tif bottom \u003c self.top.unwrap () { panic! () }\n\t\tself.bottom = Some (bottom);\n\t\tself.height = Some (usize::checked_sub (\n\t\t\tbottom.try_into ().unwrap (),\n\t\t\tself.top.unwrap ().try_into ().unwrap (),\n\t\t).unwrap ());\n\t\tself\n\t}\n\n\tpub fn left (mut self, left: i64) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.left.is_some () { panic! () }\n\t\tself.left = Some (left);\n\t\tself\n\t}\n\n\tpub fn right (mut self, right: i64) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.left.is_none () { panic! () }\n\t\tif self.right.is_some () { panic! () }\n\t\tif right \u003c self.left.unwrap () { panic! () }\n\t\tself.right = Some (right);\n\t\tself.width = Some (usize::checked_sub (\n\t\t\tright.try_into ().unwrap (),\n\t\t\tself.left.unwrap ().try_into ().unwrap (),\n\t\t).unwrap ());\n\t\tself\n\t}\n\t*/\n\n\tpub fn width \u003cNum\u003e (mut self, width: Num) -\u003e GridBuilder \u003cValue\u003e where Num: TryInto \u003cusize\u003e {\n\t\tlet width: usize = width.try_into ().map_err (|_| \"overflow\").unwrap ();\n\t\tif self.left.is_none () { self.left = Some (0) }\n\t\tself.right = Some (i64::checked_add (\n\t\t\tself.left.unwrap (),\n\t\t\twidth.try_into ().unwrap (),\n\t\t).unwrap ());\n\t\tself.width = Some (width);\n\t\tself\n\t}\n\n\tpub fn height \u003cNum\u003e (mut self, height: Num) -\u003e GridBuilder \u003cValue\u003e where Num: TryInto \u003cusize\u003e {\n\t\tlet height: usize = height.try_into ().map_err (|_| \"overflow\").unwrap ();\n\t\tif self.top.is_none () { self.top = Some (0) }\n\t\tself.bottom = Some (i64::checked_add (\n\t\t\tself.left.unwrap (),\n\t\t\theight.try_into ().unwrap (),\n\t\t).unwrap ());\n\t\tself.height = Some (height);\n\t\tself\n\t}\n\n\t/*\n\tpub fn bounded (mut self) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.bounded.is_some () { panic! () }\n\t\tself.bounded = Some (true);\n\t\tself\n\t}\n\t*/\n\n\tpub fn unbounded (mut self) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.bounded.is_some () { panic! () }\n\t\tself.bounded = Some (false);\n\t\tself\n\t}\n\n\tpub fn default (mut self, default: Value) -\u003e GridBuilder \u003cValue\u003e {\n\t\tif self.default.is_some () { panic! () }\n\t\tself.default = Some (default);\n\t\tself\n\t}\n\n\tpub fn build (self) -\u003e Grid \u003cValue\u003e {\n\t\tif self.top.is_none () { panic! () }\n\t\tif self.bottom.is_none () { panic! () }\n\t\tif self.left.is_none () { panic! () }\n\t\tif self.right.is_none () { panic! () }\n\t\tif self.default.is_none () { panic! () }\n\t\tif self.bounded.is_none () { panic! () }\n\t\tGrid {\n\t\t\ttop: self.top.unwrap (),\n\t\t\tbottom: self.bottom.unwrap (),\n\t\t\tleft: self.left.unwrap (),\n\t\t\tright: self.right.unwrap (),\n\t\t\twidth: self.width.unwrap (),\n\t\t\theight: self.height.unwrap (),\n\t\t\tdefault: self.default.clone ().unwrap (),\n\t\t\tbounded: self.bounded.unwrap (),\n\t\t\tdata: iter::repeat (self.default.unwrap ())\n\t\t\t\t.take (usize::checked_mul (self.width.unwrap (), self.height.unwrap ()).unwrap ())\n\t\t\t\t.collect (),\n\t\t}\n\t}\n\n}\n","traces":[{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":63},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-11-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-11-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-13-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn next (\u0026 mut self) -\u003e Option \u003ci64\u003e {\n\t\tmatch self.run () {\n\t\t\tRunResult::Output (value) =\u003e Some (value),\n\t\t\tRunResult::Halt =\u003e None,\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-13-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-15-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-15-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-17-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-17-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-19-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-19-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-21-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-21-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-23-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-23-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-25","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\n#[ derive (Clone) ]\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn input_char (\u0026 mut self, value: char) {\n\t\tself.input (value as i64);\n\t}\n\n\tpub fn input_str (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_buffer.push_back (ch as i64);\n\t\t}\n\t}\n\n\tpub fn input_line (\u0026 mut self, value: \u0026 str) {\n\t\tfor ch in value.chars () {\n\t\t\tself.input_char (ch);\n\t\t}\n\t\tself.input_char ('\\n');\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\t\tself.pos += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn RunResult::Input;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\npub type Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\n#[ derive (Debug) ]\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n\tInput,\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-7-part-1","src","intcode.rs"],"content":"use rustyline::Editor;\n\nuse std::collections::VecDeque;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: usize,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n\tinput_readline: Option \u003cEditor \u003c()\u003e\u003e,\n\toutput_buffer: Option \u003cVecDeque \u003ci64\u003e\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t\tinput_readline: None,\n\t\t\toutput_buffer: None,\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn with_input_readline (mut self, input_readline: Editor \u003c()\u003e) -\u003e Machine {\n\t\tself.input_readline = Some (input_readline);\n\t\tself\n\t}\n\n\tpub fn with_output_buffer (mut self) -\u003e Machine {\n\t\tself.output_buffer = Some (VecDeque::new ());\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn output_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\tself.output_buffer.as_mut ().unwrap ()\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem [self.pos].into ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tif let Some (output_buffer) = self.output_buffer.as_mut () {\n\t\t\t\t\t\toutput_buffer.push_back (value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprintln! (\"Output: {}\", value);\n\t\t\t\t\t}\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest as usize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest as usize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else if let Some (input_readline) = self.input_readline.as_mut () {\n\t\t\tlet value_str = input_readline.readline (\"Input: \").unwrap ();\n\t\t\treturn value_str.parse ().unwrap ();\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: usize) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem [self.pos].into ();\n\t\tlet param = self.mem [self.pos + 1 + num];\n\t\tmatch opcode.modes [num] {\n\t\t\tMode::Position =\u003e self.mem [param as usize],\n\t\t\tMode::Immediate =\u003e param,\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: usize, value: i64) {\n\t\tlet opcode: Opcode = self.mem [self.pos].into ();\n\t\tlet param = self.mem [self.pos + 1 + num];\n\t\tmatch opcode.modes [num] {\n\t\t\tMode::Position =\u003e self.mem [param as usize] = value,\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t}\n\t}\n\n}\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n}\n\nimpl From \u003ci64\u003e for Instruction {\n\n\tfn from (value: i64) -\u003e Instruction {\n\t\tmatch value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e panic! (\"Invalid instruction: {}\", value),\n\t\t}\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl From \u003ci64\u003e for Opcode {\n\n\tfn from (value: i64) -\u003e Opcode {\n\t\tOpcode {\n\t\t\tinstr: (value % 100).into (),\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-7-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: usize,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem [self.pos].try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest as usize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest as usize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: usize) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem [self.pos].try_into ().unwrap ();\n\t\tlet param = self.mem [self.pos + 1 + num];\n\t\tmatch opcode.modes [num] {\n\t\t\tMode::Position =\u003e self.mem [param as usize],\n\t\t\tMode::Immediate =\u003e param,\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: usize, value: i64) {\n\t\tlet opcode: Opcode = self.mem [self.pos].try_into ().unwrap ();\n\t\tlet param = self.mem [self.pos + 1 + num];\n\t\tmatch opcode.modes [num] {\n\t\t\tMode::Position =\u003e self.mem [param as usize] = value,\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t}\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-9-part-1","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2019","aoc-2019-day-9-part-2","src","intcode.rs"],"content":"use std::collections::VecDeque;\nuse std::convert::TryFrom;\nuse std::convert::TryInto as _;\nuse std::iter;\n\npub struct Machine {\n\tmem: Mem,\n\tpos: i64,\n\trel: i64,\n\tinput_buffer: VecDeque \u003ci64\u003e,\n}\n\nimpl Machine {\n\n\tpub fn new (mem: Mem) -\u003e Machine {\n\t\tMachine {\n\t\t\tmem: mem,\n\t\t\tpos: 0,\n\t\t\trel: 0,\n\t\t\tinput_buffer: VecDeque::new (),\n\t\t}\n\t}\n\n\tpub fn with_input_buffer (mut self, input_buffer: VecDeque \u003ci64\u003e) -\u003e Machine {\n\t\tself.input_buffer = input_buffer;\n\t\tself\n\t}\n\n\tpub fn input_buffer (\u0026 mut self) -\u003e \u0026 mut VecDeque \u003ci64\u003e {\n\t\t\u0026 mut self.input_buffer\n\t}\n\n\tpub fn queue_input (\u0026 mut self, value: i64) {\n\t\tself.input_buffer.push_back (value);\n\t}\n\n\tpub fn run (\u0026 mut self) -\u003e RunResult {\n\t\tloop {\n\t\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().map_err (\n\t\t\t\t|error| format! (\"[pos={}] {}\", self.pos, error),\n\t\t\t).unwrap ();\n\t\t\tmatch opcode.instr {\n\t\t\t\tInstruction::Add =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 + param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Multiply =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tself.param_set (2, param_0 * param_1);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Input =\u003e {\n\t\t\t\t\tlet value = self.get_input ();\n\t\t\t\t\tself.param_set (0, value);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Output =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t\treturn RunResult::Output (value);\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfTrue =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value != 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::JumpIfFalse =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tlet dest = self.param_get (1);\n\t\t\t\t\tif value == 0 {\n\t\t\t\t\t\tself.pos = dest;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.pos += 3;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tInstruction::LessThan =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 \u003c param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::Equals =\u003e {\n\t\t\t\t\tlet param_0 = self.param_get (0);\n\t\t\t\t\tlet param_1 = self.param_get (1);\n\t\t\t\t\tlet value = if param_0 == param_1 { 1 } else { 0 };\n\t\t\t\t\tself.param_set (2, value);\n\t\t\t\t\tself.pos += 4;\n\t\t\t\t},\n\t\t\t\tInstruction::AdjustRelBase =\u003e {\n\t\t\t\t\tlet value = self.param_get (0);\n\t\t\t\t\tself.rel += value;\n\t\t\t\t\tself.pos += 2;\n\t\t\t\t},\n\t\t\t\tInstruction::Halt =\u003e {\n\t\t\t\t\treturn RunResult::Halt;\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t}\n\n\tfn get_input (\u0026 mut self) -\u003e i64 {\n\t\tif let Some (value) = self.input_buffer.pop_front () {\n\t\t\treturn value;\n\t\t} else {\n\t\t\tpanic! (\"No input\");\n\t\t}\n\t}\n\n\tfn param_get (\u0026 mut self, num: u8) -\u003e i64 {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_get (param),\n\t\t\tMode::Immediate =\u003e param,\n\t\t\tMode::Relative =\u003e self.mem_get (param + self.rel),\n\t\t}\n\t}\n\n\tfn param_set (\u0026 mut self, num: u8, value: i64) {\n\t\tlet opcode: Opcode = self.mem_get (self.pos).try_into ().unwrap ();\n\t\tlet param = self.mem_get (self.pos + 1 + num as i64);\n\t\tmatch opcode.modes [num as usize] {\n\t\t\tMode::Position =\u003e self.mem_set (param, value),\n\t\t\tMode::Immediate =\u003e panic! (),\n\t\t\tMode::Relative =\u003e self.mem_set (param + self.rel, value),\n\t\t}\n\t}\n\n\tfn mem_get (\u0026 mut self, addr: i64) -\u003e i64 {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize]\n\t}\n\n\tfn mem_set (\u0026 mut self, addr: i64, value: i64) {\n\t\tself.mem_extend (addr);\n\t\tself.mem [addr as usize] = value;\n\t}\n\n\tfn mem_extend (\u0026 mut self, addr: i64) {\n\t\tif addr \u003c 0 || addr == i64::MAX { panic! (); }\n\t\tlet size = addr as usize + 1;\n\t\tif size \u003c self.mem.len () {\n\t\t\treturn;\n\t\t}\n\t\tself.mem.extend (iter::repeat (0).take (size - self.mem.len ()));\n\t}\n\n}\n\ntype Mem = Vec \u003ci64\u003e;\n\npub fn from_str (source: \u0026 str) -\u003e Mem {\n\tsource.split (',').map (\n\t\t|item_str| item_str.trim ().parse ().unwrap (),\n\t).collect ()\n}\n\npub enum RunResult {\n\tHalt,\n\tOutput (i64),\n}\n\n#[ derive (Clone, Copy) ]\nstruct Opcode {\n\tinstr: Instruction,\n\tmodes: [Mode; 3],\n}\n\nimpl TryFrom \u003ci64\u003e for Opcode {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cOpcode, String\u003e {\n\t\tOk (Opcode {\n\t\t\tinstr: (value % 100).try_into () ?,\n\t\t\tmodes: [\n\t\t\t\t((value / 100) % 10).into (),\n\t\t\t\t((value / 1000) % 10).into (),\n\t\t\t\t((value / 10000) % 10).into (),\n\t\t\t],\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Instruction {\n\tAdd,\n\tMultiply,\n\tInput,\n\tOutput,\n\tHalt,\n\tJumpIfTrue,\n\tJumpIfFalse,\n\tLessThan,\n\tEquals,\n\tAdjustRelBase,\n}\n\nimpl TryFrom \u003ci64\u003e for Instruction {\n\n\ttype Error = String;\n\n\tfn try_from (value: i64) -\u003e Result \u003cInstruction, String\u003e {\n\t\tOk (match value {\n\t\t\t1 =\u003e Instruction::Add,\n\t\t\t2 =\u003e Instruction::Multiply,\n\t\t\t3 =\u003e Instruction::Input,\n\t\t\t4 =\u003e Instruction::Output,\n\t\t\t5 =\u003e Instruction::JumpIfTrue,\n\t\t\t6 =\u003e Instruction::JumpIfFalse,\n\t\t\t7 =\u003e Instruction::LessThan,\n\t\t\t8 =\u003e Instruction::Equals,\n\t\t\t9 =\u003e Instruction::AdjustRelBase,\n\t\t\t99 =\u003e Instruction::Halt,\n\t\t\t_ =\u003e return Err (format! (\"Invalid instruction: {}\", value)),\n\t\t})\n\t}\n\n}\n\n#[ derive (Clone, Copy, Eq, PartialEq) ]\nenum Mode { Position, Immediate, Relative }\n\nimpl From \u003ci64\u003e for Mode {\n\n\tfn from (value: i64) -\u003e Mode {\n\t\tmatch value {\n\t\t\t0 =\u003e Mode::Position,\n\t\t\t1 =\u003e Mode::Immediate,\n\t\t\t2 =\u003e Mode::Relative,\n\t\t\t_ =\u003e panic! (\"Invalid mode: {}\", value),\n\t\t}\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-01","src","lib.rs"],"content":"//! Advent of Code 2021: Day 1: Sonar Sweep\n//!\n//! [https://adventofcode.com/2021/day/1](https://adventofcode.com/2021/day/1)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Sonar Sweep\";\n\tyear = 2021;\n\tday = 1;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut last = None;\n\t\tlet mut num: u64 = 0;\n\t\tfor line in lines {\n\t\t\tif line.trim ().is_empty () { continue }\n\t\t\tlet cur: u64 = line.parse () ?;\n\t\t\tif let Some (last) = last {\n\t\t\t\tif last \u003c cur {\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast = Some (cur);\n\t\t}\n\t\tOk (num)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut last_0 = None;\n\t\tlet mut last_1 = None;\n\t\tlet mut last_2 = None;\n\t\tlet mut num: u64 = 0;\n\t\tfor line in lines {\n\t\t\tif line.trim ().is_empty () { continue }\n\t\t\tlet cur: u64 = line.parse () ?;\n\t\t\tif let Some (last_2) = last_2 {\n\t\t\t\tif last_2 \u003c cur {\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast_2 = last_1;\n\t\t\tlast_1 = last_0;\n\t\t\tlast_0 = Some (cur);\n\t\t}\n\t\tOk (num)\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"199\", \"200\", \"208\", \"210\", \"200\", \"207\", \"240\", \"269\", \"260\", \"263\"\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (7, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (5, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[21193,20729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[20814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[21278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[29088],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":20,"address":[29147],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[29156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[29274,29575,29165],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[29295],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[29459,29355],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[29444,29506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[29519,29609],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[29580,29611],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[29529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[29253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[29648],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":36,"address":[29707],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[29716],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[29725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[29737],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[29749,30220,29867],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[29888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[30055,29948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[30102,30037],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[30118,30260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[30265,30225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[30128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[30154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[30174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[29843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[18096,18105],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":68,"address":[19527,19767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[19747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[18153,18144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":74,"address":[19815,20055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[20035],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-02","src","lib.rs"],"content":"//! Advent of Code 2021: Day 2: Dive!\n//!\n//! [https://adventofcode.com/2021/day/2](https://adventofcode.com/2021/day/2)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Dive!\";\n\tyear = 2021;\n\tday = 2;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet mut distance: i64 = 0;\n\t\tlet mut depth: i64 = 0;\n\t\tfor line in lines.iter () {\n\t\t\tif line.trim ().is_empty () { continue }\n\t\t\tlet line_parts: Vec \u003c_\u003e = line.split (' ').collect ();\n\t\t\tif line_parts.len () != 2 { panic! () }\n\t\t\tlet line_verb = line_parts [0];\n\t\t\tlet line_arg: i64 = line_parts [1].parse () ?;\n\t\t\tmatch line_verb {\n\t\t\t\t\"forward\" =\u003e distance += line_arg,\n\t\t\t\t\"down\" =\u003e depth += line_arg,\n\t\t\t\t\"up\" =\u003e depth -= line_arg,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t}\n\t\t}\n\t\tOk (distance * depth)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet mut distance: i64 = 0;\n\t\tlet mut depth: i64 = 0;\n\t\tlet mut aim: i64 = 0;\n\t\tfor line in lines.iter () {\n\t\t\tif line.trim ().is_empty () { continue }\n\t\t\tlet line_parts: Vec \u003c_\u003e = line.split (' ').collect ();\n\t\t\tif line_parts.len () != 2 { panic! () }\n\t\t\tlet line_verb = line_parts [0];\n\t\t\tlet line_arg: i64 = line_parts [1].parse () ?;\n\t\t\tmatch line_verb {\n\t\t\t\t\"forward\" =\u003e {\n\t\t\t\t\tdistance += line_arg;\n\t\t\t\t\tdepth += aim * line_arg;\n\t\t\t\t},\n\t\t\t\t\"down\" =\u003e aim += line_arg,\n\t\t\t\t\"up\" =\u003e aim -= line_arg,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t}\n\t\t}\n\t\tOk (distance * depth)\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"forward 5\",\n\t\t\"down 5\",\n\t\t\"forward 8\",\n\t\t\"up 3\",\n\t\t\"down 8\",\n\t\t\"forward 2\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (150, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (900, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[22745,23209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[22830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[23294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[36160,37373],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":20,"address":[36237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":21,"address":[36249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[36441,36261],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[36462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[36528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[36649,36690,36576],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[36655,36727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[36938,36760],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[37048,36907,37004],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[37139,37020,37183],"length":1,"stats":{"Line":3},"fn_name":null},{"line":31,"address":[37155,37255,37299],"length":1,"stats":{"Line":3},"fn_name":null},{"line":32,"address":[37261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[37431,36400,37415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[37472,38838],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":39,"address":[37549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[37561],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[37573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[37585,37765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[37786],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[37858],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[37906,37979,38020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[38057,37985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[38268,38090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[38548,38237,38334],"length":1,"stats":{"Line":3},"fn_name":null},{"line":50,"address":[38381,38442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[38419,38480,38550],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[38350,38606,38650],"length":1,"stats":{"Line":3},"fn_name":null},{"line":54,"address":[38766,38622,38722],"length":1,"stats":{"Line":3},"fn_name":null},{"line":55,"address":[38728],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[37724,38880,38896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[39744],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":79,"address":[39751,39990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[39970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[40032],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":85,"address":[40278,40039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[40258],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":35,"coverable":40},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-03","src","lib.rs"],"content":"//! Advent of Code 2021: Day 3: Binary Diagnostic\n//!\n//! [https://adventofcode.com/2021/day/3](https://adventofcode.com/2021/day/3)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Binary Diagnostic\";\n\tyear = 2021;\n\tday = 3;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Mode;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet mut sums: Vec \u003ci64\u003e = Vec::new ();\n\t\tfor line in lines {\n\t\t\tif line.trim ().is_empty () { continue }\n\t\t\tlet sums_temp = sums;\n\t\t\tlet prev_sums = Iterator::chain (sums_temp.iter_vals (), iter::repeat (0));\n\t\t\tsums = Vec::new ();\n\t\t\tfor (ch, sum) in iter::zip (line.chars (), prev_sums) {\n\t\t\t\tsums.push (sum + match ch {\n\t\t\t\t\t'0' =\u003e -1,\n\t\t\t\t\t'1' =\u003e 1,\n\t\t\t\t\t_ =\u003e Err (format! (\"Invalid bit: {}\", ch)) ?,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tfor sum in sums.iter_vals () {\n\t\t\tif sum == 0 {\n\t\t\t\tErr (format! (\"Equal number of bits\")) ?;\n\t\t\t}\n\t\t}\n\t\tlet gamma_str: String = sums.iter ().map (|sum|\n\t\t\tmatch sum.signum () {\n\t\t\t\t-1 =\u003e '0',\n\t\t\t\t1 =\u003e '1',\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t).collect ();\n\t\tlet gamma = i64::from_str_radix (\u0026 gamma_str, 2) ?;\n\t\tlet epsilon_str: String = sums.iter ().map (|sum|\n\t\t\tmatch sum.signum () {\n\t\t\t\t-1 =\u003e '1',\n\t\t\t\t1 =\u003e '0',\n\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t}\n\t\t).collect ();\n\t\tlet epsilon = i64::from_str_radix (\u0026 epsilon_str, 2) ?;\n\t\tOk (gamma * epsilon)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet oxygen = calc_rating (lines.to_vec (), Mode::Oxygen) ?;\n\t\tlet co2 = calc_rating (lines.to_vec (), Mode::CO2) ?;\n\t\tOk (oxygen * co2)\n\t}\n\n\tfn calc_rating (mut lines: Vec \u003c\u0026 str\u003e, mode: Mode) -\u003e GenResult \u003ci64\u003e {\n\t\tlet mut offset: usize = 0;\n\t\twhile lines.len () \u003e 1 {\n\t\t\tlet mut sum: i64 = 0;\n\t\t\tfor line in lines.iter () {\n\t\t\t\tsum += if line.chars ().nth (offset).unwrap () == '1' { 1 } else { -1 };\n\t\t\t}\n\t\t\tlet sel = if (sum \u003c 0) == (mode == Mode::Oxygen) { '0' } else { '1' };\n\t\t\tlines.retain (|line| line.chars ().nth (offset).unwrap () == sel);\n\t\t\toffset += 1;\n\t\t}\n\t\tOk (i64::from_str_radix (lines [0], 2) ?)\n\t}\n\n}\n\nmod model {\n\n\t#[ derive (PartialEq, Eq) ]\n\tpub enum Mode { Oxygen, CO2 }\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"00100\", \"11110\", \"10110\", \"10111\", \"10101\", \"01111\",\n\t\t\"00111\", \"11100\", \"10000\", \"11001\", \"00010\", \"01010\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (198, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (230, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[33785,33321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[33406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[33870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[24589,23040,25941],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[23095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[23224,23342,23140],"length":1,"stats":{"Line":3},"fn_name":null},{"line":23,"address":[23366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[23443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[23491,23590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[23652],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[23707,23961],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[23999,24506],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[24069],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[24086],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[24034,24119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[23316,24787,24616],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[24803,24987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[25000,24813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[24761,25134],"length":1,"stats":{"Line":4},"fn_name":null},{"line":41,"address":[46350,46270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[46400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[46410],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[46370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[25288,25415,25217],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[25481,25390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[46446,46526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[46576],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[46586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[46546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[25629,25558,25753],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[25874,25844,25723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[25984],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":60,"address":[26161,26027],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[26140,26214,26347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[26406,26422,26324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[26464,27446],"length":1,"stats":{"Line":1},"fn_name":"calc_rating"},{"line":66,"address":[26503],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[27230,26520,26582],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[26628],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[26640,27055,26856],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[26872,27060],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[27100,26811],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[27148],"length":1,"stats":{"Line":3},"fn_name":null},{"line":74,"address":[27195,27235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[26593,27401,27273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[35968,35977],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":100,"address":[39079,39318],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[39298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[36025,36016],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":106,"address":[39606,39367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[39586],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":44,"coverable":51},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-04","src","lib.rs"],"content":"//! Advent of Code 2021: Day 4: Giant Squid\n//!\n//! [https://adventofcode.com/2021/day/4](https://adventofcode.com/2021/day/4)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Giant Squid\";\n\tyear = 2021;\n\tday = 4;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Board;\n\tuse model::Input;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tOk (scores_iter (\u0026 input).next ().unwrap ())\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tOk (scores_iter (\u0026 input).last ().unwrap ())\n\t}\n\n\tfn scores_iter (input: \u0026 Rc \u003cInput\u003e) -\u003e ScoresIter {\n\t\tScoresIter {\n\t\t\tinput: Rc::clone (input),\n\t\t\tboards: iter::repeat (false).take (input.boards.len ()).collect (),\n\t\t\tcall_idx: 0,\n\t\t\tboard_idx: 0,\n\t\t}\n\t}\n\n\tstruct ScoresIter {\n\t\tinput: Rc \u003cInput\u003e,\n\t\tboards: Vec \u003cbool\u003e,\n\t\tcall_idx: usize,\n\t\tboard_idx: usize,\n\t}\n\n\timpl Iterator for ScoresIter {\n\t\ttype Item = i64;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003ci64\u003e {\n\t\t\tloop {\n\t\t\t\tif self.board_idx == self.boards.len () {\n\t\t\t\t\tself.board_idx = 0;\n\t\t\t\t\tself.call_idx += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif self.call_idx == self.input.call_order.len () {\n\t\t\t\t\treturn None;\n\t\t\t\t}\n\t\t\t\tif self.boards [self.board_idx] {\n\t\t\t\t\tself.board_idx += 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif let Some (score) = calc_score (\n\t\t\t\t\t\u0026 self.input.call_order [0 .. self.call_idx + 1],\n\t\t\t\t\t\u0026 self.input.boards [self.board_idx],\n\t\t\t\t) {\n\t\t\t\t\tself.boards [self.board_idx] = true;\n\t\t\t\t\tself.board_idx += 1;\n\t\t\t\t\treturn Some (score.as_i64 ()\n\t\t\t\t\t\t* self.input.call_order [self.call_idx].as_i64 (),\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tself.board_idx += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfn calc_score (called: \u0026 [u8], board: \u0026 Board) -\u003e Option \u003cu16\u003e {\n\t\tfn check \u003cI: Iterator \u003cItem = u8\u003e\u003e (called: \u0026 [u8], mut nums: I) -\u003e bool {\n\t\t\tnums.all (|num| called.contains (\u0026 num))\n\t\t}\n\t\tlet mut winner = false;\n\t\tfor row in 0 .. 5 {\n\t\t\tif check (called, board.iter_vals ().skip (row * 5).take (5)) { winner = true }\n\t\t}\n\t\tfor col in 0 .. 5 {\n\t\t\tif check (called, board.iter_vals ().skip (col).step_by (5)) { winner = true }\n\t\t}\n\t\tif winner {\n\t\t\tSome (board.iter_vals ().filter (\n\t\t\t\t|num| ! called.contains (num),\n\t\t\t).map (\n\t\t\t\t|num| num.as_u16 (),\n\t\t\t).sum ())\n\t\t} else { None }\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Board = [u8; 25];\n\n\tpub struct Input {\n\t\tpub call_order: Vec \u003cu8\u003e,\n\t\tpub boards: Vec \u003cBoard\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cRc \u003cInput\u003e\u003e {\n\n\t\t\tlet call_order: Vec \u003cu8\u003e =\n\t\t\t\tlines [0]\n\t\t\t\t\t.split (',')\n\t\t\t\t\t.map (|num_str| num_str\n\t\t\t\t\t\t.parse ()\n\t\t\t\t\t\t.unwrap ())\n\t\t\t\t\t.collect ();\n\n\t\t\tlet boards: Vec \u003cBoard\u003e =\n\t\t\t\tlines [2 ..].chunks (6)\n\t\t\t\t\t.map (|board_lines| board_lines.iter ()\n\t\t\t\t\t\t.take (5)\n\t\t\t\t\t\t.flat_map (|board_line| board_line\n\t\t\t\t\t\t\t.split_whitespace ()\n\t\t\t\t\t\t\t.map (|num_str| num_str\n\t\t\t\t\t\t\t\t.parse ()\n\t\t\t\t\t\t\t\t.unwrap ()))\n\t\t\t\t\t\t.collect_array ()\n\t\t\t\t\t\t.unwrap ())\n\t\t\t\t\t.collect ();\n\n\t\t\tOk (Input { call_order, boards }.into ())\n\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1\",\n\t\t\"\",\n\t\t\"22 13 17 11  0\",\n\t\t\" 8  2 23  4 24\",\n\t\t\"21  9 14 16  7\",\n\t\t\" 6 10  3 18  5\",\n\t\t\" 1 12 20 15 19\",\n\t\t\"\",\n\t\t\" 3 15  0  2 22\",\n\t\t\" 9 18 13 17  5\",\n\t\t\"19  8  7 25 23\",\n\t\t\"20 11 10 24  4\",\n\t\t\"14 21 16 12  6\",\n\t\t\"\",\n\t\t\"14 21 17 24  4\",\n\t\t\"10 16 15  9 19\",\n\t\t\"18  8 23 26 20\",\n\t\t\"22 11 13  6  5\",\n\t\t\" 2  0 12  3  7\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (4512, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (1924, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[25545,26009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[25630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[26094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[69792,70015],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[69906,69825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[70085,69998,69894],"length":1,"stats":{"Line":3},"fn_name":null},{"line":27,"address":[70482,70192],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":28,"address":[70306,70225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[70294,70398],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[70795,70512],"length":1,"stats":{"Line":1},"fn_name":"scores_iter"},{"line":34,"address":[70547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[70559,70652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[70832],"length":1,"stats":{"Line":1},"fn_name":"next"},{"line":51,"address":[71748],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[70863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[70993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[71049,71001],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[71087,70983,70921],"length":1,"stats":{"Line":3},"fn_name":null},{"line":58,"address":[71164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[71208,71130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[71281,71329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[71221,71271,71380],"length":1,"stats":{"Line":3},"fn_name":null},{"line":66,"address":[71508,71568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[71672,71796],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[71799,71857],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[72006,72052,71841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[71895,71955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[71753,71711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[72096],"length":1,"stats":{"Line":1},"fn_name":"calc_score"},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":83,"address":[72148],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[72371,72156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[72392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[72679,72584,72302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":88,"address":[72700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[72835,72652],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[72902,72848],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[72886],"length":1,"stats":{"Line":3},"fn_name":null},{"line":94,"address":[85728,85744],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":96,"address":[72825],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[60415,60446,59888],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":115,"address":[59939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[86237,86192],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":123,"address":[60064,60172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[86304,86369],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":127,"address":[86496,86520],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":129,"address":[86576,86621],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":136,"address":[60225],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[40704],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":172,"address":[40950,40711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[40930],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[40992],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":178,"address":[40999,41238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[41218],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":52,"coverable":55},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-05","src","lib.rs"],"content":"//! Advent of Code 2021: Day 5: Hydrothermal Venture\n//!\n//! [https://adventofcode.com/2021/day/5](https://adventofcode.com/2021/day/5)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Hydrothermal Venture\";\n\tyear = 2021;\n\tday = 5;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse grid::Grid;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tcalc_result (lines, false)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tcalc_result (lines, true)\n\t}\n\n\tpub fn calc_result (lines: \u0026 [\u0026 str], include_diagonal: bool) -\u003e GenResult \u003ci64\u003e {\n\t\tlet mut vents = model::parse_input (lines) ?;\n\t\tif ! include_diagonal {\n\t\t\tvents.retain (|vent| ! vent.is_diagonal ());\n\t\t}\n\t\tlet size = vents.iter ()\n\t\t\t.flat_map (|vent| [ vent.start, vent.end ])\n\t\t\t.fold (Pos::ZERO, |max, pos| Pos {\n\t\t\t\tx: cmp::max (max.x, pos.x + 1),\n\t\t\t\ty: cmp::max (max.y, pos.y + 1),\n\t\t\t});\n\t\tlet mut points: Grid \u003cVec \u003cu16\u003e, Pos\u003e =\n\t\t\tGrid::wrap (\n\t\t\t\titer::repeat (0).take (size.x.as_usize () * size.y.as_usize ()).collect (),\n\t\t\t\t[0, 0],\n\t\t\t\t[size.y.as_usize (), size.x.as_usize ()]);\n\t\tfor vent in vents {\n\t\t\tlet step = Pos {\n\t\t\t\tx: (vent.end.x - vent.start.x).signum (),\n\t\t\t\ty: (vent.end.y - vent.start.y).signum (),\n\t\t\t};\n\t\t\tlet mut pos = vent.start;\n\t\t\tloop {\n\t\t\t\t* points.get_mut (pos).unwrap () += 1;\n\t\t\t\tif pos == vent.end { break }\n\t\t\t\tpos.x += step.x;\n\t\t\t\tpos.y += step.y;\n\t\t\t}\n\t\t}\n\t\tOk (points.values ().filter (|\u0026 num| num \u003e 1).count ().as_i64 ())\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Pos = pos::PosYX \u003ci16\u003e;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cVent\u003e\u003e {\n\t\tlet mut vents: Vec \u003cVent\u003e = Vec::new ();\n\t\tfor line in lines {\n\t\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split (\" -\u003e \").collect ();\n\t\t\tif line_parts.len () != 2 {\n\t\t\t\tErr (format! (\"Invalid input: {}\", line)) ?;\n\t\t\t}\n\t\t\tvents.push (Vent {\n\t\t\t\tstart: parse_pos (line_parts [0]) ?,\n\t\t\t\tend: parse_pos (line_parts [1]) ?,\n\t\t\t});\n\t\t}\n\t\tOk (vents)\n\t}\n\n\tpub fn parse_pos (input: \u0026 str) -\u003e GenResult \u003cPos\u003e {\n\t\tlet input_parts: Vec \u003c\u0026 str\u003e = input.split (',').collect ();\n\t\tif input_parts.len () != 2 {\n\t\t\tErr (format! (\"Input position: {}\", input)) ?;\n\t\t}\n\t\tOk (Pos {\n\t\t\tx: input_parts [0].parse () ?,\n\t\t\ty: input_parts [1].parse () ?,\n\t\t})\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Vent { pub start: Pos, pub end: Pos }\n\n\timpl Vent {\n\t\tpub fn is_diagonal (self) -\u003e bool {\n\t\t\tself.start.x != self.end.x \u0026\u0026 self.start.y != self.end.y\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"0,9 -\u003e 5,9\",\n\t\t\"8,0 -\u003e 0,8\",\n\t\t\"9,4 -\u003e 3,4\",\n\t\t\"2,2 -\u003e 2,1\",\n\t\t\"7,0 -\u003e 7,4\",\n\t\t\"6,4 -\u003e 2,0\",\n\t\t\"0,9 -\u003e 2,9\",\n\t\t\"3,4 -\u003e 1,4\",\n\t\t\"0,0 -\u003e 8,8\",\n\t\t\"5,5 -\u003e 8,2\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (5, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (12, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[57241,56777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[56862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[57326],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[25456],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[25477],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[25504],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":27,"address":[25525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[27701,26615,25552],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":31,"address":[25805,25609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[25789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[25040,25054],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":35,"address":[25978,25881],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[25121,25104],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":37,"address":[25377,25168],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":38,"address":[25216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[25294],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[26133],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[26342],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[26605,26526,26366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[26534,26666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[26976,26846],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[27139,27009],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[27198],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[27518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[27230,27354],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[27327,27391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[27472,27401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[27523,27442,27510],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[25408,25421],"length":1,"stats":{"Line":3},"fn_name":"{closure#3}"},{"line":70,"address":[41072,42471],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":71,"address":[41115],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[41203,41373,41135],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[41389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[41455,41528,41801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[41572,41811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[42291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[41534,41953,42100,42173],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[42185,42348,42059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[41286],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[42512,43533],"length":1,"stats":{"Line":1},"fn_name":"parse_pos"},{"line":86,"address":[42539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[42921,42587,42654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[42695,42931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[43419],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[43073,43236,42660],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[43289,43198,43485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[43568],"length":1,"stats":{"Line":1},"fn_name":"is_diagonal"},{"line":101,"address":[43586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[34809,34800],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":127,"address":[84279,84518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[84498],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[34848,34857],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":132,"address":[84567,84806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[84786],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":49,"coverable":54},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-06","src","lib.rs"],"content":"//! Advent of Code 2021: Day 6: Lanternfish\n//!\n//! [https://adventofcode.com/2021/day/6](https://adventofcode.com/2021/day/6)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Lanternfish\";\n\tyear = 2021;\n\tday = 6;\n\tpart_one = |lines| logic::part_one (lines [0]);\n\tpart_two = |lines| logic::part_two (lines [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result (input, 80)\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result (input, 256)\n\t}\n\n\tpub fn calc_result (input: \u0026 str, days: u64) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut fishes: [u64; 9] = [0; 9];\n\t\tfor fish_str in input.split (',') {\n\t\t\tlet fish: usize = fish_str.parse () ?;\n\t\t\tfishes [fish] += 1;\n\t\t}\n\t\tfor _ in 0 .. days {\n\t\t\tfishes = [\n\t\t\t\tfishes [1],\n\t\t\t\tfishes [2],\n\t\t\t\tfishes [3],\n\t\t\t\tfishes [4],\n\t\t\t\tfishes [5],\n\t\t\t\tfishes [6],\n\t\t\t\tfishes [7] + fishes [0],\n\t\t\t\tfishes [8],\n\t\t\t\tfishes [0],\n\t\t\t];\n\t\t}\n\t\tOk (fishes.into_iter ().sum::\u003cu64\u003e ().as_u64 ())\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 str = \"3,4,3,1,2\";\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (5934, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (26984457539, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[22137,22665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[22253,22232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[22781,22760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[19536],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[19557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[19584],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":25,"address":[19605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[19632],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":29,"address":[19697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[20172,19733,19919],"length":1,"stats":{"Line":6},"fn_name":null},{"line":31,"address":[20050,19951],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[20100,20177,20032],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[19863,20217,20570],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[20498],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[20337],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[20350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[20363],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[20376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[20389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[20402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[20575,20415],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[20482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[20490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[20285,20605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[27712],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":61,"address":[27719,27957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[27937],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[28000],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":67,"address":[28007,28245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[28225],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":30},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-07","src","lib.rs"],"content":"//! Advent of Code 2021: Day 7: The Treachery of Whales\n//!\n//! [https://adventofcode.com/2021/day/7](https://adventofcode.com/2021/day/7)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"The Treachery of Whales\";\n\tyear = 2021;\n\tday = 7;\n\tpart_one = |lines| logic::part_one (lines [0]);\n\tpart_two = |lines| logic::part_two (lines [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tlet start_posns = model::parse_input (input) ?;\n\t\tcalc_result (\u0026 start_posns, (0, 0), |(fuel, crabs): \u0026 mut (u64, u64), pos| {\n\t\t\t* fuel += * crabs;\n\t\t\t* crabs += start_posns.iter_vals ().filter (\n\t\t\t\t|start_pos| * start_pos == pos,\n\t\t\t).count ().as_u64 ();\n\t\t\tSome (* fuel)\n\t\t})\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tlet start_posns = model::parse_input (input) ?;\n\t\tcalc_result (\u0026 start_posns, (0, 0, 0), |(fuel, incr, crabs): \u0026 mut (u64, u64, u64), pos| {\n\t\t\t* incr += * crabs;\n\t\t\t* fuel += * incr;\n\t\t\t* crabs += start_posns.iter_vals ().filter (\n\t\t\t\t|start_pos| * start_pos == pos,\n\t\t\t).count ().as_u64 ();\n\t\t\tSome (* fuel)\n\t\t})\n\t}\n\n\tpub fn calc_result \u003c\n\t\tState: Copy,\n\t\tScanFn: Fn (\u0026 mut State, u64) -\u003e Option \u003cu64\u003e + Clone,\n\t\u003e (\n\t\tstart_posns: \u0026 [u64],\n\t\tinitial_state: State,\n\t\tscan_fn: ScanFn,\n\t) -\u003e GenResult \u003cu64\u003e {\n\t\tlet max = start_posns.iter ().copied ().max ().unwrap ();\n\t\tlet lower: Vec \u003cu64\u003e = (0 ..= max).scan (initial_state, scan_fn.clone ()).collect ();\n\t\tlet higher: Vec \u003cu64\u003e = (0 ..= max).rev ().scan (initial_state, scan_fn).collect ();\n\t\tlet moves: Vec \u003cu64\u003e = Iterator::zip (\n\t\t\tlower.into_iter (),\n\t\t\thigher.into_iter ().rev (),\n\t\t).map (\n\t\t\t|(lower, higher)| lower + higher,\n\t\t).collect ();\n\t\tOk (moves.into_iter ().min ().unwrap ())\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub fn parse_input (input: \u0026 str) -\u003e GenResult \u003cVec \u003cu64\u003e\u003e {\n\t\tOk (input.split (',').map (|pos_str| pos_str.parse ()).collect::\u003cResult \u003c_, _\u003e\u003e ()\n\t\t\t.map_err (|_| format! (\"Invalid input\")) ?)\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 str = \"16,1,2,0,4,2,7,1,2,14\";\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (37, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (168, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[83657,83129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[83224,83245],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[83752,83773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[58560,58909],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[58717,58593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[58825,58687],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[47317,47374],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[47554,47427,47354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":25,"address":[47414,47584,47597],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":27,"address":[47519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[58944,59297],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[58977,59101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[47632,47665,48007],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":34,"address":[47779,47721],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[47759,47824,47847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[48025,47827,47900],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[47887,48064,48077],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":39,"address":[47990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[49296,50436,49277,48112,50197,49038],"length":1,"stats":{"Line":2},"fn_name":"calc_result\u003c(u64, u64, u64), aoc_2021_day_07::logic::part_two::{closure_env#0}\u003e"},{"line":51,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[50656],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":70,"address":[51004,50689],"length":1,"stats":{"Line":6},"fn_name":null},{"line":71,"address":[50917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[21056],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":85,"address":[21301,21063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[21281],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[21344],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":91,"address":[21589,21351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[21569],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":31,"coverable":35},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-08","src","lib.rs"],"content":"//! Advent of Code 2021: Day 8: Seven Segment Search\n//!\n//! [https://adventofcode.com/2021/day/8](https://adventofcode.com/2021/day/8)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Seven Segment Search\";\n\tyear = 2021;\n\tday = 8;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Digit;\n\tuse model::Display;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet displays = model::parse_input (lines) ?;\n\t\tlet mut count: u64 = 0;\n\t\tfor display in displays.iter () {\n\t\t\tfor digit in display.value.iter () {\n\t\t\t\tlet num = digit.segments.iter_vals ().filter (|\u0026 segment| segment).count ();\n\t\t\t\tif [2, 3, 4, 7].contains (\u0026 num) { count += 1 }\n\t\t\t}\n\t\t}\n\t\tOk (count)\n\t}\n\n\t#[ allow (clippy::identity_op) ]\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet displays = model::parse_input (lines) ?;\n\t\tlet mut sum: u64 = 0;\n\t\tfor display in displays.iter () {\n\t\t\tlet digits = get_digits (display);\n\t\t\tlet digit_val = |digit| {\n\t\t\t\tdigits.iter ().position (|\u0026 some_digit| some_digit == digit).unwrap ().as_u64 ()\n\t\t\t};\n\t\t\tsum += [\n\t\t\t\tdigit_val (display.value [0]) * 1000,\n\t\t\t\tdigit_val (display.value [1]) * 100,\n\t\t\t\tdigit_val (display.value [2]) * 10,\n\t\t\t\tdigit_val (display.value [3]) * 1,\n\t\t\t].into_iter ().sum::\u003cu64\u003e ();\n\t\t}\n\t\tOk (sum)\n\t}\n\n\tfn get_digits (display: \u0026 Display) -\u003e Vec \u003cDigit\u003e {\n\t\tfn find_one \u003cT, I: Iterator \u003cItem = T\u003e\u003e (mut iter: I) -\u003e T {\n\t\t\tlet val = iter.next ().unwrap ();\n\t\t\tif iter.next ().is_some () { panic! () }\n\t\t\tval\n\t\t}\n\t\tlet without_segment = |segment: usize| move |digit: \u0026 Digit|\n\t\t\t! digit.segments [segment];\n\t\tlet has_num_segments = |num_segments: usize| move |digit: \u0026 Digit|\n\t\t\tdigit.segments.iter_vals ().filter (|\u0026 segment| segment).count () == num_segments;\n\t\tlet samples = || display.samples.iter_vals ();\n\t\tlet samples_with_segments = |num_segments| samples ().filter (has_num_segments (num_segments));\n\t\tlet digit_1 = find_one (samples_with_segments (2));\n\t\tlet digit_4 = find_one (samples_with_segments (4));\n\t\tlet digit_7 = find_one (samples_with_segments (3));\n\t\tlet digit_8 = find_one (samples_with_segments (7));\n\t\tlet segment_counts: Vec \u003cusize\u003e = (0 .. 7).map (\n\t\t\t|segment| display.samples.iter ().filter (\n\t\t\t\t|sample| sample.segments [segment],\n\t\t\t).count (),\n\t\t).collect ();\n\t\tlet find_segment_freq = |segment_freq| segment_counts.iter ().copied ().position (\n\t\t\t|some_freq| some_freq == segment_freq,\n\t\t).unwrap ();\n\t\tlet segment_b = find_segment_freq (6);\n\t\tlet segment_e = find_segment_freq (4);\n\t\tlet segment_f = find_segment_freq (9);\n\t\tlet digit_2 = find_one (samples_with_segments (5).filter (without_segment (segment_f)));\n\t\tlet segment_c = find_one (\n\t\t\tdigit_1.segments.iter_vals ().enumerate ()\n\t\t\t\t.filter (|\u0026 (index, value)| value \u0026\u0026 index != segment_f)\n\t\t\t\t.map (|(index, _value)| index));\n\t\tlet digit_5 = find_one (samples_with_segments (5).filter (without_segment (segment_c)));\n\t\tlet digit_6 = find_one (samples_with_segments (6).filter (without_segment (segment_c)));\n\t\tlet digit_9 = find_one (samples_with_segments (6).filter (without_segment (segment_e)));\n\t\tlet digit_3 = find_one (\n\t\t\tsamples_with_segments (5)\n\t\t\t\t.filter (without_segment (segment_b))\n\t\t\t\t.filter (without_segment (segment_e)),\n\t\t);\n\t\tlet digit_0 = find_one (\n\t\t\tsamples_with_segments (6)\n\t\t\t\t.filter (|\u0026 sample| sample != digit_6)\n\t\t\t\t.filter (|\u0026 sample| sample != digit_9),\n\t\t);\n\t\tvec! [\n\t\t\tdigit_0, digit_1, digit_2, digit_3, digit_4, digit_5, digit_6, digit_7, digit_8, digit_9,\n\t\t]\n\t}\n\n\t#[ test ]\n\tfn test_get_digits () {\n\t\tlet display = model::parse_display (\n\t\t\t\"acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab \\\n\t\t\t| cdfeb fcadb cdfeb cdbaf\",\n\t\t).unwrap ();\n\t\tlet digits = get_digits (\u0026 display);\n\t\tassert_eq! (display.samples [0], digits [8]);\n\t\tassert_eq! (display.samples [1], digits [5]);\n\t\tassert_eq! (display.samples [2], digits [2]);\n\t\tassert_eq! (display.samples [3], digits [3]);\n\t\tassert_eq! (display.samples [4], digits [7]);\n\t\tassert_eq! (display.samples [5], digits [9]);\n\t\tassert_eq! (display.samples [6], digits [6]);\n\t\tassert_eq! (display.samples [7], digits [4]);\n\t\tassert_eq! (display.samples [8], digits [0]);\n\t\tassert_eq! (display.samples [9], digits [1]);\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cDisplay\u003e\u003e {\n\t\tlet mut displays: Vec \u003cDisplay\u003e = Vec::new ();\n\t\tfor line in lines {\n\t\t\tdisplays.push (parse_display (line) ?);\n\t\t}\n\t\tOk (displays)\n\t}\n\n\tpub fn parse_display (input: \u0026 str) -\u003e GenResult \u003cDisplay\u003e {\n\t\tlet err = || format! (\"Invalid input: {}\", input);\n\t\tlet line_parts: Vec \u003c\u0026 str\u003e = input.split (\" | \").collect ();\n\t\tif line_parts.len () != 2 { Err (err ()) ? }\n\t\tlet samples = parse_digits (line_parts [0]) ?;\n\t\tif samples.len () != 10 { Err (err ()) ? }\n\t\tlet values = parse_digits (line_parts [1]) ?;\n\t\tif values.len () != 4 { Err (err ()) ? }\n\t\tOk (Display {\n\t\t\tsamples: samples.try_into ().map_err (|_| err ()) ?,\n\t\t\tvalue: values.try_into ().map_err (|_| err ()) ?,\n\t\t})\n\t}\n\n\tfn parse_digits (input: \u0026 str) -\u003e GenResult \u003cVec \u003cDigit\u003e\u003e {\n\t\tlet input_parts: Vec \u003c\u0026 str\u003e = input.split (' ').collect ();\n\t\tlet mut digits: Vec \u003cDigit\u003e = Vec::new ();\n\t\tfor part in input_parts {\n\t\t\tdigits.push (parse_digit (part) ?);\n\t\t}\n\t\tOk (digits)\n\t}\n\n\tfn parse_digit (input: \u0026 str) -\u003e GenResult \u003cDigit\u003e {\n\t\tlet mut digit = Digit { segments: [false; 7] };\n\t\tfor (index, letter) in ('a' ..= 'g').enumerate () {\n\t\t\tif input.contains (letter) {\n\t\t\t\tdigit.segments [index] = true;\n\t\t\t}\n\t\t}\n\t\tOk (digit)\n\t}\n\n\t#[ derive (Clone, Copy, Debug, PartialEq, Eq) ]\n\tpub struct Digit {\n\t\tpub segments: [bool; 7],\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Display {\n\t\tpub samples: [Digit; 10],\n\t\tpub value: [Digit; 4],\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe\",\n\t\t\"edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc\",\n\t\t\"fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg\",\n\t\t\"fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb\",\n\t\t\"aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea\",\n\t\t\"fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb\",\n\t\t\"dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe\",\n\t\t\"bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef\",\n\t\t\"egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb\",\n\t\t\"gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (26, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (61229, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[85753,85289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[85374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[85838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[27376,28256],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[27415,27583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[27532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[27701,27886,27552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[27902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[28059],"length":1,"stats":{"Line":3},"fn_name":null},{"line":28,"address":[28138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[27849],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[28288,29739],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":36,"address":[28327,28495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[28444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[28786,28464,28613],"length":1,"stats":{"Line":3},"fn_name":null},{"line":39,"address":[28815],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[28835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[103408,103264,103422],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":43,"address":[29544,29640,29706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[28843,28995,29127],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[29296,29164,29020],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[29189,29334,29466],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[29359,29504,29599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[28749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":53,"address":[32731,29776],"length":1,"stats":{"Line":1},"fn_name":"get_digits"},{"line":54,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[105431,105376,105344,105358],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":60,"address":[105395,105446],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[105486,105504,105472,105610],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":62,"address":[105632,105645,105536],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":63,"address":[29815],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[29823],"length":1,"stats":{"Line":3},"fn_name":null},{"line":65,"address":[29855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[29989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[30123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[30257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[30431,30399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[30423],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[105952,105971,105903],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":74,"address":[30497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":75,"address":[106237,106224,106148],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":77,"address":[30505,30600],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[30608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[30667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[30726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[30938,30996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[30988],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[106352,106379],"length":1,"stats":{"Line":2},"fn_name":"{closure#7}"},{"line":85,"address":[31083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[31284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[31485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[31797,31689,31869],"length":1,"stats":{"Line":3},"fn_name":null},{"line":90,"address":[31740],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[31812],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[32071,31965,32024],"length":1,"stats":{"Line":3},"fn_name":null},{"line":95,"address":[32016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[32063],"length":1,"stats":{"Line":3},"fn_name":null},{"line":98,"address":[32504,32201],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[32224],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[35030,32784],"length":1,"stats":{"Line":3},"fn_name":"test_get_digits"},{"line":109,"address":[32844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[32881,32972,33130],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[33063,33192,33350],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[33571,33413,33283],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[33504,33792,33634],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[33725,33855,34013],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[33946,34076,34234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[34443,34297,34167],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[34385,34500,34633],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[34690,34824,34579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[34769,34881,34983],"length":1,"stats":{"Line":2},"fn_name":null},{"line":128,"address":[37189,36480],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":129,"address":[36523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[36611,36766,37184,36543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":131,"address":[36779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[36679],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[37216,38995,38966],"length":1,"stats":{"Line":1},"fn_name":"parse_display"},{"line":137,"address":[37243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[37269],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[37317,37438,37384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[37390,37835,37671],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[38024,37815,37969],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[37975,38259,38422],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[38554,38639,38403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[39685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[39010,39243,38560,38885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[39559,39172,39460,39845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[40016,40800,40920],"length":1,"stats":{"Line":1},"fn_name":"parse_digits"},{"line":151,"address":[40049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[40105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":153,"address":[40740,40153,40251,40795],"length":1,"stats":{"Line":3},"fn_name":null},{"line":154,"address":[40501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[40816],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[40960],"length":1,"stats":{"Line":1},"fn_name":"parse_digit"},{"line":160,"address":[41003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[41046,41287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[41373,41322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[41383,41350],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[41199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[35417,35408],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":202,"address":[53975,53735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[53955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[35465,35456],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":208,"address":[54263,54023],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[54243],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":104,"coverable":108},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-09","src","lib.rs"],"content":"//! Advent of Code 2021: Day 9: Smoke Basin\n//!\n//! [https://adventofcode.com/2021/day/9](https://adventofcode.com/2021/day/9)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Smoke Basin\";\n\tyear = 2021;\n\tday = 9;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet floor = model::parse_input (lines) ?;\n\t\tlet mut sum: u64 = 0;\n\t\t'OUTER: for (\u0026 pos, \u0026 height) in floor.iter () {\n\t\t\tfor next_pos in [\n\t\t\t\tPos { row: pos.row, col: pos.col - 1 },\n\t\t\t\tPos { row: pos.row, col: pos.col + 1 },\n\t\t\t\tPos { row: pos.row - 1, col: pos.col },\n\t\t\t\tPos { row: pos.row + 1, col: pos.col },\n\t\t\t] {\n\t\t\t\tif let Some (\u0026 next_height) = floor.get (\u0026 next_pos) {\n\t\t\t\t\tif next_height \u003c= height { continue 'OUTER }\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += height.as_u64 () + 1;\n\t\t}\n\t\tOk (sum)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet floor = model::parse_input (lines) ?;\n\t\tlet mut basin_sizes: Vec \u003cu64\u003e = Vec::new ();\n\t\t'OUTER: for (\u0026 pos, \u0026 height) in floor.iter () {\n\t\t\tfor adj_pos in pos.adjacent () {\n\t\t\t\tif let Some (\u0026 adj_height) = floor.get (\u0026 adj_pos) {\n\t\t\t\t\tif adj_height \u003c= height { continue 'OUTER }\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet mut visited: HashSet \u003cPos\u003e = vec! [ pos ].into_iter ().collect ();\n\t\t\tlet mut todo: Vec \u003cPos\u003e = vec! [ pos ];\n\t\t\tlet mut basin_size: u64 = 1;\n\t\t\twhile ! todo.is_empty () {\n\t\t\t\tlet mut next_todo = Vec::new ();\n\t\t\t\tfor pos in todo.into_iter () {\n\t\t\t\t\tlet height = floor [\u0026 pos];\n\t\t\t\t\tfor adj_pos in pos.adjacent () {\n\t\t\t\t\t\tif visited.contains (\u0026 adj_pos) { continue }\n\t\t\t\t\t\tif let Some (\u0026 adj_height) = floor.get (\u0026 adj_pos) {\n\t\t\t\t\t\t\tif adj_height == 9 { continue }\n\t\t\t\t\t\t\tif adj_height \u003c= height { continue }\n\t\t\t\t\t\t\tnext_todo.push (adj_pos);\n\t\t\t\t\t\t\tvisited.insert (adj_pos);\n\t\t\t\t\t\t\tbasin_size += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttodo = next_todo;\n\t\t\t}\n\t\t\tbasin_sizes.push (basin_size);\n\t\t}\n\t\tbasin_sizes.sort ();\n\t\tOk (basin_sizes.into_iter ().rev ().take (3).product ())\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cHashMap \u003cPos, u8\u003e\u003e {\n\t\tlet mut floor: HashMap \u003cPos, u8\u003e = HashMap::new ();\n\t\tfor (row, line) in lines.iter ().enumerate () {\n\t\t\tlet row = row.as_i32 ();\n\t\t\tfor (col, letter) in line.chars ().enumerate () {\n\t\t\t\tlet col = col.as_i32 ();\n\t\t\t\tfloor.insert (Pos { row, col }, letter.to_digit (10).unwrap ().as_u8 ());\n\t\t\t}\n\t\t}\n\t\tOk (floor)\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Pos { pub row: i32, pub col: i32 }\n\n\timpl Pos {\n\t\tpub fn adjacent (\u0026 self) -\u003e Vec \u003cPos\u003e {\n\t\t\tvec! [\n\t\t\t\tPos { row: self.row, col: self.col - 1 },\n\t\t\t\tPos { row: self.row, col: self.col + 1 },\n\t\t\t\tPos { row: self.row - 1, col: self.col },\n\t\t\t\tPos { row: self.row + 1, col: self.col },\n\t\t\t]\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"2199943210\",\n\t\t\"3987894921\",\n\t\t\"9856789892\",\n\t\t\"8767896789\",\n\t\t\"9899965678\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (15, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (1134, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[76345,76809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[76430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[76894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[29488,30871,30660],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[29521,29701],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[29664],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[30833,29689,29961,29813],"length":1,"stats":{"Line":4},"fn_name":null},{"line":25,"address":[30438,30708,30270],"length":1,"stats":{"Line":3},"fn_name":null},{"line":26,"address":[30071,30017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":27,"address":[30056,30111,30140],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[30182,30215,30125],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[30405,30196,30256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[30604,30675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[30692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[30838,30722],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[29927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[31808,33506,30896],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":41,"address":[31123,30935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[31108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[31451,31310,31225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":44,"address":[31856,31515],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[31752,31823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[31840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[31876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[31988,32045],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[32092],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[32168,32112,33215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":53,"address":[32208],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[32215,32334],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[32532],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[32601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[32838],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[33074,32879],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[32955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[32971],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[32979],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[33008],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[33037,33079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[33111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[32174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[31419,33289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[33300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[78512,79365],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":83,"address":[78558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[78581,78895,78660],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[78932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[78963],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[79207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[79241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[78814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[79851,79392],"length":1,"stats":{"Line":1},"fn_name":"adjacent"},{"line":99,"address":[79416,79553,79751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[79451,79518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[79619,79494,79594],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[79658,79689,79602],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[79818,79669,79740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[33728,33737],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":125,"address":[36567,36807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[36787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[33776,33785],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":131,"address":[36855,37095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[37075],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":59,"coverable":62},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-10","src","lib.rs"],"content":"//! Advent of Code 2021: Day 10: Syntax Scoring\n//!\n//! [https://adventofcode.com/2021/day/10](https://adventofcode.com/2021/day/10)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Syntax Scoring\";\n\tyear = 2021;\n\tday = 10;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Delim;\n\tuse model::Mode;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tlet score = input.iter ().flat_map (|line| {\n\t\t\tlet mut stack: Vec \u003cDelim\u003e = Vec::new ();\n\t\t\tline.iter ().copied ().map (move |(delim, mode)| match mode {\n\t\t\t\tMode::Open =\u003e { stack.push (delim); 0 },\n\t\t\t\tMode::Close =\u003e {\n\t\t\t\t\tif stack.pop ().unwrap () != delim {\n\t\t\t\t\t\tdelim.mismatched_points ()\n\t\t\t\t\t} else { 0 }\n\t\t\t\t},\n\t\t\t})\n\t\t}).sum ();\n\t\tOk (score)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tlet mut scores: Vec \u003cu64\u003e = input.iter ().filter_map (|line| {\n\t\t\tlet mut stack: Vec \u003cDelim\u003e = Vec::new ();\n\t\t\tfor (delim, mode) in line.iter ().copied () {\n\t\t\t\tmatch mode {\n\t\t\t\t\tMode::Open =\u003e stack.push (delim),\n\t\t\t\t\tMode::Close =\u003e {\n\t\t\t\t\t\tlet expect = stack.pop ().unwrap ();\n\t\t\t\t\t\tif delim != expect { return None }\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tSome (\n\t\t\t\tstack.into_iter ().rev ().map (Delim::not_closed_points)\n\t\t\t\t\t.fold (0, |total, value| total * 5 + value)\n\t\t\t)\n\t\t}).collect ();\n\t\tscores.sort ();\n\t\tOk (scores [(scores.len () - 1) / 2])\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\ttype Token = (Delim, Mode);\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cVec \u003cToken\u003e\u003e\u003e {\n\t\tlines.iter ().enumerate ().map (|(line_idx, line)| {\n\t\t\tlet line_err = || format! (\"Invalid input: {}: {}\", line_idx + 1, line);\n\t\t\tline.chars ().map (\n\t\t\t\t|letter| decode_char (letter).ok_or_else (|| line_err ().into ()),\n\t\t\t).collect::\u003cGenResult \u003cVec \u003cToken\u003e\u003e\u003e ()\n\t\t}).collect::\u003cGenResult \u003cVec \u003cVec \u003cToken\u003e\u003e\u003e\u003e ()\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Delim { Round, Square, Curly, Angle }\n\n\timpl Delim {\n\t\tpub fn mismatched_points (self) -\u003e u64 {\n\t\t\tmatch self {\n\t\t\t\tDelim::Round =\u003e 3,\n\t\t\t\tDelim::Square =\u003e 57,\n\t\t\t\tDelim::Curly =\u003e 1197,\n\t\t\t\tDelim::Angle =\u003e 25137,\n\t\t\t}\n\t\t}\n\t\tpub fn not_closed_points (self) -\u003e u64 {\n\t\t\tmatch self {\n\t\t\t\tDelim::Round =\u003e 1,\n\t\t\t\tDelim::Square =\u003e 2,\n\t\t\t\tDelim::Curly =\u003e 3,\n\t\t\t\tDelim::Angle =\u003e 4,\n\t\t\t}\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Mode { Open, Close }\n\n\tpub fn decode_char (letter: char) -\u003e Option \u003cToken\u003e {\n\t\tmatch letter {\n\t\t\t'(' =\u003e Some ((Delim::Round, Mode::Open)),\n\t\t\t')' =\u003e Some ((Delim::Round, Mode::Close)),\n\t\t\t'[' =\u003e Some ((Delim::Square, Mode::Open)),\n\t\t\t']' =\u003e Some ((Delim::Square, Mode::Close)),\n\t\t\t'{' =\u003e Some ((Delim::Curly, Mode::Open)),\n\t\t\t'}' =\u003e Some ((Delim::Curly, Mode::Close)),\n\t\t\t'\u003c' =\u003e Some ((Delim::Angle, Mode::Open)),\n\t\t\t'\u003e' =\u003e Some ((Delim::Angle, Mode::Close)),\n\t\t\t_ =\u003e None,\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"[({(\u003c(())[]\u003e[[{[]{\u003c()\u003c\u003e\u003e\",\n\t\t\"[(()[\u003c\u003e])]({[\u003c{\u003c\u003c[]\u003e\u003e(\",\n\t\t\"{([(\u003c{}[\u003c\u003e[]}\u003e{[]{[(\u003c()\u003e\",\n\t\t\"(((({\u003c\u003e}\u003c{\u003c{\u003c\u003e}{[]{[]{}\",\n\t\t\"[[\u003c[([]))\u003c([[{}[[()]]]\",\n\t\t\"[{[{({}]{}}([{[{{{}}([]\",\n\t\t\"{\u003c[[]]\u003e}\u003c{[{[{[]{()[[[]\",\n\t\t\"[\u003c(\u003c(\u003c(\u003c{}))\u003e\u003c([]([]()\",\n\t\t\"\u003c{([([[(\u003c\u003e()){}]\u003e(\u003c\u003c{{\",\n\t\t\"\u003c{([{{}}[\u003c[[[\u003c\u003e{}]]]\u003e[]]\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (26397, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (288957, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[64809,65273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[64894],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[65358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[66544,66909],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[66577,66703],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[21178,21143,20896],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":24,"address":[20934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[21229,20965,21033,21361,21200],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":26,"address":[21257,21371],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[21274,21344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":29,"address":[21346],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[21335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[20982,21135,21171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[66883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[66944,67538,67564],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":38,"address":[67118,66977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[21935,22084,22055,21392],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":40,"address":[21420],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[21451,21747,21519],"length":1,"stats":{"Line":3},"fn_name":null},{"line":42,"address":[21775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[21953,21793],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[21821],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[21884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[22033],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[21684,21974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[22096,22123],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":54,"address":[22077,21917,22047,21468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[67293,67376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":56,"address":[67395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[34400],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":68,"address":[34450],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[49856,49750,49886],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":70,"address":[49770,49817],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[50151,49807,50224,50233,50112],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":80,"address":[34528],"length":1,"stats":{"Line":1},"fn_name":"mismatched_points"},{"line":81,"address":[34539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[34570],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[34581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[34592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[34603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[34624],"length":1,"stats":{"Line":1},"fn_name":"not_closed_points"},{"line":89,"address":[34635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[34666],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[34677],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[34688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[34699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[34720],"length":1,"stats":{"Line":2},"fn_name":"decode_char"},{"line":102,"address":[34732],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[34842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[34869],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[34896],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[34920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[34944],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[34968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[34992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[35016],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[34832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[32560,32569],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":137,"address":[70967,70727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[70947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[32608,32617],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":143,"address":[71255,71015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[71235],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":59,"coverable":63},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-11","src","lib.rs"],"content":"//! Advent of Code 2021: Day 11: Dumbo Octopus\n//!\n//! [https://adventofcode.com/2021/day/11](https://adventofcode.com/2021/day/11)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Dumbo Octopus\";\n\tyear = 2021;\n\tday = 11;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Octopodes;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet octopodes = model::parse_input (lines) ?;\n\t\tOk (\n\t\t\tstep_iter (octopodes)\n\t\t\t\t.take (100)\n\t\t\t\t.sum ()\n\t\t)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet octopodes = model::parse_input (lines) ?;\n\t\tlet num_octopodes = octopodes.len ().as_u64 ();\n\t\tOk (\n\t\t\tstep_iter (octopodes)\n\t\t\t\t.take_while (|\u0026 num_flashes| num_flashes \u003c num_octopodes)\n\t\t\t\t.count ().as_u64 () + 1\n\t\t)\n\t}\n\n\tfn step_iter (octopodes: Octopodes) -\u003e impl Iterator \u003cItem = u64\u003e {\n\t\titer::repeat (()).scan (octopodes, |octopodes, _| {\n\t\t\tlet mut num_flashes: u64 = 0;\n\t\t\tlet mut flashed: HashSet \u003cPos\u003e = HashSet::new ();\n\t\t\tlet mut todo: Vec \u003cPos\u003e = Vec::new ();\n\t\t\tfor (\u0026 pos, energy) in octopodes.iter_mut () {\n\t\t\t\t* energy += 1;\n\t\t\t\tif * energy \u003e 9 {\n\t\t\t\t\t* energy = 0;\n\t\t\t\t\tflashed.insert (pos);\n\t\t\t\t\ttodo.push (pos);\n\t\t\t\t\tnum_flashes += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile ! todo.is_empty () {\n\t\t\t\tlet todo_temp = todo;\n\t\t\t\ttodo = Vec::new ();\n\t\t\t\tfor pos in todo_temp.into_iter () {\n\t\t\t\t\tfor adj_pos in pos.adjacent () {\n\t\t\t\t\t\tif let Some (adj_energy) = octopodes.get_mut (\u0026 adj_pos) {\n\t\t\t\t\t\t\tif flashed.contains (\u0026 adj_pos) { continue }\n\t\t\t\t\t\t\t* adj_energy += 1;\n\t\t\t\t\t\t\tif * adj_energy \u003e 9 {\n\t\t\t\t\t\t\t\t* adj_energy = 0;\n\t\t\t\t\t\t\t\tflashed.insert (adj_pos);\n\t\t\t\t\t\t\t\ttodo.push (adj_pos);\n\t\t\t\t\t\t\t\tnum_flashes += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSome (num_flashes)\n\t\t})\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub type Octopodes = HashMap \u003cPos, u8\u003e;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cOctopodes\u003e {\n\t\tlet mut octopodes: HashMap \u003cPos, u8\u003e = HashMap::new ();\n\t\tfor (row, line) in lines.iter ().enumerate () {\n\t\t\tlet row = row.as_i16 ();\n\t\t\tfor (col, letter) in line.chars ().enumerate () {\n\t\t\t\tlet col = col.as_i16 ();\n\t\t\t\toctopodes.insert (Pos { row, col }, letter.to_digit (10).unwrap ().as_u8 ());\n\t\t\t}\n\t\t}\n\t\tOk (octopodes)\n\t}\n\n\t#[ derive (Clone, Copy, Eq, Hash, PartialEq) ]\n\tpub struct Pos { pub row: i16, pub col: i16 }\n\n\timpl Pos {\n\t\tpub fn adjacent (self) -\u003e Vec \u003cPos\u003e {\n\t\t\tvec! [\n\t\t\t\tPos { row: self.row - 1, col: self.col - 1 },\n\t\t\t\tPos { row: self.row - 1, col: self.col     },\n\t\t\t\tPos { row: self.row - 1, col: self.col + 1 },\n\t\t\t\tPos { row: self.row    , col: self.col - 1 },\n\t\t\t\tPos { row: self.row    , col: self.col + 1 },\n\t\t\t\tPos { row: self.row + 1, col: self.col - 1 },\n\t\t\t\tPos { row: self.row + 1, col: self.col     },\n\t\t\t\tPos { row: self.row + 1, col: self.col + 1 },\n\t\t\t]\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"5483143223\",\n\t\t\"2745854711\",\n\t\t\"5264556173\",\n\t\t\"6141336146\",\n\t\t\"6357385478\",\n\t\t\"4167524645\",\n\t\t\"2176841721\",\n\t\t\"6882881134\",\n\t\t\"4846848554\",\n\t\t\"5283751526\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (1656, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (195, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n\n","traces":[{"line":7,"address":[62793,62329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[62414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[62878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[29848,29424,29875],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[29457,29676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[29790,29601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[30499,29888,30472],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":32,"address":[29921,30090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[30073,30198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[30227,30313,30440],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[30305],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[30512,30660,30636],"length":1,"stats":{"Line":1},"fn_name":"step_iter"},{"line":42,"address":[30583,30531],"length":1,"stats":{"Line":4},"fn_name":null},{"line":43,"address":[70284],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[70312],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[70333],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[70462,70385,70593],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[70691,70655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[70830,70681],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[70738],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[70741],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[70772],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[70793,70835],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[70872,72061,70579],"length":1,"stats":{"Line":6},"fn_name":null},{"line":56,"address":[70921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[70977,71025],"length":1,"stats":{"Line":4},"fn_name":null},{"line":58,"address":[71065,71376,71387],"length":1,"stats":{"Line":6},"fn_name":null},{"line":59,"address":[71368,71379,71414],"length":1,"stats":{"Line":6},"fn_name":null},{"line":60,"address":[71706],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[71798],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[71828,71864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[72004,71854],"length":1,"stats":{"Line":4},"fn_name":null},{"line":64,"address":[71902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":65,"address":[71905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[71936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[71967,72009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[70878],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[74512,73648],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":87,"address":[73694],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[74031,73717,73796],"length":1,"stats":{"Line":6},"fn_name":null},{"line":89,"address":[74068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[74102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[74346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[74384],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[73950],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[75662,74544],"length":1,"stats":{"Line":2},"fn_name":"adjacent"},{"line":103,"address":[75462,74700,74593],"length":1,"stats":{"Line":4},"fn_name":null},{"line":104,"address":[74776,74749,74628],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[74848,74821,74759],"length":1,"stats":{"Line":4},"fn_name":null},{"line":106,"address":[74831,74886,74978],"length":1,"stats":{"Line":4},"fn_name":null},{"line":107,"address":[74961,75053,75026],"length":1,"stats":{"Line":4},"fn_name":null},{"line":108,"address":[75036,75096,75123],"length":1,"stats":{"Line":4},"fn_name":null},{"line":109,"address":[75161,75253,75106],"length":1,"stats":{"Line":4},"fn_name":null},{"line":110,"address":[75236,75334,75301],"length":1,"stats":{"Line":4},"fn_name":null},{"line":111,"address":[75317,75372,75629],"length":1,"stats":{"Line":4},"fn_name":null},{"line":137,"address":[61033,61024],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":138,"address":[66167,66407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[66387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[61072,61081],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":144,"address":[66695,66455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[66675],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":58,"coverable":61},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-12","src","lib.rs"],"content":"//! Advent of Code 2021: Day 12: Passage Pathing\n//!\n//! [https://adventofcode.com/2021/day/12](https://adventofcode.com/2021/day/12)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Passage Pathing\";\n\tyear = 2021;\n\tday = 12;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Caves;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet caves = model::parse_input (lines) ?;\n\t\tOk (calc_result (\u0026 caves, (), |_, route, next_cave| {\n\t\t\tif caves.is_small (next_cave) \u0026\u0026 route.contains (\u0026 next_cave) { return false }\n\t\t\ttrue\n\t\t}))\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet caves = model::parse_input (lines) ?;\n\t\tlet dupe_index: Option \u003c(usize, usize)\u003e = None;\n\t\tOk (calc_result (\u0026 caves, dupe_index, |dupe_index, route, next_cave| {\n\t\t\tif let Some (dupe_index_val) = dupe_index {\n\t\t\t\tif dupe_index_val.1 + 1 \u003e route.len ()\n\t\t\t\t\t\t|| route [dupe_index_val.0] != route [dupe_index_val.1] {\n\t\t\t\t\t* dupe_index = None;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif caves.is_small (next_cave) {\n\t\t\t\tif next_cave == caves.start { return false }\n\t\t\t\tif let Some (prev_pos) = route.iter ()\n\t\t\t\t\t\t.position (|\u0026 some_cave| some_cave == next_cave) {\n\t\t\t\t\tif dupe_index.is_some () { return false }\n\t\t\t\t\t* dupe_index = Some ((prev_pos, route.len ()));\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrue\n\t\t}))\n\t}\n\n\tfn calc_result \u003c\n\t\tState,\n\t\tCheckFn: Fn (\u0026 mut State, \u0026 [usize], usize) -\u003e bool,\n\t\u003e (\n\t\tcaves: \u0026 Caves,\n\t\tstate: State,\n\t\tcheck_fn: CheckFn,\n\t) -\u003e u64 {\n\t\tlet mut state = state;\n\t\tlet mut cache: HashMap \u003c(usize, Vec \u003cusize\u003e), u64\u003e = HashMap::new ();\n\t\tlet mut route: Vec \u003cusize\u003e = vec! [ caves.start ];\n\t\tcalc_recurse (caves, \u0026 mut state, \u0026 check_fn, \u0026 mut cache, \u0026 mut route)\n\t}\n\n\tfn calc_recurse \u003c\n\t\tState,\n\t\tCheckFn: Fn (\u0026 mut State, \u0026 [usize], usize) -\u003e bool,\n\t\u003e (\n\t\tcaves: \u0026 Caves,\n\t\tstate: \u0026 mut State,\n\t\tcheck_fn: \u0026 CheckFn,\n\t\tcache: \u0026 mut HashMap \u003c(usize, Vec \u003cusize\u003e), u64\u003e,\n\t\troute: \u0026 mut Vec \u003cusize\u003e,\n\t) -\u003e u64 {\n\t\tlet this_cave = route.last ().unwrap ().to_owned ();\n\t\tif this_cave == caves.end { return 1 }\n\t\tlet mut route_sorted = route.clone ();\n\t\troute_sorted.sort ();\n\t\tlet cache_key = (this_cave, route_sorted);\n\t\tif let Some (\u0026 cached_val) = cache.get (\u0026 cache_key) { return cached_val }\n\t\tlet mut num_routes: u64 = 0;\n\t\tfor next_cave in caves.connexions [\u0026 this_cave].iter_vals () {\n\t\t\tif ! check_fn (state, route, next_cave) { continue }\n\t\t\troute.push (next_cave);\n\t\t\tnum_routes += calc_recurse (caves, state, check_fn, cache, route);\n\t\t\troute.pop ();\n\t\t}\n\t\tcache.insert (cache_key, num_routes);\n\t\tnum_routes\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cCaves\u003e {\n\t\tlet mut caves = Caves::new ();\n\t\tfor line in lines {\n\t\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split ('-').collect ();\n\t\t\tif line_parts.len () != 2 { Err (format! (\"Invalid input: {}\", line)) ? }\n\t\t\tlet cave_a = caves.name_idx (line_parts [0]);\n\t\t\tlet cave_b = caves.name_idx (line_parts [1]);\n\t\t\tfor (cave_0, cave_1) in [(cave_a, cave_b), (cave_b, cave_a)] {\n\t\t\t\tcaves.connexions.entry (cave_0).or_insert (Vec::new ()).push (cave_1);\n\t\t\t}\n\t\t}\n\t\tOk (caves)\n\t}\n\n\tpub struct Caves {\n\t\tpub connexions: HashMap \u003cusize, Vec \u003cusize\u003e\u003e,\n\t\tpub names: Vec \u003cString\u003e,\n\t\tpub start: usize,\n\t\tpub end: usize,\n\t}\n\n\timpl Caves {\n\t\tfn new () -\u003e Caves {\n\t\t\tCaves {\n\t\t\t\tconnexions: HashMap::new (),\n\t\t\t\tnames: vec! [ \"start\".to_string (), \"end\".to_string () ],\n\t\t\t\tstart: 0,\n\t\t\t\tend: 1,\n\t\t\t}\n\t\t}\n\t\tfn name_idx (\u0026 mut self, name: \u0026 str) -\u003e usize {\n\t\t\tif let Some (pos) = self.names.iter ().position (|some_name| some_name == name) {\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t\tlet pos = self.names.len ();\n\t\t\tself.names.push (name.to_string ());\n\t\t\tpos\n\t\t}\n\t\tpub fn is_small (\u0026 self, index: usize) -\u003e bool {\n\t\t\tself.names [index].chars ().next ().unwrap ().is_lowercase ()\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\t\"start-A\",\n\t\t\"start-b\",\n\t\t\"A-c\",\n\t\t\"A-b\",\n\t\t\"b-d\",\n\t\t\"A-end\",\n\t\t\"b-end\",\n\t];\n\n\tconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\t\"dc-end\",\n\t\t\"HN-start\",\n\t\t\"start-kj\",\n\t\t\"dc-start\",\n\t\t\"dc-HN\",\n\t\t\"LN-dc\",\n\t\t\"HN-end\",\n\t\t\"kj-sa\",\n\t\t\"kj-HN\",\n\t\t\"kj-dc\",\n\t];\n\n\tconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\t\"fs-end\",\n\t\t\"he-DX\",\n\t\t\"fs-he\",\n\t\t\"start-DX\",\n\t\t\"pj-DX\",\n\t\t\"end-zg\",\n\t\t\"zg-sl\",\n\t\t\"zg-pj\",\n\t\t\"pj-he\",\n\t\t\"RW-he\",\n\t\t\"fs-DX\",\n\t\t\"pj-RW\",\n\t\t\"zg-RW\",\n\t\t\"start-pj\",\n\t\t\"he-WI\",\n\t\t\"zg-he\",\n\t\t\"pj-fs\",\n\t\t\"start-RW\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (10, logic::part_one (EXAMPLE_0) ?);\n\t\tassert_eq! (19, logic::part_one (EXAMPLE_1) ?);\n\t\tassert_eq! (226, logic::part_one (EXAMPLE_2) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (36, logic::part_two (EXAMPLE_0) ?);\n\t\tassert_eq! (103, logic::part_two (EXAMPLE_1) ?);\n\t\tassert_eq! (3509, logic::part_two (EXAMPLE_2) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[75225,75689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[75310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[75774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[73616,74043],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[73917,73649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[73884,74020],"length":1,"stats":{"Line":5},"fn_name":null},{"line":23,"address":[25929,25847],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[25922],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[74080,74559],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":29,"address":[74113,74433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":30,"address":[74343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[74355,74536],"length":1,"stats":{"Line":5},"fn_name":null},{"line":32,"address":[26016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[26106,26047,26173,26291,26370],"length":1,"stats":{"Line":5},"fn_name":null},{"line":34,"address":[26309,26153,26211],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[26332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[26379,26074],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[26397,26448],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[26421,26483,26688],"length":1,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[26717,26704,26475],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":42,"address":[26560,26693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[26593],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[26385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[26752,27011,27312,27341,27040,27072],"length":1,"stats":{"Line":2},"fn_name":"calc_result\u003ccore::option::Option\u003c(usize, usize)\u003e, aoc_2021_day_12::logic::part_two::{closure_env#0}\u003e"},{"line":58,"address":[26777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[27099,26799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[26838,26897,27138,27197],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[27246,26946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[27376,30087,28679,28752,30055,28711],"length":1,"stats":{"Line":2},"fn_name":"calc_recurse\u003c(), aoc_2021_day_12::logic::part_one::{closure_env#0}\u003e"},{"line":74,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[91917,90496,91884],"length":1,"stats":{"Line":1},"fn_name":"parse_input"},{"line":98,"address":[90539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[90781,90562,90633],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[90797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[90980,90936,90863],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[91382,90942],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[91422],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[91508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[91806],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[90711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[92315,91936,92223],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":121,"address":[91953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[92031,91973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[92336],"length":1,"stats":{"Line":1},"fn_name":"name_idx"},{"line":128,"address":[92366],"length":1,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[92471],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[92483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[92511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[92559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[92592],"length":1,"stats":{"Line":1},"fn_name":"is_small"},{"line":136,"address":[92606],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[45760],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":193,"address":[46027,45767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[46328,46071,45988],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[46612,46289,46372],"length":1,"stats":{"Line":2},"fn_name":null},{"line":196,"address":[46589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[46656],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":201,"address":[46663,46923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[46884,47224,46967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[47268,47185,47508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":204,"address":[47485],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":71,"coverable":74},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-13","src","lib.rs"],"content":"//! Advent of Code 2021: Day 13: Transparent Origami\n//!\n//! [https://adventofcode.com/2021/day/13](https://adventofcode.com/2021/day/13)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Transparent Origami\";\n\tyear = 2021;\n\tday = 13;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n\tcommands = [\n\t\t( name = \"run\"; method = tool::run; ),\n\t];\n}\n\nmod tool {\n\n\tuse super::*;\n\tuse model::Input;\n\n\t#[ derive (clap::Parser) ]\n\tpub struct RunArgs {\n\n\t\t#[ clap (long, value_parser, default_value = \"inputs/day-13\") ]\n\t\tinput: String,\n\n\t}\n\n\tpub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet input_string = fs::read_to_string (args.input) ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tlet input = Input::parse (\u0026 input_lines) ?;\n\t\tlet mut dots = input.dots;\n\t\tfor fold in input.folds.iter () {\n\t\t\tdots = logic::fold_dots (fold, \u0026 dots);\n\t\t}\n\t\tprint! (\"{}\", logic::DrawDots (\u0026 dots));\n\t\tOk (())\n\t}\n\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Axis;\n\tuse model::Fold;\n\tuse model::Input;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet dots = fold_dots (\u0026 input.folds [0], \u0026 input.dots);\n\t\tOk (dots.len ().as_u64 ())\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet mut dots = input.dots;\n\t\tfor fold in input.folds.iter () {\n\t\t\tdots = fold_dots (fold, \u0026 dots);\n\t\t}\n\t\tlet result = read_dots (\u0026 dots) ?;\n\t\tOk (result)\n\t}\n\n\tpub fn fold_dots (fold: \u0026 Fold, dots: \u0026 HashSet \u003cPos\u003e) -\u003e HashSet \u003cPos\u003e {\n\t\tlet mut new_dots = HashSet::new ();\n\t\tfor mut dot in dots.iter_vals () {\n\t\t\tmatch fold.axis {\n\t\t\t\tAxis::X =\u003e if dot.x \u003e fold.val { dot.x = fold.val - (dot.x - fold.val) },\n\t\t\t\tAxis::Y =\u003e if dot.y \u003e fold.val { dot.y = fold.val - (dot.y - fold.val) },\n\t\t\t}\n\t\t\tnew_dots.insert (dot);\n\t\t}\n\t\tnew_dots\n\t}\n\n\tpub fn read_dots (dots: \u0026 HashSet \u003cPos\u003e) -\u003e GenResult \u003cString\u003e {\n\t\tlet mut result = String::new ();\n\t\tfor offset in (0 .. ).step_by (5) {\n\t\t\tlet mut encoded: u32 = 0;\n\t\t\tfor row in 0 .. 6 {\n\t\t\t\tfor col in 0 .. 5 {\n\t\t\t\t\tencoded \u003c\u003c= 1;\n\t\t\t\t\tif dots.contains (\u0026 Pos { x: offset + col, y: row }) {\n\t\t\t\t\t\tencoded |= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.push (match encoded {\n\t\t\t\t0x19297a52 =\u003e 'A',\n\t\t\t\t0x392e4a5c =\u003e 'B',\n\t\t\t\t0x1928424c =\u003e 'C',\n\t\t\t\t0x3d0e421e =\u003e 'E',\n\t\t\t\t0x19285a4e =\u003e 'G',\n\t\t\t\t0x3d0e4210 =\u003e 'F',\n\t\t\t\t0x0c210a4c =\u003e 'J',\n\t\t\t\t0x252f4a52 =\u003e 'H',\n\t\t\t\t0x254c5292 =\u003e 'K',\n\t\t\t\t0x2108421e =\u003e 'L',\n\t\t\t\t0x39297210 =\u003e 'P',\n\t\t\t\t0x39297292 =\u003e 'R',\n\t\t\t\t0x25294a4c =\u003e 'U',\n\t\t\t\t0x3c22221e =\u003e 'Z',\n\t\t\t\t0x00000000 =\u003e break,\n\t\t\t\t_ =\u003e Err (format! (\"Unrecognised character: {:#08x} in position {}\", encoded,\n\t\t\t\t\tresult.len () + 1)) ?,\n\t\t\t});\n\t\t}\n\t\tOk (result)\n\t}\n\n\tpub struct DrawDots \u003c'a\u003e (pub \u0026 'a HashSet \u003cPos\u003e);\n\n\timpl \u003c'a\u003e fmt::Display for DrawDots \u003c'a\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet dots = {\n\t\t\t\tlet mut dots_temp: Vec \u003cPos\u003e =\n\t\t\t\t\tself.0.iter_vals ().collect ();\n\t\t\t\tdots_temp.sort_by_key (|pos| (pos.y, pos.x));\n\t\t\t\tdots_temp\n\t\t\t};\n\t\t\tlet mut row: i64 = -1;\n\t\t\tlet mut col: i64 = -1;\n\t\t\tfor dot in dots {\n\t\t\t\twhile row \u003c dot.y {\n\t\t\t\t\twrite! (formatter, \"\\n\") ?;\n\t\t\t\t\tcol = -1;\n\t\t\t\t\trow += 1;\n\t\t\t\t}\n\t\t\t\twhile col \u003c dot.x {\n\t\t\t\t\twrite! (formatter, \"  \") ?;\n\t\t\t\t\tcol += 1;\n\t\t\t\t}\n\t\t\t\twrite! (formatter, \"##\") ?;\n\t\t\t\tcol += 1;\n\t\t\t}\n\t\t\twrite! (formatter, \"\\n\\n\") ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\t#[ derive (Debug) ]\n\tpub struct Input {\n\t\tpub dots: HashSet \u003cPos\u003e,\n\t\tpub folds: Vec \u003cFold\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet mut lines_iter = lines.iter ();\n\t\t\tlet mut dots = HashSet::new ();\n\t\t\tfor line in lines_iter.by_ref () {\n\t\t\t\tif line.is_empty () { break }\n\t\t\t\tlet line_err = || format! (\"Invalid input: {}\", line);\n\t\t\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split (',').collect ();\n\t\t\t\tif line_parts.len () != 2 { Err (line_err ()) ? }\n\t\t\t\tdots.insert (Pos {\n\t\t\t\t\tx: line_parts [0].parse ().map_err (|_| line_err ()) ?,\n\t\t\t\t\ty: line_parts [1].parse ().map_err (|_| line_err ()) ?,\n\t\t\t\t});\n\t\t\t}\n\t\t\tlet mut folds = Vec::new ();\n\t\t\tfor line in lines_iter.by_ref () {\n\t\t\t\tlet line_err = || format! (\"Invalid input: {}\", line);\n\t\t\t\tif let Some (line) = line.strip_prefix (\"fold along x=\") {\n\t\t\t\t\tfolds.push (Fold { axis: Axis::X, val: line.parse () ? });\n\t\t\t\t} else if let Some (line) = line.strip_prefix (\"fold along y=\") {\n\t\t\t\t\tfolds.push (Fold { axis: Axis::Y, val: line.parse () ? });\n\t\t\t\t} else {\n\t\t\t\t\tErr (line_err ()) ?\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (Input { dots, folds })\n\t\t}\n\t}\n\n\t#[ derive (Debug) ]\n\tpub struct Fold {\n\t\tpub axis: Axis,\n\t\tpub val: i64,\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub enum Axis { X, Y }\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Pos { pub x: i64, pub y: i64 }\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"6,10\",\n\t\t\"0,14\",\n\t\t\"9,10\",\n\t\t\"0,3\",\n\t\t\"10,4\",\n\t\t\"4,11\",\n\t\t\"6,0\",\n\t\t\"6,12\",\n\t\t\"4,1\",\n\t\t\"0,13\",\n\t\t\"10,12\",\n\t\t\"3,4\",\n\t\t\"3,0\",\n\t\t\"8,4\",\n\t\t\"1,10\",\n\t\t\"2,14\",\n\t\t\"8,10\",\n\t\t\"9,0\",\n\t\t\"\",\n\t\t\"fold along y=7\",\n\t\t\"fold along x=5\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (17, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[44009,44473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[44094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[44558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[118704,117264,118843],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":32,"address":[117271,117471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[117601,117448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[118074,117770,117679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[117998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[118054,118455,118588,118283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[118487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[118419,118603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[118677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[122374,122400,121872],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":55,"address":[121905,122139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[122111,122253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[122268,122322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[123562,123442,122416],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":61,"address":[122749,122449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[122680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[123012,122858,123145,122727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[123044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[123002,123150,123354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[123268],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[124225,123600],"length":1,"stats":{"Line":1},"fn_name":"fold_dots"},{"line":71,"address":[123646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[123811,123664,123721],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[123843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[124078,123862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[123886,123935],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[123904,124220],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[126416,124256],"length":1,"stats":{"Line":0},"fn_name":"read_dots"},{"line":83,"address":[124295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[124649,124308,124408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[124673],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[124684,125171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[125195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[125391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[125429,125562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[125545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[126389,124864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[125595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[125611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[125627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[125643],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[125659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[125675],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[125691],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[125707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[125723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[125739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[125755],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[125771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[125787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[125803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[126310,125575,125893,125975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[125847,126233,125922,126332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[124553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[58496,61239,59940],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":161,"address":[58567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[58592],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[58771,58613,58670],"length":1,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[58787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[40288,40306],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":166,"address":[58839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[59038,58905,58978],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[59724],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[40422,40400],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":170,"address":[40470,40448],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":173,"address":[58761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[59959,60300,60016],"length":1,"stats":{"Line":3},"fn_name":null},{"line":175,"address":[40514,40496],"length":1,"stats":{"Line":1},"fn_name":"{closure#3}"},{"line":176,"address":[60332],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[61234,61079,60464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[60494,60757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[60919,60624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[60670,60770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[60102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[55984,55993],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":233,"address":[135799,135559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[135779],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":32,"coverable":100},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-14","src","lib.rs"],"content":"//! Advent of Code 2021: Day 14: Extended Polymerization\n//!\n//! [https://adventofcode.com/2021/day/14](https://adventofcode.com/2021/day/14)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Extended Polymerization\";\n\tyear = 2021;\n\tday = 14;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result (10, lines)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tcalc_result (40, lines)\n\t}\n\n\tpub fn calc_result (loops: usize, lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet mut global_counts = {\n\t\t\tlet mut global_counts = HashMap::new ();\n\t\t\tfor letter in input.template.chars () {\n\t\t\t\t* global_counts.entry (letter).or_insert (0) += 1;\n\t\t\t}\n\t\t\tglobal_counts\n\t\t};\n\t\tstruct Frame {\n\t\t\tcounts: HashMap \u003cchar, usize\u003e,\n\t\t\tletter_0: char,\n\t\t\tletter_1: char,\n\t\t\tloops: usize,\n\t\t\tpending: bool,\n\t\t}\n\t\tlet mut stack = {\n\t\t\tlet mut stack = Vec::new ();\n\t\t\tlet mut letter_0 = input.template.chars ().next ().unwrap ();\n\t\t\tfor letter_1 in input.template.chars ().skip (1) {\n\t\t\t\tstack.push (Frame {\n\t\t\t\t\tcounts: HashMap::new (),\n\t\t\t\t\tletter_0,\n\t\t\t\t\tletter_1,\n\t\t\t\t\tloops,\n\t\t\t\t\tpending: true,\n\t\t\t\t});\n\t\t\t\tletter_0 = letter_1;\n\t\t\t}\n\t\t\tstack\n\t\t};\n\t\tlet mut cache: HashMap \u003c(char, char, usize), HashMap \u003cchar, usize\u003e\u003e = HashMap::new ();\n\t\twhile let Some (frame) = stack.last_mut () {\n\t\t\tlet cache_key = (frame.letter_0, frame.letter_1, frame.loops);\n\t\t\tif frame.pending \u0026\u0026 frame.loops \u003e 0 {\n\t\t\t\tif let Some (cached_counts) = cache.get (\u0026 cache_key) {\n\t\t\t\t\tframe.counts = cached_counts.clone ();\n\t\t\t\t\tframe.pending = false;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif let Some (\u0026 letter_insert) = input.rules.get (\u0026 (frame.letter_0, frame.letter_1)) {\n\t\t\t\t\t* frame.counts.entry (letter_insert).or_insert (0) += 1;\n\t\t\t\t\tframe.pending = false;\n\t\t\t\t\tfor new_frame in vec! [\n\t\t\t\t\t\tFrame {\n\t\t\t\t\t\t\tcounts: HashMap::new (),\n\t\t\t\t\t\t\tletter_0: frame.letter_0,\n\t\t\t\t\t\t\tletter_1: letter_insert,\n\t\t\t\t\t\t\tloops: frame.loops - 1,\n\t\t\t\t\t\t\tpending: true,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tFrame {\n\t\t\t\t\t\t\tcounts: HashMap::new (),\n\t\t\t\t\t\t\tletter_0: letter_insert,\n\t\t\t\t\t\t\tletter_1: frame.letter_1,\n\t\t\t\t\t\t\tloops: frame.loops - 1,\n\t\t\t\t\t\t\tpending: true,\n\t\t\t\t\t\t}\n\t\t\t\t\t] {\n\t\t\t\t\t\tstack.push (new_frame);\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tframe.pending = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet frame = stack.pop ().unwrap ();\n\t\t\tlet prev_counts =\n\t\t\t\tif let Some (prev_frame) =\n\t\t\t\t\tstack.iter_mut ().rev ()\n\t\t\t\t\t\t.find (|some_frame| some_frame.loops != frame.loops)\n\t\t\t\t{ \u0026 mut prev_frame.counts } else { \u0026 mut global_counts };\n\t\t\tfor (\u0026 letter, count) in frame.counts.iter () {\n\t\t\t\t* prev_counts.entry (letter).or_insert (0) += count;\n\t\t\t}\n\t\t\tif frame.loops \u003e 0 {\n\t\t\t\tcache.entry (cache_key).or_insert (frame.counts);\n\t\t\t}\n\t\t}\n\t\tlet most = global_counts.values ().max ().unwrap ();\n\t\tlet least = global_counts.values ().min ().unwrap ();\n\t\tOk ((most - least).as_u64 ())\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub struct Input {\n\t\tpub template: String,\n\t\tpub rules: HashMap \u003c(char, char), char\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet template = lines [0].to_string ();\n\t\t\tlet mut rules = HashMap::new ();\n\t\t\tfor line in lines.iter ().skip (2) {\n\t\t\t\tlet line_err = || format! (\"Invalid input: {}\", line);\n\t\t\t\tlet mut line_iter = line.chars ();\n\t\t\t\tlet letter_before = line_iter.next ().ok_or_else (line_err) ?;\n\t\t\t\tlet letter_after = line_iter.next ().ok_or_else (line_err) ?;\n\t\t\t\tif iter::from_fn (|| line_iter.next ()).take (4).collect::\u003cString\u003e () != \" -\u003e \" {\n\t\t\t\t\tErr (line_err ()) ?;\n\t\t\t\t}\n\t\t\t\tlet letter_insert = line_iter.next ().ok_or_else (line_err) ?;\n\t\t\t\trules.insert ((letter_before, letter_after), letter_insert);\n\t\t\t}\n\t\t\tOk (Input { template, rules })\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"NNCB\",\n\t\t\"\",\n\t\t\"CH -\u003e B\",\n\t\t\"HH -\u003e N\",\n\t\t\"CB -\u003e H\",\n\t\t\"NH -\u003e C\",\n\t\t\"HB -\u003e C\",\n\t\t\"HC -\u003e B\",\n\t\t\"HN -\u003e C\",\n\t\t\"NN -\u003e C\",\n\t\t\"BH -\u003e H\",\n\t\t\"NC -\u003e B\",\n\t\t\"NB -\u003e B\",\n\t\t\"BN -\u003e B\",\n\t\t\"BB -\u003e N\",\n\t\t\"BC -\u003e B\",\n\t\t\"CC -\u003e N\",\n\t\t\"CN -\u003e C\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (1588, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (2188189693529, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[96009,96473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[96094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[96558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[76224],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[76251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[76272],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":26,"address":[76299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[76320,77226,81024],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":30,"address":[76413,76660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[76645],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[77076,76850,76770,77189],"length":1,"stats":{"Line":4},"fn_name":null},{"line":34,"address":[77106,77194],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[77010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[77066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[77365,77289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[77962,77496,77789],"length":1,"stats":{"Line":3},"fn_name":null},{"line":49,"address":[77847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[77818],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[77840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[77955],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[77739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[78007,77779],"length":1,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[81000,78093,78017],"length":1,"stats":{"Line":3},"fn_name":null},{"line":62,"address":[78174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[78549,78206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[78636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[78717,80138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[80236],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[78735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[78868,79005,78904],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[78976],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[79071,79502,79737,78990,80098,79332],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[79154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[79059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[79111],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[79118,79247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[79424],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[79240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[79372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[79644,79379],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[79995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[78883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[78887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[78610,80245],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[80486,80536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[80291,80445,80359],"length":1,"stats":{"Line":3},"fn_name":null},{"line":99,"address":[37008,37021],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":100,"address":[80538,80528],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[80715,80570],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[80753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[80702],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[80839],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[78237],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[78329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[78413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[97200,99126,98554],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":126,"address":[97246],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[97322],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[97799,97383,97464],"length":1,"stats":{"Line":3},"fn_name":null},{"line":129,"address":[44082,44064],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":130,"address":[97831],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[97897,98028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[98165,98009,98295],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[44185,44176],"length":1,"stats":{"Line":5},"fn_name":"{closure#1}"},{"line":134,"address":[98613,98707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[98583,98829,98973],"length":1,"stats":{"Line":2},"fn_name":null},{"line":137,"address":[99121,98922],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[97603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[51520],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":173,"address":[51527,51767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[51747],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[51808],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":179,"address":[51815,52055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[52035],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":68,"coverable":74},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-15","src","lib.rs"],"content":"//! Advent of Code 2021: Day 15: Chiton\n//!\n//! [https://adventofcode.com/2021/day/15](https://adventofcode.com/2021/day/15)\n//!\n//! This is a relatively simple path finder. We use [`PrioritySearch`](search::PrioritySearch) to\n//! prioritise the routes with the lowest risk, and keep a cache of the best ones so far to each\n//! point so we can short-circuit appropriately.\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Chiton\";\n\tyear = 2021;\n\tday = 15;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Cave;\n\tuse model::Grid;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\tuse search::PrioritySearch;\n\tuse search::PrioritySearchAdder;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet cave = Cave::parse (lines) ?;\n\t\tcalc_result (\u0026 cave)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut cave = Cave::parse (lines) ?;\n\t\tlet risks = {\n\t\t\tlet cave_risks = \u0026 cave.risks;\n\t\t\t(0 .. 5).flat_map (move |rep_y| (0 ..= cave.end.y).flat_map (move |y|\n\t\t\t\t(0 .. 5).flat_map (move |rep_x| (0 ..= cave.end.x).map (move |x| {\n\t\t\t\t\tlet orig_risk = cave_risks.get (Pos { y, x }).unwrap ();\n\t\t\t\t\t(orig_risk + rep_y + rep_x - 1) % 9 + 1\n\t\t\t\t})),\n\t\t\t)).collect ()\n\t\t};\n\t\tlet new_size = [cave.risks.size () [0] * 5, cave.risks.size () [1] * 5];\n\t\tcave.risks = Grid::wrap (risks, [0, 0], new_size);\n\t\tcave.end = Pos { y: (cave.end.y + 1) * 5 - 1, x: (cave.end.x + 1) * 5 - 1 };\n\t\tcalc_result (\u0026 cave)\n\t}\n\n\tpub fn calc_result (cave: \u0026 Cave) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut search = PrioritySearch::with_grid (\n\t\t\t[0, 0],\n\t\t\tcave.risks.size (),\n\t\t\t|pos: Pos, path_risk, mut adder: PrioritySearchAdder \u003cPos, u64, _\u003e| {\n\t\t\t\tfor adj_pos in pos.adjacent_4 () {\n\t\t\t\t\tif let Some (adj_risk) = cave.risks.get (adj_pos) {\n\t\t\t\t\t\tlet adj_path_risk = path_risk + adj_risk.as_u64 ();\n\t\t\t\t\t\tadder.add (adj_pos, adj_path_risk);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(pos, path_risk)\n\t\t\t},\n\t\t);\n\t\tsearch.push (cave.start, 0);\n\t\tlet best = search\n\t\t\t.filter (|\u0026 (pos, _)| pos == cave.end)\n\t\t\t.map (|(_, score)| score)\n\t\t\t.next ().unwrap ();\n\t\tOk (best)\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub type Grid \u003cVal\u003e = grid::Grid \u003cVec \u003cVal\u003e, Pos, 2\u003e;\n\tpub type Pos = pos::PosYX \u003ci16\u003e;\n\n\tpub struct Cave {\n\t\tpub risks: Grid \u003cu8\u003e,\n\t\tpub start: Pos,\n\t\tpub end: Pos,\n\t}\n\n\timpl Cave {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cCave\u003e {\n\t\t\tlet mut risks = Vec::new ();\n\t\t\tfor (line_idx, line) in lines.iter ().enumerate () {\n\t\t\t\tlet line_err = || format! (\"Invalid input on line {}: {}\", line_idx + 1, line);\n\t\t\t\tfor letter in line.chars () {\n\t\t\t\t\trisks.push (letter.to_digit (10).ok_or_else (line_err) ?.as_u8 ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet risks = Grid::wrap (risks, [0, 0], [lines.len (), lines [0].len ()]);\n\t\t\tlet start = Pos { x: 0, y: 0 };\n\t\t\tlet end = Pos { x: risks.size () [1].as_i16 () - 1, y: risks.size () [0].as_i16 () - 1 };\n\t\t\tOk (Cave { risks, start, end })\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"1163751742\", \"1381373672\", \"2136511328\", \"3694931569\", \"7463417111\",\n\t\t\"1319128137\", \"1359912421\", \"3125421639\", \"1293138521\", \"2311944581\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (40, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (315, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":11,"address":[56665,57129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[56750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[57214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[83568,83873],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":30,"address":[83600,83774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[83763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[85224,83904],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":35,"address":[83937,84215],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[84113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[86576,86610,86736,86827],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":39,"address":[87293,86761,86866,86832,86992],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":40,"address":[87017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[87110,87298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[84331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":45,"address":[84397,84352,84654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":46,"address":[84692,84535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[84772,85146],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[85139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[85264,85795,85743],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":53,"address":[85302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[85326],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[85344],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[87392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[87750,87674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[87760,87742,87842],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[87824,87874],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[87920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[85399],"length":1,"stats":{"Line":1},"fn_name":null},{"line":66,"address":[85468,85565,85694],"length":1,"stats":{"Line":3},"fn_name":null},{"line":67,"address":[85557],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[88032,88040],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":70,"address":[85768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[67488,69208,68736],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":91,"address":[67540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[67671,67591,67925],"length":1,"stats":{"Line":3},"fn_name":null},{"line":93,"address":[79696,79726],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":94,"address":[67989,68469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[68447,68157],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[68474,67838,68714],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[68671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[69175,68707,68787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[68961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[43456],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":119,"address":[43703,43463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[43683],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[43744],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":125,"address":[43751,43991],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[43971],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":45,"coverable":48},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-16","src","lib.rs"],"content":"//! Advent of Code 2021: Day 15: Packet Decoder\n//!\n//! [https://adventofcode.com/2021/day/16](https://adventofcode.com/2021/day/16)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Packet Decoder\";\n\tyear = 2021;\n\tday = 16;\n\tpart_one = |lines| logic::part_one (lines [0]);\n\tpart_two = |lines| logic::part_two (lines [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::BitIter;\n\tuse model::Packet;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut input_iter = BitIter::new (input);\n\t\tlet packet = Packet::decode (\u0026 mut input_iter).unwrap ();\n\t\tOk (packet.version_sum ())\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003cu64\u003e {\n\t\tlet mut input_iter = BitIter::new (input);\n\t\tlet packet = Packet::decode (\u0026 mut input_iter).unwrap ();\n\t\tOk (packet_eval (\u0026 packet))\n\t}\n\n\tfn packet_eval (packet: \u0026 Packet) -\u003e u64 {\n\t\tlet child_vals = || packet.children.iter ().map (packet_eval);\n\t\tlet child_at = |pos| child_vals ().nth (pos).unwrap ();\n\t\tlet from_bool = |val| if val { 1 } else { 0 };\n\t\tmatch packet.packet_type {\n\t\t\t0 =\u003e child_vals ().sum (),\n\t\t\t1 =\u003e child_vals ().product (),\n\t\t\t2 =\u003e child_vals ().min ().unwrap (),\n\t\t\t3 =\u003e child_vals ().max ().unwrap (),\n\t\t\t4 =\u003e packet.value,\n\t\t\t5 =\u003e from_bool (child_at (0) \u003e child_at (1)),\n\t\t\t6 =\u003e from_bool (child_at (0) \u003c child_at (1)),\n\t\t\t7 =\u003e from_bool (child_at (0) == child_at (1)),\n\t\t\t_ =\u003e panic! (),\n\t\t}\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\t#[ allow (dead_code) ]\n\t#[ derive (Debug) ]\n\tpub struct Packet {\n\t\tpub version: u64,\n\t\tpub packet_type: u64,\n\t\tpub value: u64,\n\t\tpub children: Vec \u003cPacket\u003e,\n\t}\n\n\timpl Packet {\n\t\tpub fn decode (iter: \u0026 mut BitIter \u003c'_\u003e) -\u003e Option \u003cPacket\u003e {\n\t\t\tif ! iter.has_next () { return None }\n\t\t\tlet version = iter.next_uint (3).unwrap ();\n\t\t\tlet packet_type = iter.next_uint (3).unwrap ();\n\t\t\tlet mut value = 0;\n\t\t\tlet mut children = Vec::new ();\n\t\t\tif packet_type == 4 {\n\t\t\t\tlet mut bits = 0;\n\t\t\t\tloop {\n\t\t\t\t\tlet is_last = iter.next_bit ().unwrap () == 0;\n\t\t\t\t\tif bits + 4 \u003e 64 { panic! (); }\n\t\t\t\t\tvalue = value \u003c\u003c 4 | iter.next_uint (4).unwrap ();\n\t\t\t\t\tbits += 4;\n\t\t\t\t\tif is_last { break }\n\t\t\t\t}\n\t\t\t} else if iter.next_bit ().unwrap () == 0 {\n\t\t\t\tlet child_bits = iter.next_uint (15).unwrap ();\n\t\t\t\tlet end_position = iter.position + child_bits;\n\t\t\t\twhile iter.position \u003c end_position {\n\t\t\t\t\tchildren.push (Packet::decode (iter).unwrap ());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet num_children = iter.next_uint (11).unwrap ();\n\t\t\t\tfor _ in 0 .. num_children {\n\t\t\t\t\tchildren.push (Packet::decode (iter).unwrap ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tSome (Packet { version, packet_type, value, children })\n\t\t}\n\t\tpub fn version_sum (\u0026 self) -\u003e u64 {\n\t\t\tself.version + self.children.iter ().map (\n\t\t\t\t|child| child.version_sum (),\n\t\t\t).sum::\u003cu64\u003e ()\n\t\t}\n\t}\n\n\tpub struct BitIter \u003c'a\u003e {\n\t\tinner: Chars \u003c'a\u003e,\n\t\tbuffer: Vec \u003cu64\u003e,\n\t\tposition: u64,\n\t}\n\n\timpl \u003c'a\u003e BitIter \u003c'a\u003e {\n\t\tpub fn new (inner_str: \u0026 'a str) -\u003e BitIter \u003c'a\u003e {\n\t\t\tBitIter {\n\t\t\t\tinner: inner_str.chars (),\n\t\t\t\tbuffer: Vec::with_capacity (4),\n\t\t\t\tposition: 0,\n\t\t\t}\n\t\t}\n\t\tfn next_uint (\u0026 mut self, bits: u8) -\u003e Option \u003cu64\u003e {\n\t\t\tif bits \u003e 64 { panic! (); }\n\t\t\tlet mut val = 0;\n\t\t\tfor _ in 0 .. bits {\n\t\t\t\tlet next_bit = self.next_bit ().unwrap ();\n\t\t\t\tval = val \u003c\u003c 1 | next_bit;\n\t\t\t}\n\t\t\tSome (val)\n\t\t}\n\t\tfn next_bit (\u0026 mut self) -\u003e Option \u003cu64\u003e {\n\t\t\tif ! self.has_next () { return None }\n\t\t\tself.position += 1;\n\t\t\tself.buffer.pop ()\n\t\t}\n\t\tfn has_next (\u0026 mut self) -\u003e bool {\n\t\t\tif self.buffer.is_empty () {\n\t\t\t\tif let Some (next_char) = self.inner.next () {\n\t\t\t\t\tlet mut next_nibble = next_char.to_digit (16).unwrap ().as_u64 ();\n\t\t\t\t\tfor _ in 0 .. 4 {\n\t\t\t\t\t\tself.buffer.push (next_nibble \u0026 1);\n\t\t\t\t\t\tnext_nibble \u003e\u003e= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t! self.buffer.is_empty ()\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (6, logic::part_one (\"D2FE28\") ?);\n\t\tassert_eq! (9, logic::part_one (\"38006F45291200\") ?);\n\t\tassert_eq! (14, logic::part_one (\"EE00D40C823060\") ?);\n\t\tassert_eq! (16, logic::part_one (\"8A004A801A8002F478\") ?);\n\t\tassert_eq! (12, logic::part_one (\"620080001611562C8802118E34\") ?);\n\t\tassert_eq! (23, logic::part_one (\"C0015000016115A2E0802F182340\") ?);\n\t\tassert_eq! (31, logic::part_one (\"A0016C880162017C3686B18A3D4780\") ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (3, logic::part_two (\"C200B40A82\") ?);\n\t\tassert_eq! (54, logic::part_two (\"04005AC33890\") ?);\n\t\tassert_eq! (7, logic::part_two (\"880086C3E88112\") ?);\n\t\tassert_eq! (9, logic::part_two (\"CE00C43D881120\") ?);\n\t\tassert_eq! (1, logic::part_two (\"D8005AC2A8F0\") ?);\n\t\tassert_eq! (0, logic::part_two (\"F600BC2D8F\") ?);\n\t\tassert_eq! (0, logic::part_two (\"9C005AC2F8F0\") ?);\n\t\tassert_eq! (1, logic::part_two (\"9C0141080250320F1802104A08\") ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[35865,36393],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[35960,35981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[36488,36509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[65547,65570,65344],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":22,"address":[65377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[65441,65397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":24,"address":[65524,65470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[65803,65826,65600],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":28,"address":[65633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[65697,65653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[65726,65780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[65856],"length":1,"stats":{"Line":1},"fn_name":"packet_eval"},{"line":34,"address":[65879],"length":1,"stats":{"Line":3},"fn_name":null},{"line":35,"address":[65895],"length":1,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[37733,37712],"length":1,"stats":{"Line":2},"fn_name":"{closure#2}"},{"line":37,"address":[65903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[66717,65975],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[66009,66683],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[66037,66624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[66563,66065],"length":1,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[66101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":43,"address":[66118,66452],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[66161,66354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[66204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[65945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[62288,63872],"length":1,"stats":{"Line":1},"fn_name":"decode"},{"line":68,"address":[62338,62407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[62371,62447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[62484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[62555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[62567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[62588],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[62594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[62605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[63514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[63673,63589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[63719,63654],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[63839,63790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[63826],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[62618,62697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[63298,62750],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[63342,63373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[63371,63418],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[63444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[62789],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[62870],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[63217],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[63050],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[63904],"length":1,"stats":{"Line":1},"fn_name":"version_sum"},{"line":97,"address":[64045,63913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[46592,46619],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[20816,20825],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":154,"address":[39358,39063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[39657,39321,39402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[39620,39956,39701],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[40255,39919,40000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[40218,40554,40299],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[40517,40598,40853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[40897,41137,40816],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[41114],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[20873,20864],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":166,"address":[41191,41504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[41809,41464,41548],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[42114,41772,41853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[42077,42158,42419],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[42724,42382,42463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[42687,42768,43029],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[42992,43334,43073],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[43378,43629,43297],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[43602],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":88,"coverable":92},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-17","src","lib.rs"],"content":"//! Advent of Code 2021: Day 17: Trick Shot\n//!\n//! [https://adventofcode.com/2021/day/17](https://adventofcode.com/2021/day/17)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Trick Shot\";\n\tyear = 2021;\n\tday = 17;\n\tpart_one = |lines| logic::part_one (lines [0]);\n\tpart_two = |lines| logic::part_two (lines [0]);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Input;\n\tuse model::Position;\n\tuse model::Velocity;\n\tuse nums::IntConv;\n\n\tpub fn part_one (input: \u0026 str) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (input) ?;\n\t\tlet results = find_solutions (\u0026 input) ?;\n\t\tOk (results.into_iter ().map (|(_, height)| height).max ().unwrap ())\n\t}\n\n\tpub fn part_two (input: \u0026 str) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (input) ?;\n\t\tlet results = find_solutions (\u0026 input) ?;\n\t\tOk (results.len ().as_i64 ())\n\t}\n\n\tfn find_solutions (input: \u0026 Input) -\u003e GenResult \u003cVec \u003c(Velocity, i64)\u003e\u003e {\n\t\tlet mut results: Vec \u003c(Velocity, i64)\u003e = Vec::new ();\n\t\tfor x_velocity in 1 ..= * input.target_x.end () {\n\t\t\tfor y_velocity in * input.target_y.start () ..= -2 * input.target_y.end () {\n\t\t\t\tlet velocity = Velocity { x: x_velocity, y: y_velocity };\n\t\t\t\tif let Some (max_height) = simulate (input, velocity) {\n\t\t\t\t\tresults.push ((velocity, max_height));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tOk (results)\n\t}\n\n\tfn simulate (input: \u0026 Input, velocity: Velocity) -\u003e Option \u003ci64\u003e {\n\t\tlet mut position = Position { x: 0, y: 0 };\n\t\tlet mut velocity = velocity;\n\t\tlet mut max_height = 0;\n\t\twhile ! ((velocity.x == 0 \u0026\u0026 position.x \u003c * input.target_x.start ())\n\t\t\t\t|| (position.x \u003e * input.target_x.end ())\n\t\t\t\t|| (velocity.y \u003c= 0 \u0026\u0026 position.y \u003c * input.target_y.start ())) {\n\t\t\tif input.target_x.contains (\u0026 position.x)\n\t\t\t\t\t\u0026\u0026 input.target_y.contains (\u0026 position.y) {\n\t\t\t\treturn Some (max_height);\n\t\t\t}\n\t\t\tposition.x += velocity.x;\n\t\t\tif velocity.x \u003e 0 { velocity.x -= 1; }\n\t\t\tposition.y += velocity.y;\n\t\t\tvelocity.y -= 1;\n\t\t\tif position.y \u003e max_height { max_height = position.y; }\n\t\t}\n\t\tNone\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\t#[ derive (Clone, Debug) ]\n\tpub struct Input {\n\t\tpub target_x: RangeInclusive \u003ci64\u003e,\n\t\tpub target_y: RangeInclusive \u003ci64\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (input: \u0026 str) -\u003e GenResult \u003cInput\u003e {\n\t\t\tuse parser::*;\n\t\t\tParser::wrap (input, |parser| {\n\t\t\t\tlet x_min = parser.expect (\"target area: x=\") ?.int () ?;\n\t\t\t\tlet x_max = parser.expect (\"..\") ?.int () ?;\n\t\t\t\tlet y_min = parser.expect (\", y=\") ?.int () ?;\n\t\t\t\tlet y_max = parser.expect (\"..\") ?.int () ?;\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk (Input {\n\t\t\t\t\ttarget_x: x_min ..= x_max,\n\t\t\t\t\ttarget_y: y_min ..= y_max,\n\t\t\t\t})\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: col {}: {}\", char_idx + 1, input)\n\t\t\t)\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Position {\n\t\tpub x: i64,\n\t\tpub y: i64,\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Velocity {\n\t\tpub x: i64,\n\t\tpub y: i64,\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 str = \"target area: x=20..30, y=-10..-5\";\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (45, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn test_example () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (112, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[31097,31625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[31213,31192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[31720,31741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[61940,61328,61970],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":24,"address":[61491,61361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[61544,61466,61727],"length":1,"stats":{"Line":2},"fn_name":null},{"line":26,"address":[61659,61841],"length":1,"stats":{"Line":4},"fn_name":null},{"line":29,"address":[61984,62465],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":30,"address":[62017,62139],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[62192,62321,62114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":32,"address":[62412,62304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[62496,63364],"length":1,"stats":{"Line":2},"fn_name":"find_solutions"},{"line":36,"address":[62526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[62887,62544,62605],"length":1,"stats":{"Line":6},"fn_name":null},{"line":38,"address":[62908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":39,"address":[63190],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[63206],"length":1,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[63296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[62783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[63392],"length":1,"stats":{"Line":2},"fn_name":"simulate"},{"line":49,"address":[63428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[63446],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[63462],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[63474,63736,63624,63588,63648],"length":1,"stats":{"Line":10},"fn_name":null},{"line":53,"address":[63618,63565],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[63671,63635],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[63773,63838],"length":1,"stats":{"Line":4},"fn_name":null},{"line":56,"address":[63812],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[63884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":59,"address":[63857,63929,63947],"length":1,"stats":{"Line":4},"fn_name":null},{"line":60,"address":[63934,64004],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[64106,63977,64077],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[64168,64140,64082],"length":1,"stats":{"Line":4},"fn_name":null},{"line":63,"address":[64148,64198],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[63754],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[27328],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":83,"address":[27352,27387],"length":1,"stats":{"Line":10},"fn_name":null},{"line":84,"address":[45804,45486,45706],"length":1,"stats":{"Line":4},"fn_name":null},{"line":85,"address":[45768,45929,46126,46233],"length":1,"stats":{"Line":6},"fn_name":null},{"line":86,"address":[46200,46354,46658,46551],"length":1,"stats":{"Line":6},"fn_name":null},{"line":87,"address":[46779,46625,47071,46976],"length":1,"stats":{"Line":6},"fn_name":null},{"line":88,"address":[47271,47050,47192],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[47421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[47250],"length":1,"stats":{"Line":2},"fn_name":null},{"line":91,"address":[47402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[27377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[47606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[28064,28073],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":122,"address":[28167,28404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[28384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[28112,28121],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":128,"address":[28455,28692],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[28672],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":49,"coverable":53},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-18","src","lib.rs"],"content":"//! Advent of Code 2021: Day 18: Snailfish\n//!\n//! [https://adventofcode.com/2021/day/18](https://adventofcode.com/2021/day/18)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Snailfish\";\n\tyear = 2021;\n\tday = 18;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse snailfish::Snailfish;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet sum = Snailfish::sum (lines.iter ().copied ().map (Snailfish::parse));\n\t\tlet magnitude = sum.magnitude ();\n\t\tOk (magnitude)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet numbers: Vec \u003cSnailfish\u003e = lines.iter ().copied ().map (Snailfish::parse).collect ();\n\t\tlet mut best: i64 = i64::MIN;\n\t\tfor i in 0 .. numbers.len () {\n\t\t\tfor j in 0 .. numbers.len () {\n\t\t\t\tif i == j { continue }\n\t\t\t\tlet value = Snailfish::add (numbers [i].clone (), numbers [j].clone ()).magnitude ();\n\t\t\t\tif value \u003e best { best = value; }\n\t\t\t}\n\t\t}\n\t\tOk (best)\n\t}\n\n}\n\nmod snailfish {\n\n\tuse super::*;\n\tuse model::Token;\n\tuse model::Tokens;\n\n\t#[ derive (Clone, Eq, PartialEq) ]\n\tpub struct Snailfish {\n\t\ttokens: Rc \u003cTokens\u003e,\n\t}\n\n\timpl Snailfish {\n\n\t\tpub fn magnitude (\u0026 self) -\u003e i64 {\n\t\t\tlet mut pos: usize = 0;\n\t\t\tlet result = self.magnitude_real (\u0026 mut pos);\n\t\t\tif pos != self.tokens.len () { panic! () }\n\t\t\tresult\n\t\t}\n\n\t\tfn magnitude_real (\u0026 self, pos: \u0026 mut usize) -\u003e i64 {\n\t\t\tif * pos + 1 \u003e self.tokens.len () { panic! () }\n\t\t\tif self.tokens [* pos].is_value () {\n\t\t\t\tlet value = self.tokens [* pos].value ();\n\t\t\t\t* pos += 1;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif ! self.tokens [* pos].is_open () { panic! () }\n\t\t\t* pos += 1;\n\t\t\tlet left = self.magnitude_real (pos);\n\t\t\tif ! self.tokens [* pos].is_comma () { panic! () }\n\t\t\t* pos += 1;\n\t\t\tlet right = self.magnitude_real (pos);\n\t\t\tif ! self.tokens [* pos].is_close () { panic! () }\n\t\t\t* pos += 1;\n\t\t\tleft * 3 + right * 2\n\t\t}\n\n\t\tpub fn sum \u003cItem: Borrow \u003cSnailfish\u003e, Iter: Iterator \u003cItem = Item\u003e\u003e (iter: Iter) -\u003e Snailfish {\n\t\t\tlet mut sum = None;\n\t\t\tfor item in iter {\n\t\t\t\tlet item = item.borrow ();\n\t\t\t\tif let Some (prev_sum) = sum {\n\t\t\t\t\tsum = Some (Snailfish::add (prev_sum, item));\n\t\t\t\t} else {\n\t\t\t\t\tsum = Some (item.to_owned ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum.unwrap ()\n\t\t}\n\n\t\tpub fn add (left: impl Into \u003cSnailfish\u003e, right: impl Into \u003cSnailfish\u003e) -\u003e Snailfish {\n\t\t\tSnailfish::pair (left, right).reduce ()\n\t\t}\n\n\t\tpub fn pair (left: impl Into \u003cSnailfish\u003e, right: impl Into \u003cSnailfish\u003e) -\u003e Snailfish {\n\t\t\tlet Snailfish { tokens: left_tokens } = left.into ();\n\t\t\tlet Snailfish { tokens: right_tokens } = right.into ();\n\t\t\tmatch Rc::try_unwrap (left_tokens) {\n\t\t\t\tOk (mut left_tokens) =\u003e {\n\t\t\t\t\tleft_tokens.insert (0, Token::Open);\n\t\t\t\t\tleft_tokens.extend (\n\t\t\t\t\t\titer::once (Token::Comma)\n\t\t\t\t\t\t\t.chain (right_tokens.iter ().copied ())\n\t\t\t\t\t\t\t.chain (iter::once (Token::Close)));\n\t\t\t\t\tSnailfish { tokens: left_tokens.into () }\n\t\t\t\t},\n\t\t\t\tErr (left_tokens) =\u003e match Rc::try_unwrap (right_tokens) {\n\t\t\t\t\tOk (mut right_tokens) =\u003e {\n\t\t\t\t\t\tright_tokens.splice (0 .. 0,\n\t\t\t\t\t\t\titer::once (Token::Open)\n\t\t\t\t\t\t\t\t.chain (left_tokens.iter ().copied ())\n\t\t\t\t\t\t\t\t.chain (iter::once (Token::Comma)));\n\t\t\t\t\t\tright_tokens.push (Token::Close);\n\t\t\t\t\t\tSnailfish { tokens: right_tokens.into () }\n\t\t\t\t\t},\n\t\t\t\t\tErr (right_tokens) =\u003e {\n\t\t\t\t\t\tlet tokens =\n\t\t\t\t\t\t\titer::once (Token::Open)\n\t\t\t\t\t\t\t\t.chain (left_tokens.iter ().copied ())\n\t\t\t\t\t\t\t\t.chain (iter::once (Token::Comma))\n\t\t\t\t\t\t\t\t.chain (right_tokens.iter ().copied ())\n\t\t\t\t\t\t\t\t.chain (iter::once (Token::Close))\n\t\t\t\t\t\t\t\t.collect::\u003cTokens\u003e ();\n\t\t\t\t\t\tSnailfish { tokens: tokens.into () }\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tpub fn reduce (self) -\u003e Snailfish {\n\t\t\tlet mut val = self;\n\t\t\tloop {\n\t\t\t\tlet reduced;\n\t\t\t\t(reduced, val) = val.reduce_once ();\n\t\t\t\tif ! reduced { return val }\n\t\t\t}\n\t\t}\n\n\t\tpub fn reduce_once (self) -\u003e (bool, Snailfish) {\n\t\t\tlet mut depth = 0;\n\t\t\tfor (pos, token) in self.tokens.iter ().enumerate () {\n\t\t\t\tmatch token {\n\t\t\t\t\tToken::Open =\u003e {\n\t\t\t\t\t\tif depth == 4 {\n\t\t\t\t\t\t\treturn (true, self.reduce_explode (pos));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdepth += 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tToken::Close =\u003e {\n\t\t\t\t\t\tif depth == 0 { panic! () }\n\t\t\t\t\t\tdepth -= 1;\n\t\t\t\t\t},\n\t\t\t\t\t_ =\u003e (),\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (pos, token) in self.tokens.iter ().enumerate () {\n\t\t\t\tif let \u0026 Token::Value (value) = token {\n\t\t\t\t\tif value \u003e= 10 {\n\t\t\t\t\t\treturn (true, self.reduce_split (pos));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t(false, self)\n\t\t}\n\n\t\tfn reduce_explode (self, pos: usize) -\u003e Snailfish {\n\t\t\tif ! (self.tokens [pos].is_open ()\n\t\t\t\t\t\u0026\u0026 self.tokens [pos + 1].is_value ()\n\t\t\t\t\t\u0026\u0026 self.tokens [pos + 2].is_comma ()\n\t\t\t\t\t\u0026\u0026 self.tokens [pos + 3].is_value ()\n\t\t\t\t\t\u0026\u0026 self.tokens [pos + 4].is_close ()) {\n\t\t\t\tpanic! ();\n\t\t\t}\n\t\t\tlet explode_left = self.tokens [pos + 1].value ();\n\t\t\tlet explode_right = self.tokens [pos + 3].value ();\n\t\t\tmatch Rc::try_unwrap (self.tokens) {\n\t\t\t\tOk (mut tokens) =\u003e {\n\t\t\t\t\tif let Some (pos_left) =\n\t\t\t\t\t\t\ttokens [0 .. pos].iter ().rposition (Token::is_value) {\n\t\t\t\t\t\ttokens [pos_left] =\n\t\t\t\t\t\t\tToken::Value (tokens [pos_left].value () + explode_left);\n\t\t\t\t\t}\n\t\t\t\t\ttokens.splice (pos .. pos + 5, iter::once (Token::Value (0)));\n\t\t\t\t\tif let Some (pos_right) =\n\t\t\t\t\t\t\ttokens [pos + 1 ..].iter ().position (Token::is_value) {\n\t\t\t\t\t\ttokens [pos + 1 + pos_right] =\n\t\t\t\t\t\t\tToken::Value (tokens [pos + 1 + pos_right].value () + explode_right);\n\t\t\t\t\t}\n\t\t\t\t\tSnailfish { tokens: tokens.into () }\n\t\t\t\t},\n\t\t\t\tErr (tokens) =\u003e {\n\t\t\t\t\tlet mut result = Tokens::new ();\n\t\t\t\t\tif let Some (pos_left) = tokens [0 .. pos].iter ().rposition (Token::is_value) {\n\t\t\t\t\t\tresult.extend (tokens [0 .. pos_left].iter ().copied ());\n\t\t\t\t\t\tresult.push (Token::Value (tokens [pos_left].value () + explode_left));\n\t\t\t\t\t\tresult.extend (tokens [pos_left + 1 .. pos].iter ().copied ());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.extend (tokens [0 .. pos].iter ().copied ());\n\t\t\t\t\t}\n\t\t\t\t\tresult.push (Token::Value (0));\n\t\t\t\t\tif let Some (pos_right) = tokens [pos + 5 ..].iter ().position (Token::is_value) {\n\t\t\t\t\t\tlet pos_right = pos + 5 + pos_right;\n\t\t\t\t\t\tresult.extend (tokens [pos + 5 .. pos_right].iter ().copied ());\n\t\t\t\t\t\tresult.push (Token::Value (tokens [pos_right].value () + explode_right));\n\t\t\t\t\t\tresult.extend (tokens [pos_right + 1 ..].iter ().copied ());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.extend (tokens [pos + 5 ..].iter ().copied ());\n\t\t\t\t\t}\n\t\t\t\t\tSnailfish { tokens: result.into () }\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tfn reduce_split (self, pos: usize) -\u003e Snailfish {\n\t\t\tlet value = self.tokens [pos].value ();\n\t\t\tmatch Rc::try_unwrap (self.tokens) {\n\t\t\t\tOk (mut tokens) =\u003e {\n\t\t\t\t\ttokens.splice (pos .. pos + 1, [\n\t\t\t\t\t\tToken::Open,\n\t\t\t\t\t\tToken::Value (value / 2),\n\t\t\t\t\t\tToken::Comma,\n\t\t\t\t\t\tToken::Value ((value + 1) / 2),\n\t\t\t\t\t\tToken::Close,\n\t\t\t\t\t]);\n\t\t\t\t\tSnailfish { tokens: tokens.into () }\n\t\t\t\t},\n\t\t\t\tErr (tokens) =\u003e {\n\t\t\t\t\tlet mut result = Tokens::new ();\n\t\t\t\t\tresult.extend (tokens [0 .. pos].iter ().copied ());\n\t\t\t\t\tresult.push (Token::Open);\n\t\t\t\t\tresult.push (Token::Value (value / 2));\n\t\t\t\t\tresult.push (Token::Comma);\n\t\t\t\t\tresult.push (Token::Value ((value + 1) / 2));\n\t\t\t\t\tresult.push (Token::Close);\n\t\t\t\t\tresult.extend (tokens [pos + 1 ..].iter ().copied ());\n\t\t\t\t\tSnailfish { tokens: result.into () }\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\n\t\tpub fn parse (input: \u0026 str) -\u003e Snailfish {\n\t\t\tSnailfish {\n\t\t\t\ttokens: model::parse_tokens (\u0026 mut input.chars ().peekable ()).into (),\n\t\t\t}\n\t\t}\n\n\t}\n\n\timpl From \u003c\u0026 Snailfish\u003e for Snailfish {\n\t\tfn from (val: \u0026 Snailfish) -\u003e Snailfish {\n\t\t\tSnailfish { tokens: Rc::clone (\u0026 val.tokens) }\n\t\t}\n\t}\n\n\timpl Display for Snailfish {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfor token in self.tokens.iter () {\n\t\t\t\tmatch token {\n\t\t\t\t\tToken::Open =\u003e write! (formatter, \"[\") ?,\n\t\t\t\t\tToken::Close =\u003e write! (formatter, \"]\") ?,\n\t\t\t\t\tToken::Comma =\u003e write! (formatter, \",\") ?,\n\t\t\t\t\tToken::Value (value) =\u003e write! (formatter, \"{}\", value) ?,\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl Debug for Snailfish {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"Snaifish \\\"{}\\\"\", self) ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn test_reduce_once_explode () {\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[[[[0,9],2],3],4]\")),\n\t\t        Snailfish::parse (\"[[[[[9,8],1],2],3],4]\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[7,[6,[5,[7,0]]]]\")),\n\t\t\t\tSnailfish::parse (\"[7,[6,[5,[4,[3,2]]]]]\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[[6,[5,[7,0]]],3]\")),\n\t\t\t\tSnailfish::parse (\"[[6,[5,[4,[3,2]]]],1]\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\")),\n\t\t\t    Snailfish::parse (\"[[3,[2,[1,[7,3]]]],[6,[5,[4,[3,2]]]]]\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[[3,[2,[8,0]]],[9,[5,[7,0]]]]\")),\n\t\t\t\tSnailfish::parse (\"[[3,[2,[8,0]]],[9,[5,[4,[3,2]]]]]\").reduce_once (),\n\t\t\t);\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_reduce_once_split () {\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[5,5]\")),\n\t\t\t\tSnailfish::parse (\"10\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[5,6]\")),\n\t\t\t\tSnailfish::parse (\"11\").reduce_once (),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\t(true, Snailfish::parse (\"[6,6]\")),\n\t\t\t\tSnailfish::parse (\"12\").reduce_once (),\n\t\t\t);\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_add () {\n\t\t\tassert_eq! (\n\t\t\t\tSnailfish::parse (\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\"),\n\t\t\t\tSnailfish::add (\n\t\t\t\t\tSnailfish::parse (\"[[[[4,3],4],4],[7,[[8,4],9]]]\"),\n\t\t\t\t\tSnailfish::parse (\"[1,1]\"),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_sum () {\n\t\t\tassert_eq! (\n\t\t\t\tSnailfish::parse (\"[[[[1,1],[2,2]],[3,3]],[4,4]]\"),\n\t\t\t\tSnailfish::sum (vec! [\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\"].into_iter ().map (Snailfish::parse)),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\tSnailfish::parse (\"[[[[3,0],[5,3]],[4,4]],[5,5]]\"),\n\t\t\t\tSnailfish::sum (vec! [\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\"].into_iter ().map (Snailfish::parse)),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\tSnailfish::parse (\"[[[[5,0],[7,4]],[5,5]],[6,6]]\"),\n\t\t\t\tSnailfish::sum (vec! [\"[1,1]\", \"[2,2]\", \"[3,3]\", \"[4,4]\", \"[5,5]\", \"[6,6]\"].into_iter ().map (Snailfish::parse)),\n\t\t\t);\n\t\t\tassert_eq! (\n\t\t\t\tSnailfish::parse (\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\"),\n\t\t\t\tSnailfish::sum (vec! [\n\t\t\t\t\t\"[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]\",\n\t\t\t\t\t\"[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]\",\n\t\t\t\t\t\"[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]\",\n\t\t\t\t\t\"[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]\",\n\t\t\t\t\t\"[7,[5,[[3,8],[1,4]]]]\",\n\t\t\t\t\t\"[[2,[2,2]],[8,[8,1]]]\",\n\t\t\t\t\t\"[2,9]\",\n\t\t\t\t\t\"[1,[[[9,3],9],[[9,0],[0,7]]]]\",\n\t\t\t\t\t\"[[[5,[7,4]],7],1]\",\n\t\t\t\t\t\"[[[[4,2],2],6],[8,7]]\",\n\t\t\t\t].into_iter ().map (Snailfish::parse)),\n\t\t\t);\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_magnitude () {\n\t\t\tassert_eq! (143, Snailfish::parse (\"[[1,2],[[3,4],5]]\").magnitude ());\n\t\t\tassert_eq! (1384, Snailfish::parse (\"[[[[0,7],4],[[7,8],[6,0]]],[8,1]]\").magnitude ());\n\t\t\tassert_eq! (445, Snailfish::parse (\"[[[[1,1],[2,2]],[3,3]],[4,4]]\").magnitude ());\n\t\t\tassert_eq! (791, Snailfish::parse (\"[[[[3,0],[5,3]],[4,4]],[5,5]]\").magnitude ());\n\t\t\tassert_eq! (1137, Snailfish::parse (\"[[[[5,0],[7,4]],[5,5]],[6,6]]\").magnitude ());\n\t\t\tassert_eq! (3488, Snailfish::parse (\"[[[[8,7],[7,7]],[[8,6],[7,7]]],[[[0,7],[6,6]],[8,7]]]\").magnitude ());\n\t\t}\n\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\t//pub type Tokens = ArrayVec \u003cToken, 125\u003e;\n\tpub type Tokens = Vec \u003cToken\u003e;\n\n\tpub fn parse_tokens (input_iter: \u0026 mut Peekable \u003cChars \u003c'_\u003e\u003e) -\u003e Tokens {\n\t\tlet mut result = Tokens::new ();\n\t\twhile let Some (letter) = input_iter.peek () {\n\t\t\tmatch letter {\n\t\t\t\t'[' =\u003e { input_iter.next ().unwrap (); result.push (Token::Open); },\n\t\t\t\t']' =\u003e { input_iter.next ().unwrap (); result.push (Token::Close); },\n\t\t\t\t',' =\u003e { input_iter.next ().unwrap (); result.push (Token::Comma); },\n\t\t\t\t'0' ..= '9' =\u003e {\n\t\t\t\t\tlet mut value_buf = String::new ();\n\t\t\t\t\tloop {\n\t\t\t\t\t\tif let Some (letter) = input_iter.peek () {\n\t\t\t\t\t\t\tif ('0' ..= '9').contains (letter) {\n\t\t\t\t\t\t\t\tvalue_buf.push (input_iter.next ().unwrap ());\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push (Token::Value (value_buf.parse ().unwrap ()));\n\t\t\t\t},\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t}\n\t\t}\n\t\tresult\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Token {\n\t\tOpen,\n\t\tClose,\n\t\tComma,\n\t\tValue (i64),\n\t}\n\n\timpl Token {\n\t\tpub fn is_open (\u0026 self) -\u003e bool { matches! (* self, Token::Open) }\n\t\tpub fn is_close (\u0026 self) -\u003e bool { matches! (* self, Token::Close) }\n\t\tpub fn is_comma (\u0026 self) -\u003e bool { matches! (* self, Token::Comma) }\n\t\tpub fn is_value (\u0026 self) -\u003e bool { matches! (* self, Token::Value (_)) }\n\t\tpub fn value (\u0026 self) -\u003e i64 {\n\t\t\tmatch * self {\n\t\t\t\tToken::Value (value) =\u003e value,\n\t\t\t\t_ =\u003e panic! (\"Called Token::value() on Token::{:?}\", self),\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"[[[0,[5,8]],[[1,7],[9,6]]],[[4,[1,2]],[[1,4],2]]]\",\n\t\t\"[[[5,[2,8]],4],[5,[[9,9],0]]]\",\n\t\t\"[6,[[[6,2],[5,6]],[[7,6],[4,7]]]]\",\n\t\t\"[[[6,[0,7]],[0,9]],[4,[9,[9,0]]]]\",\n\t\t\"[[[7,[6,4]],[3,[1,3]]],[[[5,5],1],9]]\",\n\t\t\"[[6,[[7,3],[3,2]]],[[[3,8],[5,7]],4]]\",\n\t\t\"[[[[5,4],[7,7]],8],[[8,3],8]]\",\n\t\t\"[[9,3],[[9,9],[6,[4,9]]]]\",\n\t\t\"[[2,[[7,7],7]],[[5,8],[[9,3],[0,2]]]]\",\n\t\t\"[[[[5,2],5],[8,[3,7]]],[[5,[7,5]],[4,4]]]\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (4140, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (3993, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[91017,90553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[90638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[91102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[29232,29456],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[29285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[29377,29425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":23,"address":[29433],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[29504,30603,30504],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":27,"address":[29581],"length":1,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[29725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[29741,29804,30018],"length":1,"stats":{"Line":3},"fn_name":null},{"line":30,"address":[30047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":31,"address":[30251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[30261,30523],"length":1,"stats":{"Line":1},"fn_name":null},{"line":33,"address":[30588,30623],"length":1,"stats":{"Line":2},"fn_name":null},{"line":36,"address":[29981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[130720],"length":1,"stats":{"Line":1},"fn_name":"magnitude"},{"line":55,"address":[130734],"length":1,"stats":{"Line":1},"fn_name":null},{"line":56,"address":[130743],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[130850,130815,130768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[130880],"length":1,"stats":{"Line":1},"fn_name":"magnitude_real"},{"line":62,"address":[130996,131127,130919],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[131173,131125],"length":1,"stats":{"Line":3},"fn_name":null},{"line":64,"address":[131360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[131479,131420],"length":1,"stats":{"Line":2},"fn_name":null},{"line":66,"address":[131469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[131614,131284,131541],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[131688,131593,131665],"length":1,"stats":{"Line":3},"fn_name":null},{"line":70,"address":[131668],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[131856,131783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[131930,131907,131835],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[131910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[132098,132025],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[132146,132172,132077],"length":1,"stats":{"Line":3},"fn_name":null},{"line":76,"address":[132333,132207,132149],"length":1,"stats":{"Line":3},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":92,"address":[125088,125024],"length":1,"stats":{"Line":2},"fn_name":"add\u003caoc_2021_day_18::snailfish::Snailfish, aoc_2021_day_18::snailfish::Snailfish\u003e"},{"line":93,"address":[125038,125102],"length":1,"stats":{"Line":2},"fn_name":null},{"line":96,"address":[127909,125152,125489,130685,127936,128265],"length":1,"stats":{"Line":2},"fn_name":"pair\u003caoc_2021_day_18::snailfish::Snailfish, \u0026aoc_2021_day_18::snailfish::Snailfish\u003e"},{"line":97,"address":[125303,127959,125183,128071],"length":1,"stats":{"Line":4},"fn_name":null},{"line":98,"address":[128087,128164,125319,125388],"length":1,"stats":{"Line":4},"fn_name":null},{"line":99,"address":[128248,128180,125472,125518,125404,128294],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[125520,128296],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[128336,125560],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[127709,130485],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[127386,130384,130162,130462,127686,127608],"length":1,"stats":{"Line":6},"fn_name":null},{"line":104,"address":[127509,130285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[127615,130391],"length":1,"stats":{"Line":2},"fn_name":null},{"line":106,"address":[127716,130492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[125697,128386,125610,128473],"length":1,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[125716,128492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[125756,128532,129855,127079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[129770,129848,126994,128556,125780,127072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[126853,129629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[127001,129910,129777,127134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[129917,127141],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[129960,127184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[128610,125834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[129256,128942,128626,126480,126570,125850,126256,129346,126166,129032],"length":1,"stats":{"Line":5},"fn_name":null},{"line":120,"address":[128801,126025],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[126173,128949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[126347,129123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[129263,126487],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[129376,126600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[132368],"length":1,"stats":{"Line":1},"fn_name":"reduce"},{"line":132,"address":[132377],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[132382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[132438],"length":1,"stats":{"Line":2},"fn_name":null},{"line":140,"address":[132464,133693,133723],"length":1,"stats":{"Line":1},"fn_name":"reduce_once"},{"line":141,"address":[132479],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[132633,132963],"length":1,"stats":{"Line":4},"fn_name":null},{"line":143,"address":[133000],"length":1,"stats":{"Line":2},"fn_name":null},{"line":145,"address":[133031],"length":1,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[133159,133258],"length":1,"stats":{"Line":4},"fn_name":null},{"line":148,"address":[133187,133223],"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":[133117],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[133046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[133086,133122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":158,"address":[133555,133302],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[133597],"length":1,"stats":{"Line":2},"fn_name":null},{"line":160,"address":[133624],"length":1,"stats":{"Line":2},"fn_name":null},{"line":161,"address":[133639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[133518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[140601,133744,139089],"length":1,"stats":{"Line":2},"fn_name":"reduce_explode"},{"line":169,"address":[134684,133942,134214,134919,133775,134449],"length":1,"stats":{"Line":12},"fn_name":null},{"line":170,"address":[134096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[134330],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[134565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[134800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[135019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[135060],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[135273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[135402],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[135460],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[139315,139603],"length":1,"stats":{"Line":4},"fn_name":null},{"line":182,"address":[139509,139580],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[139424,139350,139539],"length":1,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[139624,139388],"length":1,"stats":{"Line":4},"fn_name":null},{"line":186,"address":[140026,140552],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[140350,140411],"length":1,"stats":{"Line":4},"fn_name":null},{"line":189,"address":[140157,140066,140368],"length":1,"stats":{"Line":4},"fn_name":null},{"line":191,"address":[140084,140562],"length":1,"stats":{"Line":4},"fn_name":null},{"line":193,"address":[135577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[135601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[135791,135648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[136450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[136717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[136972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[136199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[136376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[137308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[138169,137599,138018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[138210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[138549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[138804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[137711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[139040,137936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[140640,142226,143018],"length":1,"stats":{"Line":2},"fn_name":"reduce_split"},{"line":217,"address":[140838,140671],"length":1,"stats":{"Line":4},"fn_name":null},{"line":218,"address":[140899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[140957],"length":1,"stats":{"Line":2},"fn_name":null},{"line":220,"address":[141013,142360,142661,142304],"length":1,"stats":{"Line":6},"fn_name":null},{"line":221,"address":[142320],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[142332,142442,142512],"length":1,"stats":{"Line":4},"fn_name":null},{"line":223,"address":[142483],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[142868,142550,142495],"length":1,"stats":{"Line":4},"fn_name":null},{"line":225,"address":[142649],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[142916],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[141041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[141065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[141255,141112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[141406],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[141457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[141583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[141634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[141810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[141934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[142112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[143056],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":245,"address":[143070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[143168],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":253,"address":[143177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[143216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":259,"address":[143431,143293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[143452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[144018,143483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[143525,143921],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[143827,143567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[143614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[143421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[144112],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":273,"address":[144274,144134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[144267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[93840,93845],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":285,"address":[104715,104815,105042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[104631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[104680,104755],"length":1,"stats":{"Line":2},"fn_name":null},{"line":289,"address":[105156,105253],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[105072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[105193,105121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[105667,105567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[105483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[105532,105607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[106051,105966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[105891],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[105934,106003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":301,"address":[106338,106423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[106263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[106375,106306],"length":1,"stats":{"Line":2},"fn_name":null},{"line":308,"address":[93877,93872],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":309,"address":[107068,106847,106747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[106663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[106712,106787],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[107173,107255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":[107098],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[107207,107141],"length":1,"stats":{"Line":2},"fn_name":null},{"line":317,"address":[107627,107542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[107467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[107510,107579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":324,"address":[93909,93904],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":325,"address":[107863,107922,108179,108087],"length":1,"stats":{"Line":2},"fn_name":null},{"line":326,"address":[107871],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[108039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[107893,107959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[107972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[93936,93941],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":336,"address":[108621,108848,108385],"length":1,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[108327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":[108425,108362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[108933,109176],"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":[108878],"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":[108913,108967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":344,"address":[109708,109443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":[109388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":[109480,109423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[110328,109975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":349,"address":[109920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":[110012,109955],"length":1,"stats":{"Line":2},"fn_name":null},{"line":366,"address":[93973,93968],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":367,"address":[110567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":368,"address":[110868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":369,"address":[111123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[111381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":371,"address":[111639],"length":1,"stats":{"Line":1},"fn_name":null},{"line":372,"address":[111897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[91856,92764,92550],"length":1,"stats":{"Line":1},"fn_name":"parse_tokens"},{"line":387,"address":[91889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[91953,91899],"length":1,"stats":{"Line":4},"fn_name":null},{"line":389,"address":[91999],"length":1,"stats":{"Line":2},"fn_name":null},{"line":390,"address":[92068,92701],"length":1,"stats":{"Line":4},"fn_name":null},{"line":391,"address":[92087,92634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":392,"address":[92106,92567],"length":1,"stats":{"Line":4},"fn_name":null},{"line":393,"address":[92052,92158],"length":1,"stats":{"Line":4},"fn_name":null},{"line":394,"address":[92171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[92246,92185],"length":1,"stats":{"Line":4},"fn_name":null},{"line":397,"address":[92347,92296],"length":1,"stats":{"Line":4},"fn_name":null},{"line":398,"address":[92358],"length":1,"stats":{"Line":2},"fn_name":null},{"line":404,"address":[92326,92429],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[92120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[92793,92784],"length":1,"stats":{"Line":4},"fn_name":"is_open"},{"line":422,"address":[92832,92841],"length":1,"stats":{"Line":4},"fn_name":"is_close"},{"line":423,"address":[92889,92880],"length":1,"stats":{"Line":4},"fn_name":"is_comma"},{"line":424,"address":[92928,92937],"length":1,"stats":{"Line":4},"fn_name":"is_value"},{"line":425,"address":[92976],"length":1,"stats":{"Line":2},"fn_name":"value"},{"line":426,"address":[92985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[92996],"length":1,"stats":{"Line":2},"fn_name":null},{"line":428,"address":[93015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[88368],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":455,"address":[88375,88614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":456,"address":[88594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":460,"address":[88656],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":461,"address":[88663,88902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":462,"address":[88882],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":191,"coverable":240},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","src","lib.rs"],"content":"//! Advent of Code 2021: Day 19: Beacon Scanner\n//!\n//! [https://adventofcode.com/2021/day/19](https://adventofcode.com/2021/day/19)\n//!\n//! This algorithm uses bloom filters to allow it to scale better. For each scanner we generate a\n//! set of bits which have bits set according to the arrangement of the beacons they contain. If\n//! there are two beacons with a specific offset between them, then a number of bits are guaranteed\n//! to be set. Once we have this information for every scanner, we can prioritise the slower\n//! matching process to pairs of scanners which share a large number of bits.\n//!\n//! Generating these hashes for each scanner is slow, so there is some further optimisation going\n//! on as well. Firstly, we have to rotate scanners so that they will match. Instead of rotating\n//! each scanner in every direction, we rotate scanners which we have placed in one set of\n//! directions and the ones we haven't placed in another. We choose a set of directions in each\n//! case to guarntee a match. Specifically we rotate placed scanners around the Z axis only, giving\n//! four hashes for each scanner. We rotate unplaced scanners to move its Z axis into one of the\n//! six other positions. since almost all scanners will first be unplaced and later placed, this\n//! means we do a total of ten hashes for each scanner, instead of the twenty four we would have to\n//! with a more nave algorithm.\n\nuse aoc_common::*;\nuse bithash::*;\n\npub mod rotation;\n\npuzzle_info! {\n\tname = \"Beacon Scanner\";\n\tyear = 2021;\n\tday = 19;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Coord;\n\tuse model::Input;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\tuse rotation::Rotation;\n\n\tconst SCANNER_HASH_U64S: usize = 64; // 4096 bits per hash\n\tconst SCANNER_HASH_BITS: usize = 3;  // 2 bits per entry (pair of scanners)\n\n\ttype ScannerHash = BitHash \u003cSCANNER_HASH_U64S\u003e;\n\ttype ScannerHasher = BitHasher \u003cRandomHasher, SCANNER_HASH_U64S, SCANNER_HASH_BITS\u003e;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet (_, beacons) = calc_result (\u0026 input) ?;\n\t\tOk (beacons.len ().as_i64 ())\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet (scanners, _) = calc_result (\u0026 input) ?;\n\t\tlet scanners: Vec \u003cPos\u003e = scanners.into_iter ().collect ();\n\t\tOk (\n\t\t\tscanners.iter ().combinations (2).map (|scanners| {\n\t\t\t\tlet (pos_0, pos_1) = (scanners [0], scanners [1]);\n\t\t\t\tCoord::abs_diff (pos_0.x, pos_1.x)\n\t\t\t\t\t+ Coord::abs_diff (pos_0.y, pos_1.y)\n\t\t\t\t\t+ Coord::abs_diff (pos_0.z, pos_1.z)\n\t\t\t}).max ().unwrap ().as_i64 ()\n\t\t)\n\t}\n\n\tfn calc_result (input: \u0026 Input) -\u003e GenResult \u003c(HashSet \u003cPos\u003e, HashSet \u003cPos\u003e)\u003e {\n\t\tlet mut arranger = ScannerArranger::new ();\n\t\tif ! arranger.init (input) { Err (format! (\"Failed to arrange scanners\")) ? }\n\t\tif ! arranger.run () { Err (format! (\"Failed to arrange scanners\")) ? }\n\t\tOk ((arranger.scanner_positions, arranger.beacon_positions))\n\t}\n\n\t#[ derive (Default) ]\n\tstruct ScannerArranger {\n\t\thash_builder: RandomHasher,\n\t\toriginal_scanners: Vec \u003cRc \u003cOriginalScanner\u003e\u003e,\n\t\tunplaced_scanners: Vec \u003cRc \u003cUnplacedScanner\u003e\u003e,\n\t\tscanner_matches: BinaryHeap \u003cScannerMatch\u003e,\n\t\tscanner_positions: HashSet \u003cPos\u003e,\n\t\tbeacon_positions: HashSet \u003cPos\u003e,\n\t}\n\n\timpl ScannerArranger {\n\n\t\tfn new () -\u003e ScannerArranger { default () }\n\n\t\tfn init (\u0026 mut self, input: \u0026 Input) -\u003e bool {\n\t\t\tself.original_scanners.extend (\n\t\t\t\tinput.scanners.iter ().map (|scanner|\n\t\t\t\t\tRc::new (OriginalScanner {\n\t\t\t\t\t\tbeacons: scanner.beacons.iter ().copied ().sorted ().collect (),\n\t\t\t\t\t\tmatched: Cell::new (false),\n\t\t\t\t\t})));\n\t\t\tif self.original_scanners.is_empty () { return false }\n\t\t\tself.unplaced_scanners = self.original_scanners.iter ()\n\t\t\t\t.map (|scanner|\n\t\t\t\t\tRc::new (UnplacedScanner {\n\t\t\t\t\t\toriginal: Rc::clone (scanner),\n\t\t\t\t\t\thashes: self.calc_scanner_hashes (\u0026 scanner.beacons, UNPLACED_ROTATIONS),\n\t\t\t\t\t}))\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\t\ttrue\n\t\t}\n\n\t\tfn run (\u0026 mut self) -\u003e bool {\n\t\t\tself.place_scanner (\u0026 Rc::clone (\u0026 self.unplaced_scanners [0]), Rotation::None, Pos::zero ());\n\t\t\tlet mut scanner_matches_buffer = Vec::new ();\n\t\t\t'OUTER: loop {\n\t\t\t\tif self.unplaced_scanners.is_empty () { break }\n\t\t\t\tself.scanner_matches.extend (scanner_matches_buffer.drain ( .. ));\n\t\t\t\twhile let Some (scanner_match) = self.scanner_matches.pop () {\n\t\t\t\t\tif self.unplaced_scanners.is_empty () { break 'OUTER }\n\t\t\t\t\tif scanner_match.unplaced.original.matched.get () { continue }\n\t\t\t\t\tif self.process_match (\u0026 scanner_match) { continue 'OUTER }\n\t\t\t\t\tscanner_matches_buffer.push (scanner_match);\n\t\t\t\t}\n\t\t\t\tself.unplaced_scanners.retain (|scanner| ! scanner.original.matched.get ());\n\t\t\t}\n\t\t\ttrue\n\t\t}\n\n\t\tfn process_match (\u0026 mut self, scanner_match: \u0026 ScannerMatch) -\u003e bool {\n\t\t\tlet placed = Rc::clone (\u0026 scanner_match.placed);\n\t\t\tlet unplaced = Rc::clone (\u0026 scanner_match.unplaced);\n\t\t\tlet rotate = Rotation::combine (\n\t\t\t\tscanner_match.placed_rotate.rev (),\n\t\t\t\tscanner_match.unplaced_rotate);\n\t\t\tlet offset = match Self::find_offset (\u0026 placed, \u0026 unplaced, rotate) {\n\t\t\t\tSome (value) =\u003e value,\n\t\t\t\tNone =\u003e { return false },\n\t\t\t};\n\t\t\tself.place_scanner (\u0026 unplaced, rotate, offset);\n\t\t\ttrue\n\t\t}\n\n\t\tfn find_offset (\n\t\t\tplaced: \u0026 PlacedScanner,\n\t\t\tunplaced: \u0026 UnplacedScanner,\n\t\t\trotate: Rotation,\n\t\t) -\u003e Option \u003cPos\u003e {\n\t\t\tlet offsets_grouped =\n\t\t\t\tunplaced.original.beacons.iter ().copied ()\n\t\t\t\t\t.map (|beacon| rotate.apply (beacon))\n\t\t\t\t\t.cartesian_product (placed.beacons.iter ().copied ())\n\t\t\t\t\t.map (|(unplaced_beacon, placed_beacon)| placed_beacon - unplaced_beacon)\n\t\t\t\t\t.sorted ()\n\t\t\t\t\t.group_by (|offset| offset.to_owned ());\n\t\t\toffsets_grouped.into_iter ()\n\t\t\t\t.map (|(offset, iter)| (offset, iter.count ()))\n\t\t\t\t.filter (|\u0026 (_, count)| count \u003e= 12)\n\t\t\t\t.map (|(offset, _)| offset)\n\t\t\t\t.next ()\n\t\t}\n\n\t\tfn place_scanner (\u0026 mut self, scanner: \u0026 Rc \u003cUnplacedScanner\u003e, rotate: Rotation, offset: Pos) {\n\t\t\tlet beacons = scanner.original.beacons.iter ().copied ()\n\t\t\t\t.map (|beacon| rotate.apply (beacon) + offset)\n\t\t\t\t.sorted ()\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\t\tlet hashes = self.calc_scanner_hashes (\u0026 beacons, PLACED_ROTATIONS);\n\t\t\tlet scanner = Rc::new (PlacedScanner {\n\t\t\t\toriginal: Rc::clone (\u0026 scanner.original),\n\t\t\t\tbeacons,\n\t\t\t\thashes,\n\t\t\t});\n\t\t\tscanner.original.matched.set (true);\n\t\t\tself.scanner_positions.insert (offset);\n\t\t\tself.beacon_positions.extend (scanner.beacons.iter ().copied ());\n\t\t\tself.add_scanner_matches (\u0026 scanner);\n\t\t}\n\n\t\tfn add_scanner_matches (\u0026 mut self, placed: \u0026 Rc \u003cPlacedScanner\u003e) {\n\t\t\tfor unplaced in self.unplaced_scanners.iter () {\n\t\t\t\tif unplaced.original.matched.get () { continue }\n\t\t\t\tfor (unplaced_rotate_idx, unplaced_rotate)\n\t\t\t\t\t\tin UNPLACED_ROTATIONS.iter ().copied ().enumerate () {\n\t\t\t\t\tlet unplaced_hash = unplaced.hashes [unplaced_rotate_idx];\n\t\t\t\t\tfor (placed_rotate_idx, placed_rotate)\n\t\t\t\t\t\t\tin PLACED_ROTATIONS.iter ().copied ().enumerate () {\n\t\t\t\t\t\tlet placed_hash = placed.hashes [placed_rotate_idx];\n\t\t\t\t\t\tself.scanner_matches.push (ScannerMatch {\n\t\t\t\t\t\t\tplaced: Rc::clone (placed),\n\t\t\t\t\t\t\tunplaced: Rc::clone (unplaced),\n\t\t\t\t\t\t\tpriority: (placed_hash \u0026 unplaced_hash).bits ().as_u32 (),\n\t\t\t\t\t\t\tplaced_rotate,\n\t\t\t\t\t\t\tunplaced_rotate,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfn calc_scanner_hashes \u003cconst LEN: usize\u003e (\n\t\t\t\u0026 self,\n\t\t\tbeacons: \u0026 [Pos],\n\t\t\trotates: \u0026 [Rotation; LEN],\n\t\t) -\u003e [ScannerHash; LEN] {\n\t\t\tlet mut hashers =\n\t\t\t\t[0; LEN].map (|_| ScannerHasher::new_with_hasher (self.hash_builder.clone ()));\n\t\t\tfor offset in beacons.iter ().copied ().enumerate ()\n\t\t\t\t.flat_map (|(beacon_0_idx, beacon_0)| beacons.iter ().copied ()\n\t\t\t\t\t.skip (beacon_0_idx + 1)\n\t\t\t\t\t.map (move |beacon_1| beacon_1 - beacon_0)) {\n\t\t\t\tfor idx in 0 .. rotates.len () {\n\t\t\t\t\tlet offset = rotates [idx].apply (offset);\n\t\t\t\t\thashers [idx].update (cmp::max (offset, - offset));\n\t\t\t\t}\n\t\t\t}\n\t\t\thashers.map (|hasher| hasher.finish ())\n\t\t}\n\n\t}\n\n\tstruct OriginalScanner {\n\t\tbeacons: Vec \u003cPos\u003e,\n\t\tmatched: Cell \u003cbool\u003e,\n\t}\n\n\tstruct UnplacedScanner {\n\t\toriginal: Rc \u003cOriginalScanner\u003e,\n\t\thashes: [ScannerHash; 6],\n\t}\n\n\tstruct PlacedScanner {\n\t\toriginal: Rc \u003cOriginalScanner\u003e,\n\t\thashes: [ScannerHash; 4],\n\t\tbeacons: Vec \u003cPos\u003e,\n\t}\n\n\t#[ derive (Clone) ]\n\tstruct ScannerMatch {\n\t\tplaced: Rc \u003cPlacedScanner\u003e,\n\t\tunplaced: Rc \u003cUnplacedScanner\u003e,\n\t\tpriority: u32,\n\t\tplaced_rotate: Rotation,\n\t\tunplaced_rotate: Rotation,\n\t}\n\n\timpl PartialEq for ScannerMatch {\n\t\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\t\tself.priority == other.priority\n\t\t}\n\t}\n\n\timpl Eq for ScannerMatch {}\n\n\timpl PartialOrd for ScannerMatch {\n\t\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003ccmp::Ordering\u003e {\n\t\t\tu32::partial_cmp (\u0026 self.priority, \u0026 other.priority)\n\t\t}\n\t}\n\n\timpl Ord for ScannerMatch {\n\t\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e cmp::Ordering {\n\t\t\tu32::cmp (\u0026 self.priority, \u0026 other.priority)\n\t\t}\n\t}\n\n\tconst PLACED_ROTATIONS: \u0026 [Rotation; 4] = \u0026 [\n\t\tRotation::None, Rotation::Clockwise,\n\t\tRotation::UpsideDown, Rotation::CounterClockwise,\n\t];\n\n\tconst UNPLACED_ROTATIONS: \u0026 [Rotation; 6] = \u0026 [\n\t\tRotation::None, Rotation::Up, Rotation::Right,\n\t\tRotation::Around, Rotation::Down, Rotation::Left,\n\t];\n\n}\n\nmod model {\n\n\tuse aoc_common::*;\n\n\tpub type Coord = i16;\n\tpub type Pos = pos::PosXYZ \u003cCoord\u003e;\n\n\tpub struct Input {\n\t\tpub scanners: Vec \u003cInputScanner\u003e,\n\t}\n\n\t#[ derive (Debug) ]\n\tpub struct InputScanner {\n\t\tpub name: Rc \u003cString\u003e,\n\t\tpub beacons: Vec \u003cPos\u003e,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tuse parser::*;\n\t\t\tlet mut scanners = Vec::new ();\n\t\t\tlet mut lines_iter = lines.iter ().enumerate ();\n\t\t\tlet err = |line_idx, line| format! (\"Invalid input: line {}: {}\", line_idx + 1, line);\n\t\t\twhile let Some ((line_idx, line)) = lines_iter.next () {\n\t\t\t\tif ! line.starts_with (\"--- \") { Err (err (line_idx, line)) ? }\n\t\t\t\tif ! line.ends_with (\" ---\") { Err (err (line_idx, line)) ? }\n\t\t\t\tlet name = Rc::new (line [4 .. line.len () - 4].to_string ());\n\t\t\t\tlet mut beacons = Vec::new ();\n\t\t\t\tfor (line_idx, line) in lines_iter.by_ref () {\n\t\t\t\t\tif line.is_empty () { break }\n\t\t\t\t\tParser::wrap (line, |parser| {\n\t\t\t\t\t\tbeacons.push (Pos {\n\t\t\t\t\t\t\tx: parser.int () ?,\n\t\t\t\t\t\t\ty: parser.expect (\",\") ?.int () ?,\n\t\t\t\t\t\t\tz: parser.expect (\",\") ?.int () ?,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.end () ?;\n\t\t\t\t\t\tOk (())\n\t\t\t\t\t}).map_parse_err (|_| err (line_idx, line)) ?\n\t\t\t\t}\n\t\t\t\tscanners.push (InputScanner { name, beacons });\n\t\t\t}\n\t\t\tOk (Input { scanners })\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse aoc_common::*;\n\tuse crate::logic;\n\n\tconst EXAMPLE: \u0026 [\u0026 str] = \u0026 [\n\t\t\"--- scanner 0 ---\",\n\t\t\"404,-588,-901\", \"528,-643,409\", \"-838,591,734\", \"390,-675,-793\", \"-537,-823,-458\",\n\t\t\"-485,-357,347\", \"-345,-311,381\", \"-661,-816,-575\", \"-876,649,763\", \"-618,-824,-621\",\n\t\t\"553,345,-567\", \"474,580,667\", \"-447,-329,318\", \"-584,868,-557\", \"544,-627,-890\",\n\t\t\"564,392,-477\", \"455,729,728\", \"-892,524,684\", \"-689,845,-530\", \"423,-701,434\",\n\t\t\"7,-33,-71\", \"630,319,-379\", \"443,580,662\", \"-789,900,-551\", \"459,-707,401\",\n\t\t\"\",\n\t\t\"--- scanner 1 ---\",\n\t\t\"686,422,578\", \"605,423,415\", \"515,917,-361\", \"-336,658,858\", \"95,138,22\", \"-476,619,847\",\n\t\t\"-340,-569,-846\", \"567,-361,727\", \"-460,603,-452\", \"669,-402,600\", \"729,430,532\",\n\t\t\"-500,-761,534\", \"-322,571,750\", \"-466,-666,-811\", \"-429,-592,574\", \"-355,545,-477\",\n\t\t\"703,-491,-529\", \"-328,-685,520\", \"413,935,-424\", \"-391,539,-444\", \"586,-435,557\",\n\t\t\"-364,-763,-893\", \"807,-499,-711\", \"755,-354,-619\", \"553,889,-390\",\n\t\t\"\",\n\t\t\"--- scanner 2 ---\",\n\t\t\"649,640,665\", \"682,-795,504\", \"-784,533,-524\", \"-644,584,-595\", \"-588,-843,648\",\n\t\t\"-30,6,44\", \"-674,560,763\", \"500,723,-460\", \"609,671,-379\", \"-555,-800,653\",\n\t\t\"-675,-892,-343\", \"697,-426,-610\", \"578,704,681\", \"493,664,-388\", \"-671,-858,530\",\n\t\t\"-667,343,800\", \"571,-461,-707\", \"-138,-166,112\", \"-889,563,-600\", \"646,-828,498\",\n\t\t\"640,759,510\", \"-630,509,768\", \"-681,-892,-333\", \"673,-379,-804\", \"-742,-814,-386\",\n\t\t\"577,-820,562\",\n\t\t\"\",\n\t\t\"--- scanner 3 ---\",\n\t\t\"-589,542,597\", \"605,-692,669\", \"-500,565,-823\", \"-660,373,557\", \"-458,-679,-417\",\n\t\t\"-488,449,543\", \"-626,468,-788\", \"338,-750,-386\", \"528,-832,-391\", \"562,-778,733\",\n\t\t\"-938,-730,414\", \"543,643,-506\", \"-524,371,-870\", \"407,773,750\", \"-104,29,83\",\n\t\t\"378,-903,-323\", \"-778,-728,485\", \"426,699,580\", \"-438,-605,-362\", \"-469,-447,-387\",\n\t\t\"509,732,623\", \"647,635,-688\", \"-868,-804,481\", \"614,-800,639\", \"595,780,-596\",\n\t\t\"\",\n\t\t\"--- scanner 4 ---\",\n\t\t\"727,592,562\", \"-293,-554,779\", \"441,611,-461\", \"-714,465,-776\", \"-743,427,-804\",\n\t\t\"-660,-479,-426\", \"832,-632,460\", \"927,-485,-438\", \"408,393,-506\", \"466,436,-512\",\n\t\t\"110,16,151\", \"-258,-428,682\", \"-393,719,612\", \"-211,-452,876\", \"808,-476,-593\",\n\t\t\"-575,615,604\", \"-485,667,467\", \"-680,325,-822\", \"-627,-443,-432\", \"872,-547,-609\",\n\t\t\"833,512,582\", \"807,604,487\", \"839,-516,451\", \"891,-625,532\", \"-652,-548,-490\",\n\t\t\"30,-46,-14\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (79, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (3621, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":26,"address":[128313,128777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[128398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[128862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[92133,91360,92159],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":50,"address":[91393,91511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[91994,91499,91617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":52,"address":[92026,92083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[92176,93263,93315],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":56,"address":[92209,92341],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[92832,92329,92447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[92856,92992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[93007,93071],"length":1,"stats":{"Line":3},"fn_name":null},{"line":61,"address":[196318,196254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[196578,196509,196464,196406],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[196434],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[196489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[196282,196571],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[93344,94389],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":70,"address":[93374],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[93471,93446,93394],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[93457,94087,93789],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[93804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[94528,94536],"length":1,"stats":{"Line":4},"fn_name":"new"},{"line":90,"address":[94906,94560],"length":1,"stats":{"Line":2},"fn_name":"init"},{"line":91,"address":[94601,94690],"length":1,"stats":{"Line":4},"fn_name":null},{"line":92,"address":[94610],"length":1,"stats":{"Line":4},"fn_name":null},{"line":93,"address":[196853],"length":1,"stats":{"Line":2},"fn_name":null},{"line":94,"address":[196692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[196804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":97,"address":[94749,94700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":98,"address":[94819,94781,94728,94948],"length":1,"stats":{"Line":8},"fn_name":null},{"line":99,"address":[94811],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[197188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[197012],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[197035,197134],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[94984],"length":1,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[95232,95008],"length":1,"stats":{"Line":2},"fn_name":"run"},{"line":109,"address":[95028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[95258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[95273,95326],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[95394,95337],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[95974,95679,95408,95525],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[95502,95595],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[95739,95791,95601],"length":1,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[95829,95872],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[95878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[95537],"length":1,"stats":{"Line":8},"fn_name":null},{"line":125,"address":[96534,96000,96584],"length":1,"stats":{"Line":2},"fn_name":"process_match"},{"line":126,"address":[96043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[96058,96121],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[96126],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[96348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[96432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[96403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[96468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":136,"address":[96517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":139,"address":[96608,97184],"length":1,"stats":{"Line":2},"fn_name":"find_offset"},{"line":144,"address":[96648,96706,96803,96914],"length":1,"stats":{"Line":8},"fn_name":null},{"line":146,"address":[96787],"length":1,"stats":{"Line":6},"fn_name":null},{"line":147,"address":[96832],"length":1,"stats":{"Line":2},"fn_name":null},{"line":148,"address":[197593,197584],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":150,"address":[197760,197785],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":151,"address":[97063,97006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[197856,197875],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":153,"address":[198032,198045],"length":1,"stats":{"Line":4},"fn_name":"{closure#4}"},{"line":154,"address":[198080,198089],"length":1,"stats":{"Line":4},"fn_name":"{closure#5}"},{"line":158,"address":[97232,98560,98587],"length":1,"stats":{"Line":2},"fn_name":"place_scanner"},{"line":159,"address":[97461,97340,97403,97604],"length":1,"stats":{"Line":8},"fn_name":null},{"line":160,"address":[97572],"length":1,"stats":{"Line":6},"fn_name":null},{"line":163,"address":[97691,97779],"length":1,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[97981],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[97864],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[97876],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[97959],"length":1,"stats":{"Line":2},"fn_name":null},{"line":169,"address":[98184,98236],"length":1,"stats":{"Line":4},"fn_name":null},{"line":170,"address":[98260],"length":1,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[98422,98333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[98538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[100190,98624],"length":1,"stats":{"Line":2},"fn_name":"add_scanner_matches"},{"line":176,"address":[98663,98848],"length":1,"stats":{"Line":4},"fn_name":null},{"line":177,"address":[98985,98927],"length":1,"stats":{"Line":4},"fn_name":null},{"line":178,"address":[99249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[99018],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[99343,99432],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[99635],"length":1,"stats":{"Line":2},"fn_name":null},{"line":182,"address":[99465,99398],"length":1,"stats":{"Line":4},"fn_name":null},{"line":183,"address":[99820,99723],"length":1,"stats":{"Line":2},"fn_name":null},{"line":184,"address":[99791,100119],"length":1,"stats":{"Line":4},"fn_name":null},{"line":185,"address":[99800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[99851,99908],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[100067,99959],"length":1,"stats":{"Line":4},"fn_name":null},{"line":196,"address":[199775,199792,198384,201175],"length":1,"stats":{"Line":4},"fn_name":"calc_scanner_hashes\u003c6\u003e"},{"line":201,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":243,"address":[100224],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":244,"address":[100237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[100256],"length":1,"stats":{"Line":2},"fn_name":"partial_cmp"},{"line":252,"address":[100270],"length":1,"stats":{"Line":2},"fn_name":null},{"line":257,"address":[100304],"length":1,"stats":{"Line":0},"fn_name":"cmp"},{"line":258,"address":[100318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[59312,61557,61586],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":294,"address":[59367],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[59412,59503],"length":1,"stats":{"Line":4},"fn_name":null},{"line":296,"address":[105814,105776],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":297,"address":[59520,61534],"length":1,"stats":{"Line":4},"fn_name":null},{"line":298,"address":[59649,59859,59925],"length":1,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[60281,60213,59873],"length":1,"stats":{"Line":4},"fn_name":null},{"line":300,"address":[60227,60555],"length":1,"stats":{"Line":4},"fn_name":null},{"line":301,"address":[60759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":302,"address":[60807,61101,60878,61381],"length":1,"stats":{"Line":8},"fn_name":null},{"line":303,"address":[61138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[61426,61282,61175],"length":1,"stats":{"Line":10},"fn_name":null},{"line":305,"address":[106078,106972],"length":1,"stats":{"Line":4},"fn_name":null},{"line":306,"address":[106086,106183],"length":1,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[106150,106284,106482,106581],"length":1,"stats":{"Line":6},"fn_name":null},{"line":308,"address":[106548,106901,107020,106703],"length":1,"stats":{"Line":6},"fn_name":null},{"line":310,"address":[107241,107160],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[107227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[61394,61234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[60979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[59697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[219056,219065],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":369,"address":[220647,220886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":370,"address":[220866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":374,"address":[219104,219113],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":375,"address":[220935,221174],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[221154],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":124,"coverable":135},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-19","src","rotation.rs"],"content":"use super::*;\nuse model::Pos;\n\n#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\npub enum Rotation {\n\tNone, Clockwise, CounterClockwise, UpsideDown,\n\tUp, ClockwiseUp, CounterClockwiseUp, UpsideDownUp,\n\tDown, ClockwiseDown, CounterClockwiseDown, UpsideDownDown,\n\tLeft, ClockwiseLeft, CounterClockwiseLeft, UpsideDownLeft,\n\tRight, ClockwiseRight, CounterClockwiseRight, UpsideDownRight,\n\tAround, ClockwiseAround, CounterClockwiseAround, UpsideDownAround,\n}\n\n#[ allow (dead_code) ]\nimpl Rotation {\n\n\tpub const ALL: \u0026 'static [Rotation; 24] = \u0026 [\n\t\tRotation::None, Rotation::Clockwise,\n\t\tRotation::CounterClockwise, Rotation::UpsideDown,\n\t\tRotation::Up, Rotation::ClockwiseUp,\n\t\tRotation::CounterClockwiseUp, Rotation::UpsideDownUp,\n\t\tRotation::Down, Rotation::ClockwiseDown,\n\t\tRotation::CounterClockwiseDown, Rotation::UpsideDownDown,\n\t\tRotation::Left, Rotation::ClockwiseLeft,\n\t\tRotation::CounterClockwiseLeft, Rotation::UpsideDownLeft,\n\t\tRotation::Right, Rotation::ClockwiseRight,\n\t\tRotation::CounterClockwiseRight, Rotation::UpsideDownRight,\n\t\tRotation::Around, Rotation::ClockwiseAround,\n\t\tRotation::CounterClockwiseAround, Rotation::UpsideDownAround,\n\t];\n\n\tpub fn idx (self) -\u003e usize {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e 0,\n\t\t\tRotation::Clockwise =\u003e 1,\n\t\t\tRotation::CounterClockwise =\u003e 2,\n\t\t\tRotation::UpsideDown =\u003e 3,\n\t\t\tRotation::Up =\u003e 4,\n\t\t\tRotation::ClockwiseUp =\u003e 5,\n\t\t\tRotation::CounterClockwiseUp =\u003e 6,\n\t\t\tRotation::UpsideDownUp =\u003e 7,\n\t\t\tRotation::Down =\u003e 8,\n\t\t\tRotation::ClockwiseDown =\u003e 9,\n\t\t\tRotation::CounterClockwiseDown =\u003e 10,\n\t\t\tRotation::UpsideDownDown =\u003e 11,\n\t\t\tRotation::Left =\u003e 12,\n\t\t\tRotation::ClockwiseLeft =\u003e 13,\n\t\t\tRotation::CounterClockwiseLeft =\u003e 14,\n\t\t\tRotation::UpsideDownLeft =\u003e 15,\n\t\t\tRotation::Right =\u003e 16,\n\t\t\tRotation::ClockwiseRight =\u003e 17,\n\t\t\tRotation::CounterClockwiseRight =\u003e 18,\n\t\t\tRotation::UpsideDownRight =\u003e 19,\n\t\t\tRotation::Around =\u003e 20,\n\t\t\tRotation::ClockwiseAround =\u003e 21,\n\t\t\tRotation::CounterClockwiseAround =\u003e 22,\n\t\t\tRotation::UpsideDownAround =\u003e 23,\n\t\t}\n\t}\n\n\tpub fn apply (self, pos: Pos) -\u003e Pos {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e Pos { x: pos.x, y: pos.y, z: pos.z },\n\t\t\tRotation::Clockwise =\u003e Pos { x: - pos.y, y: pos.x, z: pos.z },\n\t\t\tRotation::CounterClockwise =\u003e Pos { x: pos.y, y: - pos.x, z: pos.z },\n\t\t\tRotation::UpsideDown =\u003e Pos { x: - pos.x, y: - pos.y, z: pos.z },\n\t\t\tRotation::Up =\u003e Pos { x: pos.x, y: - pos.z, z: pos.y },\n\t\t\tRotation::ClockwiseUp =\u003e Pos { x: pos.z, y: pos.x, z: pos.y },\n\t\t\tRotation::CounterClockwiseUp =\u003e Pos { x: - pos.z, y: - pos.x, z: pos.y },\n\t\t\tRotation::UpsideDownUp =\u003e Pos { x: - pos.x, y: pos.z, z: pos.y },\n\t\t\tRotation::Down =\u003e Pos { x: pos.x, y: pos.z, z: - pos.y },\n\t\t\tRotation::ClockwiseDown =\u003e Pos { x: - pos.z, y: pos.x, z: - pos.y },\n\t\t\tRotation::CounterClockwiseDown =\u003e Pos { x: pos.z, y: - pos.x, z: - pos.y },\n\t\t\tRotation::UpsideDownDown =\u003e Pos { x: - pos.x, y: - pos.z, z: - pos.y },\n\t\t\tRotation::Left =\u003e Pos { x: pos.z, y: pos.y, z: - pos.x },\n\t\t\tRotation::ClockwiseLeft =\u003e Pos { x: - pos.y, y: pos.z, z: - pos.x },\n\t\t\tRotation::CounterClockwiseLeft =\u003e Pos { x: pos.y, y: - pos.z, z: - pos.x },\n\t\t\tRotation::UpsideDownLeft =\u003e Pos { x: - pos.z, y: - pos.y, z: - pos.x },\n\t\t\tRotation::Right =\u003e Pos { x: - pos.z, y: pos.y, z: pos.x },\n\t\t\tRotation::ClockwiseRight =\u003e Pos { x: - pos.y, y: - pos.z, z: pos.x },\n\t\t\tRotation::CounterClockwiseRight =\u003e Pos { x: pos.y, y: pos.z, z: pos.x },\n\t\t\tRotation::UpsideDownRight =\u003e Pos { x: pos.z, y: - pos.y, z: pos.x },\n\t\t\tRotation::Around =\u003e Pos { x: - pos.x, y: pos.y, z: - pos.z },\n\t\t\tRotation::ClockwiseAround =\u003e Pos { x: - pos.y, y: - pos.x, z: - pos.z },\n\t\t\tRotation::CounterClockwiseAround =\u003e Pos { x: pos.y, y: pos.x, z: - pos.z },\n\t\t\tRotation::UpsideDownAround =\u003e Pos { x: pos.x, y: - pos.y, z: - pos.z },\n\t\t}\n\t}\n\n\tpub fn left (self) -\u003e Rotation {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e Rotation::Left,\n\t\t\tRotation::Clockwise =\u003e Rotation::ClockwiseUp,\n\t\t\tRotation::CounterClockwise =\u003e Rotation::CounterClockwiseDown,\n\t\t\tRotation::UpsideDown =\u003e Rotation::UpsideDownRight,\n\t\t\tRotation::Up =\u003e Rotation::CounterClockwiseLeft,\n\t\t\tRotation::ClockwiseUp =\u003e Rotation::CounterClockwiseAround,\n\t\t\tRotation::CounterClockwiseUp =\u003e Rotation::CounterClockwise,\n\t\t\tRotation::UpsideDownUp =\u003e Rotation::CounterClockwiseRight,\n\t\t\tRotation::Down =\u003e Rotation::ClockwiseLeft,\n\t\t\tRotation::ClockwiseDown =\u003e Rotation::Clockwise,\n\t\t\tRotation::CounterClockwiseDown =\u003e Rotation::ClockwiseAround,\n\t\t\tRotation::UpsideDownDown =\u003e Rotation::ClockwiseRight,\n\t\t\tRotation::Left =\u003e Rotation::Around,\n\t\t\tRotation::ClockwiseLeft =\u003e Rotation::UpsideDownUp,\n\t\t\tRotation::CounterClockwiseLeft =\u003e Rotation::UpsideDownDown,\n\t\t\tRotation::UpsideDownLeft =\u003e Rotation::UpsideDown,\n\t\t\tRotation::Right =\u003e Rotation::None,\n\t\t\tRotation::ClockwiseRight =\u003e Rotation::Up,\n\t\t\tRotation::CounterClockwiseRight =\u003e Rotation::Down,\n\t\t\tRotation::UpsideDownRight =\u003e Rotation::UpsideDownAround,\n\t\t\tRotation::Around =\u003e Rotation::Right,\n\t\t\tRotation::ClockwiseAround =\u003e Rotation::CounterClockwiseUp,\n\t\t\tRotation::CounterClockwiseAround =\u003e Rotation::ClockwiseDown,\n\t\t\tRotation::UpsideDownAround =\u003e Rotation::UpsideDownLeft,\n\t\t}\n\t}\n\n\tpub fn around (self) -\u003e Rotation { self.left ().left () }\n\tpub fn right (self) -\u003e Rotation { self.left ().left ().left () }\n\n\tpub fn clockwise (self) -\u003e Rotation {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e Rotation::Clockwise,\n\t\t\tRotation::Clockwise =\u003e Rotation::UpsideDown,\n\t\t\tRotation::CounterClockwise =\u003e Rotation::None,\n\t\t\tRotation::UpsideDown =\u003e Rotation::CounterClockwise,\n\t\t\tRotation::Up =\u003e Rotation::ClockwiseUp,\n\t\t\tRotation::ClockwiseUp =\u003e Rotation::UpsideDownUp,\n\t\t\tRotation::CounterClockwiseUp =\u003e Rotation::Up,\n\t\t\tRotation::UpsideDownUp =\u003e Rotation::CounterClockwiseUp,\n\t\t\tRotation::Down =\u003e Rotation::ClockwiseDown,\n\t\t\tRotation::ClockwiseDown =\u003e Rotation::UpsideDownDown,\n\t\t\tRotation::CounterClockwiseDown =\u003e Rotation::Down,\n\t\t\tRotation::UpsideDownDown =\u003e Rotation::CounterClockwiseDown,\n\t\t\tRotation::Left =\u003e Rotation::ClockwiseLeft,\n\t\t\tRotation::ClockwiseLeft =\u003e Rotation::UpsideDownLeft,\n\t\t\tRotation::CounterClockwiseLeft =\u003e Rotation::Left,\n\t\t\tRotation::UpsideDownLeft =\u003e Rotation::CounterClockwiseLeft,\n\t\t\tRotation::Right =\u003e Rotation::ClockwiseRight,\n\t\t\tRotation::ClockwiseRight =\u003e Rotation::UpsideDownRight,\n\t\t\tRotation::CounterClockwiseRight =\u003e Rotation::Right,\n\t\t\tRotation::UpsideDownRight =\u003e Rotation::CounterClockwiseRight,\n\t\t\tRotation::Around =\u003e Rotation::ClockwiseAround,\n\t\t\tRotation::ClockwiseAround =\u003e Rotation::UpsideDownAround,\n\t\t\tRotation::CounterClockwiseAround =\u003e Rotation::Around,\n\t\t\tRotation::UpsideDownAround =\u003e Rotation::CounterClockwiseAround,\n\t\t}\n\t}\n\n\tpub fn upside_down (self) -\u003e Rotation { self.clockwise ().clockwise () }\n\tpub fn counter_clockwise (self) -\u003e Rotation { self.clockwise ().clockwise ().clockwise () }\n\n\tpub fn up (self) -\u003e Rotation {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e Rotation::Up,\n\t\t\tRotation::Clockwise =\u003e Rotation::ClockwiseRight,\n\t\t\tRotation::CounterClockwise =\u003e Rotation::CounterClockwiseLeft,\n\t\t\tRotation::UpsideDown =\u003e Rotation::UpsideDownDown,\n\t\t\tRotation::Up =\u003e Rotation::UpsideDownAround,\n\t\t\tRotation::ClockwiseUp =\u003e Rotation::UpsideDownRight,\n\t\t\tRotation::CounterClockwiseUp =\u003e Rotation::UpsideDownLeft,\n\t\t\tRotation::UpsideDownUp =\u003e Rotation::UpsideDown,\n\t\t\tRotation::Down =\u003e Rotation::None,\n\t\t\tRotation::ClockwiseDown =\u003e Rotation::Right,\n\t\t\tRotation::CounterClockwiseDown =\u003e Rotation::Left,\n\t\t\tRotation::UpsideDownDown =\u003e Rotation::Around,\n\t\t\tRotation::Left =\u003e Rotation::ClockwiseUp,\n\t\t\tRotation::ClockwiseLeft =\u003e Rotation::Clockwise,\n\t\t\tRotation::CounterClockwiseLeft =\u003e Rotation::CounterClockwiseAround,\n\t\t\tRotation::UpsideDownLeft =\u003e Rotation::ClockwiseDown,\n\t\t\tRotation::Right =\u003e Rotation::CounterClockwiseUp,\n\t\t\tRotation::ClockwiseRight =\u003e Rotation::ClockwiseAround,\n\t\t\tRotation::CounterClockwiseRight =\u003e Rotation::CounterClockwise,\n\t\t\tRotation::UpsideDownRight =\u003e Rotation::CounterClockwiseDown,\n\t\t\tRotation::Around =\u003e Rotation::UpsideDownUp,\n\t\t\tRotation::ClockwiseAround =\u003e Rotation::ClockwiseLeft,\n\t\t\tRotation::CounterClockwiseAround =\u003e Rotation::CounterClockwiseRight,\n\t\t\tRotation::UpsideDownAround =\u003e Rotation::Down,\n\t\t}\n\t}\n\n\tpub fn flip (self) -\u003e Rotation { self.up ().up () }\n\tpub fn down (self) -\u003e Rotation { self.up ().up ().up () }\n\n\tpub fn rev (self) -\u003e Rotation {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e Rotation::None,\n\t\t\tRotation::Clockwise =\u003e Rotation::CounterClockwise,\n\t\t\tRotation::CounterClockwise =\u003e Rotation::Clockwise,\n\t\t\tRotation::UpsideDown =\u003e Rotation::UpsideDown,\n\t\t\tRotation::Up =\u003e Rotation::Down,\n\t\t\tRotation::ClockwiseUp =\u003e Rotation::CounterClockwiseRight,\n\t\t\tRotation::CounterClockwiseUp =\u003e Rotation::ClockwiseLeft,\n\t\t\tRotation::UpsideDownUp =\u003e Rotation::UpsideDownUp,\n\t\t\tRotation::Down =\u003e Rotation::Up,\n\t\t\tRotation::ClockwiseDown =\u003e Rotation::CounterClockwiseLeft,\n\t\t\tRotation::CounterClockwiseDown =\u003e Rotation::ClockwiseRight,\n\t\t\tRotation::UpsideDownDown =\u003e Rotation::UpsideDownDown,\n\t\t\tRotation::Left =\u003e Rotation::Right,\n\t\t\tRotation::ClockwiseLeft =\u003e Rotation::CounterClockwiseUp,\n\t\t\tRotation::CounterClockwiseLeft =\u003e Rotation::ClockwiseDown,\n\t\t\tRotation::UpsideDownLeft =\u003e Rotation::UpsideDownLeft,\n\t\t\tRotation::Right =\u003e Rotation::Left,\n\t\t\tRotation::ClockwiseRight =\u003e Rotation::CounterClockwiseDown,\n\t\t\tRotation::CounterClockwiseRight =\u003e Rotation::ClockwiseUp,\n\t\t\tRotation::UpsideDownRight =\u003e Rotation::UpsideDownRight,\n\t\t\tRotation::Around =\u003e Rotation::Around,\n\t\t\tRotation::ClockwiseAround =\u003e Rotation::ClockwiseAround,\n\t\t\tRotation::CounterClockwiseAround =\u003e Rotation::CounterClockwiseAround,\n\t\t\tRotation::UpsideDownAround =\u003e Rotation::UpsideDownAround,\n\t\t}\n\t}\n\n\tpub fn combine (self, other: Rotation) -\u003e Rotation {\n\t\tmatch self {\n\t\t\tRotation::None =\u003e other,\n\t\t\tRotation::Clockwise =\u003e other.clockwise (),\n\t\t\tRotation::CounterClockwise =\u003e other.counter_clockwise (),\n\t\t\tRotation::UpsideDown =\u003e other.upside_down (),\n\t\t\tRotation::Up =\u003e other.up (),\n\t\t\tRotation::ClockwiseUp =\u003e other.up ().clockwise (),\n\t\t\tRotation::CounterClockwiseUp =\u003e other.up ().counter_clockwise (),\n\t\t\tRotation::UpsideDownUp =\u003e other.up ().upside_down (),\n\t\t\tRotation::Down =\u003e other.down (),\n\t\t\tRotation::ClockwiseDown =\u003e other.down ().clockwise (),\n\t\t\tRotation::CounterClockwiseDown =\u003e other.down ().counter_clockwise (),\n\t\t\tRotation::UpsideDownDown =\u003e other.down ().upside_down (),\n\t\t\tRotation::Left =\u003e other.left (),\n\t\t\tRotation::ClockwiseLeft =\u003e other.left ().clockwise (),\n\t\t\tRotation::CounterClockwiseLeft =\u003e other.left ().counter_clockwise (),\n\t\t\tRotation::UpsideDownLeft =\u003e other.left ().upside_down (),\n\t\t\tRotation::Right =\u003e other.right (),\n\t\t\tRotation::ClockwiseRight =\u003e other.right ().clockwise (),\n\t\t\tRotation::CounterClockwiseRight =\u003e other.right ().counter_clockwise (),\n\t\t\tRotation::UpsideDownRight =\u003e other.right ().upside_down (),\n\t\t\tRotation::Around =\u003e other.around (),\n\t\t\tRotation::ClockwiseAround =\u003e other.around ().clockwise (),\n\t\t\tRotation::CounterClockwiseAround =\u003e other.around ().counter_clockwise (),\n\t\t\tRotation::UpsideDownAround =\u003e other.around ().upside_down (),\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod tests {\n\n\tuse aoc_common::*;\n\tuse super::*;\n\n\t#[ test ]\n\tfn test_rotation () {\n\t\tlet base = Pos { x: 1, y: 2, z: 3 };\n\t\tlet mut seen: HashSet \u003cPos\u003e = HashSet::new ();\n\t\tlet mut seen_left: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tlet mut seen_up: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tlet mut seen_clockwise: HashSet \u003cRotation\u003e = HashSet::new ();\n\t\tfn right_handed (pos: Pos) -\u003e bool {\n\t\t\tlet sign = match (pos.x.abs (), pos.y.abs (), pos.z.abs ()) {\n\t\t\t\t(1, 2, 3) =\u003e 1,\n\t\t\t\t(2, 3, 1) =\u003e 1,\n\t\t\t\t(3, 1, 2) =\u003e 1,\n\t\t\t\t(3, 2, 1) =\u003e -1,\n\t\t\t\t(2, 1, 3) =\u003e -1,\n\t\t\t\t(1, 3, 2) =\u003e -1,\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t} * pos.x.signum () * pos.y.signum () * pos.z.signum ();\n\t\t\tsign \u003e 0\n\t\t}\n\t\tfor rotate in Rotation::ALL.iter ().copied () {\n\t\t\tlet result = rotate.apply (base);\n\t\t\tassert! (right_handed (result));\n\t\t\tassert! (! seen.contains (\u0026 result), \"Duplicated rotation {:?}\", result);\n\t\t\tseen.insert (result);\n\t\t\tlet rotate_left = rotate.left ();\n\t\t\tassert! (! seen_left.contains (\u0026 rotate_left), \"Duplicated rotation left {:?}\", rotate_left);\n\t\t\tseen_left.insert (rotate_left);\n\t\t\tlet rotate_up = rotate.up ();\n\t\t\tassert! (! seen_up.contains (\u0026 rotate_up), \"Duplicated rotation up {:?}\", rotate_up);\n\t\t\tseen_up.insert (rotate_up);\n\t\t\tlet rotate_clockwise = rotate.clockwise ();\n\t\t\tassert! (! seen_clockwise.contains (\u0026 rotate_clockwise), \"Duplicated rotation clockwise {:?}\", rotate_clockwise);\n\t\t\tseen_clockwise.insert (rotate_clockwise);\n\t\t\tlet rotate_four_lefts = rotate.left ().left ().left ().left ();\n\t\t\tassert_eq! (rotate, rotate_four_lefts, \"Four lefts from {:?} arrives at {:?}\", rotate, rotate_four_lefts);\n\t\t\tlet rotate_four_ups = rotate.up ().up ().up ().up ();\n\t\t\tassert_eq! (rotate, rotate_four_ups, \"Four ups from {:?} arrives at {:?}\", rotate, rotate_four_ups);\n\t\t\tlet rotate_four_clockwises = rotate.clockwise ().clockwise ().clockwise ().clockwise ();\n\t\t\tassert_eq! (rotate, rotate_four_clockwises, \"Four clockwises from {:?} arrives at {:?}\", rotate, rotate_four_clockwises);\n\t\t\tassert_eq! (rotate, rotate.up ().right ().down ().counter_clockwise ());\n\t\t\tassert_eq! (rotate, rotate.flip ().around ().upside_down ());\n\t\t\tlet rotate_two_revs = rotate.rev ().rev ();\n\t\t\tassert_eq! (rotate, rotate_two_revs, \"Two reverses of {:?} arrives at {:?}\", rotate, rotate_two_revs);\n\t\t\tlet pos_forward_rev = rotate.rev ().apply (rotate.apply (base));\n\t\t\tassert_eq! (base, pos_forward_rev, \"Applying forward and reverse to {:?} arrives at {:?}\", base, pos_forward_rev);\n\t\t\tfor other in Rotation::ALL.iter ().copied () {\n\t\t\t\tlet pos_apply_twice = other.apply (rotate.apply (base));\n\t\t\t\tlet pos_combine = other.combine (rotate).apply (base);\n\t\t\t\tassert_eq! (pos_apply_twice, pos_combine,\n\t\t\t\t\t\"Applying {:?} then {:?} gives {:?} but combining then applying gives {:?}\",\n\t\t\t\t\trotate, other, pos_apply_twice, pos_combine);\n\t\t\t\tfor other_base in Rotation::ALL.iter ().copied ().map (|rot| rot.apply (base)) {\n\t\t\t\t\tif other.apply (other_base) != result { continue }\n\t\t\t\t\tassert_eq! (other.rev ().combine (rotate).apply (base), other_base);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n","traces":[{"line":32,"address":[245376],"length":1,"stats":{"Line":0},"fn_name":"idx"},{"line":33,"address":[245387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[245418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[245432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[245446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[245460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[245474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[245488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[245502],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[245516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[245530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[245544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[245558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[245572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[245586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[245597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[245608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[245619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[245630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[245641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[245652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[245663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[245674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[245685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[245696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[245707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[245728],"length":1,"stats":{"Line":2},"fn_name":"apply"},{"line":62,"address":[245799],"length":1,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[245841],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[245894,249637],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[245930,249557],"length":1,"stats":{"Line":4},"fn_name":null},{"line":66,"address":[245982,249393],"length":1,"stats":{"Line":4},"fn_name":null},{"line":67,"address":[249313,246018],"length":1,"stats":{"Line":4},"fn_name":null},{"line":68,"address":[246070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[246123,249149],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[246159,249058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":71,"address":[246195,248986],"length":1,"stats":{"Line":4},"fn_name":null},{"line":72,"address":[248813,246254],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[248663,246287],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[246333,248442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[246366,248373],"length":1,"stats":{"Line":4},"fn_name":null},{"line":76,"address":[248200,246425],"length":1,"stats":{"Line":2},"fn_name":null},{"line":77,"address":[248050,246458],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[247829,246504],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[246537,247741],"length":1,"stats":{"Line":4},"fn_name":null},{"line":80,"address":[246570,247588],"length":1,"stats":{"Line":4},"fn_name":null},{"line":81,"address":[246603],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[247511,246656],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[247343,246702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":84,"address":[246735,247122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[247056,246768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[246827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[249728],"length":1,"stats":{"Line":1},"fn_name":"left"},{"line":91,"address":[249739],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[249770],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[249780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[249790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[249800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":96,"address":[249810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[249820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[249827],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[249834],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[249841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":101,"address":[249848],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[249855],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[249862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[249869],"length":1,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[249876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[249883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[249890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[249897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[249904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[249911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[249918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[249925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":113,"address":[249932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[249939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[249946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[249968,249976],"length":1,"stats":{"Line":2},"fn_name":"around"},{"line":120,"address":[250016,250024],"length":1,"stats":{"Line":2},"fn_name":"right"},{"line":122,"address":[250080],"length":1,"stats":{"Line":2},"fn_name":"clockwise"},{"line":123,"address":[250091],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[250122],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[250132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[250142],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[250152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[250162],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[250172],"length":1,"stats":{"Line":2},"fn_name":null},{"line":130,"address":[250179],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[250186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[250193],"length":1,"stats":{"Line":1},"fn_name":null},{"line":133,"address":[250200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[250207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[250214],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[250221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[250228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":138,"address":[250235],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[250242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[250249],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[250256],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[250263],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[250270],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[250277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[250284],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[250291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[250298],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[250320,250328],"length":1,"stats":{"Line":4},"fn_name":"upside_down"},{"line":152,"address":[250368,250376],"length":1,"stats":{"Line":2},"fn_name":"counter_clockwise"},{"line":154,"address":[250432],"length":1,"stats":{"Line":1},"fn_name":"up"},{"line":155,"address":[250443],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[250474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":157,"address":[250484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":158,"address":[250494],"length":1,"stats":{"Line":1},"fn_name":null},{"line":159,"address":[250504],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[250514],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[250524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[250531],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[250538],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[250545],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[250552],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[250559],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[250566],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[250573],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[250580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[250587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[250594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[250601],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[250608],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[250615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[250622],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[250629],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[250636],"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":[250643],"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":[250650],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[250672,250680],"length":1,"stats":{"Line":2},"fn_name":"flip"},{"line":184,"address":[250720,250728],"length":1,"stats":{"Line":2},"fn_name":"down"},{"line":186,"address":[250784],"length":1,"stats":{"Line":2},"fn_name":"rev"},{"line":187,"address":[250795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[250826],"length":1,"stats":{"Line":2},"fn_name":null},{"line":189,"address":[250836],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[250846],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[250856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[250866],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[250876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[250883],"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":[250890],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[250897],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[250904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[250911],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[250918],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[250925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":[250932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[250939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[250946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[250953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":[250960],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[250967],"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":[250974],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[250981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":[250988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":[250995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[251002],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[251024],"length":1,"stats":{"Line":2},"fn_name":"combine"},{"line":216,"address":[251046],"length":1,"stats":{"Line":2},"fn_name":null},{"line":217,"address":[251083],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[251096],"length":1,"stats":{"Line":2},"fn_name":null},{"line":219,"address":[251117],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[251138],"length":1,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[251159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[251180,251845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":223,"address":[251201,251824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":224,"address":[251803,251222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[251243],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[251264,251782],"length":1,"stats":{"Line":2},"fn_name":null},{"line":227,"address":[251761,251285],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[251306,251740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[251327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[251719,251348],"length":1,"stats":{"Line":2},"fn_name":null},{"line":231,"address":[251369,251698],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[251390,251680],"length":1,"stats":{"Line":2},"fn_name":null},{"line":233,"address":[251411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[251432,251662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":235,"address":[251644,251453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":236,"address":[251474,251626],"length":1,"stats":{"Line":2},"fn_name":null},{"line":237,"address":[251495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[251513,251608],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[251531,251590],"length":1,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[251549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":253,"address":[83105,76144,83049],"length":1,"stats":{"Line":3},"fn_name":"test_rotation"},{"line":254,"address":[76151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[76181],"length":1,"stats":{"Line":1},"fn_name":null},{"line":256,"address":[76202],"length":1,"stats":{"Line":1},"fn_name":null},{"line":257,"address":[76257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[76309],"length":1,"stats":{"Line":1},"fn_name":null},{"line":259,"address":[83136],"length":1,"stats":{"Line":1},"fn_name":"right_handed"},{"line":260,"address":[83743,83176,83874,83553,83596,83650,83957,83325],"length":1,"stats":{"Line":5},"fn_name":null},{"line":261,"address":[83633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[83587],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[83544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[83462],"length":1,"stats":{"Line":1},"fn_name":null},{"line":265,"address":[83578],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[83621],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[83295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[83469,83741,83668,83542,83872,83799],"length":1,"stats":{"Line":6},"fn_name":null},{"line":269,"address":[83940],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[76612,76353,76441],"length":1,"stats":{"Line":3},"fn_name":null},{"line":272,"address":[76626],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[76873,76762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":274,"address":[77000,76859,76912],"length":1,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[76920],"length":1,"stats":{"Line":1},"fn_name":null},{"line":276,"address":[77123],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[77238,77175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":[77204],"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[77361],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[77413,77476],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[77442],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[77599],"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":[77714,77651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[77680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[77837],"length":1,"stats":{"Line":1},"fn_name":null},{"line":286,"address":[77953,78077],"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":[78380,78052],"length":1,"stats":{"Line":2},"fn_name":null},{"line":288,"address":[78591,78467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[78566,78894],"length":1,"stats":{"Line":2},"fn_name":null},{"line":290,"address":[78981,79105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[79408,79632,79080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":292,"address":[79886,79594,79686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":293,"address":[79848,79940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[79979,80103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[80399,80078],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[80788,80651],"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":[80750,81100],"length":1,"stats":{"Line":2},"fn_name":null},{"line":298,"address":[81271],"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":[81529],"length":1,"stats":{"Line":1},"fn_name":null},{"line":300,"address":[81705,81842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[81804,82308],"length":1,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[82547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[82718],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":211,"coverable":238},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-20","src","lib.rs"],"content":"//! Advent of Code 2021: Day 20: Trench Map\n//!\n//! [https://adventofcode.com/2021/day/20](https://adventofcode.com/2021/day/20)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Trench Map\";\n\tyear = 2021;\n\tday = 20;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n\tcommands = [\n\t\t( name = \"run\"; method = tool::run; ),\n\t];\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Algorithm;\n\tuse model::Image;\n\tuse model::Input;\n\tuse model::Pixels;\n\tuse model::Pos;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tcalc_result (lines, 2)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tcalc_result (lines, 50)\n\t}\n\n\tpub fn calc_result (lines: \u0026 [\u0026 str], loops: usize) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = Input::parse (lines) ?;\n\t\tlet image = Image::new_from (input.pixels, false);\n\t\tOk (\n\t\t\timage_iter (input.algorithm, image)\n\t\t\t\t.nth (loops)\n\t\t\t\t.unwrap ()\n\t\t\t\t.num_pixels ().as_i64 ()\n\t\t)\n\t}\n\n\tpub struct ImageIter {\n\t\talgorithm: Algorithm,\n\t\timage: Rc \u003cImage\u003e,\n\t\tfirst: bool,\n\t}\n\n\tpub fn image_iter \u003cIntoImage: Into \u003cRc \u003cImage\u003e\u003e\u003e (\n\t\talgorithm: Algorithm,\n\t\timage: IntoImage,\n\t) -\u003e ImageIter {\n\t\tlet image = image.into ();\n\t\tImageIter { algorithm, image, first: true }\n\t}\n\n\timpl Iterator for ImageIter {\n\t\ttype Item = Rc \u003cImage\u003e;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003cRc \u003cImage\u003e\u003e {\n\t\t\tif self.first {\n\t\t\t\tself.first = false;\n\t\t\t} else {\n\t\t\t\tself.image = Rc::new (calc_next (\u0026 self.algorithm, \u0026 self.image));\n\t\t\t}\n\t\t\tSome (Rc::clone (\u0026 self.image))\n\t\t}\n\t}\n\n\tpub fn calc_next (algorithm: \u0026 Algorithm, image: \u0026 Image) -\u003e Image {\n\t\tlet (origin, peak) = image.range ();\n\t\tlet new_pixels = (origin.y - 1 .. peak.y + 1).flat_map (|y|\n\t\t\t(origin.x - 3 .. peak.x + 1).map (move |x| [\n\t\t\t\timage.get (Pos { y: y - 1, x: x + 1 }),\n\t\t\t\timage.get (Pos { y, x: x + 1 }),\n\t\t\t\timage.get (Pos { y: y + 1, x: x + 1 }),\n\t\t\t]).scan ([false; 9], |state, next| {\n\t\t\t\t* state = [\n\t\t\t\t\tstate [1], state [2], next [0],\n\t\t\t\t\tstate [4], state [5], next [1],\n\t\t\t\t\tstate [7], state [8], next [2],\n\t\t\t\t];\n\t\t\t\tSome (* state)\n\t\t\t}).skip (2).map (|bits| {\n\t\t\t\tlet algorithm_idx = bits.into_iter ()\n\t\t\t\t\t.fold (0, |val, bit| (val \u003c\u003c 1) | if bit { 1 } else { 0 });\n\t\t\t\talgorithm [algorithm_idx]\n\t\t\t})\n\t\t).collect ();\n\t\tlet new_size = [image.height () + 2, image.width () + 2];\n\t\tlet new_pixels = Pixels::wrap (new_pixels, [0, 0], new_size);\n\t\tlet new_inverted = algorithm [if image.inverted () { 0x1ff } else { 0 }];\n\t\tImage::new_from (new_pixels, new_inverted)\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub type Algorithm = [bool; 512];\n\tpub type Pixels = grid::Grid \u003cVec \u003cbool\u003e, Pos\u003e;\n\tpub type Pos = pos::PosYX \u003ci16\u003e;\n\n\tpub struct Input {\n\t\tpub algorithm: Algorithm,\n\t\tpub pixels: Pixels,\n\t}\n\n\timpl Input {\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cInput\u003e {\n\t\t\tlet err = |idx, msg| format! (\"Invalid input: {}: {}\", idx + 1, msg);\n\t\t\tlet algorithm = {\n\t\t\t\tlet line_0_len = lines [0].chars ().count ();\n\t\t\t\tif line_0_len != 512 {\n\t\t\t\t\tErr (err (0, format! (\"Algorithm is {} chars, expected 512\", line_0_len))) ?;\n\t\t\t\t}\n\t\t\t\tlet mut algorithm = [false; 512];\n\t\t\t\tfor (letter_idx, letter) in lines [0].chars ().enumerate () {\n\t\t\t\t\tmatch letter {\n\t\t\t\t\t\t'#' =\u003e algorithm [letter_idx] = true,\n\t\t\t\t\t\t'.' =\u003e (),\n\t\t\t\t\t\t_ =\u003e Err (err (0, format! (\"Invalid character in algorithm\"))) ?,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\talgorithm\n\t\t\t};\n\t\t\tif ! lines [1].is_empty () { Err (err (1, format! (\"Expected blank line\"))) ?; }\n\t\t\tlet pixels = lines.iter ().enumerate ().skip (2).flat_map (|(line_idx, line)| {\n\t\t\t\tline.chars ().map (move |letter| { match letter {\n\t\t\t\t\t'#' =\u003e Ok (true),\n\t\t\t\t\t'.' =\u003e Ok (false),\n\t\t\t\t\t_ =\u003e Err (err (line_idx, format! (\"Invalid character\"))),\n\t\t\t\t}})\n\t\t\t}).collect::\u003cResult \u003c_, _\u003e\u003e () ?;\n\t\t\tlet size = [lines.len () - 2, lines [2].chars ().count ()];\n\t\t\tlet pixels = Pixels::wrap (pixels, [0, 0], size);\n\t\t\tOk (Input { algorithm, pixels })\n\t\t}\n\t}\n\n\t#[ derive (Debug) ]\n\tpub struct Image {\n\t\tpixels: Pixels,\n\t\tinverted: bool,\n\t}\n\n\timpl Image {\n\t\tpub fn new_from (pixels: Pixels, inverted: bool) -\u003e Image {\n\t\t\tImage { pixels, inverted }\n\t\t}\n\t\tpub fn num_pixels (\u0026 self) -\u003e usize {\n\t\t\tself.pixels.values ().filter (|\u0026 val| val != self.inverted).count ()\n\t\t}\n\t\tpub fn height (\u0026 self) -\u003e usize { self.pixels.size () [0] }\n\t\tpub fn width (\u0026 self) -\u003e usize { self.pixels.size () [1] }\n\t\tpub fn inverted (\u0026 self) -\u003e bool { self.inverted }\n\t\tpub fn get (\u0026 self, pos: Pos) -\u003e bool {\n\t\t\tself.pixels.get (pos).unwrap_or (self.inverted)\n\t\t}\n\t\tpub fn range (\u0026 self) -\u003e (Pos, Pos) {\n\t\t\t(self.pixels.origin (), self.pixels.peak () + Pos { y: 1, x: 1 })\n\t\t}\n\t\tpub fn dump (\u0026 self) -\u003e ImageDump {\n\t\t\tImageDump (self)\n\t\t}\n\t}\n\n\tpub struct ImageDump \u003c'a\u003e (\u0026 'a Image);\n\n\timpl \u003c'a\u003e fmt::Display for ImageDump \u003c'a\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet ImageDump (image) = self;\n\t\t\tlet (origin, peak) = image.range ();\n\t\t\tfor y in origin.y .. peak.y {\n\t\t\t\tfor x in origin.x .. peak.x {\n\t\t\t\t\tlet pos = Pos { y, x };\n\t\t\t\t\twrite! (formatter, \"{}\", if image.get (pos) { '#' } else { '.' }) ?;\n\t\t\t\t}\n\t\t\t\twrite! (formatter, \"\\n\") ?;\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n}\n\npub mod tool {\n\n\tuse super::*;\n\tuse model::Image;\n\tuse model::Input;\n\n\t#[ derive (Debug, clap::Parser) ]\n\tpub struct RunArgs {\n\n\t\t/// File to read algorithm and initial image from\n\t\t#[ clap (long, value_parser, default_value = \"inputs/day-20\") ]\n\t\tinput: String,\n\n\t\t/// Print the image after each step\n\t\t#[ clap (long) ]\n\t\tverbose: bool,\n\n\t\t/// Number of times to apply the algorithm\n\t\t#[ clap (long, value_parser, default_value_t = 2) ]\n\t\tloops: usize,\n\n\t}\n\n\tpub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tlet input = Input::parse (\u0026 input_lines) ?;\n\t\tlet start_image = Image::new_from (input.pixels, false);\n\t\tlet end_image = logic::image_iter (input.algorithm, start_image)\n\t\t\t.enumerate ()\n\t\t\t.inspect (|(steps, image)| if args.verbose {\n\t\t\t\tprint! (\n\t\t\t\t\t\"After {} steps: {} pixels {}\\n{}\",\n\t\t\t\t\tsteps,\n\t\t\t\t\timage.num_pixels (),\n\t\t\t\t\tif image.inverted () { \"inactive\" } else { \"active\" },\n\t\t\t\t\timage.dump (),\n\t\t\t\t);\n\t\t\t},\n\t\t).map (|(_, image)| image).nth (args.loops).unwrap ();\n\t\tprintln! (\"Result: {}\", end_image.num_pixels ());\n\t\tOk (())\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse aoc_common::*;\n\tuse crate::logic;\n\n\tconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\t\"..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..###..######.###..\\\n\t\t.####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###.######.###.####...#.##.##..#..\\\n\t\t#..#####.....#.#....###..#.##......#.....#..#..#..##..#...##.######.####.####.#.#...#.....\\\n\t\t..#..#.#.#...####.##.#......#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.#\\\n\t\t##.##...#.....####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.......##.\\\n\t\t.####..#...#.#.#...##..#.#..###..#####........#..####......#..#\",\n\t\t\"\",\n\t\t\"#..#.\",\n\t\t\"#....\",\n\t\t\"##..#\",\n\t\t\"..#..\",\n\t\t\"..###\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (35, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (3351, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[149113,149577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[149198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[149662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[43728],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":29,"address":[43749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[43776],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":33,"address":[43797],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[44363,43824,44390],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":37,"address":[43870,44105],"length":1,"stats":{"Line":1},"fn_name":null},{"line":38,"address":[44009],"length":1,"stats":{"Line":2},"fn_name":null},{"line":40,"address":[44595,44211,44443],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[73552],"length":1,"stats":{"Line":2},"fn_name":"image_iter\u003caoc_2021_day_20::model::Image\u003e"},{"line":57,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":63,"address":[44688,44867],"length":1,"stats":{"Line":2},"fn_name":"next"},{"line":64,"address":[44910,44705],"length":1,"stats":{"Line":4},"fn_name":null},{"line":65,"address":[44785],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[44719,44778,44819,44907],"length":1,"stats":{"Line":8},"fn_name":null},{"line":69,"address":[44917,44797],"length":1,"stats":{"Line":4},"fn_name":null},{"line":73,"address":[45977,44944],"length":1,"stats":{"Line":2},"fn_name":"calc_next"},{"line":74,"address":[44979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[45066],"length":1,"stats":{"Line":6},"fn_name":null},{"line":76,"address":[74074,74112,74006,74593,73758],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":77,"address":[74139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[74307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[74423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[74830,73986,74640],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":81,"address":[74733],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[74696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[74708],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[74721],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[74800],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[74848,74952,74062],"length":1,"stats":{"Line":6},"fn_name":"{closure#2}"},{"line":88,"address":[74862],"length":1,"stats":{"Line":2},"fn_name":null},{"line":89,"address":[74992,75018],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":90,"address":[74967,74921],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[45326,45389,45621],"length":1,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[45505,45654],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[45662,45896,45723],"length":1,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[45809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[61120,64171,64137],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":116,"address":[61175],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[61183],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[61698,61282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[61345,61711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[61296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[61324,62117,61853],"length":1,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[62156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[62222,62647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[62178,62244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[62059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[62793,62093,62696],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[63238,62772,63590],"length":1,"stats":{"Line":5},"fn_name":null},{"line":134,"address":[88960,88574,88640,88681],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":135,"address":[88763],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[88780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[88792,88704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[63494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[63669,63471],"length":1,"stats":{"Line":2},"fn_name":null},{"line":141,"address":[63852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[63971],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[64192],"length":1,"stats":{"Line":2},"fn_name":"new_from"},{"line":156,"address":[64288],"length":1,"stats":{"Line":1},"fn_name":"num_pixels"},{"line":157,"address":[64302],"length":1,"stats":{"Line":3},"fn_name":null},{"line":159,"address":[64384,64396],"length":1,"stats":{"Line":4},"fn_name":"height"},{"line":160,"address":[64416,64428],"length":1,"stats":{"Line":4},"fn_name":"width"},{"line":161,"address":[64448,64453],"length":1,"stats":{"Line":4},"fn_name":"inverted"},{"line":162,"address":[64464],"length":1,"stats":{"Line":2},"fn_name":"get"},{"line":163,"address":[64494],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[64560],"length":1,"stats":{"Line":2},"fn_name":"range"},{"line":166,"address":[64574],"length":1,"stats":{"Line":2},"fn_name":null},{"line":168,"address":[64720],"length":1,"stats":{"Line":0},"fn_name":"dump"},{"line":169,"address":[64729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[167746,168124,166352],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":216,"address":[166376,166439,166583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[166557,166766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[166850,167171,166941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[167071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[167699,167398,167568,167642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[151863,151840],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":223,"address":[152144,151904,152235,151991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[151978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[152069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[152222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[167875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[168015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[90256],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":261,"address":[90263,90502],"length":1,"stats":{"Line":1},"fn_name":null},{"line":262,"address":[90482],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[90544],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":267,"address":[90551,90790],"length":1,"stats":{"Line":1},"fn_name":null},{"line":268,"address":[90770],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":69,"coverable":100},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-21","src","lib.rs"],"content":"//! Advent of Code 2021: Day 21: Dirac Dice\n//!\n//! [https://adventofcode.com/2021/day/21](https://adventofcode.com/2021/day/21)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Dirac Dice\";\n\tyear = 2021;\n\tday = 21;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu64\u003e {\n\t\tlet (start_1, start_2) = model::parse_input (lines) ?;\n\t\tlet mut die_state: u16 = 0;\n\t\tlet mut die_count: u64 = 0;\n\t\tlet mut die_roll = || {\n\t\t\tlet roll = die_state + 1;\n\t\t\tdie_state = (die_state + 1) % 100;\n\t\t\tdie_count += 1;\n\t\t\troll\n\t\t};\n\t\tstruct Player { score: u16, pos: u8 }\n\t\tlet mut players = [\n\t\t\tPlayer { score: 0, pos: start_1 - 1 },\n\t\t\tPlayer { score: 0, pos: start_2 - 1 },\n\t\t];\n\t\tlet winner = 'OUTER: loop {\n\t\t\tfor (player_idx, player) in players.iter_mut ().enumerate () {\n\t\t\t\tlet roll = iter::from_fn (|| Some (die_roll ())).take (3).sum::\u003cu16\u003e ();\n\t\t\t\tplayer.pos = ((player.pos.as_u16 () + roll.as_u16 ()) % 10).as_u8 ();\n\t\t\t\tplayer.score += player.pos.as_u16 () + 1;\n\t\t\t\tif player.score \u003e= 1000 { break 'OUTER player_idx }\n\t\t\t}\n\t\t};\n\t\tlet loser = (winner + 1) % 2;\n\t\tOk (die_count * players [loser].score.as_u64 ())\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cu128\u003e {\n\t\tlet (start_1, start_2) = model::parse_input (lines) ?;\n\t\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, PartialEq) ]\n\t\tstruct Player { score: u8, pos: u8 }\n\t\t#[ derive (Clone, Copy, Debug, Default, Eq, Hash, PartialEq) ]\n\t\tstruct Game { players: [Player; 2], turn: u8 }\n\t\tstruct Frame { game: Game, counts: [u128; 2], progress: usize }\n\t\tlet start_game = Game {\n\t\t\tplayers: [ Player { score: 0, pos: start_1 }, Player { score: 0, pos: start_2 } ],\n\t\t\tturn: 0,\n\t\t};\n\t\tlet mut solved: HashMap \u003cGame, [u128; 2]\u003e = HashMap::new ();\n\t\tlet mut stack: Vec \u003cFrame\u003e = Vec::new ();\n\t\tstack.push (Frame { game: start_game, counts: [0; 2], progress: 0 });\n\t\tlet roll_freqs: [(u8, usize); 7] = [(3, 1), (4, 3), (5, 6), (6, 7), (7, 6), (8, 3), (9, 1)];\n\t\twhile let Some (frame) = stack.last_mut () {\n\t\t\tif frame.progress == roll_freqs.len () {\n\t\t\t\tsolved.insert (frame.game, frame.counts);\n\t\t\t\tstack.pop ().unwrap ();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet old_player = frame.game.players [frame.game.turn.as_usize ()];\n\t\t\tlet (roll_val, roll_freq) = roll_freqs [frame.progress];\n\t\t\tlet mut new_game = frame.game;\n\t\t\tlet new_player = \u0026 mut new_game.players [frame.game.turn.as_usize ()];\n\t\t\tnew_player.pos = ((old_player.pos - 1) + roll_val) % 10 + 1;\n\t\t\tnew_player.score = old_player.score + new_player.pos;\n\t\t\tif new_player.score \u003e= 21 {\n\t\t\t\tframe.counts [frame.game.turn.as_usize ()] = u128::checked_add (\n\t\t\t\t\tframe.counts [frame.game.turn.as_usize ()], roll_freq.as_u128 ()).unwrap ();\n\t\t\t\tframe.progress += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_game.turn = (frame.game.turn + 1) % 2;\n\t\t\tif let Some (solved_counts) = solved.get (\u0026 new_game) {\n\t\t\t\tframe.counts = [\n\t\t\t\t\tu128::checked_add (frame.counts [0],\n\t\t\t\t\t\tu128::checked_mul (solved_counts [0], roll_freq.as_u128 ()).unwrap (),\n\t\t\t\t\t).unwrap (),\n\t\t\t\t\tu128::checked_add (frame.counts [1],\n\t\t\t\t\t\tu128::checked_mul (solved_counts [1], roll_freq.as_u128 ()).unwrap (),\n\t\t\t\t\t).unwrap (),\n\t\t\t\t];\n\t\t\t\tframe.progress += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet new_frame = Frame {\n\t\t\t\tgame: new_game,\n\t\t\t\tcounts: [0; 2],\n\t\t\t\tprogress: 0,\n\t\t\t};\n\t\t\tstack.push (new_frame);\n\t\t}\n\t\tOk (solved [\u0026 start_game].into_iter ().max ().unwrap ())\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003c(u8, u8)\u003e {\n\t\tuse parser::*;\n\t\tif lines.len () != 2 { Err (\"Invalid input: expected two lines\") ? }\n\t\tlet mut parser = Parser::new (lines [0]);\n\t\tlet start_1: u8 = parser.expect (\"Player 1 starting position: \") ?.int () ?;\n\t\tparser.end () ?;\n\t\tlet mut parser = Parser::new (lines [1]);\n\t\tlet start_2: u8 = parser.expect (\"Player 2 starting position: \") ?.int () ?;\n\t\tparser.end () ?;\n\t\tOk ((start_1, start_2))\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\t\"Player 1 starting position: 4\",\n\t\t\"Player 2 starting position: 8\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (739785, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (444356092776315, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[64601,65065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[64686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[65150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[33040],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":21,"address":[33079,33254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":22,"address":[33177],"length":1,"stats":{"Line":1},"fn_name":null},{"line":23,"address":[33187],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[33199],"length":1,"stats":{"Line":3},"fn_name":null},{"line":25,"address":[53131,53070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[53107,53216,53171],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[53191,53261,53273],"length":1,"stats":{"Line":2},"fn_name":null},{"line":31,"address":[33407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[33356,33231,33324],"length":1,"stats":{"Line":2},"fn_name":null},{"line":33,"address":[33341,33390,33469],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[33467],"length":1,"stats":{"Line":1},"fn_name":null},{"line":36,"address":[33499],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[33719],"length":1,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[33811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":39,"address":[33941,34059],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[34094,34047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[34102,34166],"length":1,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[34201,34140,34304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":47,"address":[38154,34336],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":48,"address":[34603,34375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[34472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":58,"address":[34580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[34673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":60,"address":[34720],"length":1,"stats":{"Line":1},"fn_name":null},{"line":61,"address":[34902],"length":1,"stats":{"Line":1},"fn_name":null},{"line":62,"address":[35260],"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":[35380,35700],"length":1,"stats":{"Line":2},"fn_name":null},{"line":64,"address":[35746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":[35860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[35713,35910,36011],"length":1,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[36052,35975,36151],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[36101],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[36185,36270,36121],"length":1,"stats":{"Line":2},"fn_name":null},{"line":72,"address":[36244,36310,36475],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[36532,36456,36523],"length":1,"stats":{"Line":2},"fn_name":null},{"line":74,"address":[36525],"length":1,"stats":{"Line":1},"fn_name":null},{"line":75,"address":[37016,36798],"length":1,"stats":{"Line":1},"fn_name":null},{"line":76,"address":[36609],"length":1,"stats":{"Line":1},"fn_name":null},{"line":77,"address":[36983,37058,37067],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[36573,37147,37107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[37188,37132],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[38066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[37686,37262],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[37285,37565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[37799,37967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":87,"address":[37817],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[38081,38121],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[37366],"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":[37457],"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":[35423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[62064],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":111,"address":[62107,62139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[62118,62268],"length":1,"stats":{"Line":4},"fn_name":null},{"line":113,"address":[62543,62315,62624],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[62824,62598,62742],"length":1,"stats":{"Line":4},"fn_name":null},{"line":115,"address":[62950,62795],"length":1,"stats":{"Line":4},"fn_name":null},{"line":116,"address":[63326,63002,63233],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[63555,63447,63297],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[63508],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[50432],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":135,"address":[50679,50439],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[50659],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[50720],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":141,"address":[50727,50997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[50977],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":66,"coverable":69},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","lib.rs"],"content":"//! Advent of Code 2021 day 22: Reactor Reboot\n//!\n//! [https://adventofcode.com/2021/day/22](https://adventofcode.com/2021/day/22)\n//!\n//! This uses a slightly unintuitive algorithm to count up the activated locations. Instead of\n//! splitting up cubes to enusre they never intersect, we simply add them all together, then keep\n//! track of where they overlapped. Every time we overlap we track the overlapping section as well,\n//! but we add it up as the negative. If we overlap a negative we add it again as a positive.\n//!\n//! To make part two quicker, we split the referenced area up into a 101010 grid and calculate\n//! the value for each section individually. This drastically cuts down on the number of\n//! intersections we need to make.\n\nuse aoc_common::*;\n\npuzzle! {\n\tname = \"Reactor Reboot\";\n\tyear = 2021;\n\tday = 22;\n\tpart_one = |lines| logic::calc_result_part_one (lines);\n\tpart_two = |lines| logic::calc_result_part_two (lines);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Cube;\n\tuse model::Step;\n\n\tpub const BOUND_50: Cube = Cube { x0: -50, y0: -50, z0: -50, x1: 51, y1: 51, z1: 51 };\n\n\tpub fn calc_result_part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tlet steps = bound_steps (\u0026 input, BOUND_50);\n\t\tOk (calc_result (\u0026 steps))\n\t}\n\n\tpub fn calc_result_part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tOk (calc_result_with_splits (\u0026 input, 10))\n\t}\n\n\tpub fn calc_result_with_splits (steps: \u0026 [Step], num_splits: i32) -\u003e i64 {\n\t\tlet bound = steps.iter ().copied ().fold (Cube::ZERO, |bound, step| Cube {\n\t\t\tx0: cmp::min (bound.x0, step.cube.x0),\n\t\t\tx1: cmp::max (bound.x1, step.cube.x1),\n\t\t\ty0: cmp::min (bound.y0, step.cube.y0),\n\t\t\ty1: cmp::max (bound.y1, step.cube.y1),\n\t\t\tz0: cmp::min (bound.z0, step.cube.z0),\n\t\t\tz1: cmp::max (bound.z1, step.cube.z1),\n\t\t});\n\t\tlet x_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\tx0: bound.x0 + (bound.x1 - bound.x0) * idx / num_splits,\n\t\t\tx1: bound.x0 + (bound.x1 - bound.x0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet y_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\ty0: bound.y0 + (bound.y1 - bound.y0) * idx / num_splits,\n\t\t\ty1: bound.y0 + (bound.y1 - bound.y0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet z_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\tz0: bound.z0 + (bound.z1 - bound.z0) * idx / num_splits,\n\t\t\tz1: bound.z0 + (bound.z1 - bound.z0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet mut total = 0;\n\t\tfor x_bound in x_bounds.iter ().copied () {\n\t\t\tlet steps = bound_steps (\u0026 steps, x_bound);\n\t\t\tfor y_bound in y_bounds.iter ().copied () {\n\t\t\t\tlet steps = bound_steps (\u0026 steps, y_bound);\n\t\t\t\tfor z_bound in z_bounds.iter ().copied () {\n\t\t\t\t\tlet steps = bound_steps (\u0026 steps, z_bound);\n\t\t\t\t\ttotal += calc_result (\u0026 steps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttotal\n\t}\n\n\tpub fn calc_result (steps: \u0026 [Step]) -\u003e i64 {\n\t\tlet mut core: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\t\tlet mut buffer: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\t\tfor step in steps.iter () {\n\t\t\tif step.state {\n\t\t\t\tbuffer.push ((step.cube, true));\n\t\t\t}\n\t\t\tfor (core_cube, core_state) in core.iter ().cloned () {\n\t\t\t\tif let Some (intersect) = core_cube.intersect (step.cube) {\n\t\t\t\t\tbuffer.push ((intersect, ! core_state));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcore.extend (buffer.drain ( .. ));\n\t\t}\n\t\tcore.iter ().cloned ()\n\t\t\t.map (|(cube, state)| cube.volume () * if state { 1 } else { -1 })\n\t\t\t.sum::\u003ci64\u003e ()\n\t}\n\n\tfn bound_steps (steps: \u0026 [Step], bound: Cube) -\u003e Vec \u003cStep\u003e {\n\t\tsteps.iter ().cloned ().filter_map (\n\t\t\t|mut step| step.cube.intersect (bound).map (|cube| { step.cube = cube; step }),\n\t\t).collect ()\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cStep\u003e\u003e {\n\t\tlet err = || format! (\"Invalid input\");\n\t\tlines.iter ().enumerate ().map (|(line_idx, line)| {\n\t\t\tlet mut parser = parser::Parser::new (line, |char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: char {}: {}\", line_idx + 1, char_idx + 1, line));\n\t\t\tlet state = match parser.word () ? {\n\t\t\t\t\"on\" =\u003e true,\n\t\t\t\t\"off\" =\u003e false,\n\t\t\t\t_ =\u003e Err (err ()) ?,\n\t\t\t};\n\t\t\tlet cube = Cube {\n\t\t\t\tx0: parser.expect (\"x=\") ?.int () ?,\n\t\t\t\tx1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t\ty0: parser.expect (\",y=\") ?.int () ?,\n\t\t\t\ty1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t\tz0: parser.expect (\",z=\") ?.int () ?,\n\t\t\t\tz1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t};\n\t\t\tparser.end () ?;\n\t\t\tOk (Step { state, cube })\n\t\t}).collect ()\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Step {\n\t\tpub state: bool,\n\t\tpub cube: Cube,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Cube {\n\t\tpub x0: i32, pub x1: i32,\n\t\tpub y0: i32, pub y1: i32,\n\t\tpub z0: i32, pub z1: i32,\n\t}\n\n\timpl Cube {\n\t\tpub fn overlaps (self, other: Cube) -\u003e bool {\n\t\t\tself.x0 \u003c other.x1 \u0026\u0026 other.x0 \u003c self.x1\n\t\t\t\t\u0026\u0026 self.y0 \u003c other.y1 \u0026\u0026 other.y0 \u003c self.y1\n\t\t\t\t\u0026\u0026 self.z0 \u003c other.z1 \u0026\u0026 other.z0 \u003c self.z1\n\t\t}\n\t\tpub fn intersect (self, other: Cube) -\u003e Option \u003cCube\u003e {\n\t\t\tif self.overlaps (other) {\n\t\t\t\tSome (Cube {\n\t\t\t\t\tx0: cmp::max (self.x0, other.x0),\n\t\t\t\t\tx1: cmp::min (self.x1, other.x1),\n\t\t\t\t\ty0: cmp::max (self.y0, other.y0),\n\t\t\t\t\ty1: cmp::min (self.y1, other.y1),\n\t\t\t\t\tz0: cmp::max (self.z0, other.z0),\n\t\t\t\t\tz1: cmp::min (self.z1, other.z1),\n\t\t\t\t})\n\t\t\t} else { None }\n\t\t}\n\t\tpub fn volume (self) -\u003e i64 {\n\t\t\t(self.x1 as i64 - self.x0 as i64)\n\t\t\t\t* (self.y1 as i64 - self.y0 as i64)\n\t\t\t\t* (self.z1 as i64 - self.z0 as i64)\n\t\t}\n\t\tpub const ZERO: Cube = Cube { x0: 0, x1: 0, y0: 0, y1: 0, z0: 0, z1: 0 };\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Pos { pub z: i32, pub y: i32, pub x: i32 }\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=10..12,y=10..12,z=10..12\",\n\t\t\"on x=11..13,y=11..13,z=11..13\",\n\t\t\"off x=9..11,y=9..11,z=9..11\",\n\t\t\"on x=10..10,y=10..10,z=10..10\",\n\t];\n\n\tconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=-20..26,y=-36..17,z=-47..7\",\n\t\t\"on x=-20..33,y=-21..23,z=-26..28\",\n\t\t\"on x=-22..28,y=-29..23,z=-38..16\",\n\t\t\"on x=-46..7,y=-6..46,z=-50..-1\",\n\t\t\"on x=-49..1,y=-3..46,z=-24..28\",\n\t\t\"on x=2..47,y=-22..22,z=-23..27\",\n\t\t\"on x=-27..23,y=-28..26,z=-21..29\",\n\t\t\"on x=-39..5,y=-6..47,z=-3..44\",\n\t\t\"on x=-30..21,y=-8..43,z=-13..34\",\n\t\t\"on x=-22..26,y=-27..20,z=-29..19\",\n\t\t\"off x=-48..-32,y=26..41,z=-47..-37\",\n\t\t\"on x=-12..35,y=6..50,z=-50..-2\",\n\t\t\"off x=-48..-32,y=-32..-16,z=-15..-5\",\n\t\t\"on x=-18..26,y=-33..15,z=-7..46\",\n\t\t\"off x=-40..-22,y=-38..-28,z=23..41\",\n\t\t\"on x=-16..35,y=-41..10,z=-47..6\",\n\t\t\"off x=-32..-23,y=11..30,z=-14..3\",\n\t\t\"on x=-49..-5,y=-3..45,z=-29..18\",\n\t\t\"off x=18..30,y=-20..-8,z=-3..13\",\n\t\t\"on x=-41..9,y=-7..43,z=-33..15\",\n\t\t\"on x=-54112..-39298,y=-85059..-49293,z=-27449..7877\",\n\t\t\"on x=967..23432,y=45373..81175,z=27513..53682\",\n\t];\n\n\tconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=-5..47,y=-31..22,z=-19..33\",\n\t\t\"on x=-44..5,y=-27..21,z=-14..35\",\n\t\t\"on x=-49..-1,y=-11..42,z=-10..38\",\n\t\t\"on x=-20..34,y=-40..6,z=-44..1\",\n\t\t\"off x=26..39,y=40..50,z=-2..11\",\n\t\t\"on x=-41..5,y=-41..6,z=-36..8\",\n\t\t\"off x=-43..-33,y=-45..-28,z=7..25\",\n\t\t\"on x=-33..15,y=-32..19,z=-34..11\",\n\t\t\"off x=35..47,y=-46..-34,z=-11..5\",\n\t\t\"on x=-14..36,y=-6..44,z=-16..29\",\n\t\t\"on x=-57795..-6158,y=29564..72030,z=20435..90618\",\n\t\t\"on x=36731..105352,y=-21140..28532,z=16094..90401\",\n\t\t\"on x=30999..107136,y=-53464..15513,z=8553..71215\",\n\t\t\"on x=13528..83982,y=-99403..-27377,z=-24141..23996\",\n\t\t\"on x=-72682..-12347,y=18159..111354,z=7391..80950\",\n\t\t\"on x=-1060..80757,y=-65301..-20884,z=-103788..-16709\",\n\t\t\"on x=-83015..-9461,y=-72160..-8347,z=-81239..-26856\",\n\t\t\"on x=-52752..22273,y=-49450..9096,z=54442..119054\",\n\t\t\"on x=-29982..40483,y=-108474..-28371,z=-24328..38471\",\n\t\t\"on x=-4958..62750,y=40422..118853,z=-7672..65583\",\n\t\t\"on x=55694..108686,y=-43367..46958,z=-26781..48729\",\n\t\t\"on x=-98497..-18186,y=-63569..3412,z=1232..88485\",\n\t\t\"on x=-726..56291,y=-62629..13224,z=18033..85226\",\n\t\t\"on x=-110886..-34664,y=-81338..-8658,z=8914..63723\",\n\t\t\"on x=-55829..24974,y=-16897..54165,z=-121762..-28058\",\n\t\t\"on x=-65152..-11147,y=22489..91432,z=-58782..1780\",\n\t\t\"on x=-120100..-32970,y=-46592..27473,z=-11695..61039\",\n\t\t\"on x=-18631..37533,y=-124565..-50804,z=-35667..28308\",\n\t\t\"on x=-57817..18248,y=49321..117703,z=5745..55881\",\n\t\t\"on x=14781..98692,y=-1341..70827,z=15753..70151\",\n\t\t\"on x=-34419..55919,y=-19626..40991,z=39015..114138\",\n\t\t\"on x=-60785..11593,y=-56135..2999,z=-95368..-26915\",\n\t\t\"on x=-32178..58085,y=17647..101866,z=-91405..-8878\",\n\t\t\"on x=-53655..12091,y=50097..105568,z=-75335..-4862\",\n\t\t\"on x=-111166..-40997,y=-71714..2688,z=5609..50954\",\n\t\t\"on x=-16602..70118,y=-98693..-44401,z=5197..76897\",\n\t\t\"on x=16383..101554,y=4615..83635,z=-44907..18747\",\n\t\t\"off x=-95822..-15171,y=-19987..48940,z=10804..104439\",\n\t\t\"on x=-89813..-14614,y=16069..88491,z=-3297..45228\",\n\t\t\"on x=41075..99376,y=-20427..49978,z=-52012..13762\",\n\t\t\"on x=-21330..50085,y=-17944..62733,z=-112280..-30197\",\n\t\t\"on x=-16478..35915,y=36008..118594,z=-7885..47086\",\n\t\t\"off x=-98156..-27851,y=-49952..43171,z=-99005..-8456\",\n\t\t\"off x=2032..69770,y=-71013..4824,z=7471..94418\",\n\t\t\"on x=43670..120875,y=-42068..12382,z=-24787..38892\",\n\t\t\"off x=37514..111226,y=-45862..25743,z=-16714..54663\",\n\t\t\"off x=25699..97951,y=-30668..59918,z=-15349..69697\",\n\t\t\"off x=-44271..17935,y=-9516..60759,z=49131..112598\",\n\t\t\"on x=-61695..-5813,y=40978..94975,z=8655..80240\",\n\t\t\"off x=-101086..-9439,y=-7088..67543,z=33935..83858\",\n\t\t\"off x=18020..114017,y=-48931..32606,z=21474..89843\",\n\t\t\"off x=-77139..10506,y=-89994..-18797,z=-80..59318\",\n\t\t\"off x=8476..79288,y=-75520..11602,z=-96624..-24783\",\n\t\t\"on x=-47488..-1262,y=24338..100707,z=16292..72967\",\n\t\t\"off x=-84341..13987,y=2429..92914,z=-90671..-1318\",\n\t\t\"off x=-37810..49457,y=-71013..-7894,z=-105357..-13188\",\n\t\t\"off x=-27365..46395,y=31009..98017,z=15428..76570\",\n\t\t\"off x=-70369..-16548,y=22648..78696,z=-1892..86821\",\n\t\t\"on x=-53470..21291,y=-120233..-33476,z=-44150..38147\",\n\t\t\"off x=-93533..-4276,y=-16170..68771,z=-104985..-24507\",\n\t];\n\n\t#[ test ]\n\tfn part_one_0 () {\n\t\tassert_eq! (39, logic::calc_result_part_one (EXAMPLE_0).unwrap ());\n\t}\n\n\t#[ test ]\n\tfn part_one_1 () {\n\t\tassert_eq! (590784, logic::calc_result_part_one (EXAMPLE_1).unwrap ());\n\t}\n\n\t#[ test ]\n\tfn part_two () {\n\t\tassert_eq! (2758514936282235, logic::calc_result_part_two (EXAMPLE_2).unwrap ());\n\t}\n\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-22","src","lib.rs"],"content":"//! Advent of Code 2021: Day 22: Reactor Reboot\n//!\n//! [https://adventofcode.com/2021/day/22](https://adventofcode.com/2021/day/22)\n//!\n//! This uses a slightly unintuitive algorithm to count up the activated locations. Instead of\n//! splitting up cubes to enusre they never intersect, we simply add them all together, then keep\n//! track of where they overlapped. Every time we overlap we track the overlapping section as well,\n//! but we add it up as the negative. If we overlap a negative we add it again as a positive.\n//!\n//! To make part two quicker, we split the referenced area up into a 101010 grid and calculate\n//! the value for each section individually. This drastically cuts down on the number of\n//! intersections we need to make.\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Reactor Reboot\";\n\tyear = 2021;\n\tday = 22;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n}\n\npub mod logic {\n\n\tuse super::*;\n\tuse model::Cube;\n\tuse model::Step;\n\n\tpub const BOUND_50: Cube = Cube { x0: -50, y0: -50, z0: -50, x1: 51, y1: 51, z1: 51 };\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tlet steps = bound_steps (\u0026 input, BOUND_50);\n\t\tOk (calc_result (\u0026 steps))\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = model::parse_input (lines) ?;\n\t\tOk (calc_result_with_splits (\u0026 input, 10))\n\t}\n\n\tpub fn calc_result_with_splits (steps: \u0026 [Step], num_splits: i32) -\u003e i64 {\n\t\tlet bound = steps.iter ().copied ().fold (Cube::ZERO, |bound, step| Cube {\n\t\t\tx0: cmp::min (bound.x0, step.cube.x0),\n\t\t\tx1: cmp::max (bound.x1, step.cube.x1),\n\t\t\ty0: cmp::min (bound.y0, step.cube.y0),\n\t\t\ty1: cmp::max (bound.y1, step.cube.y1),\n\t\t\tz0: cmp::min (bound.z0, step.cube.z0),\n\t\t\tz1: cmp::max (bound.z1, step.cube.z1),\n\t\t});\n\t\tlet x_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\tx0: bound.x0 + (bound.x1 - bound.x0) * idx / num_splits,\n\t\t\tx1: bound.x0 + (bound.x1 - bound.x0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet y_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\ty0: bound.y0 + (bound.y1 - bound.y0) * idx / num_splits,\n\t\t\ty1: bound.y0 + (bound.y1 - bound.y0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet z_bounds: Vec \u003c_\u003e = (0 .. num_splits).map (|idx| Cube {\n\t\t\tz0: bound.z0 + (bound.z1 - bound.z0) * idx / num_splits,\n\t\t\tz1: bound.z0 + (bound.z1 - bound.z0) * (idx + 1) / num_splits,\n\t\t\t.. bound\n\t\t}).collect ();\n\t\tlet mut total = 0;\n\t\tfor x_bound in x_bounds.iter ().copied () {\n\t\t\tlet steps = bound_steps (steps, x_bound);\n\t\t\tfor y_bound in y_bounds.iter ().copied () {\n\t\t\t\tlet steps = bound_steps (\u0026 steps, y_bound);\n\t\t\t\tfor z_bound in z_bounds.iter ().copied () {\n\t\t\t\t\tlet steps = bound_steps (\u0026 steps, z_bound);\n\t\t\t\t\ttotal += calc_result (\u0026 steps);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttotal\n\t}\n\n\tpub fn calc_result (steps: \u0026 [Step]) -\u003e i64 {\n\t\tlet mut core: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\t\tlet mut buffer: Vec \u003c(Cube, bool)\u003e = Vec::new ();\n\t\tfor step in steps.iter () {\n\t\t\tif step.state {\n\t\t\t\tbuffer.push ((step.cube, true));\n\t\t\t}\n\t\t\tfor (core_cube, core_state) in core.iter_vals () {\n\t\t\t\tif let Some (intersect) = core_cube.intersect (step.cube) {\n\t\t\t\t\tbuffer.push ((intersect, ! core_state));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcore.append (\u0026 mut buffer);\n\t\t}\n\t\tcore.iter_vals ()\n\t\t\t.map (|(cube, state)| cube.volume () * if state { 1 } else { -1 })\n\t\t\t.sum::\u003ci64\u003e ()\n\t}\n\n\tfn bound_steps (steps: \u0026 [Step], bound: Cube) -\u003e Vec \u003cStep\u003e {\n\t\tsteps.iter ().copied ().filter_map (\n\t\t\t|mut step| step.cube.intersect (bound).map (|cube| { step.cube = cube; step }),\n\t\t).collect ()\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub fn parse_input (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cStep\u003e\u003e {\n\t\tuse parser::*;\n\t\tlines.iter ().enumerate ().map (|(line_idx, line)|\n\t\t\tParser::wrap (line, |parser| {\n\t\t\t\tparser.set_ignore_whitespace (true);\n\t\t\t\tlet state = match parser.word () ? {\n\t\t\t\t\t\"on\" =\u003e true,\n\t\t\t\t\t\"off\" =\u003e false,\n\t\t\t\t\t_ =\u003e Err (parser.err ()) ?,\n\t\t\t\t};\n\t\t\t\tlet cube = Cube {\n\t\t\t\t\tx0: parser.expect (\"x=\") ?.int () ?,\n\t\t\t\t\tx1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t\t\ty0: parser.expect (\",y=\") ?.int () ?,\n\t\t\t\t\ty1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t\t\tz0: parser.expect (\",z=\") ?.int () ?,\n\t\t\t\t\tz1: parser.expect (\"..\") ?.int::\u003ci32\u003e () ? + 1,\n\t\t\t\t};\n\t\t\t\tparser.end () ?;\n\t\t\t\tOk (Step { state, cube })\n\t\t\t}).map_parse_err (|char_idx|\n\t\t\t\tformat! (\"Invalid input: line {}: char {}: {}\", line_idx + 1, char_idx + 1, line))\n\t\t).collect ()\n\t}\n\n\t#[ derive (Clone, Copy, Debug) ]\n\tpub struct Step {\n\t\tpub state: bool,\n\t\tpub cube: Cube,\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub struct Cube {\n\t\tpub x0: i32, pub x1: i32,\n\t\tpub y0: i32, pub y1: i32,\n\t\tpub z0: i32, pub z1: i32,\n\t}\n\n\timpl Cube {\n\t\tpub fn overlaps (self, other: Cube) -\u003e bool {\n\t\t\tself.x0 \u003c other.x1 \u0026\u0026 other.x0 \u003c self.x1\n\t\t\t\t\u0026\u0026 self.y0 \u003c other.y1 \u0026\u0026 other.y0 \u003c self.y1\n\t\t\t\t\u0026\u0026 self.z0 \u003c other.z1 \u0026\u0026 other.z0 \u003c self.z1\n\t\t}\n\t\tpub fn intersect (self, other: Cube) -\u003e Option \u003cCube\u003e {\n\t\t\tif self.overlaps (other) {\n\t\t\t\tSome (Cube {\n\t\t\t\t\tx0: cmp::max (self.x0, other.x0),\n\t\t\t\t\tx1: cmp::min (self.x1, other.x1),\n\t\t\t\t\ty0: cmp::max (self.y0, other.y0),\n\t\t\t\t\ty1: cmp::min (self.y1, other.y1),\n\t\t\t\t\tz0: cmp::max (self.z0, other.z0),\n\t\t\t\t\tz1: cmp::min (self.z1, other.z1),\n\t\t\t\t})\n\t\t\t} else { None }\n\t\t}\n\t\tpub fn volume (self) -\u003e i64 {\n\t\t\t(self.x1.as_i64 () - self.x0.as_i64 ())\n\t\t\t\t* (self.y1.as_i64 () - self.y0.as_i64 ())\n\t\t\t\t* (self.z1.as_i64 () - self.z0.as_i64 ())\n\t\t}\n\t\tpub const ZERO: Cube = Cube { x0: 0, x1: 0, y0: 0, y1: 0, z0: 0, z1: 0 };\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct Pos { pub z: i32, pub y: i32, pub x: i32 }\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=10..12,y=10..12,z=10..12\",\n\t\t\"on x=11..13,y=11..13,z=11..13\",\n\t\t\"off x=9..11,y=9..11,z=9..11\",\n\t\t\"on x=10..10,y=10..10,z=10..10\",\n\t];\n\n\tconst EXAMPLE_1: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=-20..26,y=-36..17,z=-47..7\",\n\t\t\"on x=-20..33,y=-21..23,z=-26..28\",\n\t\t\"on x=-22..28,y=-29..23,z=-38..16\",\n\t\t\"on x=-46..7,y=-6..46,z=-50..-1\",\n\t\t\"on x=-49..1,y=-3..46,z=-24..28\",\n\t\t\"on x=2..47,y=-22..22,z=-23..27\",\n\t\t\"on x=-27..23,y=-28..26,z=-21..29\",\n\t\t\"on x=-39..5,y=-6..47,z=-3..44\",\n\t\t\"on x=-30..21,y=-8..43,z=-13..34\",\n\t\t\"on x=-22..26,y=-27..20,z=-29..19\",\n\t\t\"off x=-48..-32,y=26..41,z=-47..-37\",\n\t\t\"on x=-12..35,y=6..50,z=-50..-2\",\n\t\t\"off x=-48..-32,y=-32..-16,z=-15..-5\",\n\t\t\"on x=-18..26,y=-33..15,z=-7..46\",\n\t\t\"off x=-40..-22,y=-38..-28,z=23..41\",\n\t\t\"on x=-16..35,y=-41..10,z=-47..6\",\n\t\t\"off x=-32..-23,y=11..30,z=-14..3\",\n\t\t\"on x=-49..-5,y=-3..45,z=-29..18\",\n\t\t\"off x=18..30,y=-20..-8,z=-3..13\",\n\t\t\"on x=-41..9,y=-7..43,z=-33..15\",\n\t\t\"on x=-54112..-39298,y=-85059..-49293,z=-27449..7877\",\n\t\t\"on x=967..23432,y=45373..81175,z=27513..53682\",\n\t];\n\n\tconst EXAMPLE_2: \u0026 [\u0026 str] = \u0026 [\n\t\t\"on x=-5..47,y=-31..22,z=-19..33\",\n\t\t\"on x=-44..5,y=-27..21,z=-14..35\",\n\t\t\"on x=-49..-1,y=-11..42,z=-10..38\",\n\t\t\"on x=-20..34,y=-40..6,z=-44..1\",\n\t\t\"off x=26..39,y=40..50,z=-2..11\",\n\t\t\"on x=-41..5,y=-41..6,z=-36..8\",\n\t\t\"off x=-43..-33,y=-45..-28,z=7..25\",\n\t\t\"on x=-33..15,y=-32..19,z=-34..11\",\n\t\t\"off x=35..47,y=-46..-34,z=-11..5\",\n\t\t\"on x=-14..36,y=-6..44,z=-16..29\",\n\t\t\"on x=-57795..-6158,y=29564..72030,z=20435..90618\",\n\t\t\"on x=36731..105352,y=-21140..28532,z=16094..90401\",\n\t\t\"on x=30999..107136,y=-53464..15513,z=8553..71215\",\n\t\t\"on x=13528..83982,y=-99403..-27377,z=-24141..23996\",\n\t\t\"on x=-72682..-12347,y=18159..111354,z=7391..80950\",\n\t\t\"on x=-1060..80757,y=-65301..-20884,z=-103788..-16709\",\n\t\t\"on x=-83015..-9461,y=-72160..-8347,z=-81239..-26856\",\n\t\t\"on x=-52752..22273,y=-49450..9096,z=54442..119054\",\n\t\t\"on x=-29982..40483,y=-108474..-28371,z=-24328..38471\",\n\t\t\"on x=-4958..62750,y=40422..118853,z=-7672..65583\",\n\t\t\"on x=55694..108686,y=-43367..46958,z=-26781..48729\",\n\t\t\"on x=-98497..-18186,y=-63569..3412,z=1232..88485\",\n\t\t\"on x=-726..56291,y=-62629..13224,z=18033..85226\",\n\t\t\"on x=-110886..-34664,y=-81338..-8658,z=8914..63723\",\n\t\t\"on x=-55829..24974,y=-16897..54165,z=-121762..-28058\",\n\t\t\"on x=-65152..-11147,y=22489..91432,z=-58782..1780\",\n\t\t\"on x=-120100..-32970,y=-46592..27473,z=-11695..61039\",\n\t\t\"on x=-18631..37533,y=-124565..-50804,z=-35667..28308\",\n\t\t\"on x=-57817..18248,y=49321..117703,z=5745..55881\",\n\t\t\"on x=14781..98692,y=-1341..70827,z=15753..70151\",\n\t\t\"on x=-34419..55919,y=-19626..40991,z=39015..114138\",\n\t\t\"on x=-60785..11593,y=-56135..2999,z=-95368..-26915\",\n\t\t\"on x=-32178..58085,y=17647..101866,z=-91405..-8878\",\n\t\t\"on x=-53655..12091,y=50097..105568,z=-75335..-4862\",\n\t\t\"on x=-111166..-40997,y=-71714..2688,z=5609..50954\",\n\t\t\"on x=-16602..70118,y=-98693..-44401,z=5197..76897\",\n\t\t\"on x=16383..101554,y=4615..83635,z=-44907..18747\",\n\t\t\"off x=-95822..-15171,y=-19987..48940,z=10804..104439\",\n\t\t\"on x=-89813..-14614,y=16069..88491,z=-3297..45228\",\n\t\t\"on x=41075..99376,y=-20427..49978,z=-52012..13762\",\n\t\t\"on x=-21330..50085,y=-17944..62733,z=-112280..-30197\",\n\t\t\"on x=-16478..35915,y=36008..118594,z=-7885..47086\",\n\t\t\"off x=-98156..-27851,y=-49952..43171,z=-99005..-8456\",\n\t\t\"off x=2032..69770,y=-71013..4824,z=7471..94418\",\n\t\t\"on x=43670..120875,y=-42068..12382,z=-24787..38892\",\n\t\t\"off x=37514..111226,y=-45862..25743,z=-16714..54663\",\n\t\t\"off x=25699..97951,y=-30668..59918,z=-15349..69697\",\n\t\t\"off x=-44271..17935,y=-9516..60759,z=49131..112598\",\n\t\t\"on x=-61695..-5813,y=40978..94975,z=8655..80240\",\n\t\t\"off x=-101086..-9439,y=-7088..67543,z=33935..83858\",\n\t\t\"off x=18020..114017,y=-48931..32606,z=21474..89843\",\n\t\t\"off x=-77139..10506,y=-89994..-18797,z=-80..59318\",\n\t\t\"off x=8476..79288,y=-75520..11602,z=-96624..-24783\",\n\t\t\"on x=-47488..-1262,y=24338..100707,z=16292..72967\",\n\t\t\"off x=-84341..13987,y=2429..92914,z=-90671..-1318\",\n\t\t\"off x=-37810..49457,y=-71013..-7894,z=-105357..-13188\",\n\t\t\"off x=-27365..46395,y=31009..98017,z=15428..76570\",\n\t\t\"off x=-70369..-16548,y=22648..78696,z=-1892..86821\",\n\t\t\"on x=-53470..21291,y=-120233..-33476,z=-44150..38147\",\n\t\t\"off x=-93533..-4276,y=-16170..68771,z=-104985..-24507\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (39, logic::part_one (EXAMPLE_0) ?);\n\t\tassert_eq! (590784, logic::part_one (EXAMPLE_1) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (2758514936282235, logic::part_two (EXAMPLE_2) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":16,"address":[105609,105145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[105230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[105694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[34899,34925,34464],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":33,"address":[34623,34497],"length":1,"stats":{"Line":1},"fn_name":null},{"line":34,"address":[34723,34601],"length":1,"stats":{"Line":2},"fn_name":null},{"line":35,"address":[34784,34851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[34944,35244],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":39,"address":[34977,35097],"length":1,"stats":{"Line":1},"fn_name":null},{"line":40,"address":[35075,35199],"length":1,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[37512,37471,35280],"length":1,"stats":{"Line":1},"fn_name":"calc_result_with_splits"},{"line":44,"address":[35326],"length":1,"stats":{"Line":3},"fn_name":null},{"line":45,"address":[28685],"length":1,"stats":{"Line":1},"fn_name":null},{"line":46,"address":[28708],"length":1,"stats":{"Line":1},"fn_name":null},{"line":47,"address":[28733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":48,"address":[28758],"length":1,"stats":{"Line":1},"fn_name":null},{"line":49,"address":[28783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":50,"address":[28808],"length":1,"stats":{"Line":1},"fn_name":null},{"line":52,"address":[29567,28896],"length":1,"stats":{"Line":3},"fn_name":"{closure#1}"},{"line":53,"address":[28928,29231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[29265,29617,29198],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[30322,29648],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":58,"address":[29987,29680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[29952,30372,30021],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[31089,30416],"length":1,"stats":{"Line":4},"fn_name":"{closure#3}"},{"line":63,"address":[30755,30448],"length":1,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[31140,30720,30789],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[36153],"length":1,"stats":{"Line":1},"fn_name":null},{"line":68,"address":[36457,36249,36173],"length":1,"stats":{"Line":3},"fn_name":null},{"line":69,"address":[36489],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[36823,36631,36552],"length":1,"stats":{"Line":3},"fn_name":null},{"line":71,"address":[36863],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[37176,37020,36953],"length":1,"stats":{"Line":3},"fn_name":null},{"line":73,"address":[37216],"length":1,"stats":{"Line":1},"fn_name":null},{"line":74,"address":[37306,37373,37439],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[37552,38536,38510],"length":1,"stats":{"Line":1},"fn_name":"calc_result"},{"line":82,"address":[37591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[37612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[37745,37874,37675],"length":1,"stats":{"Line":3},"fn_name":null},{"line":85,"address":[37895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[37931],"length":1,"stats":{"Line":1},"fn_name":null},{"line":88,"address":[37909,38149,38029],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[38199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[38338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[38134,38441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[38456,37854],"length":1,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[31193,31184],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":100,"address":[38576],"length":1,"stats":{"Line":1},"fn_name":"bound_steps"},{"line":101,"address":[38689,38631],"length":1,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[31520,31531,31399,31376],"length":1,"stats":{"Line":5},"fn_name":"{closure#0}"},{"line":113,"address":[39904],"length":1,"stats":{"Line":2},"fn_name":"parse_input"},{"line":115,"address":[39954],"length":1,"stats":{"Line":8},"fn_name":null},{"line":116,"address":[66345,69242,65590,65680,65636],"length":1,"stats":{"Line":10},"fn_name":"{closure#0}"},{"line":117,"address":[65726],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[65742,65855],"length":1,"stats":{"Line":2},"fn_name":null},{"line":119,"address":[65971,65827,66010],"length":1,"stats":{"Line":6},"fn_name":null},{"line":120,"address":[66055,66082,65987],"length":1,"stats":{"Line":6},"fn_name":null},{"line":121,"address":[66066,66089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[68934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[66353,66020,66550,66645],"length":1,"stats":{"Line":6},"fn_name":null},{"line":125,"address":[67194,66963,66612,66766],"length":1,"stats":{"Line":6},"fn_name":null},{"line":126,"address":[67421,67516,67166,67224],"length":1,"stats":{"Line":6},"fn_name":null},{"line":127,"address":[67637,68065,67483,67834],"length":1,"stats":{"Line":6},"fn_name":null},{"line":128,"address":[68292,68387,68037,68095],"length":1,"stats":{"Line":6},"fn_name":null},{"line":129,"address":[68354,68994,68705,68508],"length":1,"stats":{"Line":6},"fn_name":null},{"line":131,"address":[69024,69252,68978],"length":1,"stats":{"Line":4},"fn_name":null},{"line":132,"address":[69080],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[69757,69376,65616],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":134,"address":[69419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[40032],"length":1,"stats":{"Line":1},"fn_name":"overlaps"},{"line":153,"address":[40114,40045,40190,40152,40228],"length":1,"stats":{"Line":5},"fn_name":null},{"line":154,"address":[40105,40143],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[40181,40219],"length":1,"stats":{"Line":2},"fn_name":null},{"line":157,"address":[40256],"length":1,"stats":{"Line":1},"fn_name":"intersect"},{"line":158,"address":[40283,40375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":159,"address":[40557],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[40390],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[40413],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[40438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[40463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[40488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[40513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[40369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[40640],"length":1,"stats":{"Line":2},"fn_name":"volume"},{"line":170,"address":[40727,40880,40964,41022,40811,40649],"length":1,"stats":{"Line":6},"fn_name":null},{"line":171,"address":[40829,40711,40762],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[40864,40982,40915],"length":1,"stats":{"Line":4},"fn_name":null},{"line":283,"address":[63088],"length":1,"stats":{"Line":3},"fn_name":"part_one"},{"line":284,"address":[63354,63095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":285,"address":[63315,63398,63639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":286,"address":[63615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[63696],"length":1,"stats":{"Line":3},"fn_name":"part_two"},{"line":291,"address":[63703,63942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[63922],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":89,"coverable":94},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-23","src","lib.rs"],"content":"//! Advent of Code 2021: Day 23: Amphipod\n//!\n//! [https://adventofcode.com/2021/day/23](https://adventofcode.com/2021/day/23)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Amphipod\";\n\tyear = 2021;\n\tday = 23;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n\tcommands = [\n\t\t( name = \"run\"; method = tools::run; ),\n\t\t( name = \"internals\"; method = tools::internals; ),\n\t];\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Amph;\n\tuse model::Place;\n\tuse model::State;\n\tuse model::StateCompact;\n\tuse nums::IntConv;\n\tuse search::PrioritySearch;\n\tuse search::PrioritySearchAdder;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet input = State::parse (lines) ?;\n\t\tcalc_result (input)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet lines_modified = modify_input_for_part_two (lines);\n\t\tlet input = State::parse (\u0026 lines_modified) ?;\n\t\tcalc_result (input)\n\t}\n\n\tpub fn modify_input_for_part_two \u003c'a\u003e (lines: \u0026 [\u0026 'a str]) -\u003e Vec \u003c\u0026 'a str\u003e {\n\t\tvec! [\n\t\t\tlines [0],\n\t\t\tlines [1],\n\t\t\tlines [2],\n\t\t\t\"  #D#C#B#A#\",\n\t\t\t\"  #D#B#A#C#\",\n\t\t\tlines [3],\n\t\t\tlines [4],\n\t\t]\n\t}\n\n\tpub fn calc_result (input: State) -\u003e GenResult \u003ci64\u003e {\n\t\tOk (\n\t\t\titerator (input)\n\t\t\t\t.filter (|(state_compact, _)| state_compact.is_finished ())\n\t\t\t\t.map (|(_, score)| score)\n\t\t\t\t.next ()\n\t\t\t\t.ok_or (\"Failed to find solution\") ?\n\t\t)\n\t}\n\n\tpub fn iterator (input: State) -\u003e impl Iterator \u003cItem = (StateCompact, i64)\u003e {\n\t\tlet mut search = PrioritySearch::with_hash_map (\n\t\t\t|state: StateCompact, score: i64, mut adder: PrioritySearchAdder \u003c'_, _, _, _\u003e| {\n\t\t\t\tfor (next_state, next_cost) in calc_next_states (state) {\n\t\t\t\t\tlet next_score = score + next_cost;\n\t\t\t\t\tadder.add (next_state, next_score);\n\t\t\t\t}\n\t\t\t\t(state, score)\n\t\t\t},\n\t\t);\n\t\tsearch.push (input.compact (), 0);\n\t\tsearch\n\t}\n\n\tpub fn calc_next_states (state_compact: StateCompact) -\u003e ArrayVec \u003c(StateCompact, i64), 28\u003e {\n\t\tlet state = state_compact.expand ();\n\n\t\tlet out_cost = |room| state.room_size () - state.room (room).len () + 1;\n\t\tlet in_cost = |room| state.room_size () - state.room (room).len ();\n\t\tlet hall_cost = |room: Amph, hall: Place|\n\t\t\tusize::abs_diff (2 + room.idx () * 2, hall.idx ());\n\n\t\tlet next_moves = calc_next_moves (\u0026 state);\n\t\tif next_moves.is_empty () { return ArrayVec::new () }\n\n\t\tlet blocking = (state.hall () [3], state.hall () [5], state.hall () [7]);\n\t\tlet sections = [\n\t\t\t! matches! (blocking,\n\t\t\t\t(Some (Amph::Copper), _, _) | (Some (Amph::Desert), _, _) |\n\t\t\t\t(_, Some (Amph::Bronze), _) | (_, Some (Amph::Copper), _) |\n\t\t\t\t(_, Some (Amph::Desert), _) | (_, _, Some (Amph::Desert))\n\t\t\t),\n\t\t\t! matches! (blocking,\n\t\t\t\t(Some (Amph::Amber), _, _) | (_, Some (Amph::Copper), _) |\n\t\t\t\t(_, Some (Amph::Desert), _) | (_, _, Some (Amph::Desert))\n\t\t\t),\n\t\t\t! matches! (blocking,\n\t\t\t\t(Some (Amph::Amber), _, _) | (_, Some (Amph::Amber), _) |\n\t\t\t\t(_, Some (Amph::Bronze), _) | (_, _, Some (Amph::Desert))\n\t\t\t),\n\t\t\t! matches! (blocking,\n\t\t\t\t(Some (Amph::Amber), _, _) | (_, Some (Amph::Amber), _) |\n\t\t\t\t(_, Some (Amph::Bronze), _) | (_, _, Some (Amph::Amber)) |\n\t\t\t\t(_, _, Some (Amph::Bronze)) | (_, _, Some (Amph::Copper))\n\t\t\t),\n\t\t];\n\n\t\tlet mut next_states = ArrayVec::new ();\n\t\tfor next_move in next_moves.iter ().copied () {\n\t\t\tmatch next_move {\n\t\t\t\tMove::Between (amph, from_room, to_room) =\u003e {\n\t\t\t\t\tif ! sections [from_room.idx ()] || ! sections [to_room.idx ()] { continue }\n\t\t\t\t\tlet cost = amph.cost () * (out_cost (from_room) + in_cost (to_room)\n\t\t\t\t\t\t+ usize::abs_diff (from_room.idx (), to_room.idx ()) * 2).as_i64 ();\n\t\t\t\t\tlet next_state = state.move_between (from_room, to_room);\n\t\t\t\t\treturn iter::once ((next_state.compact (), cost)).collect ();\n\t\t\t\t},\n\t\t\t\tMove::In (amph, from_hall, to_room) =\u003e {\n\t\t\t\t\tif ! sections [to_room.idx ()] { continue }\n\t\t\t\t\tlet cost = amph.cost () * (in_cost (to_room) + hall_cost (to_room, from_hall)).as_i64 ();\n\t\t\t\t\tlet next_state = state.move_in (from_hall, to_room);\n\t\t\t\t\treturn iter::once ((next_state.compact (), cost)).collect ();\n\t\t\t\t},\n\t\t\t\t_ =\u003e (),\n\t\t\t}\n\t\t}\n\t\tfor next_move in next_moves.iter ().copied () {\n\t\t\tif let Move::Out (amph, from_room, to_hall) = next_move {\n\t\t\t\tif ! sections [from_room.idx ()] { continue }\n\t\t\t\tlet cost = amph.cost () * (out_cost (from_room)\n\t\t\t\t\t+ hall_cost (from_room, to_hall)).as_i64 ();\n\t\t\t\tlet next_state = state.move_out (from_room, to_hall);\n\t\t\t\tnext_states.push ((next_state.compact (), cost));\n\t\t\t}\n\t\t}\n\n\t\tnext_states\n\n\t}\n\n\t#[ derive (Clone, Copy) ]\n\tpub enum Move {\n\t\tOut (Amph, Amph, Place),\n\t\tIn (Amph, Place, Amph),\n\t\tBetween (Amph, Amph, Amph),\n\t}\n\n\tpub fn calc_next_moves (state: \u0026 State) -\u003e ArrayVec \u003cMove, 28\u003e {\n\t\tlet mut result = ArrayVec::new ();\n\t\tlet path_clear = |from: Place, to: Place|\n\t\t\tstate.hall ().iter ().enumerate ()\n\t\t\t\t.skip (cmp::min (to.idx (), from.idx ()))\n\t\t\t\t.take (usize::abs_diff (from.idx (), to.idx ()) + 1)\n\t\t\t\t.map (|(idx, amph)| (Place::for_idx (idx), amph))\n\t\t\t\t.filter (|\u0026 (hall, _)| hall != from)\n\t\t\t\t.all (|(_, amph)| amph.is_none ());\n\t\tlet room_entrance = |room: Amph| Place::for_idx (2 + room.idx () * 2);\n\t\tfor (idx, amph) in state.hall ().iter ().enumerate ()\n\t\t\t\t.filter_map (|(idx, amph)| amph.map (|amph| (idx, amph))) {\n\t\t\tlet to_room = amph;\n\t\t\tlet hall = Place::for_idx (idx);\n\t\t\tif ! state.room_is_happy (to_room) { continue }\n\t\t\tif ! path_clear (hall, room_entrance (to_room)) { continue }\n\t\t\tresult.clear ();\n\t\t\tresult.push (Move::In (amph, hall, to_room));\n\t\t\treturn result;\n\t\t}\n\t\tfor (from_room, amphs) in [\n\t\t\t(Amph::Amber, state.room (Amph::Amber)),\n\t\t\t(Amph::Bronze, state.room (Amph::Bronze)),\n\t\t\t(Amph::Copper, state.room (Amph::Copper)),\n\t\t\t(Amph::Desert, state.room (Amph::Desert)),\n\t\t] {\n\t\t\tif let Some (\u0026 amph) = amphs.last () {\n\t\t\t\tlet to_room = amph;\n\t\t\t\tif state.room_is_happy (from_room) { continue }\n\t\t\t\tif state.room_is_happy (to_room) {\n\t\t\t\t\tif ! path_clear (room_entrance (from_room), room_entrance (to_room)) { continue }\n\t\t\t\t\tresult.clear ();\n\t\t\t\t\tresult.push (Move::Between (amph, from_room, to_room));\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\tfor hall in\n\t\t\t\t\t\titer::successors (\n\t\t\t\t\t\t\t\tSome (room_entrance (from_room)),\n\t\t\t\t\t\t\t\t|prev_hall| if prev_hall.idx () \u003e 0 {\n\t\t\t\t\t\t\t\t\tSome (Place::for_idx (prev_hall.idx () - 1))\n\t\t\t\t\t\t\t\t} else { None })\n\t\t\t\t\t\t\t.take_while (|\u0026 hall| state.get (hall).is_none ())\n\t\t\t\t\t\t\t.chain (\n\t\t\t\t\t\t\t\titer::successors (\n\t\t\t\t\t\t\t\t\t\tSome (room_entrance (from_room)),\n\t\t\t\t\t\t\t\t\t\t|prev_hall| if prev_hall.idx () + 1 \u003c 11 {\n\t\t\t\t\t\t\t\t\t\t\tSome (Place::for_idx (prev_hall.idx () + 1))\n\t\t\t\t\t\t\t\t\t\t} else { None })\n\t\t\t\t\t\t\t\t\t.take_while (|\u0026 hall| state.get (hall).is_none ()))\n\t\t\t\t\t\t\t.filter (|hall| ! hall.entrance ()) {\n\t\t\t\t\t\tif ! path_clear (room_entrance (from_room), hall) { continue }\n\t\t\t\t\t\tresult.push (Move::Out (amph, from_room, hall));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult\n\t}\n\n}\n\nmod model {\n\n\tuse aoc_common::*;\n\tuse nums::IntConv;\n\n\t#[ derive (Clone, Debug, Eq, PartialEq) ]\n\tpub struct State {\n\t\troom_size: usize,\n\t\thall: ArrayVec \u003cOption \u003cAmph\u003e, 11\u003e,\n\t\tamber: ArrayVec \u003cAmph, 4\u003e,\n\t\tbronze: ArrayVec \u003cAmph, 4\u003e,\n\t\tcopper: ArrayVec \u003cAmph, 4\u003e,\n\t\tdesert: ArrayVec \u003cAmph, 4\u003e,\n\t}\n\n\timpl State {\n\n\t\tpub fn from_array (room_size: usize, places: [Option \u003cAmph\u003e; 27]) -\u003e State {\n\t\t\tlet mut state = State {\n\t\t\t\troom_size,\n\t\t\t\thall: ArrayVec::new (),\n\t\t\t\tamber: ArrayVec::new (),\n\t\t\t\tbronze: ArrayVec::new (),\n\t\t\t\tcopper: ArrayVec::new (),\n\t\t\t\tdesert: ArrayVec::new (),\n\t\t\t};\n\t\t\tstate.hall = places [0 .. 11].iter ().copied ().collect ();\n\t\t\tfor room in Amph::ALL.iter ().copied () {\n\t\t\t\tstate.room_mut (room).extend (\n\t\t\t\t\tplaces [11 + room.idx () * 4 .. ].iter ().copied ().take (room_size).rev ()\n\t\t\t\t\t\t.while_some ());\n\t\t\t}\n\t\t\tstate\n\t\t}\n\n\t\tpub fn as_array (\u0026 self) -\u003e [Option \u003cAmph\u003e; 27] {\n\t\t\tlet mut result = [None; 27];\n\t\t\tfor idx in 0 .. 11 { result [idx] = self.hall [idx]; }\n\t\t\tfor (idx, amph) in self.amber.iter ().copied ().enumerate () {\n\t\t\t\tresult [11 + self.room_size - idx - 1] = Some (amph);\n\t\t\t}\n\t\t\tfor (idx, amph) in self.bronze.iter ().copied ().enumerate () {\n\t\t\t\tresult [15 + self.room_size - idx - 1] = Some (amph);\n\t\t\t}\n\t\t\tfor (idx, amph) in self.copper.iter ().copied ().enumerate () {\n\t\t\t\tresult [19 + self.room_size - idx - 1] = Some (amph);\n\t\t\t}\n\t\t\tfor (idx, amph) in self.desert.iter ().copied ().enumerate () {\n\t\t\t\tresult [23 + self.room_size - idx - 1] = Some (amph);\n\t\t\t}\n\t\t\tresult\n\t\t}\n\n\t\tpub fn room_size (\u0026 self) -\u003e usize { self.room_size }\n\n\t\tpub fn get (\u0026 self, place: Place) -\u003e Option \u003cAmph\u003e {\n\t\t\tmatch place {\n\t\t\t\tPlace::Hall (id) =\u003e self.hall [id.as_usize ()],\n\t\t\t\tPlace::Room (Amph::Amber, depth) =\u003e\n\t\t\t\t\tself.amber.get (self.room_size - depth.as_usize () - 1).copied (),\n\t\t\t\tPlace::Room (Amph::Bronze, depth) =\u003e\n\t\t\t\t\tself.bronze.get (self.room_size - depth.as_usize () - 1).copied (),\n\t\t\t\tPlace::Room (Amph::Copper, depth) =\u003e\n\t\t\t\t\tself.copper.get (self.room_size - depth.as_usize () - 1).copied (),\n\t\t\t\tPlace::Room (Amph::Desert, depth) =\u003e\n\t\t\t\t\tself.desert.get (self.room_size - depth.as_usize () - 1).copied (),\n\t\t\t}\n\t\t}\n\n\t\tpub fn hall (\u0026 self) -\u003e \u0026 [Option \u003cAmph\u003e] { \u0026 self.hall }\n\n\t\tpub fn room (\u0026 self, amph: Amph) -\u003e \u0026 [Amph] {\n\t\t\tmatch amph {\n\t\t\t\tAmph::Amber =\u003e \u0026 self.amber,\n\t\t\t\tAmph::Bronze =\u003e \u0026 self.bronze,\n\t\t\t\tAmph::Copper =\u003e \u0026 self.copper,\n\t\t\t\tAmph::Desert =\u003e \u0026 self.desert,\n\t\t\t}\n\t\t}\n\n\t\tfn room_mut (\u0026 mut self, amph: Amph) -\u003e \u0026 mut ArrayVec \u003cAmph, 4\u003e {\n\t\t\tmatch amph {\n\t\t\t\tAmph::Amber =\u003e \u0026 mut self.amber,\n\t\t\t\tAmph::Bronze =\u003e \u0026 mut self.bronze,\n\t\t\t\tAmph::Copper =\u003e \u0026 mut self.copper,\n\t\t\t\tAmph::Desert =\u003e \u0026 mut self.desert,\n\t\t\t}\n\t\t}\n\n\t\tpub fn is_finished (\u0026 self) -\u003e bool {\n\t\t\tself.hall.iter ().all (Option::is_none)\n\t\t\t\t\u0026\u0026 self.amber.iter ().all (|\u0026 amph| amph == Amph::Amber)\n\t\t\t\t\u0026\u0026 self.bronze.iter ().all (|\u0026 amph| amph == Amph::Bronze)\n\t\t\t\t\u0026\u0026 self.copper.iter ().all (|\u0026 amph| amph == Amph::Copper)\n\t\t\t\t\u0026\u0026 self.desert.iter ().all (|\u0026 amph| amph == Amph::Desert)\n\t\t}\n\n\t\tpub fn room_is_happy (\u0026 self, room: Amph) -\u003e bool {\n\t\t\tself.room (room).iter ().copied ().all (|amph| amph == room)\n\t\t}\n\n\t\tpub fn move_out (\u0026 self, room: Amph, hall: Place) -\u003e State {\n\t\t\tlet mut state = self.clone ();\n\t\t\tlet amph = state.room_mut (room).pop ().unwrap ();\n\t\t\tassert! (state.get (hall).is_none ());\n\t\t\tstate.hall [hall.idx ()] = Some (amph);\n\t\t\tstate\n\t\t}\n\n\t\tpub fn move_in (\u0026 self, hall: Place, room: Amph) -\u003e State {\n\t\t\tlet mut state = self.clone ();\n\t\t\tlet amph = state.hall [hall.idx ()].take ().unwrap ();\n\t\t\tstate.room_mut (room).push (amph);\n\t\t\tstate\n\t\t}\n\n\t\tpub fn move_between (\u0026 self, from: Amph, to: Amph) -\u003e State {\n\t\t\tlet mut state = self.clone ();\n\t\t\tlet amph = state.room_mut (from).pop ().unwrap ();\n\t\t\tlet to = match to {\n\t\t\t\tAmph::Amber =\u003e \u0026 mut state.amber, Amph::Bronze =\u003e \u0026 mut state.bronze,\n\t\t\t\tAmph::Copper =\u003e \u0026 mut state.copper, Amph::Desert =\u003e \u0026 mut state.desert,\n\t\t\t};\n\t\t\tassert! (to.len () \u003c self.room_size);\n\t\t\tto.push (amph);\n\t\t\tstate\n\t\t}\n\n\t\tpub fn pretty_line (\u0026 self, line: usize) -\u003e String {\n\t\t\tlet print_amph = |amph: Option \u003cAmph\u003e| amph.map (Amph::letter).unwrap_or (' ');\n\t\t\tif line == 0 {\n\t\t\t\tformat! (\"\")\n\t\t\t} else if line == 1 {\n\t\t\t\tformat! (\"{}\",\n\t\t\t\t\tself.hall.iter ().copied ().map (print_amph).collect::\u003cString\u003e ())\n\t\t\t} else if line == 2 {\n\t\t\t\tformat! (\"{}{}{}{}\",\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Amber, 0))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Bronze, 0))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Copper, 0))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Desert, 0))))\n\t\t\t} else if line \u003c self.room_size.as_usize () + 2 {\n\t\t\t\tlet depth = (line - 2).as_u8 ();\n\t\t\t\tformat! (\"  {}{}{}{}\",\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Amber, depth))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Bronze, depth))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Copper, depth))),\n\t\t\t\t\tprint_amph (self.get (Place::Room (Amph::Desert, depth))))\n\t\t\t} else if line == self.room_size.as_usize () + 2 {\n\t\t\t\tformat! (\"  \")\n\t\t\t} else {\n\t\t\t\tpanic! ();\n\t\t\t}\n\t\t}\n\n\t\t#[ allow (dead_code) ]\n\t\tpub fn print (\u0026 self) {\n\t\t\tfor line in 0 .. self.room_size.as_usize () + 3 {\n\t\t\t\tprintln! (\"{}\", self.pretty_line (line));\n\t\t\t}\n\t\t}\n\n\t\t#[ allow (dead_code) ]\n\t\tpub fn from_str (input: \u0026 str) -\u003e Option \u003cState\u003e {\n\t\t\tlet num_chars = input.chars ().count ();\n\t\t\tif ! [23, 27, 31].contains (\u0026 num_chars) { return None }\n\t\t\tlet room_size = (num_chars - 11) / 5;\n\t\t\tlet mut places = [None; 27];\n\t\t\tlet mut place_idx = 0;\n\t\t\tfor (char_idx, letter) in input.chars ().enumerate () {\n\t\t\t\tif 11 \u003c= char_idx \u0026\u0026 (char_idx - 11) % (room_size + 1) == 0 {\n\t\t\t\t\tif letter != '/' { return None }\n\t\t\t\t\tif 11 \u003c char_idx { place_idx += 4 - room_size; }\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tplaces [place_idx] = match Amph::from_letter (letter) {\n\t\t\t\t\tSome (amph) =\u003e amph,\n\t\t\t\t\tNone =\u003e return None,\n\t\t\t\t};\n\t\t\t\tplace_idx += 1;\n\t\t\t}\n\t\t\tSome (State::from_array (room_size, places))\n\t\t}\n\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cState\u003e {\n\t\t\tlet err = |line_idx| format! (\"Invalid input: {}: {}\", line_idx, lines [line_idx]);\n\t\t\tif lines.len () \u003c 5 || lines.len () \u003e 7 { Err (err (5)) ?; }\n\t\t\tif lines [0] != \"#############\" { Err (err (0)) ?; }\n\t\t\tif lines [1] != \"#...........#\" { Err (err (1)) ?; }\n\t\t\tfor line_idx in 2 .. lines.len () - 1 {\n\t\t\t\tif line_idx == 2 \u0026\u0026 lines [line_idx].len () != 13 { Err (err (line_idx)) ?; }\n\t\t\t\tif line_idx != 2 \u0026\u0026 lines [line_idx].len () != 11 { Err (err (line_idx)) ?; }\n\t\t\t\tif line_idx == 2 \u0026\u0026 \u0026 lines [line_idx] [0 .. 3] != \"###\" { Err (err (line_idx)) ?; }\n\t\t\t\tif line_idx != 2 \u0026\u0026 \u0026 lines [line_idx] [0 .. 3] != \"  #\" { Err (err (line_idx)) ?; }\n\t\t\t\tif \u0026 lines [line_idx] [4 .. 5] != \"#\" { Err (err (line_idx)) ?; }\n\t\t\t\tif \u0026 lines [line_idx] [6 .. 7] != \"#\" { Err (err (line_idx)) ?; }\n\t\t\t\tif \u0026 lines [line_idx] [8 .. 9] != \"#\" { Err (err (line_idx)) ?; }\n\t\t\t\tif line_idx == 2 \u0026\u0026 \u0026 lines [line_idx] [10 .. 13] != \"###\" { Err (err (line_idx)) ?; }\n\t\t\t\tif line_idx != 2 \u0026\u0026 \u0026 lines [line_idx] [10 .. 11] != \"#\" { Err (err (line_idx)) ?; }\n\t\t\t}\n\t\t\tlet line_idx = lines.len () - 1;\n\t\t\tif lines [line_idx] != \"  #########\" { Err (err (line_idx)) ?; }\n\t\t\tlet room_size = lines.len () - 3;\n\t\t\tlet parse_amph = |line: usize, col| Amph::from_letter (\n\t\t\t\tlines [line].chars ().nth (col).unwrap (),\n\t\t\t).ok_or_else (|| err (line));\n\t\t\tlet mut places = [None; 27];\n\t\t\tfor idx in 0 .. 11 { places [idx] = parse_amph (1, 1 + idx) ?; }\n\t\t\tfor room in 0 .. 4 {\n\t\t\t\tfor depth in 0 .. room_size {\n\t\t\t\t\tplaces [11 + room * 4 + depth] = parse_amph (2 + depth, 3 + room * 2) ?;\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (State::from_array (room_size, places))\n\t\t}\n\n\t\tpub fn compact (\u0026 self) -\u003e StateCompact {\n\t\t\tlet mut place_bits: u64 = 0;\n\t\t\tlet mut amph_bits: u64 = 0;\n\t\t\tfor amph in self.as_array () {\n\t\t\t\tplace_bits \u003c\u003c= 1;\n\t\t\t\tif let Some (amph) = amph {\n\t\t\t\t\tplace_bits |= 1;\n\t\t\t\t\tamph_bits \u003c\u003c= 2;\n\t\t\t\t\tamph_bits |= match amph {\n\t\t\t\t\t\tAmph::Amber =\u003e 0, Amph::Bronze =\u003e 1,\n\t\t\t\t\t\tAmph::Copper =\u003e 2, Amph::Desert =\u003e 3,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert! (64 - place_bits.leading_zeros () \u003c= 27);\n\t\t\tassert! (64 - amph_bits.leading_zeros () \u003c= 32);\n\t\t\tlet data = ((self.room_size.as_u64 ()) \u003c\u003c 59) | (place_bits \u003c\u003c 32) | amph_bits;\n\t\t\tStateCompact { data }\n\t\t}\n\n\t}\n\n\timpl fmt::Display for State {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tfor amph in self.hall.iter ().copied () {\n\t\t\t\twrite! (formatter, \"{}\", amph.map (Amph::letter).unwrap_or ('.')) ?;\n\t\t\t}\n\t\t\tfor room in [\u0026 self.amber, \u0026 self.bronze, \u0026 self.copper, \u0026 self.desert] {\n\t\t\t\twrite! (formatter, \"/\") ?;\n\t\t\t\tfor amph in iter::repeat (None).take (self.room_size - room.len ())\n\t\t\t\t\t\t.chain (room.iter ().copied ().rev ().map (Some)) {\n\t\t\t\t\twrite! (formatter, \"{}\", amph.map (Amph::letter).unwrap_or ('.')) ?;\n\t\t\t\t}\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub struct StateCompact {\n\t\tdata: u64,\n\t}\n\n\timpl StateCompact {\n\t\tpub fn expand (self) -\u003e State {\n\t\t\tlet mut present_bits = (self.data \u0026 0x07ffffff00000000) \u003e\u003e 32;\n\t\t\tlet mut amph_bits = self.data \u0026 0x00000000ffffffff;\n\t\t\tlet mut places = [None; 27];\n\t\t\tfor place_idx in (0 .. 27).rev () {\n\t\t\t\tif present_bits \u0026 1 != 0 {\n\t\t\t\t\tmatch amph_bits \u0026 0x3 {\n\t\t\t\t\t\t0 =\u003e places [place_idx] = Some (Amph::Amber),\n\t\t\t\t\t\t1 =\u003e places [place_idx] = Some (Amph::Bronze),\n\t\t\t\t\t\t2 =\u003e places [place_idx] = Some (Amph::Copper),\n\t\t\t\t\t\t3 =\u003e places [place_idx] = Some (Amph::Desert),\n\t\t\t\t\t\t_ =\u003e unreachable! (),\n\t\t\t\t\t}\n\t\t\t\t\tamph_bits \u003e\u003e= 2;\n\t\t\t\t}\n\t\t\t\tpresent_bits \u003e\u003e= 1;\n\t\t\t}\n\t\t\tlet room_size = (self.data \u003e\u003e 59).as_usize ();\n\t\t\tState::from_array (room_size, places)\n\t\t}\n\t\tpub fn is_finished (self) -\u003e bool {\n\t\t\tlet mut present_bits = (self.data \u0026 0x07ffffff00000000) \u003e\u003e 32;\n\t\t\tif present_bits \u0026 0x07ff0000 != 0 { return false }\n\t\t\tlet mut amph_bits = self.data \u0026 0x00000000ffffffff;\n\t\t\tfor idx in (0 .. 4).rev () {\n\t\t\t\tfor _ in 0 .. 4 {\n\t\t\t\t\tif present_bits \u0026 1 != 0 {\n\t\t\t\t\t\tif amph_bits \u0026 0x3 != idx { return false }\n\t\t\t\t\t\tamph_bits \u003e\u003e= 2;\n\t\t\t\t\t}\n\t\t\t\t\tpresent_bits \u003e\u003e= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrue\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, PartialEq) ]\n\tpub enum Place {\n\t\tHall (u8),\n\t\tRoom (Amph, u8),\n\t}\n\n\timpl Place {\n\t\tpub fn idx (self) -\u003e usize {\n\t\t\tmatch self {\n\t\t\t\tPlace::Hall (id) =\u003e id.as_usize (),\n\t\t\t\tPlace::Room (Amph::Amber, depth) =\u003e 11 + depth.as_usize (),\n\t\t\t\tPlace::Room (Amph::Bronze, depth) =\u003e 15 + depth.as_usize (),\n\t\t\t\tPlace::Room (Amph::Copper, depth) =\u003e 19 + depth.as_usize (),\n\t\t\t\tPlace::Room (Amph::Desert, depth) =\u003e 23 + depth.as_usize (),\n\t\t\t}\n\t\t}\n\t\tpub fn for_idx (idx: usize) -\u003e Place {\n\t\t\tmatch idx {\n\t\t\t\t0 ..= 10 =\u003e Place::Hall (idx.as_u8 ()),\n\t\t\t\t11 ..= 14 =\u003e Place::Room (Amph::Amber, idx.as_u8 () - 11),\n\t\t\t\t15 ..= 18 =\u003e Place::Room (Amph::Bronze, idx.as_u8 () - 15),\n\t\t\t\t19 ..= 22 =\u003e Place::Room (Amph::Copper, idx.as_u8 () - 19),\n\t\t\t\t23 ..= 26 =\u003e Place::Room (Amph::Desert, idx.as_u8 () - 23),\n\t\t\t\t_ =\u003e panic! (),\n\t\t\t}\n\t\t}\n\t\tpub fn entrance (self) -\u003e bool { [2, 4, 6, 8].contains (\u0026 self.idx ()) }\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\tpub enum Amph { Amber, Bronze, Copper, Desert }\n\n\timpl Amph {\n\t\tpub fn idx (self) -\u003e usize {\n\t\t\tmatch self {\n\t\t\t\tAmph::Amber =\u003e 0,\n\t\t\t\tAmph::Bronze =\u003e 1,\n\t\t\t\tAmph::Copper =\u003e 2,\n\t\t\t\tAmph::Desert =\u003e 3,\n\t\t\t}\n\t\t}\n\t\tpub fn from_letter (letter: char) -\u003e Option \u003cOption \u003cAmph\u003e\u003e {\n\t\t\tmatch letter {\n\t\t\t\t'A' =\u003e Some (Some (Amph::Amber)),\n\t\t\t\t'B' =\u003e Some (Some (Amph::Bronze)),\n\t\t\t\t'C' =\u003e Some (Some (Amph::Copper)),\n\t\t\t\t'D' =\u003e Some (Some (Amph::Desert)),\n\t\t\t\t'.' =\u003e Some (None), _ =\u003e None,\n\t\t\t}\n\t\t}\n\t\tpub fn cost (self) -\u003e i64 { Amph::COSTS [self.idx ()] }\n\t\tpub fn letter (self) -\u003e char { Amph::LETTERS [self.idx ()] }\n\t\tconst COSTS: \u0026 'static [i64; 4] = \u0026 [1, 10, 100, 1000];\n\t\tconst LETTERS: \u0026 'static [char; 4] = \u0026 ['A', 'B', 'C', 'D'];\n\t\tpub const ALL: \u0026 'static [Amph] = \u0026 [\n\t\t\tAmph::Amber, Amph::Bronze, Amph::Copper, Amph::Desert\n\t\t];\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\t#[ test ]\n\t\tfn test_state_finished () {\n\t\t\tassert! (State::from_str (\".........../AA/BB/CC/DD\").unwrap ().is_finished ());\n\t\t\tassert! (! State::from_str (\"A........../.A/BB/CC/DD\").unwrap ().is_finished ());\n\t\t}\n\n\t}\n\n}\n\npub mod tools {\n\n\tuse super::*;\n\tuse model::State;\n\tuse nums::IntConv;\n\tuse search::PrioritySearch;\n\tuse search::PrioritySearchAdder;\n\n\t#[ derive (Debug, clap::Parser) ]\n\tpub struct RunArgs {\n\n\t\t#[ clap (long, default_value (\"inputs/day-23\")) ]\n\t\tinput: String,\n\n\t\t#[ clap (long) ]\n\t\tverbose: bool,\n\n\t\t#[ clap (long) ]\n\t\tdead_ends: bool,\n\n\t\t#[ clap (long) ]\n\t\tpart_1: bool,\n\n\t\t#[ clap (long) ]\n\t\tpart_2: bool,\n\n\t}\n\n\tpub fn run (args: RunArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet mut args = args;\n\t\tif ! (args.part_1 || args.part_2) { args.part_1 = true; args.part_2 = true; }\n\t\tlet input_string = fs::read_to_string (\u0026 args.input) ?;\n\t\tlet input_lines: Vec \u003c_\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tif args.part_1 {\n\t\t\trun_part (\u0026 args, \u0026 input_lines) ?;\n\t\t}\n\t\tif args.part_2 {\n\t\t\tlet input_lines_modified = logic::modify_input_for_part_two (\u0026 input_lines);\n\t\t\trun_part (\u0026 args, \u0026 input_lines_modified) ?;\n\t\t}\n\t\tOk (())\n\t}\n\n\tpub fn run_part (args: \u0026 RunArgs, lines: \u0026 [\u0026 str]) -\u003e GenResult \u003c()\u003e {\n\t\tlet input = State::parse (lines) ?;\n\t\tlet mut num_loops = 0;\n\t\tlet mut last_cost = -1;\n\t\tlet mut prev_states = HashMap::new ();\n\t\tlet mut search = PrioritySearch::with_hash_map (\n\t\t\t|state_compact, score, mut adder: PrioritySearchAdder \u003c_, _, _\u003e| {\n\t\t\t\tlet next_states_compact = logic::calc_next_states (state_compact);\n\t\t\t\tfor (next_state_compact, next_cost) in next_states_compact.iter ().copied () {\n\t\t\t\t\tlet next_score = score + next_cost;\n\t\t\t\t\tadder.add (next_state_compact, next_score);\n\t\t\t\t}\n\t\t\t\t(state_compact, score, next_states_compact)\n\t\t\t},\n\t\t);\n\t\tsearch.push (input.compact (), 0);\n\t\tlet final_cost = loop {\n\t\t\tlet (state_compact, cost, next_states_compact) = match search.next () {\n\t\t\t\tSome (val) =\u003e val,\n\t\t\t\tNone =\u003e break None,\n\t\t\t};\n\t\t\tnum_loops += 1;\n\t\t\tlet state = state_compact.expand ();\n\t\t\tif state.is_finished () {\n\t\t\t\tbreak Some ((state_compact, cost));\n\t\t\t}\n\t\t\tif args.verbose {\n\t\t\t\tlet next_states: Vec \u003c_\u003e =\n\t\t\t\t\tnext_states_compact.iter ().copied ()\n\t\t\t\t\t\t.map (|(state_compact, cost)| (state_compact.expand (), cost))\n\t\t\t\t\t\t.sorted_by_key (|\u0026 (_, cost)| cost)\n\t\t\t\t\t\t.collect ();\n\t\t\t\tif cost != last_cost {\n\t\t\t\t\tprintln! ();\n\t\t\t\t\tprintln! (\"Evaluating states with cost: {}\", cost);\n\t\t\t\t\tprintln! (\"Number of iterations: {}\", num_loops);\n\t\t\t\t\tprintln! (\"Size of backlog: {}\", search.len ());\n\t\t\t\t}\n\t\t\t\tprintln! ();\n\t\t\t\tif next_states.is_empty () \u0026\u0026 args.dead_ends {\n\t\t\t\t\tlet all_states =\n\t\t\t\t\t\titer::successors (\n\t\t\t\t\t\t\t\tSome (state_compact),\n\t\t\t\t\t\t\t\t|state| prev_states.get (state).copied ())\n\t\t\t\t\t\t\t.map (|state_compact| state_compact.expand ())\n\t\t\t\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\t\t\t\tprintln! (\"    Dead end:\");\n\t\t\t\t\tfor chunk in all_states.chunks (11) {\n\t\t\t\t\t\tfor line in 0 .. state.room_size () + 3 {\n\t\t\t\t\t\t\tprint! (\"    \");\n\t\t\t\t\t\t\tfor (idx, state) in chunk.iter ().enumerate () {\n\t\t\t\t\t\t\t\tif idx \u003e 0 { print! (\" \"); }\n\t\t\t\t\t\t\t\tprint! (\"{:13}\", state.pretty_line (line));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprint! (\"\\n\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprint_next_states (\u0026 state, \u0026 next_states);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (next_state_compact, _) in next_states_compact {\n\t\t\t\tprev_states.insert (next_state_compact, state_compact);\n\t\t\t}\n\t\t\tlast_cost = cost;\n\t\t};\n\t\tlet (final_state_compact, final_cost) =\n\t\t\tfinal_cost.ok_or_else (|| format! (\"Failed to find a solution\")) ?;\n\t\tlet final_state = final_state_compact.expand ();\n\t\tlet mut all_states =\n\t\t\titer::successors (\n\t\t\t\t\tSome (final_state_compact),\n\t\t\t\t\t|state| prev_states.get (state).copied ())\n\t\t\t\t.map (|state_compact| state_compact.expand ())\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tall_states.reverse ();\n\t\tif args.verbose {\n\t\t\tprintln! ();\n\t\t\tprintln! (\" Found solution \");\n\t\t\tprintln! ();\n\t\t}\n\t\tprintln! (\"Solved with cost: {}\", final_cost);\n\t\tprintln! (\"Number of steps in solution: {}\", all_states.len () - 1);\n\t\tprintln! ();\n\t\tprintln! (\"Number of iterations: {}\", num_loops);\n\t\tprintln! (\"Total states genereated: {}\", prev_states.len ());\n\t\tif args.verbose { println! (); }\n\t\tfor chunk in all_states.chunks (11) {\n\t\t\tfor line in 0 .. final_state.room_size () + 3 {\n\t\t\t\tfor (idx, state) in chunk.iter ().enumerate () {\n\t\t\t\t\tif idx \u003e 0 { print! (\" \"); }\n\t\t\t\t\tprint! (\"{:13}\", state.pretty_line (line));\n\t\t\t\t}\n\t\t\t\tprint! (\"\\n\");\n\t\t\t}\n\t\t}\n\t\tif args.verbose { println! (); }\n\t\tOk (())\n\t}\n\n\tpub fn print_next_states (cur_state: \u0026 State, next_states: \u0026 [(State, i64)]) {\n\t\tif next_states.is_empty () {\n\t\t\tprintln! (\"{:^13}\", \"START\");\n\t\t\tfor line in 0 .. cur_state.room_size () + 3 {\n\t\t\t\tprint! (\"{:13}\", cur_state.pretty_line (line));\n\t\t\t\tif line == (cur_state.room_size () + 3) / 2 {\n\t\t\t\t\tprint! (\"   (dead end)\");\n\t\t\t\t}\n\t\t\t\tprint! (\"\\n\");\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (chunk_idx, chunk) in next_states.chunks (10).enumerate () {\n\t\t\tprint! (\"{:^13}  \", if chunk_idx == 0 { \"START\" } else { \"\" });\n\t\t\tfor (_, cost) in chunk.iter () {\n\t\t\t\tprint! (\" {:^13}\", cost);\n\t\t\t}\n\t\t\tprint! (\"\\n\");\n\t\t\tfor line in 0 .. (cur_state.room_size ().as_usize () + 3) {\n\t\t\t\tprint! (\"{:13}  \", if chunk_idx == 0 { cur_state.pretty_line (line) } else { String::new () });\n\t\t\t\tfor (next_state, _) in chunk.iter () {\n\t\t\t\t\tprint! (\" {:13}\", next_state.pretty_line (line));\n\t\t\t\t}\n\t\t\t\tprint! (\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\t#[ derive (Debug, clap::Parser) ]\n\tpub struct InternalsArgs {}\n\n\tpub fn internals (_args: InternalsArgs) -\u003e GenResult \u003c()\u003e {\n\t\tprintln! (\"Data structures:\");\n\t\tfn show_struct \u003cType\u003e () {\n\t\t\tlet name = std::any::type_name::\u003cType\u003e ();\n\t\t\tlet size = mem::size_of::\u003cType\u003e ();\n\t\t\tlet align = mem::align_of::\u003cType\u003e ();\n\t\t\tprintln! (\" - {} {} bytes (align = {})\", name, size, align);\n\t\t}\n\t\tshow_struct::\u003clogic::Move\u003e ();\n\t\tshow_struct::\u003cmodel::Amph\u003e ();\n\t\tshow_struct::\u003cmodel::Place\u003e ();\n\t\tshow_struct::\u003cmodel::State\u003e ();\n\t\tshow_struct::\u003cmodel::StateCompact\u003e ();\n\t\tOk (())\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE: \u0026 'static [\u0026 'static str] = \u0026 [\n\t\t\"#############\",\n\t\t\"#...........#\",\n\t\t\"###B#C#B#D###\",\n\t\t\"  #A#D#C#A#\",\n\t\t\"  #########\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (12521, logic::part_one (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n\t#[ test ]\n\tfn part_two () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (44169, logic::part_two (EXAMPLE) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[299145,299609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[299230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[299694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[213842,213424,213815],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":31,"address":[213712,213456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[213633],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[213856,214434],"length":1,"stats":{"Line":1},"fn_name":"part_two"},{"line":36,"address":[213889],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[213907,213992,214256],"length":1,"stats":{"Line":2},"fn_name":null},{"line":38,"address":[214173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[215438,215120],"length":1,"stats":{"Line":2},"fn_name":"calc_result"},{"line":55,"address":[215282,215137,215412],"length":1,"stats":{"Line":3},"fn_name":null},{"line":56,"address":[279742,279728],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":57,"address":[279797,279776],"length":1,"stats":{"Line":2},"fn_name":"{closure#1}"},{"line":59,"address":[215386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[215488,215623],"length":1,"stats":{"Line":2},"fn_name":"iterator"},{"line":65,"address":[279808,280176,280130],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":66,"address":[279854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":67,"address":[280049,280093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":68,"address":[280125,280086],"length":1,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[280166],"length":1,"stats":{"Line":2},"fn_name":null},{"line":73,"address":[215550,215604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":77,"address":[218530,215664,220318],"length":1,"stats":{"Line":2},"fn_name":"calc_next_states"},{"line":78,"address":[215695],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[215716],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[215724],"length":1,"stats":{"Line":6},"fn_name":null},{"line":82,"address":[280528,280768],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":83,"address":[280579],"length":1,"stats":{"Line":2},"fn_name":null},{"line":85,"address":[215740],"length":1,"stats":{"Line":2},"fn_name":null},{"line":86,"address":[215853,215898,215795],"length":1,"stats":{"Line":5},"fn_name":null},{"line":88,"address":[215867,216248,215933],"length":1,"stats":{"Line":4},"fn_name":null},{"line":89,"address":[216946],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[216208,216274],"length":1,"stats":{"Line":4},"fn_name":null},{"line":95,"address":[216424],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[216598],"length":1,"stats":{"Line":2},"fn_name":null},{"line":103,"address":[216765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[216993],"length":1,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[217087,217359,217008],"length":1,"stats":{"Line":6},"fn_name":null},{"line":112,"address":[217389],"length":1,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[217525],"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":[217588],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[218187,217990,217823,218126,218333],"length":1,"stats":{"Line":6},"fn_name":null},{"line":116,"address":[217972,218030,218146],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[218304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[218374,218445],"length":1,"stats":{"Line":4},"fn_name":null},{"line":120,"address":[217432],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[217504,218567],"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":[219066,218648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[218989],"length":1,"stats":{"Line":1},"fn_name":null},{"line":124,"address":[219178,219107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[217333,219555,219311],"length":1,"stats":{"Line":6},"fn_name":null},{"line":130,"address":[219585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":131,"address":[219669],"length":1,"stats":{"Line":2},"fn_name":null},{"line":132,"address":[219761,220134,219945],"length":1,"stats":{"Line":4},"fn_name":null},{"line":133,"address":[219819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[220057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":135,"address":[220175,220235],"length":1,"stats":{"Line":4},"fn_name":null},{"line":139,"address":[219535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[223927,223869,220336],"length":1,"stats":{"Line":2},"fn_name":"calc_next_moves"},{"line":151,"address":[220375],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[220412],"length":1,"stats":{"Line":6},"fn_name":null},{"line":153,"address":[281072,281336,281249,281302,280870],"length":1,"stats":{"Line":10},"fn_name":null},{"line":154,"address":[280936],"length":1,"stats":{"Line":2},"fn_name":null},{"line":155,"address":[281093,281272],"length":1,"stats":{"Line":2},"fn_name":null},{"line":156,"address":[281408,281454],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":157,"address":[281552,281566,281323],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":158,"address":[281616,281625],"length":1,"stats":{"Line":4},"fn_name":"{closure#2}"},{"line":159,"address":[281664,281680],"length":1,"stats":{"Line":4},"fn_name":"{closure#1}"},{"line":160,"address":[220420,220786,220500],"length":1,"stats":{"Line":6},"fn_name":null},{"line":161,"address":[281872,281952,281891,281967],"length":1,"stats":{"Line":7},"fn_name":"{closure#2}"},{"line":162,"address":[220820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[220827],"length":1,"stats":{"Line":2},"fn_name":null},{"line":164,"address":[220905],"length":1,"stats":{"Line":2},"fn_name":null},{"line":165,"address":[220937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":166,"address":[221199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[221210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[221339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[221688,222677],"length":1,"stats":{"Line":4},"fn_name":null},{"line":171,"address":[220739,221399],"length":1,"stats":{"Line":4},"fn_name":null},{"line":172,"address":[221429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[221518],"length":1,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[221607],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[222019],"length":1,"stats":{"Line":2},"fn_name":null},{"line":177,"address":[222107],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[222114],"length":1,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[222154],"length":1,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[222223],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[222548],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[222563],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[222639],"length":1,"stats":{"Line":2},"fn_name":null},{"line":185,"address":[223451],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[222788,222891,223229],"length":1,"stats":{"Line":6},"fn_name":null},{"line":187,"address":[222182,222707],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[282019,282075,282237,282000],"length":1,"stats":{"Line":8},"fn_name":"{closure#3}"},{"line":189,"address":[282085],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[282070],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[222883],"length":1,"stats":{"Line":6},"fn_name":null},{"line":193,"address":[223161,223058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":194,"address":[222939],"length":1,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[282403,282512,282676,282384],"length":1,"stats":{"Line":8},"fn_name":"{closure#5}"},{"line":196,"address":[282522],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[282507],"length":1,"stats":{"Line":2},"fn_name":null},{"line":198,"address":[223153],"length":1,"stats":{"Line":6},"fn_name":null},{"line":199,"address":[282830,282816],"length":1,"stats":{"Line":4},"fn_name":"{closure#7}"},{"line":200,"address":[223481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":201,"address":[223743],"length":1,"stats":{"Line":2},"fn_name":null},{"line":206,"address":[223888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[108032,108588],"length":1,"stats":{"Line":2},"fn_name":"from_array"},{"line":231,"address":[108079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":232,"address":[108155,108092],"length":1,"stats":{"Line":4},"fn_name":null},{"line":233,"address":[108239,108179],"length":1,"stats":{"Line":4},"fn_name":null},{"line":234,"address":[108323,108263],"length":1,"stats":{"Line":4},"fn_name":null},{"line":235,"address":[108431,108347],"length":1,"stats":{"Line":4},"fn_name":null},{"line":237,"address":[108518,108667],"length":1,"stats":{"Line":4},"fn_name":null},{"line":238,"address":[108858,109058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":239,"address":[109417,109076],"length":1,"stats":{"Line":4},"fn_name":null},{"line":240,"address":[109095],"length":1,"stats":{"Line":2},"fn_name":null},{"line":246,"address":[109440],"length":1,"stats":{"Line":2},"fn_name":"as_array"},{"line":247,"address":[109482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":248,"address":[109510,109702],"length":1,"stats":{"Line":4},"fn_name":null},{"line":249,"address":[109664,109930,110183,110452],"length":1,"stats":{"Line":8},"fn_name":null},{"line":250,"address":[110465,110221],"length":1,"stats":{"Line":2},"fn_name":null},{"line":252,"address":[110504,110757,110145,111026],"length":1,"stats":{"Line":8},"fn_name":null},{"line":253,"address":[110795,111039],"length":1,"stats":{"Line":2},"fn_name":null},{"line":255,"address":[111319,111561,110719,111078],"length":1,"stats":{"Line":8},"fn_name":null},{"line":256,"address":[111571,111354],"length":1,"stats":{"Line":2},"fn_name":null},{"line":258,"address":[111287,111604,111811,112053],"length":1,"stats":{"Line":8},"fn_name":null},{"line":259,"address":[111846,112063],"length":1,"stats":{"Line":2},"fn_name":null},{"line":264,"address":[112096,112101],"length":1,"stats":{"Line":4},"fn_name":"room_size"},{"line":266,"address":[112112],"length":1,"stats":{"Line":2},"fn_name":"get"},{"line":267,"address":[112189,112266],"length":1,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[112215,113390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":269,"address":[112314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[112335,113198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[112373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[112394,112998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[112432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[112453,112792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[112491],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[112512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[113497,113488],"length":1,"stats":{"Line":4},"fn_name":"hall"},{"line":282,"address":[113536],"length":1,"stats":{"Line":2},"fn_name":"room"},{"line":283,"address":[113557,113628,113680,113654],"length":1,"stats":{"Line":8},"fn_name":null},{"line":284,"address":[113784,113595],"length":1,"stats":{"Line":4},"fn_name":null},{"line":285,"address":[113624,113762],"length":1,"stats":{"Line":4},"fn_name":null},{"line":286,"address":[113740,113650],"length":1,"stats":{"Line":4},"fn_name":null},{"line":287,"address":[113705,113676],"length":1,"stats":{"Line":4},"fn_name":null},{"line":291,"address":[113808],"length":1,"stats":{"Line":2},"fn_name":"room_mut"},{"line":292,"address":[113919,113828],"length":1,"stats":{"Line":4},"fn_name":null},{"line":293,"address":[113865],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[113880],"length":1,"stats":{"Line":2},"fn_name":null},{"line":295,"address":[113895],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[113910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[113936],"length":1,"stats":{"Line":1},"fn_name":"is_finished"},{"line":301,"address":[114335,114230,114440,114125,113956],"length":1,"stats":{"Line":5},"fn_name":null},{"line":302,"address":[114054],"length":1,"stats":{"Line":3},"fn_name":null},{"line":303,"address":[114159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":304,"address":[114264],"length":1,"stats":{"Line":3},"fn_name":null},{"line":305,"address":[114369],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[114480],"length":1,"stats":{"Line":2},"fn_name":"room_is_happy"},{"line":309,"address":[114496],"length":1,"stats":{"Line":6},"fn_name":null},{"line":312,"address":[114624,115107],"length":1,"stats":{"Line":2},"fn_name":"move_out"},{"line":313,"address":[114692],"length":1,"stats":{"Line":2},"fn_name":null},{"line":314,"address":[114763,114706],"length":1,"stats":{"Line":4},"fn_name":null},{"line":315,"address":[114815,114927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":316,"address":[114978,114902,115086],"length":1,"stats":{"Line":4},"fn_name":null},{"line":320,"address":[115136,115499],"length":1,"stats":{"Line":1},"fn_name":"move_in"},{"line":321,"address":[115206],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[115288,115216],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[115454],"length":1,"stats":{"Line":1},"fn_name":null},{"line":327,"address":[115890,115536],"length":1,"stats":{"Line":2},"fn_name":"move_between"},{"line":328,"address":[115580],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[115645,115594],"length":1,"stats":{"Line":4},"fn_name":null},{"line":330,"address":[115689],"length":1,"stats":{"Line":2},"fn_name":null},{"line":331,"address":[115727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":[115759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[115784,115845,115814],"length":1,"stats":{"Line":4},"fn_name":null},{"line":335,"address":[115830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[118371,115920],"length":1,"stats":{"Line":0},"fn_name":"pretty_line"},{"line":340,"address":[206880,206864],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":341,"address":[115975,118550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[115981,118486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[116031,118481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[118397,118191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[116045,118103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[116083,118082],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[117720,117458,117845,117595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[116097,117423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[117496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[117627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[117752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[117411,116167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[116302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[116780,116923,116494,116637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[116396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[116539],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[116682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[116825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[116272,117208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[117310],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[117280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[118963,118560],"length":1,"stats":{"Line":0},"fn_name":"print"},{"line":368,"address":[118765,118580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[118778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[118992],"length":1,"stats":{"Line":1},"fn_name":"from_str"},{"line":375,"address":[119063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[119190,119113],"length":1,"stats":{"Line":1},"fn_name":null},{"line":377,"address":[119152,119218,119319],"length":1,"stats":{"Line":2},"fn_name":null},{"line":378,"address":[119241],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[119290],"length":1,"stats":{"Line":1},"fn_name":null},{"line":380,"address":[119302,119359,119610,120237],"length":1,"stats":{"Line":4},"fn_name":null},{"line":381,"address":[119649],"length":1,"stats":{"Line":1},"fn_name":null},{"line":382,"address":[119925,119892],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[119942,119902],"length":1,"stats":{"Line":2},"fn_name":null},{"line":386,"address":[120201,120067,119871,120128],"length":1,"stats":{"Line":3},"fn_name":null},{"line":387,"address":[120110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":388,"address":[120098],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[120229,120242,120170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":392,"address":[119506,120280],"length":1,"stats":{"Line":2},"fn_name":null},{"line":395,"address":[120336],"length":1,"stats":{"Line":1},"fn_name":"parse"},{"line":396,"address":[120391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":397,"address":[120407,120486],"length":1,"stats":{"Line":1},"fn_name":null},{"line":398,"address":[120873,120465,120776],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[121150,121256,120849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":400,"address":[121743,121533,121228],"length":1,"stats":{"Line":5},"fn_name":null},{"line":401,"address":[121961,121767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[122226,122411,121938],"length":1,"stats":{"Line":4},"fn_name":null},{"line":403,"address":[122692,122388,122981],"length":1,"stats":{"Line":4},"fn_name":null},{"line":404,"address":[123246,122958,123551],"length":1,"stats":{"Line":4},"fn_name":null},{"line":405,"address":[123524,124067,123832],"length":1,"stats":{"Line":4},"fn_name":null},{"line":406,"address":[124040,124348,124583],"length":1,"stats":{"Line":4},"fn_name":null},{"line":407,"address":[125087,124556,124864],"length":1,"stats":{"Line":4},"fn_name":null},{"line":408,"address":[125368,125657,125064],"length":1,"stats":{"Line":4},"fn_name":null},{"line":409,"address":[125922,125634],"length":1,"stats":{"Line":4},"fn_name":null},{"line":411,"address":[121715,126477,126497],"length":1,"stats":{"Line":4},"fn_name":null},{"line":412,"address":[126663,126485,126543],"length":1,"stats":{"Line":4},"fn_name":null},{"line":413,"address":[127092,126952,126627],"length":1,"stats":{"Line":4},"fn_name":null},{"line":415,"address":[207239],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[126992],"length":1,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[127138,127621,127028,127270],"length":1,"stats":{"Line":8},"fn_name":null},{"line":419,"address":[127862,127674,127206],"length":1,"stats":{"Line":6},"fn_name":null},{"line":420,"address":[127883,128653],"length":1,"stats":{"Line":4},"fn_name":null},{"line":421,"address":[128663,128038,128484],"length":1,"stats":{"Line":4},"fn_name":null},{"line":424,"address":[127750,128694],"length":1,"stats":{"Line":4},"fn_name":null},{"line":427,"address":[129100,128736],"length":1,"stats":{"Line":2},"fn_name":"compact"},{"line":428,"address":[128759],"length":1,"stats":{"Line":2},"fn_name":null},{"line":429,"address":[128768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":430,"address":[128777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":431,"address":[128956],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[128980,129200],"length":1,"stats":{"Line":4},"fn_name":null},{"line":433,"address":[129028],"length":1,"stats":{"Line":2},"fn_name":null},{"line":434,"address":[129042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[129182,129066,129126],"length":1,"stats":{"Line":4},"fn_name":null},{"line":436,"address":[129128],"length":1,"stats":{"Line":2},"fn_name":null},{"line":437,"address":[129156],"length":1,"stats":{"Line":2},"fn_name":null},{"line":441,"address":[129377,129259,129205],"length":1,"stats":{"Line":4},"fn_name":null},{"line":442,"address":[129325,129375,129411,129498],"length":1,"stats":{"Line":6},"fn_name":null},{"line":443,"address":[129482,129533],"length":1,"stats":{"Line":4},"fn_name":null},{"line":450,"address":[131402,129600],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":451,"address":[129941,129639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[129955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[130598,130217,129858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":455,"address":[130389,130557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[130527,130632,131125,130677,130955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[130799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[131117,131135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[131428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[131456],"length":1,"stats":{"Line":2},"fn_name":"expand"},{"line":472,"address":[131489],"length":1,"stats":{"Line":2},"fn_name":null},{"line":473,"address":[131526],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[131544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":475,"address":[131580,131759,132245],"length":1,"stats":{"Line":5},"fn_name":null},{"line":476,"address":[131780,132230],"length":1,"stats":{"Line":4},"fn_name":null},{"line":477,"address":[131814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[132173,131889],"length":1,"stats":{"Line":2},"fn_name":null},{"line":479,"address":[132124,131922],"length":1,"stats":{"Line":4},"fn_name":null},{"line":480,"address":[132075,131955],"length":1,"stats":{"Line":3},"fn_name":null},{"line":481,"address":[131981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[132225,132051],"length":1,"stats":{"Line":4},"fn_name":null},{"line":486,"address":[132240,131795],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[132255,131745],"length":1,"stats":{"Line":4},"fn_name":null},{"line":489,"address":[132282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":491,"address":[132400],"length":1,"stats":{"Line":2},"fn_name":"is_finished"},{"line":492,"address":[132423],"length":1,"stats":{"Line":2},"fn_name":null},{"line":493,"address":[132540,132455],"length":1,"stats":{"Line":4},"fn_name":null},{"line":494,"address":[132477],"length":1,"stats":{"Line":2},"fn_name":null},{"line":495,"address":[132495,132572,132668],"length":1,"stats":{"Line":6},"fn_name":null},{"line":496,"address":[132689,132907],"length":1,"stats":{"Line":3},"fn_name":null},{"line":497,"address":[132809,132895],"length":1,"stats":{"Line":3},"fn_name":null},{"line":498,"address":[132875,132845],"length":1,"stats":{"Line":2},"fn_name":null},{"line":499,"address":[132859,132890],"length":1,"stats":{"Line":2},"fn_name":null},{"line":501,"address":[132902,132824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":504,"address":[132661],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[132912],"length":1,"stats":{"Line":2},"fn_name":"idx"},{"line":516,"address":[132994,132952],"length":1,"stats":{"Line":2},"fn_name":null},{"line":517,"address":[132967],"length":1,"stats":{"Line":2},"fn_name":null},{"line":518,"address":[133025,133329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[133052,133266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[133203,133079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":521,"address":[133103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[133392],"length":1,"stats":{"Line":2},"fn_name":"for_idx"},{"line":526,"address":[133435,133406],"length":1,"stats":{"Line":4},"fn_name":null},{"line":527,"address":[133511,133418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":528,"address":[133629,133494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[133612,133754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[133733,133888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[133853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[134000,134040],"length":1,"stats":{"Line":4},"fn_name":"entrance"},{"line":541,"address":[134128],"length":1,"stats":{"Line":2},"fn_name":"idx"},{"line":542,"address":[134139],"length":1,"stats":{"Line":2},"fn_name":null},{"line":543,"address":[134170],"length":1,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[134181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":545,"address":[134192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":546,"address":[134203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":549,"address":[134224],"length":1,"stats":{"Line":2},"fn_name":"from_letter"},{"line":550,"address":[134234],"length":1,"stats":{"Line":2},"fn_name":null},{"line":551,"address":[134275],"length":1,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[134282],"length":1,"stats":{"Line":2},"fn_name":null},{"line":553,"address":[134289],"length":1,"stats":{"Line":2},"fn_name":null},{"line":554,"address":[134296],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[134303,134268],"length":1,"stats":{"Line":2},"fn_name":null},{"line":558,"address":[134331,134320],"length":1,"stats":{"Line":4},"fn_name":"cost"},{"line":559,"address":[134427,134416],"length":1,"stats":{"Line":0},"fn_name":"letter"},{"line":573,"address":[163328,163333],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":574,"address":[166153,166007,166186],"length":1,"stats":{"Line":2},"fn_name":null},{"line":575,"address":[166159,166216,166346],"length":1,"stats":{"Line":2},"fn_name":null},{"line":610,"address":[71008,69504,70917],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":611,"address":[69511],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[69558,69630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[69623,69688,69832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[69806,70015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[70342,70105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[70237,70134,70347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[70115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":619,"address":[70516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[70570,70661,70782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[70482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[71024,74656,77848],"length":1,"stats":{"Line":0},"fn_name":"run_part"},{"line":626,"address":[71302,71069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[71261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[71272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[71292],"length":1,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[170288,170786,170654],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":632,"address":[170352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[170440,170667,170373],"length":1,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[170749,170704],"length":1,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[170781,170742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[170579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[71564,71492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[74948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[71589,71688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[71632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[71615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[71826,71766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[71819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[71965,71907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[72002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[71979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[72246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[170816,170866],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":655,"address":[170957,170944],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":657,"address":[72440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[72579,72500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":659,"address":[72598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[72733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[72856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[72458,73019],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[73046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[73155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[73183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[171040,171075],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":671,"address":[73276,73355],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[73618,73382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":673,"address":[73674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[73966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[74040,74295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[74372,74335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":677,"address":[74365,74432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[74253,74667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[73121,74733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[74742,72166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[74897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[74909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[75053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[75077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[75304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":697,"address":[75332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[171283,171248],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":700,"address":[75552,75473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[75567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[75611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[75669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":704,"address":[75727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":706,"address":[75806,75573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[75890],"length":1,"stats":{"Line":0},"fn_name":null},{"line":708,"address":[76108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[76174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":710,"address":[76297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[76463,76500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":712,"address":[76477,76589,76778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[76834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[77109,77340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[77377,77408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[77401,77468],"length":1,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[77298,77674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[76763,77725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":722,"address":[77698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[77872,78675],"length":1,"stats":{"Line":0},"fn_name":"print_next_states"},{"line":726,"address":[77965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[78029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":728,"address":[78420,78182],"length":1,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[78444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[78709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[78845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[78806,78898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[78006,78917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":738,"address":[79145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[79547,79369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":740,"address":[79567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[79716,79505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[79738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[79997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":745,"address":[80260,80419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[80435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[80651,80372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[80672],"length":1,"stats":{"Line":0},"fn_name":"internals"},{"line":757,"address":[80676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":762,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":764,"address":[80721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[80726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[80731],"length":1,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[80736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[80741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[80746],"length":1,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[273801,273792],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":789,"address":[298182,297943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":790,"address":[298162],"length":1,"stats":{"Line":1},"fn_name":null},{"line":794,"address":[273840,273849],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":795,"address":[298231,298470],"length":1,"stats":{"Line":1},"fn_name":null},{"line":796,"address":[298450],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":281,"coverable":451},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","src","lib.rs"],"content":"//! Advent of Code 2021: Day 24: Arithmetic Logic Unit\n//!\n//! [https://adventofcode.com/2021/day/24](https://adventofcode.com/2021/day/24)\n\n#![ allow (dead_code) ]\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Arithmetic Logic Unit\";\n\tyear = 2021;\n\tday = 24;\n\tpart_one = |lines| logic::part_one (lines);\n\tpart_two = |lines| logic::part_two (lines);\n\tcommands = [\n\t\t( name = \"all\"; method = tool::all; ),\n\t\t( name = \"machine\"; method = tool::machine; ),\n\t\t( name = \"solver\"; method = tool::solver; ),\n\t];\n}\n\npub mod machine;\npub mod quick;\npub mod solver;\n\npub mod logic {\n\n\tuse super::*;\n\tuse machine::Instr;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\tlet prog = machine::parse_prog (lines) ?;\n\t\tcalc_result (\u0026 prog, true)\n\t}\n\n\tpub fn part_two (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\tlet prog = machine::parse_prog (lines) ?;\n\t\tcalc_result (\u0026 prog, false)\n\t}\n\n\tpub fn calc_result (prog: \u0026 [Instr], reverse: bool) -\u003e GenResult \u003cString\u003e {\n\t\tlet steps = quick::steps_for (prog) ?;\n\t\tlet result = quick::iterator (\u0026 steps, reverse).next ()\n\t\t\t.ok_or_else (|| format! (\"Not found\")) ?;\n\t\tOk (model::input_to_str (result))\n\t}\n\n}\n\npub mod model {\n\n\tuse super::*;\n\tuse nums::IntConv;\n\n\tpub type Input = [u8; 14];\n\n\tpub fn input_from_str (input_str: \u0026 str) -\u003e Input {\n\t\tinput_str.chars ().map (\n\t\t\t|letter| letter.to_digit (10).unwrap ().as_u8 (),\n\t\t).collect::\u003cVec \u003cu8\u003e\u003e ().try_into ().unwrap ()\n\t}\n\n\tpub fn input_to_str (input: Input) -\u003e String {\n\t\tinput.into_iter ().map (\n\t\t\t|val| char::from_digit (val.as_u32 (), 10).unwrap (),\n\t\t).collect::\u003cString\u003e ()\n\t}\n\n}\n\npub mod tool {\n\n\tuse super::*;\n\tuse machine::Instr;\n\tuse machine::Machine;\n\tuse machine::MachineRegs;\n\tuse solver::Solver;\n\n\t#[ derive (clap::Parser) ]\n\tpub struct AllArgs {\n\t\tinput: String,\n\t}\n\n\tpub fn all (args: AllArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet input_string = fs::read_to_string (args.input) ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tlet prog = machine::parse_prog (\u0026 input_lines) ?;\n\t\tlet steps = quick::steps_for (\u0026 prog) ?;\n\t\tquick::iterator (\u0026 steps, false).for_each (\n\t\t\t|input| println! (\"{}\", model::input_to_str (input)),\n\t\t);\n\t\tOk (())\n\t}\n\n\t#[ derive (clap::Parser) ]\n\tpub struct MachineArgs { inputs: Vec \u003cString\u003e }\n\n\tpub fn machine (args: MachineArgs) -\u003e GenResult \u003c()\u003e {\n\t\tfn dump_regs (regs: \u0026 MachineRegs) -\u003e String {\n\t\t\tformat! (\"{:2}  {:10}  {:2}  {:10}\", regs.w, regs.x, regs.y, regs.z)\n\t\t}\n\t\tlet mut machines: Vec \u003c(Machine, [i64; 14])\u003e = args.inputs.iter ().map (\n\t\t\t|input_str| (\n\t\t\t\tMachine::new (),\n\t\t\t\tmachine::machine_input (model::input_from_str (input_str)),\n\t\t\t),\n\t\t).collect ();\n\t\tlet prog = load_prog () ?;\n\t\tlet mut done = false;\n\t\twhile ! done {\n\t\t\tif machines [0].0.regs.pc % 18 == 0 {\n\t\t\t\tprinter (\u0026 machines,\n\t\t\t\t\t|| print! (\"+-- {:2} ---------+\", machines [0].0.regs.pc / 18),\n\t\t\t\t\t|_| print! (\"--------------------------------+\"));\n\t\t\t}\n\t\t\tprinter (\u0026 machines,\n\t\t\t\t|| print! (\"| {:2}  {:9} |\", machines [0].0.regs.pc % 18 + 1,\n\t\t\t\t\tmatch prog.get (machines [0].0.regs.pc) {\n\t\t\t\t\t\tSome (instr) =\u003e format! (\"{}\", instr), None =\u003e format! (\"(end)\"),\n\t\t\t\t\t}),\n\t\t\t\t|machine| print! (\" {:30} |\", dump_regs (\u0026 machine.regs)));\n\t\t\tfor (machine, input) in machines.iter_mut () {\n\t\t\t\tif machine.step (\u0026 prog, input).map_err (|err| format! (\"{:?}\", err)) ? {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprinter (\u0026 machines,\n\t\t\t|| print! (\"+---------------+\"),\n\t\t\t|_| print! (\"--------------------------------+\"));\n\t\tprinter (\u0026 machines,\n\t\t\t|| print! (\"|               |\"),\n\t\t\t|machine| print! (\" {:30} |\", format! (\"Result: {}\", machine.regs.z)));\n\t\tprinter (\u0026 machines,\n\t\t\t|| print! (\"+---------------+\"),\n\t\t\t|_| print! (\"--------------------------------+\"));\n\t\treturn Ok (());\n\t\tfn printer \u003c\n\t\t\tBeforeFn: Fn (),\n\t\t\tEachFn: Fn (\u0026 Machine),\n\t\t\u003e (machines: \u0026 [(Machine, [i64; 14])], before_fn: BeforeFn, each_fn: EachFn) {\n\t\t\tbefore_fn ();\n\t\t\tfor (machine, _) in machines.iter () {\n\t\t\t\teach_fn (machine);\n\t\t\t}\n\t\t\tprint! (\"\\n\");\n\t\t}\n\t}\n\n\t#[ derive (clap::Parser) ]\n\tpub struct SolverArgs {\n\t\targs: Vec \u003cString\u003e,\n\t}\n\n\tpub fn solver (args: SolverArgs) -\u003e GenResult \u003c()\u003e {\n\t\tlet prog = load_prog () ?;\n\t\tlet (solver, regs) = Solver::from_prog (\u0026 prog);\n\t\tlet reg_z = regs.into_iter ().filter (|(name, _)| name.as_ref () == \"z\").map (|(_, reg)| reg).next ().unwrap ();\n\t\tmatch args.args [0].as_str () {\n\t\t\t\"solver-full\" =\u003e {\n\t\t\t\tsolver.dump (3, true);\n\t\t\t},\n\t\t\t\"solver-z\" =\u003e {\n\t\t\t\tsolver.dump_symbol (3, true, \u0026 reg_z);\n\t\t\t},\n\t\t\t\"solver-z-auto\" =\u003e {\n\t\t\t\tsolver.dump_symbol_auto (\u0026 reg_z);\n\t\t\t},\n\t\t\t_ =\u003e panic! (),\n\t\t}\n\t\tOk (())\n\t}\n\n\tfn load_prog () -\u003e GenResult \u003cVec \u003cInstr\u003e\u003e {\n\t\tlet input_string = fs::read_to_string (\"inputs/day-24\") ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\t\tmachine::parse_prog (\u0026 input_lines)\n\t}\n\n}\n","traces":[{"line":9,"address":[236105,235513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[235598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[236190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[129797,129520],"length":1,"stats":{"Line":0},"fn_name":"part_one"},{"line":32,"address":[129672,129553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[129651,129778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[130098,129824],"length":1,"stats":{"Line":0},"fn_name":"part_two"},{"line":37,"address":[129857,129976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[130079,129955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[130746,130128],"length":1,"stats":{"Line":0},"fn_name":"calc_result"},{"line":42,"address":[130175,130315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[130390,130679,130453,130285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[130405,130593,130701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[130772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[444416],"length":1,"stats":{"Line":0},"fn_name":"input_from_str"},{"line":58,"address":[444472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[152784,152808],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":63,"address":[444592],"length":1,"stats":{"Line":0},"fn_name":"input_to_str"},{"line":64,"address":[444606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[152896,152880],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":84,"address":[393984,395143,395192],"length":1,"stats":{"Line":0},"fn_name":"all"},{"line":85,"address":[394177,393991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[394160,394301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[394470,394379,394611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[394591,394953,394804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[394943,395109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[344191,344176],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":92,"address":[395116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[395216,396789,396815],"length":1,"stats":{"Line":0},"fn_name":"machine"},{"line":99,"address":[396864],"length":1,"stats":{"Line":0},"fn_name":"dump_regs"},{"line":100,"address":[396902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[395231,395314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[344528,344416],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":104,"address":[344454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[344469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[395617,395482,395419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[395604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[395612,395760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[395889,395807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[396003,395917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[344592,344601],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":114,"address":[344782,344768],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":116,"address":[396068,395948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[345287,345446,344832,344852,344950],"length":1,"stats":{"Line":0},"fn_name":"{closure#3}"},{"line":118,"address":[344985,344929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[345066,345372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[345728,345748],"length":1,"stats":{"Line":0},"fn_name":"{closure#4}"},{"line":122,"address":[396099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[345984,346005],"length":1,"stats":{"Line":0},"fn_name":"{closure#5}"},{"line":124,"address":[396654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[396683,395781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[346121,346112],"length":1,"stats":{"Line":0},"fn_name":"{closure#6}"},{"line":130,"address":[346176,346190],"length":1,"stats":{"Line":0},"fn_name":"{closure#7}"},{"line":131,"address":[396698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[346249,346240],"length":1,"stats":{"Line":0},"fn_name":"{closure#8}"},{"line":133,"address":[346340,346304],"length":1,"stats":{"Line":0},"fn_name":"{closure#9}"},{"line":134,"address":[396740],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[346704,346713],"length":1,"stats":{"Line":0},"fn_name":"{closure#10}"},{"line":136,"address":[346768,346782],"length":1,"stats":{"Line":0},"fn_name":"{closure#11}"},{"line":137,"address":[396772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[347472,347767,347152,347122,347442,347792,348128,348418,348090,346832],"length":1,"stats":{"Line":0},"fn_name":"printer\u003caoc_2021_day_24::tool::machine::{closure_env#6}, aoc_2021_day_24::tool::machine::{closure_env#7}\u003e"},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[397184,398406,397921],"length":1,"stats":{"Line":0},"fn_name":"solver"},{"line":156,"address":[397390,397196,397272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[397583,397370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[348448,348475,348544,348566],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":159,"address":[397977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[398052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[398136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[398176,398095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[398241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[398192,398254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[398306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[398260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[398145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[398896,398869,398432],"length":1,"stats":{"Line":0},"fn_name":"load_prog"},{"line":175,"address":[398449,398588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[398566,398679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[398757,398843],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":82},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","src","machine.rs"],"content":"use aoc_common::*;\nuse nums::IntConv;\n\npub fn parse_prog (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cVec \u003cInstr\u003e\u003e {\n\tlines.iter ().enumerate ().map (|(line_idx, line)| -\u003e GenResult \u003cInstr\u003e {\n\t\tlet err = || format! (\"Invalid input: {}: {}\", line_idx + 1, line);\n\t\tlet parse_reg = |input| Ok (match input {\n\t\t\t\"w\" =\u003e Reg::W,\n\t\t\t\"x\" =\u003e Reg::X,\n\t\t\t\"y\" =\u003e Reg::Y,\n\t\t\t\"z\" =\u003e Reg::Z,\n\t\t\t_ =\u003e return Err (err ()),\n\t\t});\n\t\tlet parse_reg_or_int = |input| -\u003e GenResult \u003cRegOrInt\u003e {\n\t\t\tOk (match input {\n\t\t\t\t\"w\" =\u003e RegOrInt::W,\n\t\t\t\t\"x\" =\u003e RegOrInt::X,\n\t\t\t\t\"y\" =\u003e RegOrInt::Y,\n\t\t\t\t\"z\" =\u003e RegOrInt::Z,\n\t\t\t\t_ =\u003e RegOrInt::Int (input.parse::\u003ci64\u003e ().map_err (|_| err ()) ?),\n\t\t\t})\n\t\t};\n\t\tlet line_parts: Vec \u003c\u0026 str\u003e = line.split (' ').collect ();\n\t\tlet instr_str = line_parts [0];\n\t\tlet instr_args = \u0026 line_parts [1 .. ];\n\t\tOk (match (instr_str, instr_args.len ()) {\n\t\t\t(\"inp\", 1) =\u003e Instr::Inp (parse_reg (instr_args [0]) ?),\n\t\t\t(\"add\", 2) =\u003e Instr::Add (parse_reg (instr_args [0]) ?, parse_reg_or_int (instr_args [1]) ?),\n\t\t\t(\"mul\", 2) =\u003e Instr::Mul (parse_reg (instr_args [0]) ?, parse_reg_or_int (instr_args [1]) ?),\n\t\t\t(\"div\", 2) =\u003e Instr::Div (parse_reg (instr_args [0]) ?, parse_reg_or_int (instr_args [1]) ?),\n\t\t\t(\"mod\", 2) =\u003e Instr::Mod (parse_reg (instr_args [0]) ?, parse_reg_or_int (instr_args [1]) ?),\n\t\t\t(\"eql\", 2) =\u003e Instr::Eql (parse_reg (instr_args [0]) ?, parse_reg_or_int (instr_args [1]) ?),\n\t\t\t_ =\u003e Err (err ()) ?,\n\t\t})\n\t}).collect ()\n}\n\npub fn machine_input (input: [u8; 14]) -\u003e [i64; 14] {\n\tlet mut result = [0; 14];\n\tfor idx in 0 .. 14 { result [idx] = input [idx].as_i64 (); }\n\tresult\n}\n\n#[ derive (Clone, Debug, Default, Eq, Hash, PartialEq) ]\npub struct Machine {\n\tpub regs: MachineRegs,\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum MachineError {\n\tNoMoreInput,\n\tDivideByZero,\n\tNegativeModulo,\n}\n\nimpl Machine {\n\tpub fn new () -\u003e Machine {\n\t\tMachine { regs: default () }\n\t}\n\tpub fn step (\u0026 mut self, prog: \u0026 [Instr], input: \u0026 [i64]) -\u003e Result \u003cbool, MachineError\u003e {\n\t\tlet instr = match prog.get (self.regs.pc) {\n\t\t\tSome (\u0026 instr) =\u003e instr,\n\t\t\tNone =\u003e return Ok (true),\n\t\t};\n\t\tmatch instr {\n\t\t\tInstr::Inp (dest) =\u003e {\n\t\t\t\tlet val = match input.get (self.regs.ic) {\n\t\t\t\t\tSome (\u0026 val) =\u003e val,\n\t\t\t\t\tNone =\u003e return Err (MachineError::NoMoreInput),\n\t\t\t\t};\n\t\t\t\tself.regs.ic += 1;\n\t\t\t\tself.regs.store (dest, val);\n\t\t\t},\n\t\t\tInstr::Add (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val + src_val);\n\t\t\t},\n\t\t\tInstr::Mul (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val * src_val);\n\t\t\t},\n\t\t\tInstr::Div (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tif src_val == 0 { Err (MachineError::DivideByZero) ? }\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val / src_val);\n\t\t\t},\n\t\t\tInstr::Mod (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tif src_val == 0 { Err (MachineError::DivideByZero) ? }\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, dst_val % src_val);\n\t\t\t},\n\t\t\tInstr::Eql (dest, src) =\u003e {\n\t\t\t\tlet src_val = self.regs.retrieve_or_int (src);\n\t\t\t\tlet dst_val = self.regs.retrieve (dest);\n\t\t\t\tself.regs.store (dest, if dst_val == src_val { 1 } else { 0 });\n\t\t\t},\n\t\t}\n\t\tself.regs.pc += 1;\n\t\tOk (false)\n\t}\n\t#[ allow (dead_code) ]\n\tfn execute (\u0026 mut self, prog: \u0026 [Instr], input: \u0026 [i64]) -\u003e Result \u003c(), MachineError\u003e {\n\t\tloop {\n\t\t\tmatch self.step (prog, input) {\n\t\t\t\tOk (true) =\u003e break,\n\t\t\t\tOk (false) =\u003e continue,\n\t\t\t\tErr (err) =\u003e Err (err) ?,\n\t\t\t}\n\t\t}\n\t\tOk (())\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Default, Eq, Hash, PartialEq) ]\npub struct MachineRegs {\n\tpub w: i64,\n\tpub x: i64,\n\tpub y: i64,\n\tpub z: i64,\n\tpub pc: usize,\n\tpub ic: usize,\n}\n\nimpl MachineRegs {\n\tfn store (\u0026 mut self, reg: Reg, val: i64) {\n\t\tmatch reg {\n\t\t\tReg::W =\u003e self.w = val,\n\t\t\tReg::X =\u003e self.x = val,\n\t\t\tReg::Y =\u003e self.y = val,\n\t\t\tReg::Z =\u003e self.z = val,\n\t\t}\n\t}\n\tfn retrieve (\u0026 self, reg: Reg) -\u003e i64 {\n\t\tmatch reg {\n\t\t\tReg::W =\u003e self.w,\n\t\t\tReg::X =\u003e self.x,\n\t\t\tReg::Y =\u003e self.y,\n\t\t\tReg::Z =\u003e self.z,\n\t\t}\n\t}\n\tfn retrieve_or_int (\u0026 self, reg_or_int: RegOrInt) -\u003e i64 {\n\t\tmatch reg_or_int {\n\t\t\tRegOrInt::W =\u003e self.w,\n\t\t\tRegOrInt::X =\u003e self.x,\n\t\t\tRegOrInt::Y =\u003e self.y,\n\t\t\tRegOrInt::Z =\u003e self.z,\n\t\t\tRegOrInt::Int (val) =\u003e val,\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Instr {\n\tInp (Reg),\n\tAdd (Reg, RegOrInt),\n\tMul (Reg, RegOrInt),\n\tDiv (Reg, RegOrInt),\n\tMod (Reg, RegOrInt),\n\tEql (Reg, RegOrInt),\n}\n\nimpl fmt::Display for Instr {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tInstr::Inp (arg) =\u003e write! (formatter, \"inp {}\", arg) ?,\n\t\t\tInstr::Add (left, right) =\u003e write! (formatter, \"add {} {}\", left, right) ?,\n\t\t\tInstr::Mul (left, right) =\u003e write! (formatter, \"mul {} {}\", left, right) ?,\n\t\t\tInstr::Div (left, right) =\u003e write! (formatter, \"div {} {}\", left, right) ?,\n\t\t\tInstr::Mod (left, right) =\u003e write! (formatter, \"mod {} {}\", left, right) ?,\n\t\t\tInstr::Eql (left, right) =\u003e write! (formatter, \"eql {} {}\", left, right) ?,\n\t\t}\n\t\tOk (())\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum RegOrInt { W, X, Y, Z, Int (i64) }\n\nimpl fmt::Display for RegOrInt {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tRegOrInt::W =\u003e write! (formatter, \"w\") ?,\n\t\t\tRegOrInt::X =\u003e write! (formatter, \"x\") ?,\n\t\t\tRegOrInt::Y =\u003e write! (formatter, \"y\") ?,\n\t\t\tRegOrInt::Z =\u003e write! (formatter, \"z\") ?,\n\t\t\tRegOrInt::Int (val) =\u003e write! (formatter, \"{}\", val) ?,\n\t\t}\n\t\tOk (())\n\t}\n}\n\n#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\npub enum Reg { W, X, Y, Z }\n\nimpl fmt::Display for Reg {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tReg::W =\u003e write! (formatter, \"w\") ?,\n\t\t\tReg::X =\u003e write! (formatter, \"x\") ?,\n\t\t\tReg::Y =\u003e write! (formatter, \"y\") ?,\n\t\t\tReg::Z =\u003e write! (formatter, \"z\") ?,\n\t\t}\n\t\tOk (())\n\t}\n}\n","traces":[{"line":4,"address":[262592],"length":1,"stats":{"Line":0},"fn_name":"parse_prog"},{"line":5,"address":[262642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":6,"address":[339822,339792,335155],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":7,"address":[340382,335178,340182,340342,340048],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":8,"address":[340108,340172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[340240,340201,340149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[340290,340251,340217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[340267,340301,340327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[340352,340312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[335191,340942,340559,340384],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":15,"address":[340534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[340456,340520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[340568,340607,340497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[340584,340661,340622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[340711,340679,340638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[340960,340695,340982,340730],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":23,"address":[335204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[335341,335257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[335374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[338802,335610,335955,336069,335468,338133,336757,337445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[335626,335519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[336085,336414,335568,336021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[336773,337102,336027,336709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[337461,336715,337397,337790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[337403,338478,338149,338085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[339147,338773,338091,338818],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[339438,338792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[335292,335998,335931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[262720],"length":1,"stats":{"Line":0},"fn_name":"machine_input"},{"line":39,"address":[262742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[262754,262868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[263024],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":58,"address":[263038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[263088],"length":1,"stats":{"Line":0},"fn_name":"step"},{"line":61,"address":[263197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[263260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[263239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[263323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[263389],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[263410,264981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[265035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[265006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[265067,265129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[265116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[263440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[263493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[264859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[264906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[263527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[263580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[264721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[264768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[263614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[263667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[264452,264378],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[264429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[264545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[263701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[263754],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[264102,264028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[264079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[264212],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[263788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[263841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[263877],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[263924],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[265197,265172,263991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[265176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[265232],"length":1,"stats":{"Line":0},"fn_name":"execute"},{"line":108,"address":[265309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[265346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[265428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[265440],"length":1,"stats":{"Line":0},"fn_name":"store"},{"line":130,"address":[265470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[265512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[265526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[265541],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[265556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[265568],"length":1,"stats":{"Line":0},"fn_name":"retrieve"},{"line":138,"address":[265588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[265625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[265639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[265654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[265669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[265696],"length":1,"stats":{"Line":0},"fn_name":"retrieve_or_int"},{"line":146,"address":[265719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[265756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[265770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[265785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[265800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[265811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[265840],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":168,"address":[265879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[265924,267452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[265978,267215],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[266994,266047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[266116,266773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[266185,266552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[266510,266254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[266500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[267616],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":185,"address":[267649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[267680,268338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[267719,268250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[267758,268153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[267800,268063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[268022,267847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[268015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[268432],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":201,"address":[268460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[268491,268943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[268530,268855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[268765,268569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[268724,268611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[268717],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":115},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","src","quick.rs"],"content":"//! Quick algorithm found by reverse engineering the input programme.\n//!\n//! # Quick start\n//!\n//! Call [`iterator`] to create an iterator over the valid solutions:\n//!\n//! ```\n//! # use aoc_2021_day_24::*;\n//! # let steps = [quick::Step { random: false, check: 0, increment: 0 }; 14];\n//! for solution in quick::iterator (\u0026 steps, true) {\n//!   println! (\"{:?}\", solution);\n//! }\n//! ```\n//!\n//! # Description\n//!\n//! Looking carefully at the provided programme, it seems to be the same 18 instructions repeated,\n//! once for every input character. There are only three that vary. Here's the template:\n//!\n//! ```text\n//!  1  inp w\n//!  2  mul x 0\n//!  3  add x z\n//!  4  mod x 26\n//!  5  div z (1 or 26)\n//!  6  add x (-16 to 13)\n//!  7  eql x w\n//!  8  eql x 0\n//!  9  mul y 0\n//! 10  add y 25\n//! 11  mul y x\n//! 12  add y 1\n//! 13  mul z y\n//! 14  mul y 0\n//! 15  mul y w\n//! 16  add y (3 to 15)\n//! 17  mul y x\n//! 18  add z y\n//! ```\n//!\n//! So, the registers seem to be used as follows:\n//!\n//!\n//! * `w` --- The current input value. This is loaded in the first instruction and not modified\n//! again.\n//! * `x` --- Temporary value, the value from the previous step is discarded. This is set to `0` if\n//! the input value matches a calculation based on `z` and a parameter which varies for each step,\n//! or to `1` otherwise.\n//! * `y` --- Another temporary value, this is used to calculate values based on `x`, `w` and a\n//! parameter, and then used to update `z`. The value is carefully calculated to not update `z` if\n//! `x` is set to `0`, by setting it to `1` for a multiply or `0` for an add.\n//! * `z` --- An accumulator, which is kept between steps. This starts off at `0` and gets\n//! conditionally multiplied by 26, divided by 26, and added to.\n//!\n//! We can compile the differences in each step into a table of parameters. Since a divide by one\n//! is an identity operation, we reduce the first difference into a boolean, tracking whether we\n//! will divide of not. We will name the other two parameters `check` and `increment`, based on\n//! how they are used. So using the programme I was given as an example, we end up with the\n//! following:\n//!\n//! | Parameter   | 1    | 2    | 3    | 4    | 5    | 6     | 7    | 8     | 9     | 10   | 11   | 12   | 13   | 14    |\n//! |-------------|:----:|:----:|:----:|:----:|:----:|:-----:|:----:|:-----:|:-----:|:----:|:----:|:----:|:----:|:-----:|\n//! | `divide`    |      |      |      |      |      | yes   |      | yes   | yes   |      | yes  | yes  | yes  | yes   |\n//! | `check`     | `10` | `12` | `10` | `12` | `11` | `-16` | `10` | `-11` | `-13` | `13` | `-8` | `-1` | `-4` | `-14` |\n//! | `increment` | `12` | `7`  | `8`  | `8`  | `15` | `12`  | `8`  | `13`  | `3`   | `13` | `3`  | `9`  | `4`  | `13`  |\n//!\n//! And we can descibe the algorithm for each step as code. Here we use `acc` to refer to the\n//! shared state stored in register `z`, and we expect the parameters for each step to be passed in\n//! a struct:\n//!\n//! ```\n//! struct StepParams {\n//!     divide: bool,\n//!     check: i64,\n//!     increment: i64,\n//! }\n//! fn apply_step (params: \u0026 StepParams, acc: \u0026 mut i64, input: i64) {\n//!     if input == * acc % 26 + params.check { // instructions 2-4,6-8\n//!         if params.divide { * acc /= 26; }   // instruction 5\n//!     } else {\n//!         if ! params.divide { * acc *= 26; } // instructions 9-13\n//!         * acc += input + params.increment;  // instructions 14-18\n//!     }\n//! }\n//! ```\n//!\n//! We can either divide `acc` by 26, multiply it by 26 and add something, or just add something.\n//! Furthermore, in seven of our fourteen steps we always multiply, so to get this value down to\n//! zero we are going to have to make sure we divide on all seven of the other steps. The extra\n//! addition from increment will have to be removed as a rounding error from the division - this\n//! presumably is intended to reduce the total number of valid inputs.\n//!\n//! Since we are deciding whether to divide based on a value derived from `acc` and `check`, we\n//! can simply calculate the correct value based on the previous digits. This reduces our problem\n//! from searching 9 (twenty-three trillion) combinations, down to only 9 (five million). What's\n//! more, we will often be able to shortcut the search if there is no matching next digit.\n//!\n//! This leads to the algorithm implemented here. The steps are encoded in the [`Step`] struct, and\n//! the `steps_for` function reads an input programme and identifies the correct parameters for\n//! step. I inverted the `divide` parameter around and called it [`random`][Step::random] - this\n//! indicates that we should choose a random value for this input value, or in practice try all\n//! possible values. The `iterator` function returns an iterator over all of the valid inputs,\n//! actually 14 nested iterators plus a final call to `map` at the end to check the final sum, and\n//! to convert to match the function signature.\n//!\n//! The actual algorithm is implemented in the [`NextNumIter`] struct. This is an iterator adapter,\n//! which takes an iterator over partial solutions and provides the possible answers with the\n//! next digit included. If this is a `random` step, then this expands every `n`-digit entry into\n//! nine `n+1`-digit entries, one for each valid digit. Otherwise, it will either provide a single\n//! entry with the appropriate next digit, or no entries if the correct next digit is not in the\n//! valid range.\n//!\n//! # Performance\n//!\n//! This shows the time for finding the answers for the puzzle, and for finding all valid codes,\n//! plus the peak memory usage, for each build version.\n//!\n//! | Version | Puzzle    | All        | Memory   |\n//! |:-------:|:---------:|:----------:|:--------:|\n//! | Debug   | 0.56 secs | 2.23 secs  | 2.88 MiB |\n//! | Release | 0.10 secs | 0.39 secs  | 2.20 MiB |\n\nuse super::*;\nuse machine::Instr;\nuse machine::Reg;\nuse machine::RegOrInt;\nuse model::Input;\nuse nums::IntConv;\n\n#[ derive (Clone, Copy, Debug) ]\npub struct Step {\n\tpub random: bool,\n\tpub check: i64,\n\tpub increment: i64,\n}\n\nimpl Step {\n\tpub fn new (random: bool, check: i64, increment: i64) -\u003e Step {\n\t\tStep { random, check, increment }\n\t}\n\tpub fn solve (self, progress: i64) -\u003e Option \u003cu8\u003e {\n\t\tlet next = progress % 26 + self.check;\n\t\tif (1 ..= 9).contains (\u0026 next) {\n\t\t\tSome (next.as_u8 ())\n\t\t} else { None }\n\t}\n\tpub fn incr (self, progress: i64, next: u8) -\u003e i64 {\n\t\tif self.random {\n\t\t\tprogress * 26 + next.as_i64 () + self.increment\n\t\t} else {\n\t\t\tprogress / 26\n\t\t}\n\t}\n}\n\npub fn steps_for (prog: \u0026 [Instr]) -\u003e GenResult \u003c[Step; 14]\u003e {\n\tif prog.len () != 14 * 18 { Err (format! (\"Programme is not the right length\")) ? }\n\tOk (prog.chunks (18).enumerate ().map (|(chunk_idx, chunk)| {\n\t\tlet err = |line_idx|\n\t\t\tformat! (\"Unable to generate quick steps for programme at line {}\",\n\t\t\t\tchunk_idx * 18 + line_idx + 1);\n\t\tlet expect = |line_idx, val| -\u003e GenResult \u003c()\u003e {\n\t\t\tif chunk [line_idx] == val { Ok (()) } else { Err (err (line_idx)) ? }\n\t\t};\n\t\texpect (0, Instr::Inp (Reg::W)) ?;\n\t\texpect (1, Instr::Mul (Reg::X, RegOrInt::Int (0))) ?;\n\t\texpect (2, Instr::Add (Reg::X, RegOrInt::Z)) ?;\n\t\texpect (3, Instr::Mod (Reg::X, RegOrInt::Int (26))) ?;\n\t\tlet random = match chunk [4] {\n\t\t\tInstr::Div (Reg::Z, RegOrInt::Int (26)) =\u003e false,\n\t\t\tInstr::Div (Reg::Z, RegOrInt::Int (1)) =\u003e true,\n\t\t\t_ =\u003e Err (err (4)) ?,\n\t\t};\n\t\tlet check = match chunk [5] {\n\t\t\tInstr::Add (Reg::X, RegOrInt::Int (check)) =\u003e check,\n\t\t\t_ =\u003e Err (err (5)) ?,\n\t\t};\n\t\texpect (6, Instr::Eql (Reg::X, RegOrInt::W)) ?;\n\t\texpect (7, Instr::Eql (Reg::X, RegOrInt::Int (0))) ?;\n\t\texpect (8, Instr::Mul (Reg::Y, RegOrInt::Int (0))) ?;\n\t\texpect (9, Instr::Add (Reg::Y, RegOrInt::Int (25))) ?;\n\t\texpect (10, Instr::Mul (Reg::Y, RegOrInt::X)) ?;\n\t\texpect (11, Instr::Add (Reg::Y, RegOrInt::Int (1))) ?;\n\t\texpect (12, Instr::Mul (Reg::Z, RegOrInt::Y)) ?;\n\t\texpect (13, Instr::Mul (Reg::Y, RegOrInt::Int (0))) ?;\n\t\texpect (14, Instr::Add (Reg::Y, RegOrInt::W)) ?;\n\t\tlet increment = match chunk [15] {\n\t\t\tInstr::Add (Reg::Y, RegOrInt::Int (increment)) =\u003e increment,\n\t\t\t_ =\u003e Err (err (15)) ?,\n\t\t};\n\t\texpect (16, Instr::Mul (Reg::Y, RegOrInt::X)) ?;\n\t\texpect (17, Instr::Add (Reg::Z, RegOrInt::Y)) ?;\n\t\tOk (Step { random, check, increment })\n\t}).collect::\u003cGenResult \u003cVec \u003cStep\u003e\u003e\u003e () ?.try_into ().unwrap ())\n}\n\npub fn iterator (steps: \u0026 [Step; 14], reverse: bool) -\u003e impl Iterator \u003cItem = Input\u003e + '_ {\n\tNextNumIter::new (steps, reverse).nest ().nest ().nest ().nest ().nest ().nest ().nest ().nest ()\n\t\t.nest ().nest ().nest ().nest ().nest ().filter_map (|(nums, progress)| {\n\t\t\tif progress == 0 {\n\t\t\t\tlet mut answer = [0; 14];\n\t\t\t\tfor idx in 0 .. 14 { answer [idx] = nums [idx] }\n\t\t\t\tSome (answer)\n\t\t\t} else { None }\n\t\t})\n}\n\ntype TempAnswer = (ArrayVec \u003cu8, 14\u003e, i64);\n\npub enum NextNumIter \u003c'a, Nested\u003e {\n\tOuter { steps: \u0026 'a [Step; 14], nested: Nested, reverse: bool },\n\tInner { steps: \u0026 'a [Step; 14], nested: Nested, reverse: bool, nums: ArrayVec \u003cu8, 14\u003e, progress: i64, next_iter: ops::RangeInclusive \u003cu8\u003e },\n\tPoison,\n}\n\nimpl \u003c'a\u003e NextNumIter \u003c'a, std::option::IntoIter \u003cTempAnswer\u003e\u003e {\n\tfn new (steps: \u0026 'a [Step; 14], reverse: bool) -\u003e NextNumIter \u003c'a, std::option::IntoIter \u003cTempAnswer\u003e\u003e {\n\t\tlet a: TempAnswer = (ArrayVec::new (), 0);\n\t\tNextNumIter::Outer { steps, nested: Some (a).into_iter (), reverse }\n\t}\n}\n\nimpl \u003c'a, Nested: Iterator \u003cItem = TempAnswer\u003e\u003e NextNumIter \u003c'a, Nested\u003e {\n\tfn nest (self) -\u003e NextNumIter \u003c'a, Self\u003e {\n\t\tmatch \u0026 self {\n\t\t\t\u0026 NextNumIter::Outer { steps, reverse, .. } =\u003e\n\t\t\t\tNextNumIter::Outer { steps, nested: self, reverse },\n\t\t\t_ =\u003e panic! (),\n\t\t}\n\t}\n}\n\nimpl \u003c'a, Nested: Iterator \u003cItem = TempAnswer\u003e\u003e Iterator for NextNumIter \u003c'a, Nested\u003e {\n\ttype Item = TempAnswer;\n\t#[ allow (clippy::reversed_empty_ranges) ]\n\tfn next (\u0026 mut self) -\u003e Option \u003cTempAnswer\u003e {\n\t\tloop { match mem::replace (self, NextNumIter::Poison) {\n\t\t\tNextNumIter::Outer { steps, mut nested, reverse } =\u003e match nested.next () {\n\t\t\t\tSome ((nums, progress)) =\u003e {\n\t\t\t\t\tlet step = steps [nums.len ()];\n\t\t\t\t\tlet next_iter = if step.random {\n\t\t\t\t\t\t1 ..= 9\n\t\t\t\t\t} else if let Some (next) = step.solve (progress) {\n\t\t\t\t\t\tnext ..= next\n\t\t\t\t\t} else {\n\t\t\t\t\t\t10 ..= 9\n\t\t\t\t\t};\n\t\t\t\t\t* self = NextNumIter::Inner { steps, nested, reverse, nums, progress, next_iter };\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t\tNone =\u003e {\n\t\t\t\t\treturn None;\n\t\t\t\t},\n\t\t\t},\n\t\t\tNextNumIter::Inner { steps, nested, reverse, nums, progress, mut next_iter } =\u003e\n\t\t\t\t\tmatch if reverse { next_iter.next_back () } else { next_iter.next () } {\n\t\t\t\tSome (next) =\u003e {\n\t\t\t\t\tlet step = steps [nums.len ()];\n\t\t\t\t\tlet mut new_nums = nums.clone ();\n\t\t\t\t\tnew_nums.push (next);\n\t\t\t\t\tlet new_progress = step.incr (progress, next);\n\t\t\t\t\t* self = NextNumIter::Inner { steps, nested, reverse, nums, progress, next_iter };\n\t\t\t\t\treturn Some ((new_nums, new_progress));\n\t\t\t\t},\n\t\t\t\tNone =\u003e {\n\t\t\t\t\t* self = NextNumIter::Outer { steps, nested, reverse };\n\t\t\t\t\tcontinue;\n\t\t\t\t},\n\t\t\t},\n\t\t\tNextNumIter::Poison =\u003e panic! (),\n\t\t} }\n\t}\n}\n","traces":[{"line":138,"address":[444688],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":141,"address":[444752],"length":1,"stats":{"Line":0},"fn_name":"solve"},{"line":142,"address":[444893,444771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[444870,444927,444938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[444940],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[444933],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[444992],"length":1,"stats":{"Line":0},"fn_name":"incr"},{"line":148,"address":[445232,445021,445294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[445234,445068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[445296,445279,445032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[445328],"length":1,"stats":{"Line":0},"fn_name":"steps_for"},{"line":157,"address":[445370,445411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[68281,67712,67743,73674],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":159,"address":[67794,73744,74056],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":160,"address":[73931,73995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[73956,73782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[67810,74248,74064,74474],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":163,"address":[74102,74266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[67842,68227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[68036,68537,68305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[68846,68358,68602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[68994,68655,68911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[68969,69163,69051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[69214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[69227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[69112,69240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[69505,69642],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[69660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[69591,69688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[69946,70375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[70684,70440,70184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[70493,70749,70990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[70802,71278,71052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[71337,71575,71105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[71634,71860,71390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[72157,71687,71919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[72216,71972,72442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[72269,72584,72501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[72641,72759,72559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[72777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[72708,72805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[73063,73462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[73289,73521,73687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[73579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[445922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[446048],"length":1,"stats":{"Line":0},"fn_name":"iterator"},{"line":198,"address":[446093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[74541,74865],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[74547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[74696,74565,74870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[74791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[74631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":86},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-24","src","solver.rs"],"content":"use super::*;\nuse machine::Instr;\nuse machine::MachineError;\nuse machine::Reg;\nuse machine::RegOrInt;\n\n#[ derive (Clone) ]\npub struct Solver {\n\tinner: Rc \u003cSolverInner\u003e,\n\tinner_weak: RcWeak \u003cSolverInner\u003e,\n}\n\nstruct SolverInner {\n\tstate: RefCell \u003cSolverState\u003e,\n}\n\nstruct SolverState {\n\tsymbols: HashMap \u003cRc \u003cstr\u003e, Symbol\u003e,\n\tsymbols_ordered: Vec \u003cSymbol\u003e,\n}\n\n#[ derive (Clone) ]\npub struct Symbol {\n\tinner: Rc \u003cSymbolInner\u003e,\n}\n\nstruct SymbolInner {\n\tsolver_inner: RcWeak \u003cSolverInner\u003e,\n\tname: Rc \u003cstr\u003e,\n\toriginal_value: Option \u003cSymVal\u003e,\n\toriginal_depth: usize,\n\toriginal_len: usize,\n\toriginal_children: ArrayVec \u003cSymbol, 2\u003e,\n\tstate: RefCell \u003cSymbolState\u003e,\n}\n\n#[ derive (Debug) ]\nstruct SymbolState {\n\tvalue: SymVal,\n\tdepth: usize,\n\tlen: usize,\n}\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub enum SymVal {\n\tSymbol (Symbol),\n\tInput (usize),\n\tAdd (Symbol, Symbol),\n\tMultiply (Symbol, Symbol),\n\tDivide (Symbol, Symbol),\n\tModulo (Symbol, Symbol),\n\tIsEqual (Symbol, Symbol),\n\tIsUnequal (Symbol, Symbol),\n\tValue (i64),\n\tError (MachineError),\n}\n\nimpl Solver {\n\tpub fn from_prog (input: \u0026 [Instr]) -\u003e (Solver, Vec \u003c(Rc \u003cstr\u003e, Symbol)\u003e) {\n\t\tstruct Context {\n\t\t\tnamer: VerNamer,\n\t\t\tsolver: Solver,\n\t\t\tliteral_name: Rc \u003cstr\u003e,\n\t\t\treg_w_name: Rc \u003cstr\u003e,\n\t\t\treg_x_name: Rc \u003cstr\u003e,\n\t\t\treg_y_name: Rc \u003cstr\u003e,\n\t\t\treg_z_name: Rc \u003cstr\u003e,\n\t\t\treg_w: Symbol,\n\t\t\treg_x: Symbol,\n\t\t\treg_y: Symbol,\n\t\t\treg_z: Symbol,\n\t\t}\n\t\timpl Context {\n\t\t\tfn get (\u0026 self, reg: Reg) -\u003e Symbol {\n\t\t\t\tmatch reg {\n\t\t\t\t\tReg::W =\u003e self.reg_w.clone (),\n\t\t\t\t\tReg::X =\u003e self.reg_x.clone (),\n\t\t\t\t\tReg::Y =\u003e self.reg_y.clone (),\n\t\t\t\t\tReg::Z =\u003e self.reg_z.clone (),\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn get_val (\u0026 mut self, reg_or_int: RegOrInt) -\u003e Symbol {\n\t\t\t\tmatch reg_or_int {\n\t\t\t\t\tRegOrInt::W =\u003e self.reg_w.clone (),\n\t\t\t\t\tRegOrInt::X =\u003e self.reg_x.clone (),\n\t\t\t\t\tRegOrInt::Y =\u003e self.reg_y.clone (),\n\t\t\t\t\tRegOrInt::Z =\u003e self.reg_z.clone (),\n\t\t\t\t\tRegOrInt::Int (value) =\u003e self.lit (value),\n\t\t\t\t}\n\t\t\t}\n\t\t\tfn set (\u0026 mut self, reg: Reg, value: SymVal) {\n\t\t\t\tlet (reg_name, reg) = match reg {\n\t\t\t\t\tReg::W =\u003e (\u0026 self.reg_w_name, \u0026 mut self.reg_w),\n\t\t\t\t\tReg::X =\u003e (\u0026 self.reg_x_name, \u0026 mut self.reg_x),\n\t\t\t\t\tReg::Y =\u003e (\u0026 self.reg_y_name, \u0026 mut self.reg_y),\n\t\t\t\t\tReg::Z =\u003e (\u0026 self.reg_z_name, \u0026 mut self.reg_z),\n\t\t\t\t};\n\t\t\t\tlet symbol_name = self.namer.define (reg_name);\n\t\t\t\tlet symbol = self.solver.define (symbol_name, value);\n\t\t\t\t* reg = symbol;\n\t\t\t}\n\t\t\tfn lit (\u0026 mut self, value: i64) -\u003e Symbol {\n\t\t\t\tlet symbol_name = self.namer.define (\u0026 self.literal_name);\n\t\t\t\tlet symbol_value = SymVal::Value (value);\n\t\t\t\tself.solver.define (symbol_name, symbol_value)\n\t\t\t}\n\t\t}\n\t\tlet mut ctx = {\n\t\t\tlet mut namer = VerNamer::new ();\n\t\t\tlet solver = Solver::new ();\n\t\t\tlet literal_name = \"lit\".into ();\n\t\t\tlet reg_w_name: Rc \u003cstr\u003e = \"w\".into ();\n\t\t\tlet reg_x_name: Rc \u003cstr\u003e = \"x\".into ();\n\t\t\tlet reg_y_name: Rc \u003cstr\u003e = \"y\".into ();\n\t\t\tlet reg_z_name: Rc \u003cstr\u003e = \"z\".into ();\n\t\t\tlet reg_w = solver.define (namer.define (\u0026 reg_w_name), SymVal::Value (0));\n\t\t\tlet reg_x = solver.define (namer.define (\u0026 reg_x_name), SymVal::Value (0));\n\t\t\tlet reg_y = solver.define (namer.define (\u0026 reg_y_name), SymVal::Value (0));\n\t\t\tlet reg_z = solver.define (namer.define (\u0026 reg_z_name), SymVal::Value (0));\n\t\t\tContext {\n\t\t\t\tnamer, solver,\n\t\t\t\tliteral_name, reg_w_name, reg_x_name, reg_y_name, reg_z_name,\n\t\t\t\treg_w, reg_x, reg_y, reg_z,\n\t\t\t}\n\t\t};\n\t\tlet mut input_count = 0;\n\t\tfor instr in input.iter ().copied () {\n\t\t\tmatch instr {\n\t\t\t\tInstr::Inp (dest) =\u003e {\n\t\t\t\t\tctx.set (dest, SymVal::Input (input_count));\n\t\t\t\t\tinput_count += 1;\n\t\t\t\t},\n\t\t\t\tInstr::Add (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Add (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Mul (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Multiply (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Div (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Divide (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Mod (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::Modulo (dest_val, src_val));\n\t\t\t\t},\n\t\t\t\tInstr::Eql (dest, src) =\u003e {\n\t\t\t\t\tlet dest_val = ctx.get (dest);\n\t\t\t\t\tlet src_val = ctx.get_val (src);\n\t\t\t\t\tctx.set (dest, SymVal::IsEqual (dest_val, src_val));\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\t\t(ctx.solver, vec! [\n\t\t\t(ctx.reg_w_name, ctx.reg_w),\n\t\t\t(ctx.reg_x_name, ctx.reg_x),\n\t\t\t(ctx.reg_y_name, ctx.reg_y),\n\t\t\t(ctx.reg_z_name, ctx.reg_z),\n\t\t])\n\t}\n\tpub fn eval (\u0026 self, input: \u0026 [\u0026 [i64]], symbol: \u0026 Symbol) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\t\tself.require_own_symbol (\"eval\", symbol);\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tlet mut seen: HashSet \u003cSymbol\u003e = HashSet::new ();\n\t\tseen.insert (symbol.clone ());\n\t\tlet mut todo: Vec \u003cSymbol\u003e = vec! [ symbol.clone () ];\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.children ().into_iter () {\n\t\t\t\tif seen.insert (child.clone ()) {\n\t\t\t\t\ttodo.push (child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet mut values: HashMap \u003cSymbol, Rc \u003cVec \u003ci64\u003e\u003e\u003e = HashMap::new ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif ! seen.contains (symbol) { continue }\n\t\t\tlet value = symbol.eval (\u0026 |sym| Rc::clone (values.get (sym).unwrap ()), input) ?;\n\t\t\tlet value = Rc::new (value);\n\t\t\tvalues.insert (symbol.clone (), Rc::clone (\u0026 value));\n\t\t}\n\t\ttodo! ();\n\t}\n\tpub fn new () -\u003e Solver {\n\t\tlet inner = Rc::new (SolverInner {\n\t\t\tstate: RefCell::new (SolverState {\n\t\t\t\tsymbols: HashMap::new (),\n\t\t\t\tsymbols_ordered: Vec::new (),\n\t\t\t}),\n\t\t});\n\t\tlet inner_weak = Rc::downgrade (\u0026 inner);\n\t\tSolver { inner, inner_weak }\n\t}\n\tpub fn fork (\u0026 self, symbols: \u0026 mut [\u0026 mut Symbol], input: \u0026 [i64]) -\u003e Solver {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tlet mut seen: HashSet \u003cSymbol\u003e = symbols.iter ().map (|a| \u0026 ** a).cloned ().collect ();\n\t\tlet mut todo: Vec \u003cSymbol\u003e = seen.iter ().cloned ().collect ();\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.children ().into_iter () {\n\t\t\t\tif seen.insert (child.clone ()) {\n\t\t\t\t\ttodo.push (child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet mut new_solver = Solver::new ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif ! seen.contains (symbol) { continue }\n\t\t\tlet new_value = symbol.value ().migrate (\u0026 mut new_solver, input);\n\t\t\tnew_solver.define (Rc::clone (symbol.name ()), new_value);\n\t\t}\n\t\tfor old_symbol in symbols.iter_mut () {\n\t\t\tlet new_symbol = new_solver.get (old_symbol.name ()).unwrap ();\n\t\t\t** old_symbol = new_symbol;\n\t\t}\n\t\tnew_solver\n\t}\n\tpub fn get (\u0026 self, name: \u0026 Rc \u003cstr\u003e) -\u003e Option \u003cSymbol\u003e {\n\t\tlet state = self.inner.state.borrow ();\n\t\tstate.symbols.get (name).cloned ()\n\t}\n\tpub fn define (\u0026 self, name: Rc \u003cstr\u003e, value: SymVal) -\u003e Symbol {\n\t\tvalue.children ().iter ().for_each (|child| self.require_own_symbol (\"define\", child));\n\t\tlet mut state = self.inner.state.borrow_mut ();\n\t\tif state.symbols.contains_key (\u0026 name) { panic! () }\n\t\tlet mut value = value;\n\t\tlet mut depth = value.depth ();\n\t\tlet mut len = value.len ();\n\t\tlet mut original_value = None;\n\t\tlet original_depth = value.original_depth ();\n\t\tlet original_len = value.original_len ();\n\t\tlet original_children = value.children ();\n\t\tif let Some (simplified_value) = value.simplify () {\n\t\t\toriginal_value = Some (value);\n\t\t\tvalue = simplified_value;\n\t\t\tdepth = value.depth ();\n\t\t\tlen = value.len ();\n\t\t}\n\t\tlet symbol = Symbol {\n\t\t\tinner: Rc::new (SymbolInner {\n\t\t\t\tsolver_inner: Rc::downgrade (\u0026 self.inner),\n\t\t\t\tname: Rc::clone (\u0026 name),\n\t\t\t\toriginal_value,\n\t\t\t\toriginal_depth,\n\t\t\t\toriginal_len,\n\t\t\t\toriginal_children,\n\t\t\t\tstate: RefCell::new (SymbolState {\n\t\t\t\t\tvalue,\n\t\t\t\t\tdepth,\n\t\t\t\t\tlen,\n\t\t\t\t}),\n\t\t\t}),\n\t\t};\n\t\tstate.symbols.insert (name, symbol.clone ());\n\t\tstate.symbols_ordered.push (symbol.clone ());\n\t\tsymbol\n\t}\n\tpub fn dump (\u0026 self, depth: usize, show_original: bool) {\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tlet state = self.inner.state.borrow ();\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tsymbol.dump (options, show_original, None);\n\t\t}\n\t}\n\tfn require_own_symbol (\u0026 self, fn_name: \u0026 str, symbol: \u0026 Symbol) {\n\t\tif ! RcWeak::ptr_eq (\u0026 self.inner_weak, \u0026 symbol.inner.solver_inner) {\n\t\t\tpanic! (\"Tried to call Solver::{} on solver at {:p} with a symbol from solver at {:p}\",\n\t\t\t\tfn_name,\n\t\t\t\tRc::as_ptr (\u0026 self.inner),\n\t\t\t\tRcWeak::as_ptr (\u0026 symbol.inner.solver_inner));\n\t\t}\n\t}\n\tpub fn dump_symbol (\u0026 self, depth: usize, show_original: bool, symbol: \u0026 Symbol) {\n\t\tself.require_own_symbol (\"dump_symbol\", symbol);\n\t\tlet state = self.inner.state.borrow ();\n\t\tlet counts = state.symbol_use_counts (symbol);\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tlet count = match counts.get (symbol) {\n\t\t\t\tSome (\u0026 count) =\u003e count,\n\t\t\t\tNone =\u003e continue,\n\t\t\t};\n\t\t\tsymbol.dump (options, show_original, Some (count));\n\t\t}\n\t}\n\tpub fn dump_symbol_auto (\u0026 self, symbol: \u0026 Symbol) {\n\t\tself.require_own_symbol (\"dump_symbol_auto\", symbol);\n\t\tlet state = self.inner.state.borrow ();\n\t\tlet counts = state.symbol_use_counts (symbol);\n\t\tlet break_symbols: HashSet \u003cSymbol\u003e = counts.iter ().filter_map (\n\t\t\t|(symbol, \u0026 count)| if count \u003e 1 { Some (symbol) } else { None },\n\t\t).cloned ().collect ();\nlet a: Vec \u003cSymbol\u003e = break_symbols.iter ().cloned ().collect ();\nfor b in a.iter () { println! (\"{:?}\", b); }\n\t\tlet options = FormatExpandOptions::BreakSymbols (\u0026 break_symbols);\n\t\tfor symbol in state.symbols_ordered.iter () {\n\t\t\tif counts.get (symbol).map (|count| * count == 1).unwrap_or (true) { continue }\n\t\t\tsymbol.dump (options, true, None);\n\t\t}\n\t}\n}\n\nimpl SolverState {\n\tfn symbol_use_counts (\u0026 self, symbol: \u0026 Symbol) -\u003e HashMap \u003cSymbol, usize\u003e {\n\t\tlet mut counts: HashMap \u003cSymbol, usize\u003e = HashMap::new ();\n\t\tcounts.insert (symbol.clone (), 0);\n\t\tlet mut todo: Vec \u003cSymbol\u003e = Vec::new ();\n\t\ttodo.push (symbol.clone ());\n\t\twhile let Some (symbol) = todo.pop () {\n\t\t\tfor child in symbol.original_children ().into_iter () {\n\t\t\t\tlet child_count = counts.entry (child.clone ()).or_insert (0);\n\t\t\t\tif * child_count == 0 {\n\t\t\t\t\ttodo.push (child.clone ());\n\t\t\t\t}\n\t\t\t\t* child_count += 1;\n\t\t\t}\n\t\t}\n\t\tcounts\n\t}\n}\n\nimpl Symbol {\n\tpub fn eval (\n\t\t\u0026 self,\n\t\tlookup: \u0026 dyn Fn (\u0026 Symbol) -\u003e Rc \u003cVec \u003ci64\u003e\u003e, input: \u0026 [\u0026 [i64]],\n\t) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.eval (lookup, input)\n\t}\n\tpub fn name (\u0026 self) -\u003e \u0026 Rc \u003cstr\u003e {\n\t\t\u0026 self.inner.name\n\t}\n\tpub fn value (\u0026 self) -\u003e SymVal {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.clone ()\n\t}\n\tpub fn children (\u0026 self) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.value.children ()\n\t}\n\tpub fn original_children (\u0026 self) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_children.clone ()\n\t}\n\tfn dump (\n\t\t\u0026 self,\n\t\toptions: FormatExpandOptions,\n\t\tshow_original: bool,\n\t\tuse_count: Option \u003cusize\u003e,\n\t) {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tprint! (\"{}\", inner.name);\n\t\tif let Some (use_count) = use_count {\n\t\t\tprint! (\" ({})\", use_count);\n\t\t}\n\t\tmatch options {\n\t\t\tFormatExpandOptions::Depth (depth) =\u003e {\n\t\t\t\tif show_original {\n\t\t\t\t\tif let Some (original_value) = \u0026 inner.original_value {\n\t\t\t\t\t\tprint! (\"  {}\", original_value.expand (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprint! (\"  {}\", state.value);\n\t\t\t\tprint! (\"  {}\", state.value.expand (depth));\n\t\t\t},\n\t\t\tFormatExpandOptions::BreakSymbols (_) =\u003e\n\t\t\t\tprint! (\"  {}\", FormatExpand::SymVal (options, false, \u0026 state.value)),\n\t\t}\n\t\tprint! (\"\\n\");\n\t}\n\tpub fn depth (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.depth\n\t}\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tstate.len\n\t}\n\tpub fn is_empty (\u0026 self) -\u003e bool { self.len () == 0 }\n\tpub fn original_depth (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_depth\n\t}\n\tpub fn original_len (\u0026 self) -\u003e usize {\n\t\tlet inner = self.inner.as_ref ();\n\t\tinner.original_len\n\t}\n\tfn fmt_expand (\n\t\t\u0026 self,\n\t\tformatter: \u0026 mut fmt::Formatter,\n\t\toptions: FormatExpandOptions,\n\t\twrap: bool,\n\t) -\u003e fmt::Result {\n\t\tlet inner = self.inner.as_ref ();\n\t\tlet state = inner.state.borrow ();\n\t\tmatch options {\n\t\t\tFormatExpandOptions::Depth (depth) =\u003e {\n\t\t\t\tif depth \u003e 0 {\n\t\t\t\t\tlet options = FormatExpandOptions::Depth (depth - 1);\n\t\t\t\t\twrite! (formatter, \"C{}\", FormatExpand::SymVal (options, wrap, \u0026 state.value)) ?;\n\t\t\t\t} else {\n\t\t\t\t\twrite! (formatter, \"D{}\", inner.name) ?;\n\t\t\t\t}\n\t\t\t},\n\t\t\tFormatExpandOptions::BreakSymbols (break_symbols) =\u003e {\n\t\t\t\tif break_symbols.contains (self) {\n\t\t\t\t\twrite! (formatter, \"A{}\", inner.name) ?;\n\t\t\t\t} else {\n\t\t\t\t\tlet value = inner.original_value.clone ().unwrap_or_else (|| state.value.clone ()).simplified ();\n\t\t\t\t\twrite! (formatter, \"B{}\", FormatExpand::SymVal (options, wrap, \u0026 value)) ?;\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl cmp::PartialOrd for Symbol {\n\tfn partial_cmp (\u0026 self, other: \u0026 Symbol) -\u003e Option \u003ccmp::Ordering\u003e {\n\t\tself.inner.name.partial_cmp (\u0026 other.inner.name)\n\t}\n}\n\nimpl fmt::Debug for Symbol {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet inner = self.inner.as_ref ();\n\t\twrite! (formatter, \"Symbol {:?}\", inner.name) ?;\n\t\tOk (())\n\t}\n}\n\nimpl fmt::Display for Symbol {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"{}\",\n\t\t\tFormatExpand::Symbol (\n\t\t\t\tFormatExpandOptions::Depth (formatter.precision ().unwrap_or (0)),\n\t\t\t\tfalse,\n\t\t\t\tself)) ?;\n\t\tOk (())\n\t}\n}\n\nimpl hash::Hash for Symbol {\n\tfn hash \u003cHasher: hash::Hasher\u003e (\u0026 self, state: \u0026 mut Hasher) {\n\t\tself.inner.name.hash (state);\n\t}\n}\n\nimpl PartialEq for Symbol {\n\tfn eq (\u0026 self, other: \u0026 Symbol) -\u003e bool { self.inner.name == other.inner.name }\n}\n\nimpl Eq for Symbol {}\n\nimpl SymVal {\n\tfn eval (\u0026 self, lookup: \u0026 dyn Fn (\u0026 Symbol) -\u003e Rc \u003cVec \u003ci64\u003e\u003e, input: \u0026 [\u0026 [i64]]) -\u003e Result \u003cVec \u003ci64\u003e, MachineError\u003e {\n\t\tfn combine \u003cCombine: Fn (i64, i64) -\u003e i64\u003e (left: Rc \u003cVec \u003ci64\u003e\u003e, right: Rc \u003cVec \u003ci64\u003e\u003e, combine: Combine) -\u003e Vec \u003ci64\u003e {\n\t\t\tlet mut results = HashSet::new ();\n\t\t\tfor left in left.iter ().copied () { for right in right.iter ().copied () {\n\t\t\t\tresults.insert (combine (left, right));\n\t\t\t} }\n\t\t\tlet mut results: Vec \u003ci64\u003e = results.into_iter ().collect ();\n\t\t\tresults.sort ();\n\t\t\tresults\n\t\t}\n\t\tOk (match self {\n\t\t\tSymVal::Symbol (arg) =\u003e lookup (arg).to_vec (),\n\t\t\tSymVal::Input (arg) =\u003e input.get (* arg).copied ().ok_or (MachineError::NoMoreInput) ?.to_vec (),\n\t\t\tSymVal::Add (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| a + b),\n\t\t\tSymVal::Multiply (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| a * b),\n\t\t\tSymVal::Divide (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| a / b),\n\t\t\tSymVal::Modulo (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| a % b),\n\t\t\tSymVal::IsEqual (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| if a == b { 1 } else { 0 }),\n\t\t\tSymVal::IsUnequal (left, right) =\u003e combine (lookup (left), lookup (right), |a, b| if a != b { 1 } else { 0 }),\n\t\t\tSymVal::Value (arg) =\u003e vec! [ * arg ],\n\t\t\tSymVal::Error (arg) =\u003e Err (* arg) ?,\n\t\t})\n\t}\n\tpub fn depth (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().map (|child| child.depth ()).max ().unwrap_or (0) + 1\n\t}\n\tpub fn len (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().fold (1, |len, child| len + child.len ())\n\t}\n\tpub fn is_empty (\u0026 self) -\u003e bool {\n\t\tself.children ().iter ().next ().is_some ()\n\t}\n\tpub fn original_depth (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().map (|child| child.original_depth ()).max ().unwrap_or (0) + 1\n\t}\n\tpub fn original_len (\u0026 self) -\u003e usize {\n\t\tself.children ().iter ().fold (1, |len, child| len + child.original_len ())\n\t}\n\tpub fn children (\u0026 self) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\tfn make \u003cconst CAP: usize\u003e (arg: [\u0026 Symbol; CAP]) -\u003e ArrayVec \u003cSymbol, 2\u003e {\n\t\t\targ.into_iter ().cloned ().collect ()\n\t\t}\n\t\tmatch self {\n\t\t\tSymVal::Symbol (arg) =\u003e make ([ arg ]),\n\t\t\tSymVal::Input (_) =\u003e make ([ ]),\n\t\t\tSymVal::Add (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::Multiply (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::Divide (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::Modulo (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::IsEqual (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::IsUnequal (left, right) =\u003e make ([ left, right ]),\n\t\t\tSymVal::Value (_) =\u003e make ([ ]),\n\t\t\tSymVal::Error (_) =\u003e make ([ ]),\n\t\t}\n\t}\n\tfn fmt_expand (\n\t\t\u0026 self,\n\t\tformatter: \u0026 mut fmt::Formatter,\n\t\toptions: FormatExpandOptions,\n\t\twrap: bool,\n\t) -\u003e fmt::Result {\n\t\tlet expand = |symbol, wrap| FormatExpand::Symbol (options, wrap, symbol);\n\t\tlet (open, close) = if wrap { (\"(\", \")\") } else { (\"\", \"\") };\n\t\tmatch self {\n\t\t\tSymVal::Symbol (other_symbol) =\u003e\n\t\t\t\twrite! (formatter, \"{}\", expand (other_symbol, wrap)) ?,\n\t\t\tSymVal::Input (index) =\u003e\n\t\t\t\twrite! (formatter, \"input [{}]\", index) ?,\n\t\t\tSymVal::Add (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} + {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::Multiply (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::Divide (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::Modulo (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} mod {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::IsEqual (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{} = {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::IsUnequal (left, right) =\u003e\n\t\t\t\twrite! (formatter, \"{}{}  {}{}\", open, expand (left, true), expand (right, true), close) ?,\n\t\t\tSymVal::Value (value) =\u003e\n\t\t\t\twrite! (formatter, \"{}\", value) ?,\n\t\t\tSymVal::Error (arg) =\u003e\n\t\t\t\twrite! (formatter, \"{:?}\", arg) ?,\n\t\t}\n\t\tOk (())\n\t}\n\tfn expand (\u0026 self, depth: usize) -\u003e FormatExpand {\n\t\tlet options = FormatExpandOptions::Depth (depth);\n\t\tFormatExpand::SymVal (options, false, self)\n\t}\n\tfn simplified (\u0026 self) -\u003e SymVal {\n\t\tmatch self.simplify () {\n\t\t\tSome (val) =\u003e val,\n\t\t\tNone =\u003e self.clone (),\n\t\t}\n\t}\n\tfn simplify (\u0026 self) -\u003e Option \u003cSymVal\u003e {\n\t\tlet mut value = self;\n\t\tlet mut result = None;\n\t\twhile let Some (temp) = value.simplify_real () {\n\t\t\tresult = Some (temp);\n\t\t\tvalue = result.as_ref ().unwrap ();\n\t\t}\n\t\tresult\n\t}\n\tfn simplify_real (\u0026 self) -\u003e Option \u003cSymVal\u003e {\n\t\tmatch self {\n\t\t\tSymVal::Input (_) =\u003e None,\n\t\t\tSymVal::Add (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::Value (left_val), SymVal::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Value (left_val + right_val)),\n\t\t\t\t\t(_, SymVal::Value (0)) =\u003e Some (left_symval),\n\t\t\t\t\t(SymVal::Value (0), _) =\u003e Some (right_symval),\n\t\t\t\t\t(_, _) if left_symval == right_symval =\u003e todo! (),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSymVal::Multiply (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::Value (left_val), SymVal::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Value (left_val * right_val)),\n\t\t\t\t\t(_, SymVal::Value (0)) =\u003e Some (SymVal::Value (0)),\n\t\t\t\t\t(SymVal::Value (0), _) =\u003e Some (SymVal::Value (0)),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSymVal::Divide (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::Value (left_val), SymVal::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Value (left_val / right_val)),\n\t\t\t\t\t(_, SymVal::Value (1)) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Value (0)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Error (MachineError::DivideByZero)),\n\t\t\t\t\t(SymVal::Value (0), _) =\u003e Some (SymVal::Value (0)),\n\t\t\t\t\t(_, _) if left_symval == right_symval =\u003e todo! (),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t}\n\t\t\tSymVal::Modulo (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(\u0026 SymVal::Value (left_val), \u0026 SymVal::Value (right_val)) =\u003e {\n\t\t\t\t\t\tif left_val \u003e= 0 \u0026\u0026 right_val \u003e 0 {\n\t\t\t\t\t\t\tSome (SymVal::Value (left_val % right_val))\n\t\t\t\t\t\t} else if right_val == 0 {\n\t\t\t\t\t\t\tSome (SymVal::Error (MachineError::DivideByZero))\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSome (SymVal::Error (MachineError::NegativeModulo))\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(_, SymVal::Value (0)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Error (MachineError::DivideByZero)),\n\t\t\t\t\t(_, \u0026 SymVal::Value (right_val)) if right_val \u003c 0 =\u003e\n\t\t\t\t\t\tSome (SymVal::Error (MachineError::NegativeModulo)),\n\t\t\t\t\t(\u0026 SymVal::Value (left_val), _) if left_val \u003c 0 =\u003e\n\t\t\t\t\t\tSome (SymVal::Error (MachineError::NegativeModulo)),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSymVal::IsEqual (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::IsEqual (inner_left_sym, inner_right_sym), SymVal::Value (0)) =\u003e\n\t\t\t\t\t\tSome (SymVal::IsUnequal (inner_left_sym.clone (), inner_right_sym.clone ())),\n\t\t\t\t\t(SymVal::Value (0), SymVal::IsEqual (inner_left_sym, inner_right_sym)) =\u003e\n\t\t\t\t\t\tSome (SymVal::IsUnequal (inner_left_sym.clone (), inner_right_sym.clone ())),\n\t\t\t\t\t(SymVal::IsEqual (_, _), SymVal::Value (1)) =\u003e Some (left_symval),\n\t\t\t\t\t(SymVal::Value (1), SymVal::IsEqual (_, _)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::Value (left_val), SymVal::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Value (if left_val == right_val { 1 } else { 0 })),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSymVal::IsUnequal (left_sym, right_sym) =\u003e {\n\t\t\t\tlet left_symval = left_sym.value ();\n\t\t\t\tlet right_symval = right_sym.value ();\n\t\t\t\tmatch (\u0026 left_symval, \u0026 right_symval) {\n\t\t\t\t\t(SymVal::Error (_), _) =\u003e Some (left_symval),\n\t\t\t\t\t(_, SymVal::Error (_)) =\u003e Some (right_symval),\n\t\t\t\t\t(SymVal::Value (left_val), SymVal::Value (right_val)) =\u003e\n\t\t\t\t\t\tSome (SymVal::Value (if left_val != right_val { 1 } else { 0 })),\n\t\t\t\t\t_ =\u003e None,\n\t\t\t\t}\n\t\t\t},\n\t\t\tSymVal::Value (_) =\u003e None,\n\t\t\t_ =\u003e todo! (\"SymVal::{:?}\", self),\n\t\t}\n\t}\n\tfn migrate (\u0026 self, solver: \u0026 mut Solver, input: \u0026 [i64]) -\u003e SymVal {\n\t\tlet dup = |arg: Symbol| solver.get (arg.name ()).unwrap ();\n\t\tmatch self.clone () {\n\t\t\tSymVal::Symbol (arg) =\u003e SymVal::Symbol (dup (arg)),\n\t\t\tSymVal::Input (arg) =\u003e\n\t\t\t\tif let Some (\u0026 val) = input.get (arg) {\n\t\t\t\t\tSymVal::Value (val)\n\t\t\t\t} else {\n\t\t\t\t\tSymVal::Input (arg)\n\t\t\t\t},\n\t\t\tSymVal::Add (left, right) =\u003e SymVal::Add (dup (left), dup (right)),\n\t\t\tSymVal::Multiply (left, right) =\u003e SymVal::Multiply (dup (left), dup (right)),\n\t\t\tSymVal::Divide (left, right) =\u003e SymVal::Divide (dup (left), dup (right)),\n\t\t\tSymVal::Modulo (left, right) =\u003e SymVal::Modulo (dup (left), dup (right)),\n\t\t\tSymVal::IsEqual (left, right) =\u003e SymVal::IsEqual (dup (left), dup (right)),\n\t\t\tSymVal::IsUnequal (left, right) =\u003e SymVal::IsUnequal (dup (left), dup (right)),\n\t\t\tSymVal::Value (arg) =\u003e SymVal::Value (arg),\n\t\t\tSymVal::Error (arg) =\u003e SymVal::Error (arg),\n\t\t}\n\t}\n}\n\nimpl fmt::Display for SymVal {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tlet options = FormatExpandOptions::Depth (formatter.precision ().unwrap_or (0));\n\t\twrite! (formatter, \"{}\",\n\t\t\tFormatExpand::SymVal (options, false, self)) ?;\n\t\tOk (())\n\t}\n}\n\nenum FormatExpand \u003c'a\u003e {\n\tSymbol (FormatExpandOptions \u003c'a\u003e, bool, \u0026 'a Symbol),\n\tSymVal (FormatExpandOptions \u003c'a\u003e, bool, \u0026 'a SymVal),\n}\n\nimpl \u003c'a\u003e fmt::Display for FormatExpand \u003c'a\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch * self {\n\t\t\tFormatExpand::Symbol (options, wrap, symbol) =\u003e\n\t\t\t\tsymbol.fmt_expand (formatter, options, wrap),\n\t\t\tFormatExpand::SymVal (options, wrap, symbol_value) =\u003e\n\t\t\t\tsymbol_value.fmt_expand (formatter, options, wrap),\n\t\t}\n\t}\n}\n\n#[ derive (Clone, Copy) ]\nenum FormatExpandOptions \u003c'a\u003e {\n\tDepth (usize),\n\tBreakSymbols (\u0026 'a HashSet \u003cSymbol\u003e),\n}\n\nstruct VerNamer {\n\tentries: HashMap \u003cRc \u003cstr\u003e, VerNamerEntry\u003e,\n}\n\nstruct VerNamerEntry {\n\tbase_name: Rc \u003cstr\u003e,\n\tlatest_name: Rc \u003cstr\u003e,\n\tlatest_rev: usize,\n}\n\nimpl VerNamer {\n\n\tfn new () -\u003e VerNamer {\n\t\tVerNamer {\n\t\t\tentries: HashMap::new (),\n\t\t}\n\t}\n\n\tfn define (\u0026 mut self, base_name: \u0026 Rc \u003cstr\u003e) -\u003e Rc \u003cstr\u003e {\n\t\tlet entry =\n\t\t\tself.entries.entry (Rc::clone (base_name))\n\t\t\t\t.and_modify (|entry| entry.latest_rev += 1)\n\t\t\t\t.or_insert (VerNamerEntry {\n\t\t\t\t\tbase_name: Rc::clone (base_name),\n\t\t\t\t\tlatest_name: Rc::clone (base_name),\n\t\t\t\t\tlatest_rev: 0,\n\t\t\t\t});\n\t\tentry.latest_name = format! (\"{}{}\", entry.base_name, entry.latest_rev).into ();\n\t\tRc::clone (\u0026 entry.latest_name)\n\t}\n\n}\n","traces":[{"line":59,"address":[173861,171936],"length":1,"stats":{"Line":0},"fn_name":"from_prog"},{"line":74,"address":[176784],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":75,"address":[176804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[176841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[176864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[176887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[176910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[176944],"length":1,"stats":{"Line":0},"fn_name":"get_val"},{"line":83,"address":[176967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[177004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[177027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[177050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[177073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[177096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[177608,177581,177136],"length":1,"stats":{"Line":0},"fn_name":"set"},{"line":92,"address":[177165,177334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[177213],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[177243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[177273],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[177303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[177440,177365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[177456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[177515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[177632],"length":1,"stats":{"Line":0},"fn_name":"lit"},{"line":103,"address":[177662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[177714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[177724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[172001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[172113],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[172126,172205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[172309,172221],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[172325,172413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[172517,172429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[172621,172533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[172637,172725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[172833,172757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[172995,172916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[173078,173157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[173240,173319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[173826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[174151,173838,173943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[174183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[174233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[174225,174243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[175830,175790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[174293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[174362,175600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[175624,175685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[175693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[174391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[175386,174460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[175410,175471],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[175479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[174489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[175175,174552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[175199,175257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[175265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[174581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[174641,174967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[174991,175049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[175057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[174667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[174727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[174789,174847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[174855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[174083,176166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[175910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[175974],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[176038],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[176102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[177792,180054,178286],"length":1,"stats":{"Line":0},"fn_name":"eval"},{"line":168,"address":[177901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[177950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[177979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[178015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[178138,178070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[178150,178297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[178307,178454,178370,180022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[179570,178436,179937,179965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[179812,179871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[179904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[178469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[179489,178484,178739,178547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[178768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[178822,179047],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[178976,179239],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[179247,179301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[180246,180080],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":191,"address":[180272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[180152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[180087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[180108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[180312,180361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[180416,181579,182711],"length":1,"stats":{"Line":0},"fn_name":"fork"},{"line":201,"address":[180495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[180540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[180584,180663],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[180835,180772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[180935,181019,180875,182679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[182622,181001,182227,182594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[182528,182469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[182561],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[181026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[181089,181152,181784,181395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[181424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[181462],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[181636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[181823,182114,181942,181369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[181963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[182045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[182736,182912],"length":1,"stats":{"Line":0},"fn_name":"get"},{"line":225,"address":[182755,182795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[182822,182872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[183315,182944,185658],"length":1,"stats":{"Line":0},"fn_name":"define"},{"line":229,"address":[183010,183154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[183392,183334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[183462,183630,183533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[183568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[183615,183711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[183727],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[183752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[183776,183834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[183850],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[183891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[183922,183970,184497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[184060,184186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[184309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[184397,184448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[184464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[184936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[185248,185186],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[185461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[185696,186133],"length":1,"stats":{"Line":0},"fn_name":"dump"},{"line":265,"address":[185734],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[185800,185748],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[185827,185881,186050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[186066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[186176],"length":1,"stats":{"Line":0},"fn_name":"require_own_symbol"},{"line":272,"address":[186282,186219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[186348,186309,186438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[186335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[186425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[186608,187341,187315],"length":1,"stats":{"Line":0},"fn_name":"dump_symbol"},{"line":280,"address":[186669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[186691,186743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[186779,186849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[186861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[186889,187120,186943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[187148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[187210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[187237],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[188631,188687,187376],"length":1,"stats":{"Line":0},"fn_name":"dump_symbol_auto"},{"line":293,"address":[187418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[187443,187501],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[187537,187616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[187699,187639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[225747,225728],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":299,"address":[187831,187768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[187948,187869,188145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[188102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[188459,188130,188282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[188488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[188562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[188720,189606,189693],"length":1,"stats":{"Line":0},"fn_name":"symbol_use_counts"},{"line":311,"address":[188761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[188787,188854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[188866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[188878,188934],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[189661,188948,189028],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[189016,189129,189617],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[189363,189433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[189477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[189491,189538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[189556,189508,189574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[189035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[189728,189950],"length":1,"stats":{"Line":0},"fn_name":"eval"},{"line":333,"address":[189803],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[189826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[189857,189931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[190000],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":338,"address":[190044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[190214,190064],"length":1,"stats":{"Line":0},"fn_name":"value"},{"line":341,"address":[190096],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[190116],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[190147,190195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[190406,190256],"length":1,"stats":{"Line":0},"fn_name":"children"},{"line":346,"address":[190288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[190308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[190339,190387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[190448],"length":1,"stats":{"Line":0},"fn_name":"original_children"},{"line":351,"address":[190480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[190505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[190528,191777],"length":1,"stats":{"Line":0},"fn_name":"dump"},{"line":360,"address":[190585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[190614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[190737,190654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[190811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[190900,190838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[190875,190978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[190995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[191012],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[191293],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[191357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[191270,191483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[191592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[191033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[191220,191743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[191949,191824],"length":1,"stats":{"Line":0},"fn_name":"depth"},{"line":382,"address":[191833],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[191853],"length":1,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[191929,191884],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[192109,191984],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":387,"address":[191993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[192013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[192044,192089],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[192153,192144],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":392,"address":[192192],"length":1,"stats":{"Line":0},"fn_name":"original_depth"},{"line":393,"address":[192201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[192219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[192240],"length":1,"stats":{"Line":0},"fn_name":"original_len"},{"line":397,"address":[192249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[192267],"length":1,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[193956,192288,192968],"length":1,"stats":{"Line":0},"fn_name":"fmt_expand"},{"line":406,"address":[192350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[192379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[192416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[192435],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[192452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[193453,193376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[193497,193417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[193347,193770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[192480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[192492,192547],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[192591,192790],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[192561,192851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[193286,193031],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[192764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[194000],"length":1,"stats":{"Line":0},"fn_name":"partial_cmp"},{"line":432,"address":[194076,194139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[194272],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":438,"address":[194294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[194454,194317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[194447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[194496],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":446,"address":[194819,194669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[194613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[194542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[194812],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[194864,194976,194925],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":468,"address":[196433,195008,196463],"length":1,"stats":{"Line":0},"fn_name":"eval"},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[195111,196220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[197526,195220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[197258,195291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[195352,197117],"length":1,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[196960,195454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[196803,195556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[196646,195658],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[195757,196495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[195856,196321,196456],"length":1,"stats":{"Line":0},"fn_name":null},{"line":487,"address":[195939,196271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[195987],"length":1,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[197889,197632],"length":1,"stats":{"Line":0},"fn_name":"depth"},{"line":492,"address":[197857,197723,197647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":494,"address":[198073,197936],"length":1,"stats":{"Line":0},"fn_name":"len"},{"line":495,"address":[198018,197948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[198112,198289],"length":1,"stats":{"Line":0},"fn_name":"is_empty"},{"line":498,"address":[198124,198197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[198336,198593],"length":1,"stats":{"Line":0},"fn_name":"original_depth"},{"line":501,"address":[198561,198351,198427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[198640,198777],"length":1,"stats":{"Line":0},"fn_name":"original_len"},{"line":504,"address":[198722,198652],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[198816],"length":1,"stats":{"Line":0},"fn_name":"children"},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[198845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[198885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":512,"address":[198922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[198941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":514,"address":[199002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[199063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[199124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[199185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[199243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[199300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[199312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":523,"address":[199344],"length":1,"stats":{"Line":0},"fn_name":"fmt_expand"},{"line":529,"address":[199404],"length":1,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[199412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[199598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[199650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[203830,199662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[199733],"length":1,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[199745,203672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[199787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[203214,199830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[199873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[199916,202752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[199959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[200002,202260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[200045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[200088,201768],"length":1,"stats":{"Line":0},"fn_name":null},{"line":544,"address":[200131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[200174,201276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[200217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[200260,200784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[200303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[200614,200315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[200358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[200556,200370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":553,"address":[200546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[204032],"length":1,"stats":{"Line":0},"fn_name":"expand"},{"line":556,"address":[204049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[204062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[204128],"length":1,"stats":{"Line":0},"fn_name":"simplified"},{"line":560,"address":[204152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[204204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":562,"address":[204192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[204272,204651],"length":1,"stats":{"Line":0},"fn_name":"simplify"},{"line":566,"address":[204300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[204305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[204587,204646,204308,204478,204362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[204503,204414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[204575,204619],"length":1,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[204688,206129,206273],"length":1,"stats":{"Line":0},"fn_name":"simplify_real"},{"line":575,"address":[204719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[204910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[204918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[204966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[211130,211178],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[211597,211720,211186,211339],"length":1,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[211243],"length":1,"stats":{"Line":0},"fn_name":null},{"line":582,"address":[211432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[211542],"length":1,"stats":{"Line":0},"fn_name":null},{"line":584,"address":[211981,211582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":585,"address":[211624],"length":1,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[211773],"length":1,"stats":{"Line":0},"fn_name":null},{"line":588,"address":[211927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[204992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[205040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[210271,210319],"length":1,"stats":{"Line":0},"fn_name":null},{"line":594,"address":[210825,210738,210327,210480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[210384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":596,"address":[210573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":597,"address":[210683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":598,"address":[210723,210977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[210765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[210864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":601,"address":[210848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[205066],"length":1,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[205114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[209268,209220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":607,"address":[209429,209687,209896,209276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":608,"address":[209333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[209522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[209632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[209672,210118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":612,"address":[209736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[209840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[209946],"length":1,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[210064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[205140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[205188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[207888,207936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[208365,208097,207944],"length":1,"stats":{"Line":0},"fn_name":null},{"line":624,"address":[208001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[208190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[208300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[208960,208692,208350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[208896,208758,208965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[208738,209054,209118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[209003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[209067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[208388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[208444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[208506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[208562,208616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[208636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[208600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[205214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[205262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[206392,206347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":647,"address":[206820,206553,206400,207429,206628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[206457],"length":1,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[206710],"length":1,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[207095],"length":1,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[207278,207143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[207475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[207646,207520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[207166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[207540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[206874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[206991,206930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[206620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":661,"address":[205288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[205336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":663,"address":[205652,205604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":664,"address":[205869,205660,205813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[205717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[205896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[206006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[206123,206062,206140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[205864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":672,"address":[205370],"length":1,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[212128,213144],"length":1,"stats":{"Line":0},"fn_name":"migrate"},{"line":677,"address":[212196],"length":1,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[212252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":679,"address":[212301,214313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[212369],"length":1,"stats":{"Line":0},"fn_name":null},{"line":681,"address":[214270,214210,214295,212390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":682,"address":[214263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[214288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":686,"address":[212408,214006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[212487,213800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[212566,213594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":689,"address":[212645,213388],"length":1,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[212724,213185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":691,"address":[212803,213178,212956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":692,"address":[212887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[212920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[214336],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":700,"address":[214382],"length":1,"stats":{"Line":0},"fn_name":null},{"line":701,"address":[214529,214679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[214447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[214672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":716,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":741,"address":[214976],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":743,"address":[214990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":747,"address":[215040,215432,215481],"length":1,"stats":{"Line":0},"fn_name":"define"},{"line":748,"address":[215396,215448,215094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[215175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":751,"address":[215336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":752,"address":[215256,215183],"length":1,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[215272],"length":1,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[215464,215516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":757,"address":[215806],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":449},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","day-25","src","lib.rs"],"content":"//! Advent of Code 2021: Day 25: Sea Cucumber\n//!\n//! [https://adventofcode.com/2021/day/25](https://adventofcode.com/2021/day/25)\n\nuse aoc_common::*;\n\npuzzle_info! {\n\tname = \"Sea Cucumber\";\n\tyear = 2021;\n\tday = 25;\n\tpart_one = |lines| logic::part_one (lines);\n}\n\nmod logic {\n\n\tuse super::*;\n\tuse model::Pos;\n\tuse model::Region;\n\tuse model::Seafloor;\n\tuse nums::IntConv;\n\n\tpub fn part_one (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003ci64\u003e {\n\t\tlet seafloor = Seafloor::parse (lines) ?;\n\t\tlet mut count = 0;\n\t\tlet mut prev_seafloor = seafloor;\n\t\tloop {\n\t\t\tlet next_seafloor = move_both (\u0026 prev_seafloor);\n\t\t\tcount += 1;\n\t\t\tif prev_seafloor == next_seafloor { break }\n\t\t\tprev_seafloor = next_seafloor;\n\t\t}\n\t\tOk (count)\n\t}\n\n\tpub fn move_both (seafloor: \u0026 Seafloor) -\u003e Seafloor {\n\t\tlet size = seafloor.size ();\n\t\tlet iter_row = |y|\n\t\t\titer::once (seafloor.get (Pos { y, x: size.x - 1 }))\n\t\t\t\t.chain (seafloor.values ()\n\t\t\t\t\t.skip (size.x.as_usize () * y.as_usize ())\n\t\t\t\t\t.take (size.x.as_usize ()))\n\t\t\t\t.chain (iter::once (seafloor.get (Pos { y, x: 0 })))\n\t\t\t\t.collect::\u003cVec \u003cRegion\u003e\u003e ();\n\t\tlet data =\n\t\t\titer::once (iter_row (size.y - 1))\n\t\t\t\t.chain ((0 .. size.y).map (iter_row))\n\t\t\t\t.chain (iter::once (iter_row (0)))\n\t\t\t\t.scan ((Rc::new (Vec::new ()), Rc::new (Vec::new ())),\n\t\t\t\t\tmove |rows, row| {\n\t\t\t\t\t\tlet row_0 = Rc::clone (\u0026 rows.0);\n\t\t\t\t\t\tlet row_1 = Rc::clone (\u0026 rows.1);\n\t\t\t\t\t\tlet row_2 = Rc::new (row);\n\t\t\t\t\t\t* rows = (Rc::clone (\u0026 row_1), Rc::clone (\u0026 row_2));\n\t\t\t\t\t\tif row_0.len () == 0 || row_1.len () == 0 {\n\t\t\t\t\t\t\treturn Some (Either::Left (iter::empty ()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSome (Either::Right (\n\t\t\t\t\t\t\t(0 .. size.x.as_usize ()).map (move |idx|\n\t\t\t\t\t\t\t\tcalc_one_region (\n\t\t\t\t\t\t\t\t\trow_0 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t\t\trow_1 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t\t\trow_2 [idx .. idx + 3].try_into ().unwrap (),\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t))\n\t\t\t\t\t})\n\t\t\t\t.flatten ()\n\t\t\t\t.collect::\u003cVec \u003c_\u003e\u003e ();\n\t\tSeafloor::new (size, data)\n\t}\n\n\tpub fn calc_one_region (\n\t\tabove: [Region; 3],\n\t\tlevel: [Region; 3],\n\t\tbelow: [Region; 3],\n\t) -\u003e Region {\n\t\tuse Region::{ Empty as X, East as E, South as S };\n\t\tmatch (above, level, below) {\n\t\t\t([_, _, _], [E, X, _], [_, _, _]) =\u003e E,\n\t\t\t([_, S, _], [_, E, X], [_, _, _]) =\u003e S,\n\t\t\t([_, _, _], [_, E, X], [_, _, _]) =\u003e X,\n\t\t\t([_, S, _], [_, X, _], [_, _, _]) =\u003e S,\n\t\t\t([_, _, _], [_, S, _], [_, E, X]) =\u003e X,\n\t\t\t([_, _, _], [_, S, _], [E, X, _]) =\u003e S,\n\t\t\t([_, _, _], [_, S, _], [_, X, _]) =\u003e X,\n\t\t\t([_, _, _], [_, h, _], [_, _, _]) =\u003e h,\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\n\t\tfn test_sequence \u003cStepFn: Fn (\u0026 Seafloor) -\u003e Seafloor\u003e (\n\t\t\tstep_fn: StepFn,\n\t\t\tseafloor_strs: \u0026 [\u0026 [\u0026 str]],\n\t\t) -\u003e GenResult \u003c()\u003e {\n\t\t\tlet mut seafloor = Seafloor::parse (seafloor_strs [0]) ?;\n\t\t\tlet count = |seafloor: \u0026 Seafloor, region|\n\t\t\t\tseafloor.iter ()\n\t\t\t\t\t.filter (|\u0026 (_, other_region)| region == other_region)\n\t\t\t\t\t.count ();\n\t\t\tlet num_east = count (\u0026 seafloor, Region::East);\n\t\t\tlet num_south = count (\u0026 seafloor, Region::South);\n\t\t\tfor expect_str in seafloor_strs.iter ().skip (1) {\n\t\t\t\tlet expect = Seafloor::parse (expect_str) ?;\n\t\t\t\tseafloor = step_fn (\u0026 seafloor);\n\t\t\t\tassert_eq! (expect, seafloor);\n\t\t\t\tassert_eq! (num_east, count (\u0026 seafloor, Region::East));\n\t\t\t\tassert_eq! (num_south, count (\u0026 seafloor, Region::South));\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_complex () -\u003e GenResult \u003c()\u003e {\n\t\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\t\u0026 [ \"v...\u003e\u003e.vv\u003e\", \".vv\u003e\u003e.vv..\", \"\u003e\u003e.\u003ev\u003e...v\", \"\u003e\u003ev\u003e\u003e.\u003e.v.\", \"v\u003ev.vv.v..\",\n\t\t\t\t\t\"\u003e.\u003e\u003e..v...\", \".vv..\u003e.\u003ev.\", \"v.v..\u003e\u003ev.v\", \"....v..v.\u003e\" ],\n\t\t\t\t\u0026 [ \"....\u003e.\u003ev.\u003e\", \"v.v\u003e.\u003ev.v.\", \"\u003ev\u003e\u003e..\u003ev..\", \"\u003e\u003ev\u003ev\u003e.\u003e.v\", \".\u003ev.v...v.\",\n\t\t\t\t\t\"v\u003e\u003e.\u003evvv..\", \"..v...\u003e\u003e..\", \"vv...\u003e\u003evv.\", \"\u003e.v.v..v.v\" ],\n\t\t\t])\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_east () -\u003e GenResult \u003c()\u003e {\n\t\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\t\u0026 [\"...\u003e\u003e\u003e\u003e\u003e...\"], \u0026 [\"...\u003e\u003e\u003e\u003e.\u003e..\"], \u0026 [\"...\u003e\u003e\u003e.\u003e.\u003e.\"], \u0026 [\"...\u003e\u003e.\u003e.\u003e.\u003e\"],\n\t\t\t])\n\t\t}\n\n\t\t#[ test ]\n\t\tfn test_both () -\u003e GenResult \u003c()\u003e {\n\t\t\ttest_sequence (move_both, \u0026 [\n\t\t\t\t\u0026 [\"..........\", \".\u003ev....v..\", \".......\u003e..\", \"..........\"],\n\t\t\t\t\u0026 [\"..........\", \".\u003e........\", \"..v....v\u003e.\", \"..........\"],\n\t\t\t\t\u0026 [\"..........\", \"..\u003e.......\", \".........\u003e\", \"..v....v..\"],\n\t\t\t])\n\t\t}\n\n\t}\n\n}\n\nmod model {\n\n\tuse super::*;\n\tuse bitvec::BitVecNative;\n\tuse grid::Grid;\n\tuse nums::IntConv;\n\tuse pos::PosYX;\n\n\tpub type Pos = PosYX \u003cCoord\u003e;\n\tpub type Coord = u16;\n\tpub type GridInner = Vec \u003cRegion\u003e;\n\n\t#[ derive (Clone, Eq, PartialEq) ]\n\tpub struct Seafloor {\n\t\tgrid: Grid \u003cGridInner, Pos\u003e,\n\t\tsize: Pos,\n\t}\n\n\timpl Seafloor {\n\t\tpub fn new (size: Pos, regions: GridInner) -\u003e Seafloor {\n\t\t\tlet grid_size = [size.y.as_usize (), size.x.as_usize ()];\n\t\t\tlet grid = Grid::wrap (regions, [0, 0], grid_size);\n\t\t\tSeafloor { grid, size }\n\t\t}\n\t\tpub fn size (\u0026 self) -\u003e Pos { self.size }\n\t\tpub fn parse (lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cSeafloor\u003e {\n\t\t\tif lines.is_empty () { Err (format! (\"Invalid input\")) ? }\n\t\t\tlet size = Pos { y: lines.len ().as_u16 (), x: lines [0].chars ().count ().as_u16 () };\n\t\t\tlet data = lines.iter ().enumerate ()\n\t\t\t\t.flat_map (|(line_idx, line)| {\n\t\t\t\t\tlet line_err = move || format! (\"Invalid input: {}: {}\", line_idx, line);\n\t\t\t\t\tline.chars ().map::\u003cResult \u003c_, String\u003e, _\u003e (move |letter|\n\t\t\t\t\t\tOk (match letter {\n\t\t\t\t\t\t\t'.' =\u003e Region::Empty,\n\t\t\t\t\t\t\t'\u003e' =\u003e Region::East,\n\t\t\t\t\t\t\t'v' =\u003e Region::South,\n\t\t\t\t\t\t\t_ =\u003e Err (line_err ()) ?,\n\t\t\t\t\t\t}),\n\t\t\t\t\t)\n\t\t\t\t}).collect::\u003cResult \u003c_, _\u003e\u003e () ?;\n\t\t\tlet grid_size = [size.y.as_usize (), size.x.as_usize ()];\n\t\t\tlet grid = Grid::wrap (data, [0, 0], grid_size);\n\t\t\tOk (Seafloor { grid, size })\n\t\t}\n\t\tpub fn get (\u0026 self, pos: Pos) -\u003e Region {\n\t\t\tself.grid.get (pos).unwrap ()\n\t\t}\n\t\tpub fn iter (\u0026 self) -\u003e impl Iterator \u003cItem = (Pos, Region)\u003e + '_ {\n\t\t\tself.grid.iter ()\n\t\t}\n\t\tpub fn values (\u0026 self) -\u003e impl Iterator \u003cItem = Region\u003e + '_ {\n\t\t\tself.grid.values ()\n\t\t}\n\t}\n\n\timpl fmt::Debug for Seafloor {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"Seafloor {{ {:?}, \", self.size) ?;\n\t\t\tfor (pos, region) in self.iter () {\n\t\t\t\tif pos.x == 0 \u0026\u0026 pos.y \u003e 0 { write! (formatter, \", \") ?; }\n\t\t\t\tif pos.x == 0 { write! (formatter, \"\\\"\") ?; }\n\t\t\t\twrite! (formatter, \"{}\", region) ?;\n\t\t\t\tif pos.x + 1 == self.size.x { write! (formatter, \"\\\"\") ?; }\n\t\t\t}\n\t\t\twrite! (formatter, \" }}\") ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\t#[ derive (Clone, Copy, Debug, Eq, PartialEq) ]\n\tpub enum Region {\n\t\tEmpty,\n\t\tEast,\n\t\tSouth,\n\t}\n\n\timpl BitVecNative for Region {\n\t\tconst BITS: u32 = 2;\n\t\tfn encode (self) -\u003e usize {\n\t\t\tmatch self {\n\t\t\t\tRegion::Empty =\u003e 0x0,\n\t\t\t\tRegion::East =\u003e 0x1,\n\t\t\t\tRegion::South =\u003e 0x2,\n\t\t\t}\n\t\t}\n\t\tfn decode (encoded: usize) -\u003e Region {\n\t\t\tmatch encoded {\n\t\t\t\t0 =\u003e Region::Empty,\n\t\t\t\t1 =\u003e Region::East,\n\t\t\t\t2 =\u003e Region::South,\n\t\t\t\t_ =\u003e panic! (\"Invalid encoded value for Region: {:#x}\", encoded),\n\t\t\t}\n\t\t}\n\t}\n\n\timpl Display for Region {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"{}\", match * self {\n\t\t\t\tRegion::Empty =\u003e '.',\n\t\t\t\tRegion::East =\u003e '\u003e',\n\t\t\t\tRegion::South =\u003e 'v',\n\t\t\t})\n\t\t}\n\t}\n\n}\n\n#[ cfg (test) ]\nmod examples {\n\n\tuse super::*;\n\n\tconst EXAMPLE_0: \u0026 [\u0026 str] = \u0026 [\n\t\t\"v...\u003e\u003e.vv\u003e\", \".vv\u003e\u003e.vv..\", \"\u003e\u003e.\u003ev\u003e...v\", \"\u003e\u003ev\u003e\u003e.\u003e.v.\", \"v\u003ev.vv.v..\", \"\u003e.\u003e\u003e..v...\",\n\t\t\".vv..\u003e.\u003ev.\", \"v.v..\u003e\u003ev.v\", \"....v..v.\u003e\",\n\t];\n\n\t#[ test ]\n\tfn part_one () -\u003e GenResult \u003c()\u003e {\n\t\tassert_eq! (58, logic::part_one (EXAMPLE_0) ?);\n\t\tOk (())\n\t}\n\n}\n","traces":[{"line":7,"address":[65977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[66062],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[108656,109452],"length":1,"stats":{"Line":1},"fn_name":"part_one"},{"line":23,"address":[108689,108860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":24,"address":[108810],"length":1,"stats":{"Line":1},"fn_name":null},{"line":25,"address":[108822],"length":1,"stats":{"Line":1},"fn_name":null},{"line":26,"address":[108853,109429],"length":1,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[108935,108982],"length":1,"stats":{"Line":2},"fn_name":null},{"line":28,"address":[108990,109053],"length":1,"stats":{"Line":1},"fn_name":null},{"line":29,"address":[109130,109042],"length":1,"stats":{"Line":2},"fn_name":null},{"line":30,"address":[109342,109136],"length":1,"stats":{"Line":1},"fn_name":null},{"line":32,"address":[109254],"length":1,"stats":{"Line":1},"fn_name":null},{"line":35,"address":[109921,109951,109504],"length":1,"stats":{"Line":1},"fn_name":"move_both"},{"line":36,"address":[109542],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[103376,103907],"length":1,"stats":{"Line":4},"fn_name":"{closure#0}"},{"line":38,"address":[103866,103763,103422],"length":1,"stats":{"Line":4},"fn_name":null},{"line":39,"address":[103738,103565,103665],"length":1,"stats":{"Line":3},"fn_name":null},{"line":40,"address":[103588,103680],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[103715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[103797],"length":1,"stats":{"Line":2},"fn_name":null},{"line":44,"address":[110357,110395,109828,109605,110019,110293],"length":1,"stats":{"Line":11},"fn_name":null},{"line":46,"address":[109944,109867,109726],"length":1,"stats":{"Line":4},"fn_name":null},{"line":47,"address":[109883,110097,109962,110058],"length":1,"stats":{"Line":4},"fn_name":null},{"line":48,"address":[110082,110156],"length":1,"stats":{"Line":4},"fn_name":null},{"line":49,"address":[104454,104932,105217,103920],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":50,"address":[103976,104079],"length":1,"stats":{"Line":4},"fn_name":null},{"line":51,"address":[104156,104092],"length":1,"stats":{"Line":4},"fn_name":null},{"line":52,"address":[104269,104172],"length":1,"stats":{"Line":4},"fn_name":null},{"line":53,"address":[104470,104348,104293],"length":1,"stats":{"Line":4},"fn_name":null},{"line":54,"address":[104614,104725],"length":1,"stats":{"Line":4},"fn_name":null},{"line":55,"address":[104794],"length":1,"stats":{"Line":2},"fn_name":null},{"line":57,"address":[105072],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[104773,106334,104944,105248],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":59,"address":[106258],"length":1,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[105281,105333],"length":1,"stats":{"Line":4},"fn_name":null},{"line":61,"address":[105662,105605],"length":1,"stats":{"Line":4},"fn_name":null},{"line":62,"address":[105934,105991],"length":1,"stats":{"Line":4},"fn_name":null},{"line":69,"address":[110415],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[110496],"length":1,"stats":{"Line":2},"fn_name":"calc_one_region"},{"line":78,"address":[110759,110606,110822,110890],"length":1,"stats":{"Line":5},"fn_name":null},{"line":79,"address":[110749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":80,"address":[110813],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[110942],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[110949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[110914],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[110928],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[110935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[110876,110820],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[64203,64187,62128],"length":1,"stats":{"Line":1},"fn_name":"test_sequence\u003cfn(\u0026aoc_2021_day_25::model::Seafloor) -\u003e aoc_2021_day_25::model::Seafloor\u003e"},{"line":99,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":117,"address":[64400,64409],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":118,"address":[49348],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[49392],"length":1,"stats":{"Line":3},"fn_name":"test_east"},{"line":128,"address":[49396],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[49440],"length":1,"stats":{"Line":3},"fn_name":"test_both"},{"line":135,"address":[49444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[98864,99229,99256],"length":1,"stats":{"Line":2},"fn_name":"new"},{"line":166,"address":[98918,98999],"length":1,"stats":{"Line":4},"fn_name":null},{"line":167,"address":[99043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":170,"address":[99280,99285],"length":1,"stats":{"Line":2},"fn_name":"size"},{"line":171,"address":[99296,100603,100633],"length":1,"stats":{"Line":2},"fn_name":"parse"},{"line":172,"address":[99355,99404],"length":1,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[99741,99388],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[99883,100204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[107968,107996,108095],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":176,"address":[108112,108150,108009],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":177,"address":[108648,108019,108304,108618],"length":1,"stats":{"Line":6},"fn_name":"{closure#1}"},{"line":178,"address":[108345,108638],"length":1,"stats":{"Line":4},"fn_name":null},{"line":179,"address":[108391],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[108401],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[108411],"length":1,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[108421,108379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[100108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[100278,100076],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[100328],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[100447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":190,"address":[100656],"length":1,"stats":{"Line":1},"fn_name":"get"},{"line":191,"address":[100681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[100736],"length":1,"stats":{"Line":1},"fn_name":"iter"},{"line":194,"address":[100753],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[100768],"length":1,"stats":{"Line":1},"fn_name":"values"},{"line":197,"address":[100777],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[100816],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":203,"address":[101010,100849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[101046,101222,100995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[101345,101278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[101544,101475,101330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[101642,101787,101514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[101821,101769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[102001,101180,102075],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[102065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[102112],"length":1,"stats":{"Line":0},"fn_name":"encode"},{"line":225,"address":[102123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[102155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[102166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[102177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[102208],"length":1,"stats":{"Line":0},"fn_name":"decode"},{"line":232,"address":[102217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[102282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[102289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[102296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[102260,102313],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[102416],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":243,"address":[102501,102441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[102473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[102483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[102493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[28336,28345],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":265,"address":[41302,41063],"length":1,"stats":{"Line":1},"fn_name":null},{"line":266,"address":[41282],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":93,"coverable":122},{"path":["/","home","runner","work","advent-of-code","advent-of-code","2021","src","lib.rs"],"content":"use aoc_common::*;\n\npub use aoc_2021_day_01 as day_01;\npub use aoc_2021_day_02 as day_02;\npub use aoc_2021_day_03 as day_03;\npub use aoc_2021_day_04 as day_04;\npub use aoc_2021_day_05 as day_05;\npub use aoc_2021_day_06 as day_06;\npub use aoc_2021_day_07 as day_07;\npub use aoc_2021_day_08 as day_08;\npub use aoc_2021_day_09 as day_09;\npub use aoc_2021_day_10 as day_10;\npub use aoc_2021_day_11 as day_11;\npub use aoc_2021_day_12 as day_12;\npub use aoc_2021_day_13 as day_13;\npub use aoc_2021_day_14 as day_14;\npub use aoc_2021_day_15 as day_15;\npub use aoc_2021_day_16 as day_16;\npub use aoc_2021_day_17 as day_17;\npub use aoc_2021_day_18 as day_18;\npub use aoc_2021_day_19 as day_19;\npub use aoc_2021_day_20 as day_20;\npub use aoc_2021_day_21 as day_21;\npub use aoc_2021_day_22 as day_22;\npub use aoc_2021_day_23 as day_23;\npub use aoc_2021_day_24 as day_24;\npub use aoc_2021_day_25 as day_25;\n\npub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\n\tvec! [\n\t\tday_01::puzzle_metadata (),\n\t\tday_02::puzzle_metadata (),\n\t\tday_03::puzzle_metadata (),\n\t\tday_04::puzzle_metadata (),\n\t\tday_05::puzzle_metadata (),\n\t\tday_06::puzzle_metadata (),\n\t\tday_07::puzzle_metadata (),\n\t\tday_08::puzzle_metadata (),\n\t\tday_09::puzzle_metadata (),\n\t\tday_10::puzzle_metadata (),\n\t\tday_11::puzzle_metadata (),\n\t\tday_12::puzzle_metadata (),\n\t\tday_13::puzzle_metadata (),\n\t\tday_14::puzzle_metadata (),\n\t\tday_15::puzzle_metadata (),\n\t\tday_16::puzzle_metadata (),\n\t\tday_17::puzzle_metadata (),\n\t\tday_18::puzzle_metadata (),\n\t\tday_19::puzzle_metadata (),\n\t\tday_20::puzzle_metadata (),\n\t\tday_21::puzzle_metadata (),\n\t\tday_22::puzzle_metadata (),\n\t\tday_23::puzzle_metadata (),\n\t\tday_24::puzzle_metadata (),\n\t\tday_25::puzzle_metadata (),\n\t]\n}\n","traces":[{"line":29,"address":[11616,14789],"length":1,"stats":{"Line":0},"fn_name":"puzzle_metadata"},{"line":30,"address":[12408,11713,12208,13308,12908,13208,13936,13405,12308,14024,13008,12008,11639,13672,12808,12508,12108,13496,13848,13584,12608,11808,12708,11908,13108,13760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[11678,11765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[11865,11781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[11881,11965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[12065,11981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[12165,12081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[12181,12265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[12281,12365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[9249,9329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[9425,9345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[9521,9441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[9617,9537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[9713,9633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[12881,12965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[12981,13065],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[13165,13081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[10017,10097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[13365,13281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[10209,10283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[10299,10367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[10383,10451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[10467,10535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[10619,10551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[10703,10635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[10719,10787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[10803],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":27},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","bithash.rs"],"content":"use super::*;\nuse nums::IntConv;\n\npub struct BitHasher \u003cBldHsh: BuildHasher, const LEN: usize, const BITS: usize\u003e {\n\tdata: [u64; LEN],\n\thash_builder: BldHsh,\n}\n\nimpl \u003cBldHsh: BuildHasher, const LEN: usize, const BITS: usize\u003e BitHasher \u003cBldHsh, LEN, BITS\u003e {\n\tpub fn new_with_hasher (hash_builder: BldHsh) -\u003e BitHasher \u003cBldHsh, LEN, BITS\u003e {\n\t\tBitHasher { data: [0; LEN], hash_builder }\n\t}\n\tpub fn update \u003cVal: Hash\u003e (\u0026 mut self, val: Val) -\u003e \u0026 mut Self {\n\t\tlet mut hasher = self.hash_builder.build_hasher ();\n\t\tval.hash (\u0026 mut hasher);\n\t\tlet mut hash = hasher.finish ();\n\t\tfor _ in 0 .. BITS {\n\t\t\tlet bit = 1 \u003c\u003c (hash \u0026 0x3f);\n\t\t\thash \u003e\u003e= 6;\n\t\t\tlet idx = (hash % LEN.to_u64 ().unwrap ()).to_usize ().unwrap ();\n\t\t\thash /= LEN.to_u64 ().unwrap ();\n\t\t\tself.data [idx] |= bit;\n\t\t}\n\t\tself\n\t}\n\tpub fn finish (\u0026 self) -\u003e BitHash \u003cLEN\u003e {\n\t\tBitHash { data: self.data }\n\t}\n}\n\n#[ derive (Clone, Copy) ]\npub struct BitHash \u003cconst LEN: usize\u003e {\n\tdata: [u64; LEN],\n}\n\nimpl \u003cconst LEN: usize\u003e BitHash \u003cLEN\u003e {\n\tpub fn zero () -\u003e Self {\n\t\tBitHash { data: [0; LEN] }\n\t}\n\tpub fn bits (\u0026 self) -\u003e usize {\n\t\tlet mut sum = 0;\n\t\tfor idx in 0 .. LEN { sum += self.data [idx].count_ones ().to_usize ().unwrap (); }\n\t\tsum\n\t}\n\tpub fn reduce \u003cconst OTHER_LEN: usize\u003e (\u0026 self) -\u003e BitHash \u003cOTHER_LEN\u003e {\n\t\tif LEN \u003c OTHER_LEN { panic! () }\n\t\tlet mut data = [0; OTHER_LEN];\n\t\tfor idx in 0 .. LEN { data [idx % OTHER_LEN] |= self.data [idx]; }\n\t\tBitHash { data }\n\t}\n\tpub fn is_zero (\u0026 self) -\u003e bool {\n\t\tfor idx in 0 .. LEN { if self.data [idx] != 0 { return false } }\n\t\ttrue\n\t}\n}\n\nimpl \u003cconst LEN: usize\u003e fmt::Display for BitHash \u003cLEN\u003e {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tfor idx in 0 .. LEN {\n\t\t\twrite! (formatter, \"{:064b}\", self.data [idx]) ?;\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl \u003cconst LEN: usize\u003e ops::BitAnd for BitHash \u003cLEN\u003e {\n\ttype Output = BitHash \u003cLEN\u003e;\n\tfn bitand (mut self, other: Self) -\u003e Self {\n\t\tfor idx in 0 .. LEN { self.data [idx] \u0026= other.data [idx]; }\n\t\tself\n\t}\n}\n\nimpl \u003cconst LEN: usize\u003e ops::Not for BitHash \u003cLEN\u003e {\n\ttype Output = BitHash \u003cLEN\u003e;\n\tfn not (mut self) -\u003e Self {\n\t\tfor idx in 0 .. LEN { self.data [idx] = ! self.data [idx]; }\n\t\tself\n\t}\n}\n\npub trait IteratorBitHash : Iterator {\n\tfn bit_hash \u003cBldHsh, const LEN: usize, const BITS: usize\u003e (self, hash_builder: BldHsh) -\u003e BitHash \u003cLEN\u003e\n\t\t\twhere BldHsh: BuildHasher, Self: Sized, Self::Item: Hash {\n\t\tlet mut hasher = BitHasher::\u003cBldHsh, LEN, BITS\u003e::new_with_hasher (hash_builder);\n\t\tfor item in self { hasher.update (\u0026 item); }\n\t\thasher.finish ()\n\t}\n}\n\nimpl \u003cSomeIter, SomeItem\u003e IteratorBitHash for SomeIter\n\twhere\n\t\tSomeIter: Iterator \u003cItem = SomeItem\u003e + Sized,\n\t\tSomeItem: Hash {\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":41},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","bitvec.rs"],"content":"use super::*;\nuse nums::IntConv;\n\n#[ derive (Debug, Clone, Eq, PartialEq) ]\npub struct BitVec \u003cItem, Encoding = BitVecEncodingDefault\u003e {\n\tlen: usize,\n\twords: Vec \u003cusize\u003e,\n\tphantom: PhantomData \u003c(Item, Encoding)\u003e,\n}\n\nimpl \u003cItem, Encoding\u003e BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\tpub fn new () -\u003e Self {\n\t\tdebug_assert! (Encoding::BITS \u003c usize::BITS);\n\t\tdebug_assert! (Encoding::MASK == (1 \u003c\u003c Encoding::BITS) - 1);\n\t\tBitVec {\n\t\t\twords: Vec::new (),\n\t\t\tlen: 0,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\tpub fn len (\u0026 self) -\u003e usize { self.len }\n\tpub fn is_empty (\u0026 self) -\u003e bool { self.len == 0 }\n\tpub fn push (\u0026 mut self, item: Item) {\n\t\tlet mut item_enc = Encoding::encode (item);\n\t\tdebug_assert! (item_enc \u0026 ! Encoding::MASK == 0);\n\t\tlet mut item_bits = Encoding::BITS;\n\t\tlet mut word_idx = self.len * Encoding::BITS.as_usize () / usize::BITS.as_usize ();\n\t\tlet mut bit_idx = (self.len * Encoding::BITS.as_usize () % usize::BITS.as_usize ()).as_u32 ();\n\t\twhile item_bits \u003e 0 {\n\t\t\tlet word_bits = cmp::min (item_bits, usize::BITS - bit_idx);\n\t\t\tlet word_mask = (1 \u003c\u003c word_bits) - 1;\n\t\t\tlet mut word_val = if word_idx \u003c self.words.len () {\n\t\t\t\tself.words [word_idx]\n\t\t\t} else { 0 };\n\t\t\tword_val |= (item_enc \u0026 word_mask) \u003c\u003c bit_idx;\n\t\t\tif word_idx \u003c self.words.len () {\n\t\t\t\tself.words [word_idx] = word_val;\n\t\t\t} else {\n\t\t\t\tself.words.push (word_val);\n\t\t\t}\n\t\t\titem_enc \u003e\u003e= word_bits;\n\t\t\titem_bits -= word_bits;\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t\tself.len += 1;\n\t}\n\tpub fn get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e {\n\t\tif self.len \u003c idx + 1 { return None }\n\t\tlet mut item_enc = 0;\n\t\tlet mut item_bits = 0;\n\t\tlet mut word_idx = idx * Encoding::BITS.as_usize () / usize::BITS.as_usize ();\n\t\tlet mut bit_idx = (idx * Encoding::BITS.as_usize () % usize::BITS.as_usize ()).as_u32 ();\n\t\twhile item_bits \u003c Encoding::BITS {\n\t\t\tlet word_bits = cmp::min (Encoding::BITS - item_bits, usize::BITS - bit_idx);\n\t\t\tlet word_mask = (1 \u003c\u003c word_bits) - 1;\n\t\t\tlet word_val = self.words [word_idx];\n\t\t\titem_enc |= ((word_val \u003e\u003e bit_idx) \u0026 word_mask) \u003c\u003c item_bits;\n\t\t\titem_bits += word_bits;\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t\tSome (Encoding::decode (item_enc))\n\t}\n\tpub fn set (\u0026 mut self, idx: usize, item: Item) {\n\t\tif self.len \u003c idx + 1 { panic! (\"Tried to set {} but len is {}\", idx, self.len) }\n\t\tlet mut item_enc = Encoding::encode (item);\n\t\tlet mut item_bits = Encoding::BITS;\n\t\tlet mut word_idx = idx * Encoding::BITS.as_usize () / usize::BITS.as_usize ();\n\t\tlet mut bit_idx = (idx * Encoding::BITS.as_usize () % usize::BITS.as_usize ()).as_u32 ();\n\t\twhile item_bits \u003e 0 {\n\t\t\tlet word_bits = cmp::min (item_bits, usize::BITS - bit_idx);\n\t\t\tlet word_mask = (1 \u003c\u003c word_bits) - 1;\n\t\t\tlet mut word_val = self.words [word_idx];\n\t\t\tword_val |= (item_enc \u0026 word_mask) \u003c\u003c bit_idx;\n\t\t\tself.words [word_idx] = word_val;\n\t\t\titem_enc \u003e\u003e= word_bits;\n\t\t\titem_bits -= word_bits;\n\t\t\tword_idx += 1;\n\t\t\tbit_idx = 0;\n\t\t}\n\t}\n\tpub fn iter (\u0026 self) -\u003e BitVecIter \u003cItem, Encoding\u003e {\n\t\tBitVecIter {\n\t\t\twords: self.words.as_slice (),\n\t\t\tlen: self.len,\n\t\t\tword_val: 0,\n\t\t\tword_bits: 0,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n}\n\nimpl \u003cItem, Encoding\u003e FromIterator \u003cItem\u003e for BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\tfn from_iter \u003cIter: IntoIterator \u003cItem = Item\u003e\u003e (iter: Iter) -\u003e BitVec \u003cItem, Encoding\u003e {\n\t\tlet mut bitvec = BitVec::new ();\n\t\tfor item in iter.into_iter () {\n\t\t\tbitvec.push (item);\n\t\t}\n\t\tbitvec\n\t}\n}\n\n#[ derive (Clone) ]\npub struct BitVecIter \u003c'a, Item, Encoding = BitVecEncodingDefault\u003e {\n\twords: \u0026 'a [usize],\n\tlen: usize,\n\tword_val: usize,\n\tword_bits: u32,\n\tphantom: PhantomData \u003c(Item, Encoding)\u003e,\n}\n\nimpl \u003c'a, Item, Encoding\u003e Iterator for BitVecIter \u003c'a, Item, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\ttype Item = Item;\n\tfn next (\u0026 mut self) -\u003e Option \u003cItem\u003e {\n\t\tif self.len == 0 { return None }\n\t\tlet mut item_enc = 0;\n\t\tlet mut item_bits = 0;\n\t\twhile item_bits \u003c Encoding::BITS {\n\t\t\tlet word_bits = cmp::min (Encoding::BITS - item_bits, self.word_bits);\n\t\t\titem_enc |= (self.word_val \u0026 ((1 \u003c\u003c word_bits) - 1)) \u003c\u003c item_bits;\n\t\t\tself.word_val \u003e\u003e= word_bits;\n\t\t\tself.word_bits -= word_bits;\n\t\t\titem_bits += word_bits;\n\t\t\tif self.word_bits == 0 {\n\t\t\t\tself.word_val = self.words [0];\n\t\t\t\tself.word_bits = usize::BITS;\n\t\t\t\tself.words = \u0026 self.words [1 .. ];\n\t\t\t}\n\t\t}\n\t\tself.len -= 1;\n\t\tSome (Encoding::decode (item_enc))\n\t}\n\tfn nth (\u0026 mut self, num: usize) -\u003e Option \u003cItem\u003e {\n\t\tlet mut adv_bits = Encoding::BITS.as_usize () * num;\n\t\tlet adv_words =\n\t\t\t(usize::BITS.as_usize () - self.word_bits.as_usize () + adv_bits)\n\t\t\t\t/ usize::BITS.as_usize ();\n\t\tif adv_words \u003e 0 {\n\t\t\tself.word_val = self.words [adv_words - 1];\n\t\t\tself.words = \u0026 self.words [adv_words .. ];\n\t\t\tadv_bits -= (adv_words - 1) * usize::BITS.as_usize ();\n\t\t\tself.word_bits = usize::BITS;\n\t\t}\n\t\tdebug_assert! (adv_bits \u003c= self.word_bits.as_usize ());\n\t\tself.word_bits -= adv_bits.as_u32 ();\n\t\tself.word_val \u003e\u003e= adv_bits;\n\t\tself.len -= num;\n\t\tself.next ()\n\t}\n\tfn count (self) -\u003e usize {\n\t\tself.len\n\t}\n}\n\npub trait BitVecEncoding \u003cItem\u003e {\n\tconst BITS: u32;\n\tconst MASK: usize = (1 \u003c\u003c Self::BITS) - 1;\n\tfn encode (item: Item) -\u003e usize;\n\tfn decode (bits: usize) -\u003e Item;\n}\n\npub trait BitVecNative {\n\tconst BITS: u32;\n\tfn encode (self) -\u003e usize;\n\tfn decode (encoded: usize) -\u003e Self;\n}\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct BitVecEncodingDefault;\n\nimpl \u003cItem\u003e BitVecEncoding \u003cItem\u003e for BitVecEncodingDefault where Item: BitVecNative {\n\tconst BITS: u32 = Item::BITS;\n\tconst MASK: usize = (1 \u003c\u003c Item::BITS) - 1;\n\tfn encode (item: Item) -\u003e usize { Item::encode (item) }\n\tfn decode (bits: usize) -\u003e Item { Item::decode (bits) }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":97},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","grid.rs"],"content":"use super::*;\n\nuse bitvec::BitVec;\nuse bitvec::BitVecEncoding;\nuse bitvec::BitVecIter;\nuse nums::Int;\nuse pos::PosYX;\n\n/// Multi dimensional abstraction over a single dimensional collection\n///\n/// This allows a simple one-dimensional collection to be accessed in a multi-dimensional way. It\n/// wraps a backing collection which implements [`GridStorage`], and takes indexes which implement\n/// [`GridPos`].\n\n#[ derive (Clone, Debug, Eq, PartialEq) ]\npub struct Grid \u003cStorage, Pos, const DIMS: usize = 2\u003e {\n\tstorage: Storage,\n\torigin: [isize; DIMS],\n\tsize: [usize; DIMS],\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e Grid \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorage + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\tpub fn wrap (\n\t\tstorage: Storage,\n\t\torigin: [isize; DIMS],\n\t\tsize: [usize; DIMS],\n\t) -\u003e Grid \u003cStorage, Pos, DIMS\u003e {\n\t\tif size.into_iter ().any (|dim| dim == 0 ) {\n\t\t\tpanic! (\"Size must be positive in all dimensions: {:?}\", size);\n\t\t}\n\t\tlet expected_len = size.into_iter ().product::\u003cusize\u003e ();\n\t\tlet actual_len = storage.storage_len ();\n\t\tif expected_len != actual_len {\n\t\t\tpanic! (\"Expected {} items but was passed {}\", expected_len, actual_len);\n\t\t}\n\t\tGrid { storage, origin, size, phantom: PhantomData }\n\t}\n\n\tpub fn len (\u0026 self) -\u003e usize { self.size.into_iter ().product () }\n\tpub fn is_empty (\u0026 self) -\u003e bool { self.size.into_iter ().any (|dim| dim == 0) }\n\tpub fn size (\u0026 self) -\u003e [usize; DIMS] { self.size }\n\n\tpub fn raw_origin (\u0026 self) -\u003e [isize; DIMS] { self.origin }\n\tpub fn raw_size (\u0026 self) -\u003e [usize; DIMS] { self.size }\n\tpub fn origin (\u0026 self) -\u003e Pos { Pos::from_scalar (0, self.origin, self.size).unwrap () }\n\tpub fn peak (\u0026 self) -\u003e Pos { Pos::from_scalar (self.len () - 1, self.origin, self.size).unwrap () }\n\n\tpub fn get (\u0026 self, pos: Pos) -\u003e Option \u003cStorage::Item\u003e {\n\t\tPos::to_scalar (\u0026 pos, self.origin, self.size)\n\t\t\t.and_then (|index| self.storage.storage_get (index))\n\t}\n\n\tpub fn set (\u0026 mut self, pos: Pos, item: Storage::Item) {\n\t\tself.storage.storage_set (\n\t\t\tPos::to_scalar (\u0026 pos, self.origin, self.size).unwrap (),\n\t\t\titem);\n\t}\n\n\tpub fn iter \u003c'a\u003e (\u0026 'a self) -\u003e GridIter \u003c\u003c\u0026 'a Storage as GridStorageIntoIter\u003e::Iter, Pos, DIMS\u003e\n\t\t\twhere \u0026 'a Storage: GridStorageIntoIter {\n\t\tGridIter {\n\t\t\tstorage: (\u0026 self.storage).storage_iter (),\n\t\t\tidx: 0,\n\t\t\torigin: self.origin,\n\t\t\tsize: self.size,\n\t\t\tphantom: PhantomData,\n\t\t}\n\t}\n\n\tpub fn values \u003c'a\u003e (\u0026 'a self) -\u003e \u003c\u0026 'a Storage as GridStorageIntoIter\u003e::Iter\n\t\t\twhere \u0026 'a Storage: GridStorageIntoIter {\n\t\t(\u0026 self.storage).storage_iter ()\n\t}\n\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e Grid \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: GridStorageMut + Clone,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\n\tpub fn get_ref (\u0026 self, pos: Pos) -\u003e Option \u003c\u0026 Storage::Item\u003e {\n\t\tPos::to_scalar (\u0026 pos, self.origin, self.size)\n\t\t\t.and_then (|index| self.storage.storage_ref (index))\n\t}\n\n\tpub fn get_mut (\u0026 mut self, pos: Pos) -\u003e Option \u003c\u0026 mut Storage::Item\u003e {\n\t\tPos::to_scalar (\u0026 pos, self.origin, self.size)\n\t\t\t.and_then (|index| self.storage.storage_mut (index))\n\t}\n\n}\n\n/// Iterator returned by [`Grid::iter`].\n///\n/// This iterator wraps the iterator from an implementation of [`GridStorage`] and maps from `Item`\n/// to `([GridPos], Item)`.\n\npub struct GridIter \u003cStorage, Pos, const DIMS: usize\u003e {\n\tstorage: Storage,\n\tidx: usize,\n\torigin: [isize; DIMS],\n\tsize: [usize; DIMS],\n\tphantom: PhantomData \u003cPos\u003e,\n}\n\nimpl \u003cStorage, Pos, const DIMS: usize\u003e Iterator for GridIter \u003cStorage, Pos, DIMS\u003e\n\twhere\n\t\tStorage: Iterator,\n\t\tPos: GridPos \u003cDIMS\u003e {\n\ttype Item = (Pos, Storage::Item);\n\tfn next (\u0026 mut self) -\u003e Option \u003c(Pos, Storage::Item)\u003e {\n\t\tif let Some (item) = self.storage.next () {\n\t\t\tlet idx = self.idx;\n\t\t\tself.idx += 1;\n\t\t\tSome ((Pos::from_scalar (idx, self.origin, self.size).unwrap (), item))\n\t\t} else { None }\n\t}\n\tfn nth (\u0026 mut self, num: usize) -\u003e Option \u003c(Pos, Storage::Item)\u003e {\n\t\tif let Some (item) = self.storage.nth (num) {\n\t\t\tlet idx = self.idx;\n\t\t\tself.idx += num + 1;\n\t\t\tSome ((Pos::from_scalar (idx, self.origin, self.size).unwrap (), item))\n\t\t} else { None }\n\t}\n}\n\n/// Trait for backing stores for a [`Grid`]\n///\n/// This provides a simple abstraction over a fixed size array of items. It is implemented for\n/// [`Vec`] and [`BitVec`].\n\npub trait GridStorage {\n\ttype Item;\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cSelf::Item\u003e;\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item);\n\tfn storage_len (\u0026 self) -\u003e usize;\n}\n\nimpl \u003cItem\u003e GridStorage for Vec \u003cItem\u003e where Item: Clone {\n\ttype Item = Item;\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e { self.get (idx).cloned () }\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item) { self [idx] = item; }\n\tfn storage_len (\u0026 self) -\u003e usize { self.len () }\n}\n\nimpl \u003cItem, Encoding\u003e GridStorage for BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\ttype Item = Item;\n\tfn storage_get (\u0026 self, idx: usize) -\u003e Option \u003cItem\u003e { self.get (idx) }\n\tfn storage_set (\u0026 mut self, idx: usize, item: Self::Item) { self.set (idx, item); }\n\tfn storage_len (\u0026 self) -\u003e usize { self.len () }\n}\n\n/// Additional trait for backing stores which which can provide references to items\n\npub trait GridStorageMut: GridStorage {\n\tfn storage_ref (\u0026 self, idx: usize) -\u003e Option \u003c\u0026 Self::Item\u003e;\n\tfn storage_mut (\u0026 mut self, idx: usize) -\u003e Option \u003c\u0026 mut Self::Item\u003e;\n}\n\nimpl \u003cItem\u003e GridStorageMut for Vec \u003cItem\u003e where Item: Clone {\n\tfn storage_ref (\u0026 self, idx: usize) -\u003e Option \u003c\u0026 Item\u003e { self.get (idx) }\n\tfn storage_mut (\u0026 mut self, idx: usize) -\u003e Option \u003c\u0026 mut Item\u003e { self.get_mut (idx) }\n}\n\n/// Extra trait for [`GridStorage`] to support iteration.\n///\n/// This is a separate trait to make the lifetimes work. It should be implemented on a reference to\n/// the storage, rather than directly. This allows us to capture the lifetime without polluting the\n/// main trait.\n\npub trait GridStorageIntoIter {\n\ttype Item;\n\ttype Iter: Iterator \u003cItem = Self::Item\u003e;\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter;\n}\n\nimpl \u003c'a, Item\u003e GridStorageIntoIter for \u0026 'a Vec \u003cItem\u003e where Item: Clone {\n\ttype Item = Item;\n\ttype Iter = GridStorageClone \u003cSliceIter \u003c'a, Item\u003e\u003e;\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter { GridStorageClone::new (self.iter ()) }\n}\n\nimpl \u003c'a, Item, Encoding\u003e GridStorageIntoIter for \u0026 'a BitVec \u003cItem, Encoding\u003e\n\twhere\n\t\tEncoding: BitVecEncoding \u003cItem\u003e,\n\t\tItem: Clone {\n\ttype Item = Item;\n\ttype Iter = BitVecIter \u003c'a, Item, Encoding\u003e;\n\tfn storage_iter (\u0026 self) -\u003e Self::Iter { self.iter () }\n}\n\n/// Trait for values to use as indices for a [`Grid`].\n///\n/// For example, a two dimensional grid might be indexed with a struct containing an `x` and a `y`\n/// coordinate.\n///\n/// This trait provides methods to translate whatever coordinate system is in use to and from a\n/// single `usize` value.\n\npub trait GridPos \u003cconst DIMS: usize\u003e: Sized {\n\tfn to_scalar (\u0026 self, origin: [isize; DIMS], size: [usize; DIMS]) -\u003e Option \u003cusize\u003e;\n\tfn from_scalar (scalar: usize, origin: [isize; DIMS], size: [usize; DIMS]) -\u003e Option \u003cSelf\u003e;\n}\n\nimpl GridPos \u003c2\u003e for (usize, usize) {\n\tfn to_scalar (\u0026 self, origin: [isize; 2], size: [usize; 2]) -\u003e Option \u003cusize\u003e {\n\t\tif origin != [0, 0] { unimplemented! () }\n\t\tusize::checked_add (match usize::checked_mul (self.0, size [1]) {\n\t\t\tSome (val) =\u003e val, None =\u003e return None }, self.1)\n\t}\n\tfn from_scalar (scalar: usize, origin: [isize; 2], size: [usize; 2]) -\u003e Option \u003cSelf\u003e {\n\t\tif origin != [0, 0] { unimplemented! () }\n\t\tSome ((scalar / size [1], scalar % size [1]))\n\t}\n}\n\nimpl \u003cVal: Int\u003e GridPos \u003c2\u003e for PosYX \u003cVal\u003e {\n\tfn to_scalar (\u0026 self, origin: [isize; 2], size: [usize; 2]) -\u003e Option \u003cusize\u003e {\n\t\tif origin != [0, 0] { unimplemented! () }\n\t\tlet y = ok_or! (self.y.to_usize (), return None);\n\t\tlet x = ok_or! (self.x.to_usize (), return None);\n\t\tif y \u003e= size [0] || x \u003e= size [1] { return None }\n\t\tSome (y * size [1] + x)\n\t}\n\tfn from_scalar (scalar: usize, origin: [isize; 2], size: [usize; 2]) -\u003e Option \u003cSelf\u003e {\n\t\tif origin != [0, 0] { unimplemented! () }\n\t\tlet y = ok_or! (Val::from_usize (scalar / size [1]), return None);\n\t\tlet x = ok_or! (Val::from_usize (scalar % size [1]), return None);\n\t\tSome (PosYX { y, x })\n\t}\n}\n\n/// Wrapping iterator which clones items.\n///\n/// We don't use [`Cloned`](iter::Cloned) from the standard library because it doesn't handle\n/// [`Iterator::skip`] the way we would like. Although it says in the documentation that there is\n/// no guarantee each element will be processed, it seems like it does so. Instead, we want to\n/// completely bypass any elements which aren't required.\n\npub struct GridStorageClone \u003cStorage\u003e {\n\tstorage: Storage,\n}\n\nimpl \u003cStorage\u003e GridStorageClone \u003cStorage\u003e {\n\tfn new (storage: Storage) -\u003e GridStorageClone \u003cStorage\u003e {\n\t\tGridStorageClone { storage }\n\t}\n}\n\nimpl \u003c'a, Storage, Item\u003e Iterator for GridStorageClone \u003cStorage\u003e\n\twhere\n\t\tStorage: Iterator \u003cItem = \u0026 'a Item\u003e,\n\t\tItem: Clone + 'a {\n\ttype Item = Item;\n\tfn next (\u0026 mut self) -\u003e Option \u003cItem\u003e {\n\t\tself.storage.next ().cloned ()\n\t}\n\tfn nth (\u0026 mut self, num: usize) -\u003e Option \u003cItem\u003e {\n\t\tself.storage.nth (num).cloned ()\n\t}\n}\n","traces":[{"line":28,"address":[129424,129602,130255],"length":1,"stats":{"Line":8},"fn_name":"wrap\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":33,"address":[],"length":0,"stats":{"Line":40},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":9},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[129113,129104],"length":1,"stats":{"Line":6},"fn_name":"len\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":46,"address":[129400,129392],"length":1,"stats":{"Line":6},"fn_name":"size\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":48,"address":[30272,30280],"length":1,"stats":{"Line":4},"fn_name":"raw_origin\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003cu16\u003e, 2\u003e"},{"line":49,"address":[32288,32296],"length":1,"stats":{"Line":4},"fn_name":"raw_size\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003cu16\u003e, 2\u003e"},{"line":50,"address":[130313,130304],"length":1,"stats":{"Line":6},"fn_name":"origin\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":51,"address":[129198,129184],"length":1,"stats":{"Line":6},"fn_name":"peak\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":53,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":64,"address":[30816],"length":1,"stats":{"Line":2},"fn_name":"iter\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003cu16\u003e, 2\u003e"},{"line":67,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":75,"address":[130448],"length":1,"stats":{"Line":5},"fn_name":"values\u003calloc::vec::Vec\u003cbool, alloc::alloc::Global\u003e, aoc_common::pos::dim_2::yx::PosYX\u003ci16\u003e, 2\u003e"},{"line":77,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[94563,94544],"length":1,"stats":{"Line":12},"fn_name":"storage_get\u003cbool\u003e"},{"line":148,"address":[59392,59418],"length":1,"stats":{"Line":2},"fn_name":"storage_set\u003cbool\u003e"},{"line":149,"address":[94649,94640],"length":1,"stats":{"Line":18},"fn_name":"storage_len\u003cbool\u003e"},{"line":171,"address":[66419,66400],"length":1,"stats":{"Line":4},"fn_name":"storage_mut\u003caoc_common::search::PrioritySearchSeenState\u003cu64\u003e\u003e"},{"line":189,"address":[94672,94681],"length":1,"stats":{"Line":8},"fn_name":"storage_iter\u003cbool\u003e"},{"line":215,"address":[426208],"length":1,"stats":{"Line":0},"fn_name":"to_scalar"},{"line":217,"address":[426330,426376,426276],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[426346,426362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[426416],"length":1,"stats":{"Line":0},"fn_name":"from_scalar"},{"line":222,"address":[426551,426691,426489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":15},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":16},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":52,"coverable":68},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","lib.rs"],"content":"#![ doc (html_playground_url = \"https://play.rust-lang.org/\") ]\n\nuse clap::ArgMatches;\nuse clap::Command;\n\n#[ doc (no_inline) ]\npub use prelude::*;\n\npub mod bithash;\npub mod bitvec;\npub mod grid;\npub mod list;\npub mod nums;\npub mod parser;\npub mod pos;\npub mod puzzle;\npub mod search;\n\npub type GenError = Box \u003cdyn Error\u003e;\npub type GenResult \u003cOk\u003e = Result \u003cOk, GenError\u003e;\n\n#[ must_use ]\n#[ inline ]\npub fn default \u003cT: Default\u003e () -\u003e T {\n\tDefault::default ()\n}\n\nmod assertions {\n\n\t#[ macro_export ]\n\tmacro_rules! ok_or {\n\t\t( $val:expr, $if_err:expr ) =\u003e {\n\t\t\tmatch ($val) { Ok (val) =\u003e val, Err (_) =\u003e $if_err }\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! some_or {\n\t\t( $val:expr, $if_err:expr ) =\u003e {\n\t\t\tmatch ($val) { Some (val) =\u003e val, None =\u003e $if_err }\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_is_ok {\n\t\t( $actual:expr ) =\u003e {\n\t\t\tassert! ($actual.is_ok ());\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_eq_ok {\n\t\t( $expect:expr , $actual:expr ) =\u003e {\n\t\t\tlet actual = $actual;\n\t\t\tassert! (actual.is_ok ());\n\t\t\tassert_eq! ($expect, actual.unwrap ());\n\t\t};\n\t}\n\n\t#[ macro_export ]\n\tmacro_rules! assert_err {\n\t\t( $expect:expr , $actual:expr ) =\u003e {\n\t\t\tassert_eq! ($expect, $actual.unwrap_err ().to_string ());\n\t\t};\n\t}\n\n}\n\n#[ macro_export ]\nmacro_rules! array_vec {\n\t( ) =\u003e { ArrayVec::new () };\n\t( $($vals:expr),+ ) =\u003e {\n\t\t{\n\t\t\tlet mut result = ArrayVec::new ();\n\t\t\tarray_vec! (@push result, $($vals,)*);\n\t\t\tresult\n\t\t}\n\t};\n\t( @push $result:ident $(,)? ) =\u003e {};\n\t( @push $result:ident , $val:expr $(, $rest:expr)* ) =\u003e {\n\t\t$result.push ($val);\n\t\tarray_vec! (@push $result, $($rest),*);\n\t};\n\t( @push $result:ident , $val:expr $(, $rest:expr)* , ) =\u003e {\n\t\t$result.push ($val);\n\t\tarray_vec! (@push $result, $($rest),*);\n\t};\n}\n\nmod iter_ext {\n\n\tuse super::*;\n\tuse iter::Copied;\n\n\tpub trait IntoIteratorExt: IntoIterator + Sized {\n\t\tfn iter_vals \u003c'a, Item\u003e (self) -\u003e Copied \u003cSelf::IntoIter\u003e\n\t\t\twhere\n\t\t\t\tItem: 'a + Copy,\n\t\t\t\tSelf: IntoIterator \u003cItem = \u0026 'a Item\u003e {\n\t\t\tself.into_iter ().copied ()\n\t\t}\n\t}\n\n\timpl \u003c'a, IntoIter\u003e IntoIteratorExt for \u0026 'a IntoIter where \u0026 'a IntoIter: IntoIterator {}\n\n\tpub trait IteratorExt: Iterator {\n\t\tfn collect_array \u003cconst DIM: usize\u003e (mut self) -\u003e Option \u003c[Self::Item; DIM]\u003e\n\t\t\t\twhere Self: Sized, Self::Item: Copy + Default {\n\t\t\tlet mut result = [default (); DIM];\n\t\t\tfor idx in 0 .. DIM {\n\t\t\t\tassert! (idx \u003c result.len ());\n\t\t\t\tresult [idx] = some_or! (self.next (), return None);\n\t\t\t}\n\t\t\tif self.next ().is_some () { return None }\n\t\t\tSome (result)\n\t\t}\n\t}\n\n\timpl \u003cSomeIter: Iterator\u003e IteratorExt for SomeIter {}\n\n}\n\nmod prelude {\n\tpub use arrayvec::ArrayVec;\n\tpub use clap;\n\tpub use itertools;\n\tpub use itertools::Either;\n\tpub use itertools::EitherOrBoth;\n\tpub use itertools::Itertools;\n\tpub use itertools::izip;\n\tpub use std::borrow::Borrow;\n\tpub use std::borrow::Cow;\n\tpub use std::cell::Cell;\n\tpub use std::cell::RefCell;\n\tpub use std::cmp;\n\tpub use std::cmp::Ordering;\n\tpub use std::collections::BinaryHeap;\n\tpub use std::collections::HashMap;\n\tpub use std::collections::HashSet;\n\tpub use std::collections::VecDeque;\n\tpub use std::collections::hash_map::DefaultHasher;\n\tpub use std::collections::hash_map::RandomState as RandomHasher;\n\tpub use std::convert::Infallible;\n\tpub use std::error::Error;\n\tpub use std::ffi::OsString;\n\tpub use std::fmt;\n\tpub use std::fmt::Debug;\n\tpub use std::fmt::Display;\n\tpub use std::fs;\n\tpub use std::hash;\n\tpub use std::hash::BuildHasher;\n\tpub use std::hash::BuildHasherDefault;\n\tpub use std::hash::Hash;\n\tpub use std::hash::Hasher;\n\tpub use std::iter;\n\tpub use std::iter::Peekable;\n\tpub use std::marker::PhantomData;\n\tpub use std::mem;\n\tpub use std::ops;\n\tpub use std::ops::Add;\n\tpub use std::ops::Deref;\n\tpub use std::ops::Div;\n\tpub use std::ops::Index;\n\tpub use std::ops::IndexMut;\n\tpub use std::ops::Mul;\n\tpub use std::ops::Neg;\n\tpub use std::ops::Range;\n\tpub use std::ops::RangeInclusive;\n\tpub use std::ops::Rem;\n\tpub use std::ops::Sub;\n\tpub use std::path::Path;\n\tpub use std::rc::Rc;\n\tpub use std::rc::Weak as RcWeak;\n\tpub use std::slice;\n\tpub use std::slice::Iter as SliceIter;\n\tpub use std::str::Chars;\n\tpub use std::str::FromStr;\n\tpub use std::sync::Arc;\n\tpub use std::sync::Condvar;\n\tpub use std::sync::Mutex;\n\tpub use std::thread;\n\tpub use std::time;\n\tpub use crate::iter_ext::IntoIteratorExt as _;\n\tpub use crate::iter_ext::IteratorExt as _;\n}\n","traces":[{"line":24,"address":[373904],"length":1,"stats":{"Line":5},"fn_name":"default\u003caoc_2021_day_24::machine::MachineRegs\u003e"},{"line":25,"address":[255096],"length":1,"stats":{"Line":5},"fn_name":null},{"line":96,"address":[57392],"length":1,"stats":{"Line":12},"fn_name":"iter_vals\u003c\u0026std::collections::hash::set::HashSet\u003caoc_2021_day_13::model::Pos, std::collections::hash::map::RandomState\u003e, aoc_2021_day_13::model::Pos\u003e"},{"line":100,"address":[43849],"length":1,"stats":{"Line":13},"fn_name":null},{"line":107,"address":[86768,87359],"length":1,"stats":{"Line":1},"fn_name":"collect_array\u003ccore::iter::adapters::flatten::FlatMap\u003ccore::iter::adapters::take::Take\u003ccore::slice::iter::Iter\u003c\u0026str\u003e\u003e, core::iter::adapters::map::Map\u003ccore::str::iter::SplitWhitespace, aoc_2021_day_04::model::{impl#0}::parse::{closure#1}::{closure#0}::{closure_env#0}\u003e, aoc_2021_day_04::model::{impl#0}::parse::{closure#1}::{closure_env#0}\u003e, 25\u003e"},{"line":109,"address":[86832,86790],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":11,"coverable":11},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","list.rs"],"content":"//! Implementation of lisp-like lists\n//!\n//! A list is represented as the first list item and a reference to another list to represent the\n//! remaining items - these are referred to as the \"head\" and the \"tail\". There is a special case\n//! for the empty list.\n//!\n//! While this is much less efficient than a [`Vec`], it allows reuse in a way which can be very\n//! beneficial for certain types of algorithm. Adding new items to a list only creates one new\n//! allocation per item, and removing any number of items from the start of the list requires no\n//! allocation.\n//!\n//! We also declare [`CharList`] as `List \u003cchar\u003e`, and implement some extra methods and traits to\n//! make it work nicely with [`String`] and [`str`].\n\nuse super::*;\n\npub use base_list::List;\npub use char_list::CharList;\n\nmod base_list {\n\n\tuse super::*;\n\n\tpub enum List \u003cItem\u003e {\n\t\tPresent (Rc \u003c(Item, List \u003cItem\u003e)\u003e),\n\t\tEmpty,\n\t}\n\n\timpl \u003cItem: Clone\u003e List \u003cItem\u003e {\n\n\t\t#[ inline ]\n\t\tpub fn new () -\u003e Self { List::Empty }\n\n\t\t#[ inline ]\n\t\tpub fn cons (\u0026 self) -\u003e Option \u003c(\u0026 Item, \u0026 List \u003cItem\u003e)\u003e {\n\t\t\tmatch self {\n\t\t\t\tList::Present (inner) =\u003e {\n\t\t\t\t\tlet (head, tail) = inner.deref ();\n\t\t\t\t\tSome ((head, tail))\n\t\t\t\t},\n\t\t\t\tList::Empty =\u003e None,\n\t\t\t}\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn head (\u0026 self) -\u003e Option \u003c\u0026 Item\u003e { self.cons ().map (|(head, _)| head) }\n\n\t\t#[ inline ]\n\t\tpub fn tail (\u0026 self) -\u003e Option \u003c\u0026 List \u003cItem\u003e\u003e { self.cons ().map (|(_, tail)| tail) }\n\n\t\t#[ inline ]\n\t\tpub fn is_empty (\u0026 self) -\u003e bool { self.cons ().is_none () }\n\n\t\t#[ inline ]\n\t\tpub fn len (\u0026 self) -\u003e usize {\n\t\t\tlet mut cur = self.clone ();\n\t\t\tlet mut len = 0;\n\t\t\twhile let List::Present (inner) = cur {\n\t\t\t\tlet (_, new) = inner.deref ();\n\t\t\t\tcur = new.clone ();\n\t\t\t\tlen += 1\n\t\t\t}\n\t\t\tlen\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn push_front (\u0026 self, head: Item) -\u003e List \u003cItem\u003e {\n\t\t\tList::Present (Rc::new ((head, self.clone ())))\n\t\t}\n\n\t\t#[ inline ]\n\t\tpub fn iter (\u0026 self) -\u003e ListIter \u003cItem\u003e {\n\t\t\tListIter { list: self }\n\t\t}\n\n\t}\n\n\timpl \u003cItem: Clone + Debug\u003e Debug for List \u003cItem\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\twrite! (formatter, \"[\") ?;\n\t\t\tlet mut cur = self;\n\t\t\tlet mut idx = 0;\n\t\t\twhile let Some ((head, tail)) = cur.cons () {\n\t\t\t\tif idx \u003e 0 { write! (formatter, \", \") ?; }\n\t\t\t\tDebug::fmt (\u0026 head, formatter) ?;\n\t\t\t\tcur = tail;\n\t\t\t\tidx += 1;\n\t\t\t}\n\t\t\twrite! (formatter, \"]\") ?;\n\t\t\tOk (())\n\t\t}\n\t}\n\n\timpl \u003cItem: Clone\u003e Clone for List \u003cItem\u003e {\n\t\tfn clone (\u0026 self) -\u003e Self {\n\t\t\tmatch self {\n\t\t\t\tList::Present (inner) =\u003e List::Present (Rc::clone (inner)),\n\t\t\t\tList::Empty =\u003e List::Empty,\n\t\t\t}\n\t\t}\n\t}\n\n\timpl \u003cItem: Clone + PartialEq\u003e PartialEq for List \u003cItem\u003e {\n\t\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\t\tlet mut left = self;\n\t\t\tlet mut right = other;\n\t\t\tloop {\n\t\t\t\tmatch (left.cons (), right.cons ()) {\n\t\t\t\t\t(None, None) =\u003e return true,\n\t\t\t\t\t(Some (_), None) | (None, Some (_)) =\u003e return false,\n\t\t\t\t\t(Some ((left_head, left_tail)), Some ((right_head, right_tail))) =\u003e {\n\t\t\t\t\t\tif ! Item::eq (left_head, right_head) { return false }\n\t\t\t\t\t\t(left, right) = (left_tail, right_tail)\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\timpl \u003cItem: Clone + Eq\u003e Eq for List \u003cItem\u003e { }\n\n\timpl \u003cItem: Clone + Hash\u003e Hash for List \u003cItem\u003e {\n\t\tfn hash \u003cHshr: Hasher\u003e (\u0026 self, hasher: \u0026 mut Hshr) {\n\t\t\tlet mut cur = self;\n\t\t\twhile let Some ((head, tail)) = cur.cons () {\n\t\t\t\thead.hash (hasher);\n\t\t\t\tcur = tail;\n\t\t\t}\n\t\t}\n\t}\n\n\timpl Display for List \u003cchar\u003e {\n\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\tlet mut cur = self.clone ();\n\t\t\twhile let List::Present (inner) = cur {\n\t\t\t\tlet \u0026 (head, ref tail) = inner.deref ();\n\t\t\t\twrite! (formatter, \"{}\", head) ?;\n\t\t\t\tcur = tail.clone ();\n\t\t\t}\n\t\t\tOk (())\n\t\t}\n\t}\n\n\tpub struct ListIter \u003c'a, Item: Clone\u003e {\n\t\tlist: \u0026 'a List \u003cItem\u003e,\n\t}\n\n\timpl \u003c'a, Item: Clone\u003e Iterator for ListIter \u003c'a, Item\u003e {\n\t\ttype Item = \u0026 'a Item;\n\t\tfn next (\u0026 mut self) -\u003e Option \u003c\u0026 'a Item\u003e {\n\t\t\tself.list.cons ().map (|(head, tail)| {\n\t\t\t\tself.list = tail;\n\t\t\t\thead\n\t\t\t})\n\t\t}\n\t}\n\n}\n\nmod char_list {\n\n\tuse super::*;\n\n\tpub type CharList = List \u003cchar\u003e;\n\n\timpl CharList {\n\t\t#[ inline ]\n\t\tpub fn starts_with (\u0026 self, pat: \u0026 str) -\u003e bool {\n\t\t\tself.strip_prefix (pat).is_some ()\n\t\t}\n\t\t#[ inline ]\n\t\tpub fn strip_prefix (\u0026 self, pat: \u0026 str) -\u003e Option \u003c\u0026 CharList\u003e {\n\t\t\tlet mut cur = self;\n\t\t\tlet mut pat_chars = pat.chars ();\n\t\t\tloop {\n\t\t\t\tmatch (cur.cons (), pat_chars.next ()) {\n\t\t\t\t\t(_, None) =\u003e return Some (cur),\n\t\t\t\t\t(None, _) =\u003e return None,\n\t\t\t\t\t(Some ((\u0026 head, tail)), Some (pat_ch)) =\u003e {\n\t\t\t\t\t\tif head != pat_ch { return None }\n\t\t\t\t\t\tcur = tail;\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t#[ inline ]\n\t\tpub fn prepend (\u0026 self, prefix: \u0026 str) -\u003e CharList {\n\t\t\tlet mut cur = self.clone ();\n\t\t\tfor prefix_ch in prefix.chars ().rev () {\n\t\t\t\tcur = cur.push_front (prefix_ch);\n\t\t\t}\n\t\t\tcur\n\t\t}\n\t}\n\n\timpl From \u003c\u0026 str\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn from (src: \u0026 str) -\u003e CharList {\n\t\t\tCharList::Empty.prepend (src)\n\t\t}\n\t}\n\n\timpl From \u003c\u0026 String\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn from (src: \u0026 String) -\u003e CharList {\n\t\t\tCharList::Empty.prepend (src)\n\t\t}\n\t}\n\n\timpl PartialEq \u003cstr\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 str) -\u003e bool {\n\t\t\tlet mut cur = self;\n\t\t\tlet mut other_iter = other.chars ();\n\t\t\tloop {\n\t\t\t\tmatch (cur.cons (), other_iter.next ()) {\n\t\t\t\t\t(Some (_), None) | (None, Some (_)) =\u003e return false,\n\t\t\t\t\t(None, None) =\u003e return true,\n\t\t\t\t\t(Some ((\u0026 cur_head, cur_tail)), Some (other_ch)) =\u003e {\n\t\t\t\t\t\tif cur_head != other_ch { return false }\n\t\t\t\t\t\tcur = cur_tail;\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\timpl PartialEq \u003cString\u003e for CharList {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 String) -\u003e bool {\n\t\t\tPartialEq::eq (self, other.as_str ())\n\t\t}\n\t}\n\n\timpl PartialEq \u003cCharList\u003e for \u0026 String {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 CharList) -\u003e bool {\n\t\t\tPartialEq::eq (self.as_str (), other)\n\t\t}\n\t}\n\n\timpl PartialEq \u003cCharList\u003e for str {\n\t\t#[ inline ]\n\t\tfn eq (\u0026 self, other: \u0026 CharList) -\u003e bool {\n\t\t\tPartialEq::eq (other, self)\n\t\t}\n\t}\n\n\t#[ cfg (test) ]\n\tmod tests {\n\n\t\tuse super::*;\n\t\tuse CharList as CL;\n\n\t\tfn cl (src: \u0026 str) -\u003e CL { CL::from (src) }\n\n\t\tconst SAMPLES: \u0026 [\u0026 str] = \u0026 [ \"\", \"a\", \"ab\", \"abc\", \"b\", \"bc\", \"c\" ];\n\n\t\t#[ test ]\n\t\tfn eq () {\n\t\t\tfor left in SAMPLES.iter ().cloned () {\n\t\t\t\tfor right in SAMPLES.iter ().cloned () {\n\t\t\t\t\tif left == right {\n\t\t\t\t\t\tassert! (cl (left) == cl (right),\n\t\t\t\t\t\t\t\"{:?} == {:?} but CharList::from ({:?}) != CharList::from ({:?})\",\n\t\t\t\t\t\t\tleft, right, left, right);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert! (cl (left) != cl (right),\n\t\t\t\t\t\t\t\"{:?} != {:?} but CharList::from ({:?}) == CharList::from ({:?})\",\n\t\t\t\t\t\t\tleft, right, left, right);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#[ test ]\n\t\tfn strip_prefix () {\n\t\t\tfor left in SAMPLES.iter ().cloned () {\n\t\t\t\tfor right in SAMPLES.iter ().cloned () {\n\t\t\t\t\tlet expected = left.strip_prefix (right);\n\t\t\t\t\tlet actual = cl (left).strip_prefix (right).cloned ();\n\t\t\t\t\tassert_eq! (expected.map (cl), actual,\n\t\t\t\t\t\t\"{:?}.strip_prefix ({:?}) == {:?} but {:?}.strip_prefix ({:?}) == {:?}\",\n\t\t\t\t\t\tleft, right, expected, cl (left), right, actual);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n","traces":[{"line":32,"address":[44241,44240],"length":1,"stats":{"Line":2},"fn_name":"new\u003calloc::string::String\u003e"},{"line":35,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":46,"address":[44480,44425,44497,44416],"length":1,"stats":{"Line":4},"fn_name":"head\u003calloc::string::String\u003e"},{"line":49,"address":[44512,44521,44576,44593],"length":1,"stats":{"Line":4},"fn_name":"tail\u003calloc::string::String\u003e"},{"line":52,"address":[44608,44617],"length":1,"stats":{"Line":2},"fn_name":"is_empty\u003calloc::string::String\u003e"},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[405600,406180,406201],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":134,"address":[405628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[405654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[405840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[405863,406043],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[406031,406152],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[405758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":11},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[248272,248286],"length":1,"stats":{"Line":4},"fn_name":"cl"},{"line":260,"address":[249095,249069,248304],"length":1,"stats":{"Line":3},"fn_name":"eq"},{"line":261,"address":[248515,248311],"length":1,"stats":{"Line":2},"fn_name":null},{"line":262,"address":[248547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":263,"address":[248779],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[249117,249080,248855],"length":1,"stats":{"Line":3},"fn_name":null},{"line":268,"address":[248821,249403],"length":1,"stats":{"Line":2},"fn_name":null},{"line":277,"address":[249872,250597],"length":1,"stats":{"Line":3},"fn_name":"strip_prefix"},{"line":278,"address":[250093,249884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":279,"address":[250125],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[250357],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[250414],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[251138,250660],"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":[251089],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":76,"coverable":113},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","nums.rs"],"content":"use super::*;\nuse std::fmt::{ Debug, Display };\n\npub type NumResult \u003cVal\u003e = Result \u003cVal, Overflow\u003e;\n\n#[ derive (Debug, Eq, PartialEq) ]\npub struct Overflow;\n\nimpl Display for Overflow {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\twrite! (formatter, \"Overflow\") ?;\n\t\tOk (())\n\t}\n}\n\nimpl Error for Overflow {\n}\n\npub trait Int: Clone + Copy + Debug + Display + Eq + Hash + Ord + IntOps + IntConv {\n\ttype Signed: IntSigned;\n\ttype Unsigned: IntUnsigned;\n\tconst ZERO: Self;\n\tconst ONE: Self;\n\tconst MIN: Self;\n\tconst MAX: Self;\n\tfn unsigned_abs (self) -\u003e Self::Unsigned;\n\tfn signum (self) -\u003e Self::Signed;\n\tfn signed_diff (self, other: Self) -\u003e NumResult \u003cSelf::Signed\u003e;\n\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003cSelf::Unsigned\u003e;\n\tfn add_signed (self, other: Self::Signed) -\u003e NumResult \u003cSelf\u003e;\n\tfn sub_signed (self, other: Self::Signed) -\u003e NumResult \u003cSelf\u003e;\n\tfn add_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\t#[ inline ]\n\tfn add_3 (arg_0: Self, arg_1: Self, arg_2: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::add_2 (Self::add_2 (arg_0, arg_1) ?, arg_2)\n\t}\n\t#[ inline ]\n\tfn add_4 (arg_0: Self, arg_1: Self, arg_2: Self, arg_3: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::add_2 (Self::add_3 (arg_0, arg_1, arg_2) ?, arg_3)\n\t}\n\tfn div_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\tfn mul_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n\t#[ inline ]\n\tfn mul_3 (arg_0: Self, arg_1: Self, arg_2: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::mul_2 (Self::mul_2 (arg_0, arg_1) ?, arg_2)\n\t}\n\t#[ inline ]\n\tfn mul_4 (arg_0: Self, arg_1: Self, arg_2: Self, arg_3: Self) -\u003e NumResult \u003cSelf\u003e {\n\t\tSelf::mul_2 (Self::mul_3 (arg_0, arg_1, arg_2) ?, arg_3)\n\t}\n\tfn sub_2 (arg_0: Self, arg_1: Self) -\u003e NumResult \u003cSelf\u003e;\n}\n\nmacro_rules! prim_int {\n\t( $signed:ident , $unsigned:ident, $bits:literal ) =\u003e {\n\t\timpl Int for $signed {\n\t\t\ttype Signed = $signed;\n\t\t\ttype Unsigned = $unsigned;\n\t\t\tconst ZERO: $signed = 0;\n\t\t\tconst ONE: $signed = 1;\n\t\t\tconst MIN: $signed = $signed::MIN;\n\t\t\tconst MAX: $signed = $signed::MAX;\n\t\t\t#[ inline ]\n\t\t\tfn unsigned_abs (self) -\u003e $unsigned { $signed::unsigned_abs (self) }\n\t\t\t#[ inline ]\n\t\t\tfn signum (self) -\u003e $signed { $signed::signum (self) }\n\t\t\t#[ inline ]\n\t\t\tfn signed_diff (self, other: Self) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t(other \u003c= self).then (|| $signed::abs_diff (self, other)).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn add_signed (self, other: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_add (self, other).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn sub_signed (self, other: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn add_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_add (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn div_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_div (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn mul_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_mul (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn sub_2 (arg_0: $signed, arg_1: $signed) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\t$signed::checked_sub (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t}\n\t\timpl Int for $unsigned {\n\t\t\ttype Signed = $signed;\n\t\t\ttype Unsigned = $unsigned;\n\t\t\tconst ZERO: $unsigned = 0;\n\t\t\tconst ONE: $unsigned = 1;\n\t\t\tconst MIN: $unsigned = $unsigned::MIN;\n\t\t\tconst MAX: $unsigned = $unsigned::MAX;\n\t\t\t#[ inline ]\n\t\t\tfn unsigned_abs (self) -\u003e $unsigned { self }\n\t\t\t#[ inline ]\n\t\t\tfn signum (self) -\u003e $signed {\n\t\t\t\tif self \u003e 0 { 1 } else { 0 }\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn signed_diff (self, other: Self) -\u003e NumResult \u003c$signed\u003e {\n\t\t\t\tif other \u003c self {\n\t\t\t\t\t(self - other).try_into ().ok ().ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t(other - self).try_into ().map ($signed::neg).ok ().ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn unsigned_diff (self, other: Self) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_sub (self, other).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn add_signed (self, other: $signed) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\tif other \u003e= 0 {\n\t\t\t\t\t$unsigned::checked_add (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t$unsigned::checked_sub (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn sub_signed (self, other: $signed) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\tif other \u003e= 0 {\n\t\t\t\t\t$unsigned::checked_sub (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t} else {\n\t\t\t\t\t$unsigned::checked_add (self, $signed::unsigned_abs (other)).ok_or (Overflow)\n\t\t\t\t}\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn add_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_add (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn div_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_div (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn mul_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_mul (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t\t#[ inline ]\n\t\t\tfn sub_2 (arg_0: $unsigned, arg_1: $unsigned) -\u003e NumResult \u003c$unsigned\u003e {\n\t\t\t\t$unsigned::checked_sub (arg_0, arg_1).ok_or (Overflow)\n\t\t\t}\n\t\t}\n\t\timpl IntOpsSafe for $signed {\n\t\t\tfn safe_add (self, arg: $signed) -\u003e $signed {\n\t\t\t\t$signed::checked_add (self, arg).unwrap ()\n\t\t\t}\n\t\t\tfn safe_sub (self, arg: $signed) -\u003e $signed {\n\t\t\t\t$signed::checked_sub (self, arg).unwrap ()\n\t\t\t}\n\t\t}\n\t\timpl IntOpsSafe for $unsigned {\n\t\t\tfn safe_add (self, arg: $unsigned) -\u003e $unsigned {\n\t\t\t\t$unsigned::checked_add (self, arg).unwrap ()\n\t\t\t}\n\t\t\tfn safe_sub (self, arg: $unsigned) -\u003e $unsigned {\n\t\t\t\t$unsigned::checked_sub (self, arg).unwrap ()\n\t\t\t}\n\t\t}\n\t\timpl IntSigned for $signed {\n\t\t\tconst NEG_ONE: $signed = -1;\n\t\t}\n\t\timpl IntUnsigned for $unsigned {}\n\t\timpl IntSized \u003c$bits\u003e for $signed {}\n\t\timpl IntSized \u003c$bits\u003e for $unsigned {}\n\t\timpl IntConv for $signed {\n\t\t\t#[ inline ]\n\t\t\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e { val.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t}\n\t\timpl IntConv for $unsigned {\n\t\t\t#[ inline ]\n\t\t\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e { val.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t\t#[ inline ]\n\t\t\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e { self.try_into ().ok ().ok_or (Overflow) }\n\t\t}\n\t};\n}\n\nprim_int! (i8, u8, 8);\nprim_int! (i16, u16, 16);\nprim_int! (i32, u32, 32);\nprim_int! (i64, u64, 64);\nprim_int! (i128, u128, 128);\nprim_int! (isize, usize, 128);\n\npub trait IntSigned: Int {\n\tconst NEG_ONE: Self::Signed;\n}\n\npub trait IntUnsigned: Int {}\n\npub trait IntSized \u003cconst BITS: usize\u003e: Int {}\n\npub trait IntOpsRust: Sized\n\t+ Add \u003cOutput = Self\u003e + Div \u003cOutput = Self\u003e + Mul \u003cOutput = Self\u003e + Rem \u003cOutput = Self\u003e\n\t+ Sub \u003cOutput = Self\u003e {}\nimpl \u003cVal\u003e IntOpsRust for Val where Val: Sized\n\t+ Add \u003cOutput = Self\u003e + Div \u003cOutput = Self\u003e + Mul \u003cOutput = Self\u003e + Rem \u003cOutput = Self\u003e\n\t+ Sub \u003cOutput = Self\u003e {}\n\npub trait IntOpsSafe: Sized {\n\tfn safe_add (self, arg: Self) -\u003e Self;\n\tfn safe_sub (self, arg: Self) -\u003e Self;\n}\n\npub trait IntOps: IntOpsRust + IntOpsSafe {}\nimpl \u003cVal\u003e IntOps for Val where Val: IntOpsRust + IntOpsSafe {}\n\npub trait IntConv: Sized {\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_f32 (self) -\u003e f32 { self.to_f32 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_f64 (self) -\u003e f64 { self.to_f64 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_i8 (self) -\u003e i8 { self.to_i8 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_i16 (self) -\u003e i16 { self.to_i16 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_i32 (self) -\u003e i32 { self.to_i32 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_i64 (self) -\u003e i64 { self.to_i64 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_i128 (self) -\u003e i128 { self.to_i128 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_isize (self) -\u003e isize { self.to_isize ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_u8 (self) -\u003e u8 { self.to_u8 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_u16 (self) -\u003e u16 { self.to_u16 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_u32 (self) -\u003e u32 { self.to_u32 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_u64 (self) -\u003e u64 { self.to_u64 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_u128 (self) -\u003e u128 { self.to_u128 ().unwrap () }\n\t#[ allow (clippy::wrong_self_convention) ]\n\t#[ inline ]\n\tfn as_usize (self) -\u003e usize { self.to_usize ().unwrap () }\n\tfn from_usize (val: usize) -\u003e NumResult \u003cSelf\u003e;\n\t#[ inline ]\n\tfn to_f32 (self) -\u003e NumResult \u003cf32\u003e { self.to_u16 ().map (Into::into) }\n\t#[ inline ]\n\tfn to_f64 (self) -\u003e NumResult \u003cf64\u003e { self.to_u32 ().map (Into::into) }\n\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e;\n\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e;\n\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e;\n\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e;\n\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e;\n\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e;\n\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e;\n\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e;\n\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e;\n\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e;\n\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e;\n\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e;\n}\n\nimpl IntConv for char {\n\t#[ inline ]\n\tfn from_usize (val: usize) -\u003e NumResult \u003cchar\u003e { val.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_i8 (self) -\u003e NumResult \u003ci8\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_i16 (self) -\u003e NumResult \u003ci16\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_i32 (self) -\u003e NumResult \u003ci32\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_i64 (self) -\u003e NumResult \u003ci64\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_i128 (self) -\u003e NumResult \u003ci128\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_isize (self) -\u003e NumResult \u003cisize\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_u8 (self) -\u003e NumResult \u003cu8\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_u16 (self) -\u003e NumResult \u003cu16\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_u32 (self) -\u003e NumResult \u003cu32\u003e { self.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_u64 (self) -\u003e NumResult \u003cu64\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_u128 (self) -\u003e NumResult \u003cu128\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n\t#[ inline ]\n\tfn to_usize (self) -\u003e NumResult \u003cusize\u003e { self.to_u32 () ?.try_into ().map_err (|_| Overflow) }\n}\n","traces":[{"line":10,"address":[369616],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":11,"address":[369635,369736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[369729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[371784,382069,391376,376720,382064,397568,371776,386480,386489,376729,391390,397577],"length":1,"stats":{"Line":0},"fn_name":"unsigned_abs"},{"line":66,"address":[376752,371808,382096,371880,386512,397686,382172,391583,397600,386598,376835,391424],"length":1,"stats":{"Line":0},"fn_name":"signum"},{"line":68,"address":[371888,391600,382192,386608,376848,397696],"length":1,"stats":{"Line":0},"fn_name":"signed_diff"},{"line":69,"address":[371903,386622,391624,397710,376868,382204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[376944,382256,391712,371968,397776,386688],"length":1,"stats":{"Line":0},"fn_name":"unsigned_diff"},{"line":73,"address":[345582,345630,345454,345518,345504,345688,345758,345744,345616,345440,345568,345664],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":76,"address":[391888,372096,382368,386816,377088,397904],"length":1,"stats":{"Line":6},"fn_name":"add_signed"},{"line":77,"address":[377108,391912,397918,386830,382380,372111],"length":1,"stats":{"Line":6},"fn_name":null},{"line":80,"address":[392000,377184,382432,386896,397984,372176],"length":1,"stats":{"Line":2},"fn_name":"sub_signed"},{"line":81,"address":[386910,397998,392024,377204,382444,372191],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[392112,382496,386976,398064,377280,372256],"length":1,"stats":{"Line":0},"fn_name":"add_2"},{"line":85,"address":[398078,377300,392136,382508,372271,386990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[372336,387056,392224,377376,398144,382560],"length":1,"stats":{"Line":0},"fn_name":"div_2"},{"line":89,"address":[372351,387070,392248,398158,382572,377396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[377472,387136,382624,392336,398224,372416],"length":1,"stats":{"Line":0},"fn_name":"mul_2"},{"line":93,"address":[387150,377492,392360,398238,372431,382636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[377568,398304,387216,372496,382688,392448],"length":1,"stats":{"Line":0},"fn_name":"sub_2"},{"line":97,"address":[377588,392472,372511,382700,398318,387230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[382752,387296,372586,377664,372576,387304,382761,392560,398384,398392,377675,392579],"length":1,"stats":{"Line":0},"fn_name":"unsigned_abs"},{"line":110,"address":[392592,377680,382768,387312,398400,372592],"length":1,"stats":{"Line":0},"fn_name":"signum"},{"line":111,"address":[392606,372603,398409,382773,377692,387321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[398448,382800,372640,387360,377728,392672],"length":1,"stats":{"Line":0},"fn_name":"signed_diff"},{"line":115,"address":[372666,377758,382820,387393,392743,398481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[372708,377807,382859,392855,387442,398530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[377959,382980,377773,382832,398496,392785,393079,372678,372850,398676,387408,387588],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[378112,387728,398816,383088,393264,373008],"length":1,"stats":{"Line":0},"fn_name":"unsigned_diff"},{"line":123,"address":[393288,398830,378132,373023,387742,383100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[378208,387808,393376,373088,398896,383152],"length":1,"stats":{"Line":1},"fn_name":"add_signed"},{"line":127,"address":[373114,393435,398920,387832,383172,378238],"length":1,"stats":{"Line":1},"fn_name":null},{"line":128,"address":[393482,398948,383196,378269,373140,387860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[373230,399033,373122,387843,383181,398931,383268,378249,387945,393452,378369,393621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[393680,388000,399088,383312,373296,378432],"length":1,"stats":{"Line":0},"fn_name":"sub_signed"},{"line":135,"address":[373322,378462,383332,388024,393739,399112],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[378493,383356,388052,393786,399140,373348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[383428,373330,378473,393925,399123,399225,388035,373438,383341,388137,378593,393756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[373504,378656,383472,399280,393984,388192],"length":1,"stats":{"Line":8},"fn_name":"add_2"},{"line":143,"address":[373519,388206,383484,399294,394008,378676],"length":1,"stats":{"Line":8},"fn_name":null},{"line":146,"address":[399360,383536,394096,378752,373584,388272],"length":1,"stats":{"Line":2},"fn_name":"div_2"},{"line":147,"address":[399374,378772,373599,383548,388286,394120],"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":[388352,383600,378848,399440,373664,394208],"length":1,"stats":{"Line":8},"fn_name":"mul_2"},{"line":151,"address":[399454,383612,378868,373679,394232,388366],"length":1,"stats":{"Line":8},"fn_name":null},{"line":154,"address":[378944,373744,383664,388432,399520,394320],"length":1,"stats":{"Line":4},"fn_name":"sub_2"},{"line":155,"address":[388446,378964,383676,373759,394344,399534],"length":1,"stats":{"Line":4},"fn_name":null},{"line":159,"address":[388512,394432,399600,373824,379040,383728],"length":1,"stats":{"Line":0},"fn_name":"safe_add"},{"line":160,"address":[383740,394456,379060,373839,388526,399614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[388576,383792,394528,399664,379136,373904],"length":1,"stats":{"Line":0},"fn_name":"safe_sub"},{"line":163,"address":[394552,399678,379156,383804,373919,388590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[388640,383856,373984,379232,394624,399728],"length":1,"stats":{"Line":0},"fn_name":"safe_add"},{"line":168,"address":[379252,388654,394648,399742,373999,383868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[383920,394720,379328,374064,399808,388704],"length":1,"stats":{"Line":0},"fn_name":"safe_sub"},{"line":171,"address":[374079,379348,383932,388718,394744,399822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[374153,374144,394816,399888,379433,383993,379424,383984,388768,388777,394825,399897],"length":1,"stats":{"Line":4},"fn_name":"from_usize"},{"line":184,"address":[394958,394944,399993,384064,384072,374256,379545,399984,379536,374264,388864,388873],"length":1,"stats":{"Line":0},"fn_name":"to_i8"},{"line":186,"address":[400105,379644,388976,388985,395070,374363,384160,379632,374352,384168,395056,400096],"length":1,"stats":{"Line":0},"fn_name":"to_i16"},{"line":188,"address":[400208,389088,374448,379740,374459,379728,395168,395182,384272,384280,400217,389097],"length":1,"stats":{"Line":0},"fn_name":"to_i32"},{"line":190,"address":[395262,379808,389177,400288,400297,395248,374528,384352,374539,389168,379820,384360],"length":1,"stats":{"Line":0},"fn_name":"to_i64"},{"line":192,"address":[395344,384432,384440,374635,374624,379916,389248,395358,400393,389257,400384,379904],"length":1,"stats":{"Line":0},"fn_name":"to_i128"},{"line":194,"address":[395472,389369,395486,380044,384552,400512,380032,400521,374747,384544,374736,389360],"length":1,"stats":{"Line":0},"fn_name":"to_isize"},{"line":196,"address":[389456,400592,380128,384648,389465,380137,374840,395568,395582,374832,384640,400601],"length":1,"stats":{"Line":0},"fn_name":"to_u8"},{"line":198,"address":[389568,380224,389577,380236,374928,374939,395680,384744,395694,400704,384736,400713],"length":1,"stats":{"Line":0},"fn_name":"to_u16"},{"line":200,"address":[395792,375051,380348,384848,375040,380336,389689,389680,384856,395806,400816,400825],"length":1,"stats":{"Line":0},"fn_name":"to_u32"},{"line":202,"address":[395872,375136,400896,384928,380444,384936,389769,400905,380432,389760,375147,395886],"length":1,"stats":{"Line":0},"fn_name":"to_u64"},{"line":204,"address":[380528,385032,380540,395982,400992,375232,389856,401001,395968,375243,385024,389865],"length":1,"stats":{"Line":0},"fn_name":"to_u128"},{"line":206,"address":[375360,380656,389993,389984,396110,385152,396096,401120,380668,385160,375371,401129],"length":1,"stats":{"Line":8},"fn_name":"to_usize"},{"line":210,"address":[396192,396201,401216,375456,380752,385248,401225,375465,380761,390089,390080,385257],"length":1,"stats":{"Line":10},"fn_name":"from_usize"},{"line":212,"address":[375576,380864,385328,401305,390185,385336,375568,396334,380873,401296,390176,396320],"length":1,"stats":{"Line":0},"fn_name":"to_i8"},{"line":214,"address":[401417,380972,390297,396432,390288,375675,375664,380960,385432,396446,401408,385424],"length":1,"stats":{"Line":0},"fn_name":"to_i16"},{"line":216,"address":[401529,390400,375771,385536,381084,396544,390409,385544,375760,396558,401520,381072],"length":1,"stats":{"Line":0},"fn_name":"to_i32"},{"line":218,"address":[401609,375840,375851,385624,390489,390480,396638,381164,381152,396624,385616,401600],"length":1,"stats":{"Line":0},"fn_name":"to_i64"},{"line":220,"address":[375947,385704,381260,381248,390576,401696,401705,390585,375936,396720,396734,385696],"length":1,"stats":{"Line":0},"fn_name":"to_i128"},{"line":222,"address":[396848,385816,381388,396862,376059,376048,401824,401833,390697,390688,381376,385808],"length":1,"stats":{"Line":0},"fn_name":"to_isize"},{"line":224,"address":[385912,381481,396944,401929,390784,376144,390793,396958,376152,385904,401920,381472],"length":1,"stats":{"Line":0},"fn_name":"to_u8"},{"line":226,"address":[390896,390905,381568,386008,402041,381580,402032,376240,376251,397070,397056,386000],"length":1,"stats":{"Line":0},"fn_name":"to_u16"},{"line":228,"address":[402144,386112,391008,386120,397168,402153,376336,397182,376347,381664,381676,391017],"length":1,"stats":{"Line":4},"fn_name":"to_u32"},{"line":230,"address":[376416,386192,386200,402233,391088,391097,397248,397262,402224,376427,381756,381744],"length":1,"stats":{"Line":4},"fn_name":"to_u64"},{"line":232,"address":[397358,402320,391177,386272,391168,381840,402329,381852,397344,386280,376523,376512],"length":1,"stats":{"Line":0},"fn_name":"to_u128"},{"line":234,"address":[376635,386384,381968,386392,402448,381980,397472,391289,402457,376624,397486,391280],"length":1,"stats":{"Line":12},"fn_name":"to_usize"},{"line":272,"address":[330489,330544,330016,330620,330697,330752,330080,330816,330091,330174,330332,330608,330688,330251,330160,330760,330824,330025,330320,330400,329952,330240,330480,330552,330414,329961],"length":1,"stats":{"Line":0},"fn_name":"as_f32\u003cu64\u003e"},{"line":275,"address":[331344,330960,331264,331500,331792,331033,331576,331488,330880,331408,331352,330894,331417,331568,331641,331104,331184,331115,330968,331632,331712,331726,331801,331195,331276,331024],"length":1,"stats":{"Line":0},"fn_name":"as_f64\u003ci128\u003e"},{"line":278,"address":[332080,332021,332169,332544,332617,332672,331950,332232,332416,331936,332352,332297,332480,332489,332549,332425,332224,332357,331880,332160,332094,332288,332681,332016,331872,332608],"length":1,"stats":{"Line":0},"fn_name":"as_i8\u003ci8\u003e"},{"line":281,"address":[333368,333673,333040,333360,333134,333440,333600,333120,333049,333209,332889,332880,333608,332744,332800,332968,333200,333280,333448,333520,333529,333294,332809,332736,333664,332960],"length":1,"stats":{"Line":0},"fn_name":"as_i16\u003cu8\u003e"},{"line":284,"address":[333884,333755,334012,334448,334384,333936,333817,333944,334073,334520,333808,334256,334192,334320,334398,334136,334512,334329,334201,334267,334128,333744,334064,333872,334000,334462],"length":1,"stats":{"Line":0},"fn_name":"as_i32\u003ci8\u003e"},{"line":287,"address":[334976,334576,334588,334656,334720,334912,335040,334926,335049,335112,334848,335248,335179,335328,335336,335392,335403,335168,335260,334798,334857,335104,334784,334729,334665,334984],"length":1,"stats":{"Line":0},"fn_name":"as_i64\u003ci16\u003e"},{"line":290,"address":[336576,335472,335920,335552,336112,336504,336025,335480,335632,336222,336400,335641,336412,335728,335742,335824,335932,335560,336016,336208,336304,336313,336496,336587,335835,336121],"length":1,"stats":{"Line":0},"fn_name":"as_i128\u003ci32\u003e"},{"line":293,"address":[336825,336760,337166,337344,337420,337008,337016,336816,337072,337216,337289,336672,337358,336944,336752,337083,337488,336880,336889,337224,337500,336953,337408,337280,337152,336683],"length":1,"stats":{"Line":0},"fn_name":"as_isize\u003ci8\u003e"},{"line":296,"address":[338041,338096,338032,337696,338288,338368,338169,337904,337774,337848,338224,337968,338302,338160,337632,337705,337840,337909,337760,338104,337973,337573,338233,338377,337568,337641],"length":1,"stats":{"Line":0},"fn_name":"as_u8\u003ci32\u003e"},{"line":299,"address":[338889,339200,339128,339289,339040,339360,338446,339369,338816,338432,338760,338960,339280,339209,338601,338680,338672,339054,338521,338752,338512,338824,338968,338880,338592,339120],"length":1,"stats":{"Line":0},"fn_name":"as_u16\u003ci128\u003e"},{"line":302,"address":[339641,339760,339899,339952,340088,340144,340217,339961,339835,339768,340016,340080,339696,340208,339888,339704,339577,339516,339568,339504,339454,339824,339440,339632,340156,340030],"length":1,"stats":{"Line":0},"fn_name":"as_u32\u003ci128\u003e"},{"line":305,"address":[340464,340336,340984,340558,340752,340896,341104,340544,340828,340608,340761,340344,340619,340688,340976,340400,340816,340907,341040,340409,340281,341049,340476,341112,340272,340702],"length":1,"stats":{"Line":0},"fn_name":"as_u64\u003cusize\u003e"},{"line":308,"address":[342112,341177,342126,341739,341356,342208,342216,342296,341643,341344,341449,342016,342288,341632,341272,341824,341440,341168,341264,341536,341545,341838,341728,341920,341932,342025],"length":1,"stats":{"Line":0},"fn_name":"as_u128\u003cisize\u003e"},{"line":311,"address":[342496,342793,342976,343131,342720,343040,343209,342376,343200,343120,342560,342856,342368,342640,342510,342651,342784,342440,342912,342432,342921,342985,342848,342572,343052,342734],"length":1,"stats":{"Line":0},"fn_name":"as_usize\u003ci32\u003e"},{"line":314,"address":[343993,343678,343984,343344,344064,344078,343904,343353,343424,344224,344236,343515,343824,344152,344144,343264,343504,343273,343833,343595,343916,343584,343744,343752,343432,343664],"length":1,"stats":{"Line":0},"fn_name":"to_f32\u003cisize\u003e"},{"line":316,"address":[345033,344384,345102,344318,345168,344800,345088,345024,344584,344640,344811,345176,344304,344512,344576,344521,344448,344393,344651,344720,344880,344889,344944,344732,344956,344456],"length":1,"stats":{"Line":0},"fn_name":"to_f64\u003ci128\u003e"},{"line":333,"address":[345232],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":335,"address":[345248],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":337,"address":[345264],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":339,"address":[345280],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":341,"address":[345296],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":343,"address":[345312],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":345,"address":[345328],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":347,"address":[345344],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":349,"address":[345360],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":351,"address":[345376],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":353,"address":[345392],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":355,"address":[345408],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":357,"address":[345424],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"}],"covered":22,"coverable":117},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","parser.rs"],"content":"use super::*;\n\npub type ParseResult \u003cItem\u003e = Result \u003cItem, ParseError\u003e;\n\n#[ derive (Clone) ]\npub struct Parser \u003c'inp\u003e {\n\tinput: \u0026 'inp str,\n\tpos: usize,\n\tword_pred: fn (char) -\u003e bool,\n\tignore_whitespace: bool,\n\tconfirmed: bool,\n}\n\n#[ derive (Debug) ]\npub enum ParseError {\n\tSimple (usize),\n\tWrapped (GenError),\n}\n\npub trait ResultExt \u003cItem\u003e {\n\tfn map_parse_err \u003cMapFn, IntoGenErr\u003e (self, map_fn: MapFn) -\u003e GenResult \u003cItem\u003e\n\t\twhere\n\t\t\tMapFn: Fn (usize) -\u003e IntoGenErr,\n\t\t\tIntoGenErr: Into \u003cGenError\u003e;\n}\n\nimpl \u003cItem\u003e ResultExt \u003cItem\u003e for Result \u003cItem, ParseError\u003e {\n\tfn map_parse_err \u003cMapFn, IntoGenErr\u003e (self, map_fn: MapFn) -\u003e GenResult \u003cItem\u003e\n\t\twhere\n\t\t\tMapFn: Fn (usize) -\u003e IntoGenErr,\n\t\t\tIntoGenErr: Into \u003cGenError\u003e {\n\t\tmatch self {\n\t\t\tOk (item) =\u003e Ok (item),\n\t\t\tErr (ParseError::Simple (char_idx)) =\u003e Err (map_fn (char_idx).into ()),\n\t\t\tErr (ParseError::Wrapped (err)) =\u003e Err (err),\n\t\t}\n\t}\n}\n\nimpl Display for ParseError {\n\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\tmatch self {\n\t\t\tParseError::Simple (char_idx) =\u003e\n\t\t\t\twrite! (formatter, \"Parser error at col {}\", char_idx + 1) ?,\n\t\t\tParseError::Wrapped (inner) =\u003e\n\t\t\t\tDisplay::fmt (inner, formatter) ?,\n\t\t}\n\t\tOk (())\n\t}\n}\n\nimpl Error for ParseError {\n}\n\nimpl From \u003cGenError\u003e for ParseError {\n    fn from (other: GenError) -\u003e ParseError {\n        ParseError::Wrapped (other)\n    }\n}\n\nimpl From \u003c\u0026 str\u003e for ParseError {\n\tfn from (other: \u0026 str) -\u003e ParseError {\n\t\tParseError::Wrapped (other.into ())\n\t}\n}\n\nimpl \u003c'inp\u003e Parser \u003c'inp\u003e {\n\n\tpub fn new (input: \u0026 'inp str) -\u003e Parser \u003c'inp\u003e {\n\t\tParser {\n\t\t\tinput,\n\t\t\tpos: 0,\n\t\t\tword_pred: |ch| ! ch.is_whitespace (),\n\t\t\tignore_whitespace: false,\n\t\t\tconfirmed: false,\n\t\t}\n\t}\n\n\tpub fn confirm (\u0026 mut self) -\u003e \u0026 mut Self {\n\t\tself.confirmed = true;\n\t\tself\n\t}\n\n\tpub fn set_ignore_whitespace (\u0026 mut self, ignore_whitespace: bool) -\u003e \u0026 mut Self {\n\t\tself.ignore_whitespace = ignore_whitespace;\n\t\tself\n\t}\n\n\tpub fn set_word_pred (\u0026 mut self, word_pred: fn (char) -\u003e bool) -\u003e \u0026 mut Self {\n\t\tself.word_pred = word_pred;\n\t\tself\n\t}\n\n\tpub fn expect (\u0026 mut self, expect: \u0026 str) -\u003e ParseResult \u003c\u0026 mut Self\u003e {\n\t\tfor expect_char in expect.chars () {\n\t\t\tif self.peek () != Some (expect_char) { Err (self.err ()) ? }\n\t\t\tself.next ();\n\t\t}\n\t\tOk (self)\n\t}\n\n\tpub fn expect_word (\u0026 mut self, expect: \u0026 str) -\u003e ParseResult \u003c\u0026 mut Self\u003e {\n\t\tif self.word () ? != expect { Err (self.err ()) ? }\n\t\tOk (self)\n\t}\n\n\tpub fn int \u003cIntType\u003e (\u0026 mut self) -\u003e ParseResult \u003cIntType\u003e where IntType: FromStr {\n\t\tif self.ignore_whitespace { self.skip_whitespace (); }\n\t\tlet len = self.input.chars ().enumerate ()\n\t\t\t.take_while (|\u0026 (idx, letter)|\n\t\t\t\tletter.is_ascii_digit () || (idx == 0 \u0026\u0026 (letter == '-' || letter == '+')))\n\t\t\t.map (|(_, letter)| letter.len_utf8 ())\n\t\t\t.sum ();\n\t\tlet val = self.input [0 .. len].parse ().map_err (|_| self.err ()) ?;\n\t\tself.input = \u0026 self.input [len .. ];\n\t\tif self.ignore_whitespace { self.skip_whitespace (); }\n\t\tOk (val)\n\t}\n\n\tpub fn word \u003c'b\u003e (\u0026 'b mut self) -\u003e ParseResult \u003c\u0026 'inp str\u003e {\n\t\tif self.ignore_whitespace { self.skip_whitespace (); }\n\t\tlet input_temp = self.input;\n\t\tlet start = self.pos;\n\t\twhile let Some (letter) = self.peek () {\n\t\t\tif ! (self.word_pred) (letter) { break }\n\t\t\tself.next ().unwrap ();\n\t\t}\n\t\tlet end = self.pos;\n\t\tif start == end { Err (self.err ()) ? }\n\t\tif self.ignore_whitespace { self.skip_whitespace (); }\n\t\tOk (\u0026 input_temp [ .. end - start])\n\t}\n\n\tpub fn word_into \u003c'b, Output\u003e (\u0026 'b mut self) -\u003e ParseResult \u003cOutput\u003e\n\t\t\twhere Output: TryFrom \u003c\u0026 'b str, Error = GenError\u003e {\n\t\tOk (self.word () ?.try_into () ?)\n\t}\n\n\tpub fn word_if \u003c'b, PredFn\u003e (\u0026 'b mut self, pred: PredFn) -\u003e ParseResult \u003c\u0026 'inp str\u003e\n\t\t\twhere PredFn: Fn (\u0026 'inp str) -\u003e bool {\n\t\tlet word = self.word () ?;\n\t\tif ! pred (word) { Err (self.err ()) ?; }\n\t\tOk (word)\n\t}\n\n\tpub fn peek_word (\u0026 mut self) -\u003e Option \u003c\u0026 'inp str\u003e {\n\t\tself.clone ().word ().ok ()\n\t}\n\n\tpub fn skip_whitespace (\u0026 mut self) -\u003e \u0026 mut Self {\n\t\twhile let Some (letter) = self.peek () {\n\t\t\tif ! letter.is_whitespace () { break }\n\t\t\tself.next ().unwrap ();\n\t\t}\n\t\tself\n\t}\n\n\tpub fn end (\u0026 mut self) -\u003e ParseResult \u003c()\u003e {\n\t\tif self.peek ().is_some () { Err (self.err ()) ? }\n\t\tOk (())\n\t}\n\n\t#[ allow (clippy::should_implement_trait) ]\n\tpub fn next (\u0026 mut self) -\u003e Option \u003cchar\u003e {\n\t\tlet letter_opt = self.input.chars ().next ();\n\t\tif let Some (letter) = letter_opt {\n\t\t\tself.input = \u0026 self.input [letter.len_utf8 () .. ];\n\t\t\tself.pos += letter.len_utf8 ();\n\t\t}\n\t\tletter_opt\n\t}\n\n\tpub fn peek (\u0026 mut self) -\u003e Option \u003cchar\u003e {\n\t\tself.input.chars ().next ()\n\t}\n\n\tpub fn expect_next (\u0026 mut self) -\u003e ParseResult \u003cchar\u003e {\n\t\tself.next ().ok_or_else (|| self.err ())\n\t}\n\n\tpub fn err (\u0026 self) -\u003e ParseError {\n\t    ParseError::Simple (self.pos)\n\t}\n\n\tpub fn any \u003cItem\u003e (\u0026 mut self) -\u003e ParserAny \u003c'_, 'inp, Item\u003e {\n\t\tParserAny::Parser (self)\n\t}\n\n\tpub fn wrap \u003cOutput, WrapFn\u003e (input: \u0026 str, mut wrap_fn: WrapFn) -\u003e ParseResult \u003cOutput\u003e\n\t\t\twhere WrapFn: FnMut (\u0026 mut Parser) -\u003e ParseResult \u003cOutput\u003e {\n\t\tlet mut parser = Parser::new (input);\n\t\twrap_fn (\u0026 mut parser)\n\t}\n\n}\n\npub enum ParserAny \u003c'par, 'inp, Item\u003e {\n\tParser (\u0026 'par mut Parser \u003c'inp\u003e),\n\tItem (Item),\n\tConfirmedError (ParseError),\n}\n\nimpl \u003c'par, 'inp, Item\u003e ParserAny \u003c'par, 'inp, Item\u003e {\n\n\tpub fn of \u003cOfFn\u003e (self, mut of_fn: OfFn) -\u003e Self\n\t\t\twhere OfFn: FnMut (\u0026 mut Parser \u003c'inp\u003e) -\u003e ParseResult \u003cItem\u003e {\n\t\tmatch self {\n\t\t\tParserAny::Parser (parser) =\u003e {\n\t\t\t\tlet mut sub_parser = Parser { confirmed: false, .. * parser };\n\t\t\t\tmatch of_fn (\u0026 mut sub_parser) {\n\t\t\t\t\tOk (item) =\u003e {\n\t\t\t\t\t\tparser.input = sub_parser.input;\n\t\t\t\t\t\tparser.pos = sub_parser.pos;\n\t\t\t\t\t\tParserAny::Item (item)\n\t\t\t\t\t},\n\t\t\t\t\tErr (err) =\u003e\n\t\t\t\t\t\tif sub_parser.confirmed { ParserAny::ConfirmedError (err) }\n\t\t\t\t\t\telse { ParserAny::Parser (parser) },\n\t\t\t\t}\n\t\t\t},\n\t\t\tParserAny::Item (item) =\u003e ParserAny::Item (item),\n\t\t\tParserAny::ConfirmedError (err) =\u003e ParserAny::ConfirmedError (err),\n\t\t}\n\t}\n\n\tpub fn done (self) -\u003e ParseResult \u003cItem\u003e {\n\t\tmatch self {\n\t\t\tParserAny::Parser (parser) =\u003e Err (parser.err ()),\n\t\t\tParserAny::Item (item) =\u003e Ok (item),\n\t\t\tParserAny::ConfirmedError (err) =\u003e Err (err),\n\t\t}\n\t}\n\n}\n","traces":[{"line":28,"address":[65008,65318],"length":1,"stats":{"Line":30},"fn_name":"map_parse_err\u003c(u32, u32, u32), aoc_2015_day_02::model::parse_input::{closure#0}::{closure_env#1}, alloc::string::String\u003e"},{"line":32,"address":[],"length":0,"stats":{"Line":36},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":30},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":12},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[427184],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":42,"address":[427217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[427236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[427385,427248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[427275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[427349,427287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[427342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[427552],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":57,"address":[427568],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[427600],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":63,"address":[427650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[83952,84621],"length":1,"stats":{"Line":27},"fn_name":"int\u003cu32\u003e"},{"line":108,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":80},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":39},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":54},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":37},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":27},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[178075,177456],"length":1,"stats":{"Line":2},"fn_name":"word_if\u003caoc_2015_day_07::model::{impl#2}::parse_real::{closure_env#0}\u003e"},{"line":141,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":189,"address":[85034,84944],"length":1,"stats":{"Line":28},"fn_name":"wrap\u003c(u32, u32, u32), aoc_2015_day_02::model::parse_input::{closure#0}::{closure_env#0}\u003e"},{"line":191,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":28},"fn_name":null},{"line":205,"address":[77792,78793,79833,80912,78832,81913,80873,79872],"length":1,"stats":{"Line":24},"fn_name":"of\u003caoc_2015_day_12::model::Json, aoc_2015_day_12::model::{impl#0}::parse::parse_item::{closure_env#0}\u003e"},{"line":207,"address":[],"length":0,"stats":{"Line":24},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":23},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":46},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":20},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":38},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":19},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":42,"coverable":107},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","pos.rs"],"content":"use super::*;\nuse nums::Int;\n\npub use coord::Coord;\npub use dim_2::PosXY;\npub use dim_2::PosYX;\npub use dim_2::PosGeo;\npub use dim_2::PosRowCol;\npub use dim_3::PosXYZ;\n\nmacro_rules! pos_ops {\n\n\t( $name:ident : Debug $(, $rest:tt)* ) =\u003e {\n\t\timpl \u003cVal: Int\u003e Debug for $name \u003cVal\u003e {\n\t\t\tfn fmt (\u0026 self, formatter: \u0026 mut fmt::Formatter) -\u003e fmt::Result {\n\t\t\t\tlet self_coords = self.coord_to_array ();\n\t\t\t\tformatter.write_str (\"PosXYZ (\") ?;\n\t\t\t\tfor idx in 0 .. self_coords.len () {\n\t\t\t\t\tif idx != 0 { formatter.write_str (\", \") ?; }\n\t\t\t\t\tDebug::fmt (\u0026 self_coords [idx], formatter) ?;\n\t\t\t\t}\n\t\t\t\tformatter.write_str (\")\") ?;\n\t\t\t\tOk (())\n\t\t\t}\n\t\t}\n\t\tpos_ops! ($name: $($rest),*);\n\t};\n\t( $name:ident : Add $(, $rest:tt)* ) =\u003e {\n\t\timpl \u003cVal: Int\u003e Add \u003c$name \u003cVal::Signed\u003e\u003e for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\tfn add (self, other: $name \u003cVal::Signed\u003e) -\u003e Self {\n\t\t\t\tlet self_coords = self.coord_to_array ();\n\t\t\t\tlet other_coords = other.coord_to_array ();\n\t\t\t\tlet mut result_coords = Self::ZERO.coord_to_array ();\n\t\t\t\tfor idx in 0 .. self_coords.len () {\n\t\t\t\t\tresult_coords [idx] =\n\t\t\t\t\t\tself_coords [idx].add_signed (other_coords [idx]).unwrap ();\n\t\t\t\t}\n\t\t\t\tSelf::coord_from_array (result_coords)\n\t\t\t}\n\t\t}\n\t\tpos_ops! ($name: $($rest),*);\n\t};\n\t( $name:ident : Neg $(, $rest:tt)* ) =\u003e {\n\t\timpl \u003cVal: Int + Neg \u003cOutput = Val\u003e\u003e Neg for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\tfn neg (self) -\u003e Self {\n\t\t\t\tlet self_coords = self.coord_to_array ();\n\t\t\t\tlet mut result_coords = Self::ZERO.coord_to_array ();\n\t\t\t\tfor idx in 0 .. self_coords.len () {\n\t\t\t\t\tresult_coords [idx] = - self_coords [idx];\n\t\t\t\t}\n\t\t\t\tSelf::coord_from_array (result_coords)\n\t\t\t}\n\t\t}\n\t\tpos_ops! ($name: $($rest),*);\n\t};\n\t( $name:ident : Rem $(, $rest:tt)* ) =\u003e {\n\t\timpl \u003cVal: Int\u003e Rem for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\tfn rem (self, other: $name \u003cVal\u003e) -\u003e Self {\n\t\t\t\tlet self_coords = self.coord_to_array ();\n\t\t\t\tlet other_coords = other.coord_to_array ();\n\t\t\t\tlet mut result_coords = Self::ZERO.coord_to_array ();\n\t\t\t\tfor idx in 0 .. self_coords.len () {\n\t\t\t\t\tresult_coords [idx] = self_coords [idx] % other_coords [idx];\n\t\t\t\t}\n\t\t\t\tSelf::coord_from_array (result_coords)\n\t\t\t}\n\t\t}\n\t\tpos_ops! ($name: $($rest),*);\n\t};\n\t( $name:ident : Sub $(, $rest:tt)* ) =\u003e {\n\t\timpl \u003cVal: Int\u003e Sub \u003c$name \u003cVal::Signed\u003e\u003e for $name \u003cVal\u003e {\n\t\t\ttype Output = Self;\n\t\t\tfn sub (self, other: $name \u003cVal::Signed\u003e) -\u003e Self {\n\t\t\t\tlet self_coords = self.coord_to_array ();\n\t\t\t\tlet other_coords = other.coord_to_array ();\n\t\t\t\tlet mut result_coords = Self::ZERO.coord_to_array ();\n\t\t\t\tfor idx in 0 .. self_coords.len () {\n\t\t\t\t\tresult_coords [idx] =\n\t\t\t\t\t\tself_coords [idx].sub_signed (other_coords [idx]).unwrap ();\n\t\t\t\t}\n\t\t\t\tSelf::coord_from_array (result_coords)\n\t\t\t}\n\t\t}\n\t\tpos_ops! ($name: $($rest),*);\n\t};\n\t( $name:ident : ) =\u003e {};\n\n}\n\nmod coord {\n\n\tuse super::*;\n\n\tpub trait Coord \u003cconst DIMS: usize\u003e: Copy + Debug + Sized {\n\t\ttype Val: Int;\n\t\ttype Signed;\n\t\tfn coord_to_array (self) -\u003e [Self::Val; DIMS];\n\t\tfn coord_from_array (array: [Self::Val; DIMS]) -\u003e Self;\n\t\tfn zero (self) -\u003e Self { Self::coord_from_array ([Self::Val::ZERO; DIMS]) }\n\t}\n\n}\n\nmod dim_2 {\n\n\tuse super::*;\n\n\tpub use geo::PosGeo;\n\tpub use row_col::PosRowCol;\n\tpub use xy::PosXY;\n\tpub use yx::PosYX;\n\n\tmod xy {\n\n\t\tuse super::*;\n\n\t\t#[ derive (Clone, Copy, Default, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct PosXY \u003cVal\u003e { pub x: Val, pub y: Val }\n\n\t\timpl \u003cVal: Int\u003e PosXY \u003cVal\u003e {\n\t\t\tpub const ZERO: Self = PosXY { x: Int::ZERO, y: Int::ZERO };\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cPosXY \u003cVal\u003e, 4\u003e {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet (x, y) = (self.x, self.y);\n\t\t\t\tif self.x \u003e Val::MIN { result.push (PosXY { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (PosXY { x: x + Val::ONE, y }); }\n\t\t\t\tif self.y \u003e Val::MIN { result.push (PosXY { x, y: y - Val::ONE }); }\n\t\t\t\tif self.y \u003c Val::MAX { result.push (PosXY { x, y: y + Val::ONE }); }\n\t\t\t\tresult\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Coord \u003c2\u003e for PosXY \u003cVal\u003e {\n\t\t\ttype Val = Val;\n\t\t\ttype Signed = PosXY \u003cVal::Signed\u003e;\n\t\t\tfn coord_to_array (self) -\u003e [Val; 2] { [ self.x, self.y ] }\n\t\t\tfn coord_from_array (arr: [Val; 2]) -\u003e PosXY \u003cVal\u003e { PosXY { x: arr [0], y: arr [1] } }\n\t\t}\n\n\t\tpos_ops! (PosXY: Debug);\n\t\tpos_ops! (PosXY: Add, Neg, Sub, Rem);\n\n\t}\n\n\tmod yx {\n\n\t\tuse super::*;\n\n\t\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct PosYX \u003cVal\u003e { pub y: Val, pub x: Val }\n\n\t\timpl \u003cVal: Int\u003e PosYX \u003cVal\u003e {\n\t\t\tpub const ZERO: Self = Self::zero ();\n\t\t\tpub const fn zero () -\u003e Self { Self { y: Val::ZERO, x: Val::ZERO } }\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cPosYX \u003cVal\u003e, 4\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet PosYX { y, x } = * self;\n\t\t\t\tif self.y \u003e Val::MIN { result.push (PosYX { x, y: y - Val::ONE }); }\n\t\t\t\tif self.y \u003c Val::MAX { result.push (PosYX { x, y: y + Val::ONE }); }\n\t\t\t\tif self.x \u003e Val::MIN { result.push (PosYX { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (PosYX { x: x + Val::ONE, y }); }\n\t\t\t\tresult\n\t\t\t}\n\t\t\tpub fn adjacent_8 (\u0026 self) -\u003e ArrayVec \u003cPosYX \u003cVal\u003e, 8\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet PosYX { y, x } = * self;\n\t\t\t\tif self.y \u003e Val::MIN {\n\t\t\t\t\tlet y = y - Val::ONE;\n\t\t\t\t\tif self.x \u003e Val::MIN { result.push (PosYX { x: x - Val::ONE, y }); }\n\t\t\t\t\tresult.push (PosYX { x, y });\n\t\t\t\t\tif self.x \u003c Val::MAX { result.push (PosYX { x: x + Val::ONE, y }); }\n\t\t\t\t}\n\t\t\t\tif self.x \u003e Val::MIN { result.push (PosYX { x: x - Val::ONE, y }); }\n\t\t\t\tif self.x \u003c Val::MAX { result.push (PosYX { x: x + Val::ONE, y }); }\n\t\t\t\tif self.y \u003c Val::MAX {\n\t\t\t\t\tlet y = y + Val::ONE;\n\t\t\t\t\tif self.x \u003e Val::MIN { result.push (PosYX { x: x - Val::ONE, y }); }\n\t\t\t\t\tresult.push (PosYX { x, y });\n\t\t\t\t\tif self.x \u003c Val::MAX { result.push (PosYX { x: x + Val::ONE, y }); }\n\t\t\t\t}\n\t\t\t\tresult\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Coord \u003c2\u003e for PosYX \u003cVal\u003e {\n\t\t\ttype Val = Val;\n\t\t\ttype Signed = PosYX \u003cVal::Signed\u003e;\n\t\t\tfn coord_to_array (self) -\u003e [Val; 2] {\n\t\t\t\t[ self.x, self.y ]\n\t\t\t}\n\t\t\tfn coord_from_array (arr: [Val; 2]) -\u003e PosYX \u003cVal\u003e {\n\t\t\t\tPosYX { y: arr [0], x: arr [1] }\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! (PosYX: Debug);\n\t\tpos_ops! (PosYX: Add, Neg, Rem, Sub);\n\n\t}\n\n\tmod geo {\n\n\t\tuse super::*;\n\n\t\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct PosGeo \u003cVal\u003e { pub n: Val, pub e: Val }\n\n\t\timpl \u003cVal: Int\u003e PosGeo \u003cVal\u003e {\n\t\t\tpub const ZERO: Self = PosGeo { n: Val::ZERO, e: Val::ZERO };\n\t\t\tpub fn north (\u0026 self, num: Val) -\u003e Self {\n\t\t\t\tPosGeo { n: self.n.safe_add (num), e: self.e }\n\t\t\t}\n\t\t\tpub fn south (\u0026 self, num: Val) -\u003e Self {\n\t\t\t\tPosGeo { n: self.n.safe_sub (num), e: self.e }\n\t\t\t}\n\t\t\tpub fn east (\u0026 self, num: Val) -\u003e Self {\n\t\t\t\tPosGeo { n: self.n, e: self.e.safe_add (num) }\n\t\t\t}\n\t\t\tpub fn west (\u0026 self, num: Val) -\u003e Self {\n\t\t\t\tPosGeo { n: self.n, e: self.e.safe_sub (num) }\n\t\t\t}\n\t\t\tpub fn adjacent_4 (\u0026 self) -\u003e ArrayVec \u003cSelf, 4\u003e where Val: Int {\n\t\t\t\tlet mut result = ArrayVec::new ();\n\t\t\t\tlet PosGeo { n, e } = * self;\n\t\t\t\tif n \u003e Val::MIN { result.push (PosGeo { n: n - Val::ONE, e }); }\n\t\t\t\tif n \u003c Val::MAX { result.push (PosGeo { n: n + Val::ONE, e }); }\n\t\t\t\tif e \u003e Val::MIN { result.push (PosGeo { n, e: e - Val::ONE }); }\n\t\t\t\tif e \u003c Val::MAX { result.push (PosGeo { n, e: e + Val::ONE }); }\n\t\t\t\tresult\n\t\t\t}\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Coord \u003c2\u003e for PosGeo \u003cVal\u003e {\n\t\t\ttype Val = Val;\n\t\t\ttype Signed = PosGeo \u003cVal::Signed\u003e;\n\t\t\tfn coord_to_array (self) -\u003e [Val; 2] {\n\t\t\t\t[ self.n, self.e ]\n\t\t\t}\n\t\t\tfn coord_from_array (arr: [Val; 2]) -\u003e PosGeo \u003cVal\u003e {\n\t\t\t\tPosGeo { n: arr [0], e: arr [1] }\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! (PosGeo: Debug);\n\t\tpos_ops! (PosGeo: Add, Neg, Rem, Sub);\n\n\t}\n\n\tmod row_col {\n\n\t\tuse super::*;\n\n\t\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct PosRowCol \u003cVal\u003e { pub row: Val, pub col: Val }\n\n\t\timpl \u003cVal: Int\u003e PosRowCol \u003cVal\u003e {\n\t\t\tpub const ZERO: Self = Self::zero ();\n\t\t\tpub const fn zero () -\u003e Self { Self { row: Val::ZERO, col: Val::ZERO } }\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Coord \u003c2\u003e for PosRowCol \u003cVal\u003e {\n\t\t\ttype Val = Val;\n\t\t\ttype Signed = PosRowCol \u003cVal::Signed\u003e;\n\t\t\tfn coord_to_array (self) -\u003e [Val; 2] {\n\t\t\t\t[ self.row, self.col ]\n\t\t\t}\n\t\t\tfn coord_from_array (arr: [Val; 2]) -\u003e PosRowCol \u003cVal\u003e {\n\t\t\t\tPosRowCol { row: arr [0], col: arr [1] }\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! (PosRowCol: Debug);\n\t\tpos_ops! (PosRowCol: Add, Neg, Rem, Sub);\n\n\t}\n\n}\n\nmod dim_3 {\n\n\tuse super::*;\n\n\tpub use xyz::PosXYZ;\n\n\tmod xyz {\n\n\t\tuse super::*;\n\n\t\t#[ derive (Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd) ]\n\t\tpub struct PosXYZ \u003cVal\u003e { pub x: Val, pub y: Val, pub z: Val }\n\n\t\timpl \u003cVal: Int\u003e PosXYZ \u003cVal\u003e {\n\t\t\tpub const ZERO: Self = PosXYZ { x: Val::ZERO, y: Val::ZERO, z: Val::ZERO };\n\t\t\tpub const MAX: Self = PosXYZ { x: Val::MAX, y: Val::MAX, z: Val::MAX };\n\t\t\tpub const MIN: Self = PosXYZ { x: Val::MIN, y: Val::MIN, z: Val::MIN };\n\t\t\tpub const fn zero () -\u003e Self { PosXYZ { x: Val::ZERO, y: Val::ZERO, z: Val::ZERO } }\n\t\t\tpub fn max () -\u003e Self { PosXYZ { x: Val::MAX, y: Val::MAX, z: Val::MAX } }\n\t\t}\n\n\t\timpl \u003cVal: Int\u003e Coord \u003c3\u003e for PosXYZ \u003cVal\u003e {\n\t\t\ttype Val = Val;\n\t\t\ttype Signed = PosGeo \u003cVal::Signed\u003e;\n\t\t\tfn coord_to_array (self) -\u003e [Val; 3] {\n\t\t\t\t[ self.x, self.y, self.z ]\n\t\t\t}\n\t\t\tfn coord_from_array (arr: [Val; 3]) -\u003e PosXYZ \u003cVal\u003e {\n\t\t\t\tPosXYZ { x: arr [0], y: arr [1], z: arr [2] }\n\t\t\t}\n\t\t}\n\n\t\tpos_ops! (PosXYZ: Debug);\n\t\tpos_ops! (PosXYZ: Add, Neg, Rem, Sub);\n\n\t}\n\n}\n","traces":[{"line":15,"address":[35888],"length":1,"stats":{"Line":0},"fn_name":"fmt\u003ci16\u003e"},{"line":16,"address":[35919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[36065,35957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[36193,36019,36111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[36211,36240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[36222,36336],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[36166,36459,36505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[36495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[85872],"length":1,"stats":{"Line":6},"fn_name":"add\u003ci16\u003e"},{"line":32,"address":[85933],"length":1,"stats":{"Line":6},"fn_name":null},{"line":33,"address":[85972],"length":1,"stats":{"Line":6},"fn_name":null},{"line":34,"address":[86001],"length":1,"stats":{"Line":6},"fn_name":null},{"line":35,"address":[86392,86041,86177],"length":1,"stats":{"Line":18},"fn_name":null},{"line":36,"address":[86365,86402],"length":1,"stats":{"Line":6},"fn_name":null},{"line":37,"address":[86195],"length":1,"stats":{"Line":6},"fn_name":null},{"line":39,"address":[86145],"length":1,"stats":{"Line":6},"fn_name":null},{"line":47,"address":[211648],"length":1,"stats":{"Line":2},"fn_name":"neg\u003ci16\u003e"},{"line":48,"address":[211691],"length":1,"stats":{"Line":2},"fn_name":null},{"line":49,"address":[211777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":50,"address":[212199,211872,212082],"length":1,"stats":{"Line":6},"fn_name":null},{"line":51,"address":[212103,212209],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[211979],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[207600],"length":1,"stats":{"Line":2},"fn_name":"sub\u003ci16\u003e"},{"line":77,"address":[207679],"length":1,"stats":{"Line":2},"fn_name":null},{"line":78,"address":[207765],"length":1,"stats":{"Line":2},"fn_name":null},{"line":79,"address":[207851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":80,"address":[208389,208171,207946],"length":1,"stats":{"Line":6},"fn_name":null},{"line":81,"address":[208362,208399],"length":1,"stats":{"Line":2},"fn_name":null},{"line":82,"address":[208192],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[208068],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[42672,43208],"length":1,"stats":{"Line":1},"fn_name":"adjacent_4\u003ci16\u003e"},{"line":159,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[47184,48252],"length":1,"stats":{"Line":1},"fn_name":"adjacent_8\u003cu16\u003e"},{"line":168,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[206513,206512],"length":1,"stats":{"Line":4},"fn_name":"zero\u003ci16\u003e"},{"line":306,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":65,"coverable":94},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","puzzle.rs"],"content":"use std::fs::File;\nuse std::io;\nuse std::io::BufRead as _;\nuse std::io::BufReader;\nuse std::io::Write as _;\nuse std::path::PathBuf;\n\nuse super::*;\nuse nums::IntConv;\n\npub struct RunStats {\n\tnum_correct: usize,\n\tnum_incorrect: usize,\n\tnum_unknown: usize,\n}\n\npub fn run_year_and_exit (\n\tpuzzles: \u0026 [Box \u003cdyn Puzzle\u003e],\n\trequire_answers: bool,\n) -\u003e GenResult \u003c()\u003e {\n\tlet stats = run_year (puzzles) ?;\n\tlet num_errors =\n\t\tif require_answers { stats.num_incorrect + stats.num_unknown }\n\t\telse { stats.num_incorrect };\n\tstd::process::exit (\n\t\tif num_errors == 0 { 0 }\n\t\telse { 1 });\n}\n\npub fn run_year (puzzles: \u0026 [Box \u003cdyn Puzzle\u003e]) -\u003e GenResult \u003cRunStats\u003e {\n\n\tlet flush = || io::stdout ().flush ().unwrap ();\n\n\tlet mut stats = RunStats {\n\t\tnum_correct: 0,\n\t\tnum_incorrect: 0,\n\t\tnum_unknown: 0,\n\t};\n\n\t// work out max name length\n\n\tlet name_len =\n\t\tpuzzles.iter ()\n\t\t\t.map (|puzzle| puzzle.name ().len ())\n\t\t\t.max ()\n\t\t\t.unwrap ();\n\n\t// load answers\n\n\tlet answers_path = PathBuf::from (\n\t\tformat! (\"{}/inputs/answers\", puzzles [0].year ()));\n\n\tlet answers: HashMap \u003c(u8, u8), String\u003e =\n\t\tif answers_path.exists () {\n\t\t\tBufReader::new (File::open (answers_path) ?)\n\t\t\t\t.lines ()\n\t\t\t\t.map (move |line| {\n\t\t\t\t\tlet line = line ?;\n\t\t\t\t\tlet line_parts: Vec \u003cString\u003e =\n\t\t\t\t\t\tline.split (' ')\n\t\t\t\t\t\t\t.map (str::to_string)\n\t\t\t\t\t\t\t.collect ();\n\t\t\t\t\tlet day: u8 = line_parts [0].parse::\u003cu8\u003e () ?;\n\t\t\t\t\tOk (\n\t\t\t\t\t\tline_parts.into_iter ()\n\t\t\t\t\t\t\t.skip (1)\n\t\t\t\t\t\t\t.enumerate ()\n\t\t\t\t\t\t\t.map (move |(idx, val)|\n\t\t\t\t\t\t\t\t((day, idx.as_u8 ()), val))\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t\t\t.flatten_ok ()\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?\n\t\t} else { HashMap::new () };\n\n\t// iterate puzzles\n\n\tfor puzzle in puzzles.iter () {\n\n\t\t// load input\n\n\t\tlet input_string = puzzle.load_input () ?;\n\t\tlet input_lines: Vec \u003c\u0026 str\u003e =\n\t\t\tinput_string.trim ().split ('\\n').collect ();\n\n\t\t// print day and puzzle name\n\n\t\tprint! (\n\t\t\t\"{day:02}  {name:name_len$}\",\n\t\t\tday = puzzle.day (),\n\t\t\tname = puzzle.name (),\n\t\t\tname_len = name_len);\n\n\t\t// start timer\n\n\t\tlet start_time = time::Instant::now ();\n\n\t\t// iterate over parts\n\n\t\tlet mut errors = Vec::new ();\n\t\tfor part in 0 .. 2 {\n\n\t\t\t// handle missing part\n\n\t\t\tif puzzle.num_parts () \u003c part + 1 {\n\t\t\t\tprint! (\"{:24}\", \"\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// print part name\n\n\t\t\tconst PART_NAMES: \u0026 [\u0026 str] = \u0026 [ \"One\", \"Two\" ];\n\t\t\tprint! (\"  {}: \", PART_NAMES [part]);\n\n\t\t\t// calculate result\n\n\t\t\tflush ();\n\n\t\t\tlet result =\n\t\t\t\tif part == 0 { puzzle.part_one (\u0026 input_lines) ? }\n\t\t\t\telse if part == 1 { puzzle.part_two (\u0026 input_lines) ? }\n\t\t\t\telse { panic! () };\n\n\t\t\t// check against answers\n\n\t\t\tif let Some (answer) = answers.get (\u0026 (puzzle.day (), part.as_u8 ())) {\n\t\t\t\tif \u0026 result == answer {\n\t\t\t\t\tstats.num_correct += 1;\n\t\t\t\t} else if \u0026 result != answer {\n\t\t\t\t\tstats.num_incorrect += 1;\n\t\t\t\t\terrors.push (format! (\n\t\t\t\t\t\t\"Part {part}: Expected {answer:?}, but calculated {result:?}\",\n\t\t\t\t\t\tpart = part + 1,\n\t\t\t\t\t\tanswer = answer,\n\t\t\t\t\t\tresult = result));\n\t\t\t\t}\n\t\t\t} else { stats.num_unknown += 1; }\n\n\t\t\t// print result\n\n\t\t\tprint! (\"{:17}\", result);\n\n\t\t}\n\n\t\t// print duration\n\n\t\tlet end_time = time::Instant::now ();\n\t\tlet duration = end_time - start_time;\n\n\t\tprint! (\n\t\t\t\"Time: {millis:\u003e4}.{micros:02}ms\\n\",\n\t\t\tmillis = duration.as_millis (),\n\t\t\tmicros = (duration.as_micros () % 1000) / 10);\n\n\t\t// print errors\n\n\t\tfor error in errors {\n\t\t\tprint! (\"  {}\\n\", error);\n\t\t}\n\n\t}\n\n\tOk (stats)\n\n}\n\nfn puzzle_invoke_real (\n\tpuzzle: \u0026 dyn Puzzle,\n\targs: \u0026 [OsString],\n) -\u003e GenResult \u003c()\u003e {\n\tlet mut command = Command::new (format! (\"aoc-{}-day-{}\", puzzle.year (), puzzle.day ()));\n\tfor part_num in 1 ..= puzzle.num_parts () {\n\t\tcommand = command.subcommand (\n\t\t\tCommand::new (format! (\"part-{}\", part_num))\n\t\t\t\t.arg (\n\t\t\t\t\tclap::Arg::new (\"repeat\")\n\t\t\t\t\t\t.long (\"repeat\")\n\t\t\t\t\t\t.value_parser (clap::value_parser! (u64).range (1 .. ))\n\t\t\t\t\t\t.takes_value (true)\n\t\t\t\t\t\t.default_value (\"1\")\n\t\t\t\t\t\t.help (\"Number of times to repeat the calculation\"))\n\t\t);\n\t}\n\tfor puzzle_command in puzzle.commands () {\n\t\tcommand = command.subcommand (\n\t\t\tpuzzle_command.command ()\n\t\t\t\t.name (puzzle_command.name ())\n\t\t);\n\t}\n\tlet matches = command.get_matches_from (args);\n\tlet input_string = puzzle.load_input () ?;\n\tlet input_lines: Vec \u003c\u0026 str\u003e = input_string.trim ().split ('\\n').collect ();\n\tuse time::Instant;\n\tfn percentile (times: \u0026 [u64], num: u64, denom: u64) -\u003e u64 {\n\t\tlet size = times.len ().as_u64 () - 1;\n\t\tlet idx: u64 = num * size / denom;\n\t\tlet rem = num * size % denom;\n\t\tif rem == 0 { return times [idx.as_usize ()] }\n\t\ttimes [idx.as_usize ()] * (denom - rem) / denom\n\t\t\t+ times [idx.as_usize () + 1] * rem / denom\n\t}\n\tfn runner \u003cInnerFn: Fn (u64) -\u003e GenResult \u003c()\u003e\u003e (repeat: u64, inner_fn: InnerFn) -\u003e GenResult \u003c()\u003e {\n\t\tlet times = {\n\t\t\tlet mut times: Vec \u003c_\u003e = (0 .. repeat)\n\t\t\t\t.map (|idx| { inner_fn (idx) ?; Ok (Instant::now ()) })\n\t\t\t\t.scan (Instant::now (), |state, cur|\n\t\t\t\t\tSome (cur.map (|cur| cur - mem::replace (state, cur))))\n\t\t\t\t.map_ok (|duration| duration.as_micros ().as_u64 ())\n\t\t\t\t.collect::\u003cGenResult \u003c_\u003e\u003e () ?;\n\t\t\ttimes.sort ();\n\t\t\ttimes\n\t\t};\n\t\tif repeat == 1 { return Ok (()) }\n\t\tlet total = times.iter ().map (|\u0026 val| val.as_u128 ()).sum::\u003cu128\u003e ();\n\t\tlet mean = (total / repeat.as_u128 ()).as_u64 ();\n\t\tlet disp_float = |val, ref_val|\n\t\t\tif ref_val \u003e= 2_000_000.0 { format! (\"{:.3}s\", val / 1_000_000.0) }\n\t\t\telse if ref_val \u003e= 2_000.0 { format! (\"{:.3}ms\", val / 1_000.0) }\n\t\t\telse { format! (\"{:.0}s\", val) };\n\t\tlet disp = |val: u128| disp_float (val.as_f64 (), val.as_f64 ());\n\t\tlet disp_mean = |val: u64| disp_float (val.as_f64 (), mean.as_f64 ());\n\t\tlet disp_pc = |pc| disp_float (percentile (\u0026 times, pc, 1000).as_f64 (), mean.as_f64 ());\n\t\tprint! (\"Statistics: total={} count={} mean={},\", disp (total), repeat, disp_mean (mean));\n\t\tconst PERCENTILE_OPTIONS: \u0026 [(u64, \u0026 [u64])] = \u0026 [\n\t\t\t(1000, \u0026 [0, 500, 900, 990, 999, 1000]),\n\t\t\t(100, \u0026 [0, 500, 900, 990, 1000]),\n\t\t\t(25, \u0026 [0, 500, 750, 900, 1000]),\n\t\t\t(10, \u0026 [0, 500, 900, 1000]),\n\t\t\t(0, \u0026 []),\n\t\t];\n\t\tfor (min_repeat, percentiles) in PERCENTILE_OPTIONS.iter ().copied () {\n\t\t\tif repeat \u003c min_repeat * 2 { continue }\n\t\t\tfor percentile in percentiles.iter ().copied () {\n\t\t\t\tif percentile % 10 == 0 {\n\t\t\t\t\tprint! (\" p{}={}\", percentile / 10, disp_pc (percentile));\n\t\t\t\t} else {\n\t\t\t\t\tprint! (\" p{}={}\", percentile.as_f64 () / 10.0, disp_pc (percentile));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif percentiles.is_empty () {\n\t\t\t\tprint! (\" min={} median={} max={}\", disp_pc (0), disp_pc (500), disp_pc (1000));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tprint! (\"\\n\");\n\t\tOk (())\n\t}\n\tmatch matches.subcommand () {\n\t\tNone =\u003e {\n\t\t\tlet result = puzzle.part_one (\u0026 input_lines) ?;\n\t\t\tprintln! (\"Part one: {}\", result);\n\t\t\tif puzzle.num_parts () \u003e= 2 {\n\t\t\t\tlet result = puzzle.part_two (\u0026 input_lines) ?;\n\t\t\t\tprintln! (\"Part two: {}\", result);\n\t\t\t}\n\t\t},\n\t\tSome ((\"part-1\", matches)) =\u003e {\n\t\t\tlet repeat: u64 = * matches.get_one (\"repeat\").unwrap ();\n\t\t\trunner (repeat, |idx| {\n\t\t\t\tlet result = puzzle.part_one (\u0026 input_lines) ?;\n\t\t\t\tif idx == 0 { println! (\"Result: {}\", result); }\n\t\t\t\tOk (())\n\t\t\t}) ?;\n\t\t},\n\t\tSome ((\"part-2\", matches)) =\u003e {\n\t\t\tlet repeat: u64 = * matches.get_one (\"repeat\").unwrap ();\n\t\t\trunner (repeat, |idx| {\n\t\t\t\tlet result = puzzle.part_two (\u0026 input_lines) ?;\n\t\t\t\tif idx == 0 { println! (\"Result: {}\", result); }\n\t\t\t\tOk (())\n\t\t\t}) ?;\n\t\t},\n\t\tSome ((name, matches)) =\u003e {\n\t\t\tfor puzzle_command in puzzle.commands () {\n\t\t\t\tif puzzle_command.name () == name {\n\t\t\t\t\treturn puzzle_command.invoke (matches);\n\t\t\t\t}\n\t\t\t}\n\t\t\tunreachable! ();\n\t\t},\n\t}\n\tOk (())\n}\n\npub trait Puzzle {\n\n\tfn dyn_puzzle (\u0026 self) -\u003e \u0026 dyn Puzzle;\n\n\tfn name (\u0026 self) -\u003e \u0026 'static str;\n\tfn year (\u0026 self) -\u003e u16;\n\tfn day (\u0026 self) -\u003e u8;\n\tfn part_one (\u0026 self, _lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e { unimplemented! () }\n\tfn part_two (\u0026 self, _lines: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e { unimplemented! () }\n\tfn num_parts (\u0026 self) -\u003e usize;\n\n\tfn commands (\u0026 self) -\u003e Vec \u003cPuzzleCommand\u003e { Vec::new () }\n\n\tfn set_default_params (\u0026 mut self) { }\n\tfn set_param_real (\u0026 mut self, name: String, value: String);\n\tfn set_param (\u0026 mut self, name: \u0026 str, value: String) {\n\t\tself.set_param_real (name.to_string (), value);\n\t}\n\n\tfn invoke (\u0026 self, args: \u0026 [OsString]) -\u003e GenResult \u003c()\u003e {\n\t\tpuzzle_invoke_real (self.dyn_puzzle (), args)\n\t}\n\n\tfn load_input (\u0026 self) -\u003e GenResult \u003cString\u003e {\n\t\tlet input_path = [\n\t\t\tformat! (\"{:04}/inputs/day-{:02}\", self.year (), self.day ()),\n\t\t\tformat! (\"inputs/day-{:02}\", self.day ()),\n\t\t\tformat! (\"../inputs/day-{:02}\", self.day ()),\n\t\t].into_iter ()\n\t\t\t.find (|path| Path::new (path).exists ())\n\t\t\t.ok_or_else (|| format! (\n\t\t\t\t\"Unable to find inputs/day-{:02} in \\\"{:04}\\\", \\\".\\\" or \\\"..\\\"\",\n\t\t\t\tself.day (),\n\t\t\t\tself.year ())) ?;\n\t\tlet input_string = fs::read_to_string (input_path) ?;\n\t\tOk (input_string)\n\t}\n\n}\n\npub struct PuzzleCommand {\n\tname: \u0026 'static str,\n\tinvoke_fn: Box \u003cdyn Fn (\u0026 ArgMatches) -\u003e GenResult \u003c()\u003e\u003e,\n\tmagic: Box \u003cdyn MagicTrait\u003e,\n}\n\ntrait MagicTrait {\n\tfn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e;\n}\n\nstruct MagicStruct \u003cArgs\u003e {\n\tphantom: PhantomData \u003cArgs\u003e,\n}\n\nimpl \u003cArgs: clap::CommandFactory\u003e MagicTrait for MagicStruct \u003cArgs\u003e {\n\tfn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e { Args::command () }\n}\n\nimpl PuzzleCommand {\n\n\tpub fn new \u003c\n\t\tArgs: clap::Parser + 'static,\n\t\tInvokeFn: Fn (Args) -\u003e GenResult \u003c()\u003e + 'static,\n\t\u003e (\n\t\tname: \u0026 'static str,\n\t\tinvoke_fn: InvokeFn,\n\t) -\u003e PuzzleCommand {\n\n\t\tlet invoke_fn = Box::new (\n\t\t\tmove |matches: \u0026 _| invoke_fn (Args::from_arg_matches (matches).unwrap ()),\n\t\t);\n\n\t\tlet magic: Box \u003cMagicStruct \u003cArgs\u003e\u003e = Box::new (MagicStruct {\n\t\t\tphantom: PhantomData,\n\t\t});\n\n\t\tPuzzleCommand { name, invoke_fn, magic }\n\n\t}\n\n\tpub fn name (\u0026 self) -\u003e \u0026 str { self.name }\n\tpub fn command \u003c'help\u003e (\u0026 self) -\u003e Command \u003c'help\u003e { self.magic.command () }\n\n\tpub fn invoke (\u0026 self, args: \u0026 ArgMatches) -\u003e GenResult \u003c()\u003e {\n\t\t(self.invoke_fn) (args)\n\t}\n\n}\n\n#[ macro_export ]\nmacro_rules! puzzle_info {\n\n\t(\n\t\tname = $name:literal ;\n\t\tyear = $year:literal ;\n\t\tday = $day:literal ;\n\t\t$($rest4:tt)*\n\t) =\u003e {\n\t\tpub fn puzzle_metadata () -\u003e Box \u003cdyn ::aoc_common::puzzle::Puzzle\u003e {\n\t\t\tuse ::aoc_common::puzzle::Puzzle;\n\t\t\tstruct ThisPuzzle { params: HashMap \u003cString, String\u003e }\n\t\t\timpl Puzzle for ThisPuzzle {\n\t\t\t\tfn dyn_puzzle (\u0026 self) -\u003e \u0026 dyn Puzzle { self }\n\t\t\t\tfn name (\u0026 self) -\u003e \u0026 'static str { $name }\n\t\t\t\tfn year (\u0026 self) -\u003e u16 { $year }\n\t\t\t\tfn day (\u0026 self) -\u003e u8 { $day }\n\t\t\t\tfn set_param_real (\u0026 mut self, name: String, value: String) {\n\t\t\t\t\tself.params.insert (name, value);\n\t\t\t\t}\n\t\t\t\tpuzzle_info! { @rest (input, Ok::\u003c_, Infallible\u003e (input), 0) $($rest4)* }\n\t\t\t}\n\t\t\tlet mut puzzle = ThisPuzzle { params: HashMap::new () };\n\t\t\tpuzzle.set_default_params ();\n\t\t\tBox::new (puzzle)\n\t\t}\n\t};\n\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr) ) =\u003e {\n\t\tfn num_parts (\u0026 self) -\u003e usize { $num_parts }\n\t};\n\t( @rest ($parse_input_old:ident, $parse_expr_old:expr, $num_parts:expr)\n\t\tparse = |$parse_input:ident| $parse_expr:expr;\n\t\t$($rest1:tt)*\n\t) =\u003e {\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest1)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tpart_one = |$part_input:ident $(, $param_name:ident : $param_type:ty)*| $part_expr:expr;\n\t\t$($rest0:tt)*\n\t) =\u003e {\n\t\tfn part_one (\u0026 self, $parse_input: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\t\t$(\n\t\t\t\tlet $param_name: $param_type =\n\t\t\t\t\tself.params [stringify! ($param_name)].parse ().unwrap ();\n\t\t\t)*\n\t\t\tlet $part_input = $parse_expr ?;\n\t\t\tlet result = $part_expr ?;\n\t\t\tOk (format! (\"{}\", result))\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts + 1) $($rest0)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tpart_two = |$part_input:ident $(, $param_name:ident : $param_type:ty)*| $part_expr:expr;\n\t\t$($rest0:tt)*\n\t) =\u003e {\n\t\tfn part_two (\u0026 self, $parse_input: \u0026 [\u0026 str]) -\u003e GenResult \u003cString\u003e {\n\t\t\t$(\n\t\t\t\tlet $param_name: $param_type =\n\t\t\t\t\tself.params [stringify! ($param_name)].parse ().unwrap ();\n\t\t\t)*\n\t\t\tlet $part_input = $parse_expr ?;\n\t\t\tlet result = $part_expr ?;\n\t\t\tOk (format! (\"{}\", result))\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts + 1) $($rest0)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tcommands = [ $($commands:tt)* ];\n\t\t$($rest3:tt)*\n\t) =\u003e {\n\t\tfn commands (\u0026 self) -\u003e Vec \u003c::aoc_common::puzzle::PuzzleCommand\u003e {\n\t\t\tlet mut commands = Vec::new ();\n\t\t\tpuzzle_info! { @commands commands $($commands)* }\n\t\t\tcommands\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest3)* }\n\t};\n\t( @rest ($parse_input:ident, $parse_expr:expr, $num_parts:expr)\n\t\tparams = [ $($params:tt)* ];\n\t\t$($rest:tt)*\n\t) =\u003e {\n\t\tfn set_default_params (\u0026 mut self) {\n\t\t\tpuzzle_info! { @params self $($params)* }\n\t\t}\n\t\tpuzzle_info! { @rest ($parse_input, $parse_expr, $num_parts) $($rest)* }\n\t};\n\n\t( @params ) =\u003e {};\n\t( @params $self:ident $name:ident : $type:ty = $val:expr ; $($rest:tt)* ) =\u003e {\n\t\t$self.set_param_real (stringify! ($name).to_string (), format! (\"{}\", $val as $type));\n\t\tpuzzle_info! { @params $($rest)* }\n\t};\n\n\t( @commands $commands:ident ) =\u003e {};\n\t( @commands $commands:ident (\n\t\tname = $name:literal ;\n\t\tmethod = $method:expr ;\n\t) ) =\u003e {\n\t\t$commands.push (::aoc_common::puzzle::PuzzleCommand::new ($name, $method));\n\t};\n\t( @commands $commands:ident (\n\t\tname = $name:literal ;\n\t\tmethod = $method:expr ;\n\t) , $($rest:tt)* ) =\u003e {\n\t\t$commands.push (::aoc_common::puzzle::PuzzleCommand::new ($name, $method));\n\t\tpuzzle_info! { @commands $commands $($rest)* }\n\t};\n\n}\n","traces":[{"line":17,"address":[345952],"length":1,"stats":{"Line":0},"fn_name":"run_year_and_exit"},{"line":21,"address":[346119,345996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[346113,346198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[346185],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[346265],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[346289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[351724,346320,352769],"length":1,"stats":{"Line":0},"fn_name":"run_year"},{"line":32,"address":[226064,226073],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":42,"address":[346449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[226128,226142],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":51,"address":[346589,346851],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[346867,346947,347387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[346992,347213,347429,347190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[226192,226417,227095],"length":1,"stats":{"Line":0},"fn_name":"{closure#2}"},{"line":58,"address":[226385,226217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[226363,226476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[226546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[226631,226554,226842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[227015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[226979,226770,226938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[227136,227155,227333,226972],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":69,"address":[227181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[346982,347533,347163,347443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[347799,347510,347591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[347823,347994],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[348147,347960],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[348459,348333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[348245,348318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[348396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[348750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[348831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[348982,348850,349122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[349146],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[349294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[349472,349259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[349640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[350029,349655,350201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[349875,349738,350039],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[349810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[350144,350589,350813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[350988,350728,350893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[350945,350993],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[351033,350907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[351114,351042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[351271,351163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[351093,351155,351198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[350815,350770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[350848,351595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[351767,349084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[351783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[351898,352042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[351847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[351943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[352198,352654],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[352479,352559],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[347718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[354202,352832,358563],"length":1,"stats":{"Line":0},"fn_name":"puzzle_invoke_real"},{"line":171,"address":[352909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[354441,353267,353552,353332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[354407,353568,354338],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[354287,353614,353706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[353847,354213,353919,354105,354173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[353954],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[354180,353962,354144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[354330,353878,354377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[353533,354484,355103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[354709,355016,354947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[354908,354771,354819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[354835,354939,354986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[355135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[355312,355436,355236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[355410,355639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[358608],"length":1,"stats":{"Line":0},"fn_name":"percentile"},{"line":195,"address":[358692,358767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[358805,358912,358750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[359032,358895,358950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[359725,359024,359777,359067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[359087,359656,359666,359353,359606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[359388,359341,359622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[355796,355745],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[355821,357506,357660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[357628,357828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[357920],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[358175,357966],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[358414,358143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[355859,355959],"length":1,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[355975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[238544,238813,239008],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":260,"address":[238572,238765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[238833,238927,238757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[238858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[356422,356519,355914],"length":1,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[356535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[239504,239040,239309],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":268,"address":[239261,239068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[239329,239423,239253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[239354],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[356444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[356940,356500,357392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[357173,357246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[357334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[356381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[121682,121664],"length":1,"stats":{"Line":0},"fn_name":"part_two\u003caoc_2021_day_25::puzzle_metadata::ThisPuzzle\u003e"},{"line":296,"address":[56673,56656],"length":1,"stats":{"Line":0},"fn_name":"commands\u003caoc_2015_day_02::puzzle_metadata::ThisPuzzle\u003e"},{"line":298,"address":[56549,56544],"length":1,"stats":{"Line":40},"fn_name":"set_default_params\u003caoc_2015_day_02::puzzle_metadata::ThisPuzzle\u003e"},{"line":300,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[128704,128721],"length":1,"stats":{"Line":0},"fn_name":"command\u003caoc_2021_day_13::tool::RunArgs\u003e"},{"line":345,"address":[127888,128194],"length":1,"stats":{"Line":0},"fn_name":"new\u003caoc_2021_day_13::tool::RunArgs, fn(aoc_2021_day_13::tool::RunArgs) -\u003e core::result::Result\u003c(), alloc::boxed::Box\u003cdyn std::error::Error, alloc::alloc::Global\u003e\u003e\u003e"},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[359808,359813],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":366,"address":[359824,359844],"length":1,"stats":{"Line":0},"fn_name":"command"},{"line":368,"address":[359872],"length":1,"stats":{"Line":0},"fn_name":"invoke"},{"line":369,"address":[359886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[81296,81660,81633],"length":1,"stats":{"Line":23},"fn_name":"puzzle_metadata"},{"line":387,"address":[81688,81680],"length":1,"stats":{"Line":0},"fn_name":"dyn_puzzle"},{"line":388,"address":[81712,81717],"length":1,"stats":{"Line":0},"fn_name":"name"},{"line":389,"address":[81749,81744],"length":1,"stats":{"Line":0},"fn_name":"year"},{"line":390,"address":[81765,81760],"length":1,"stats":{"Line":0},"fn_name":"day"},{"line":391,"address":[81776],"length":1,"stats":{"Line":2},"fn_name":"set_param_real"},{"line":392,"address":[81791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":396,"address":[81311],"length":1,"stats":{"Line":22},"fn_name":null},{"line":397,"address":[81364],"length":1,"stats":{"Line":23},"fn_name":null},{"line":398,"address":[81303,81432],"length":1,"stats":{"Line":45},"fn_name":null},{"line":403,"address":[83397,83392],"length":1,"stats":{"Line":0},"fn_name":"num_parts"},{"line":415,"address":[82625,82598,81888],"length":1,"stats":{"Line":16},"fn_name":"part_one"},{"line":417,"address":[72464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":418,"address":[72472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[82126,81955,81973],"length":1,"stats":{"Line":25},"fn_name":null},{"line":421,"address":[82311,82236],"length":1,"stats":{"Line":16},"fn_name":null},{"line":422,"address":[82290,82411],"length":1,"stats":{"Line":32},"fn_name":null},{"line":430,"address":[82640,83350,83377],"length":1,"stats":{"Line":15},"fn_name":"part_two"},{"line":432,"address":[73472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":433,"address":[73480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":435,"address":[82878,82707,82725],"length":1,"stats":{"Line":24},"fn_name":null},{"line":436,"address":[82988,83063],"length":1,"stats":{"Line":15},"fn_name":null},{"line":437,"address":[83163,83042],"length":1,"stats":{"Line":30},"fn_name":null},{"line":445,"address":[45024,45127],"length":1,"stats":{"Line":0},"fn_name":"commands"},{"line":446,"address":[45045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[45050,45110],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[142816,143142],"length":1,"stats":{"Line":3},"fn_name":"set_default_params"},{"line":457,"address":[142894,142981,143127],"length":1,"stats":{"Line":4},"fn_name":null}],"covered":23,"coverable":190},{"path":["/","home","runner","work","advent-of-code","advent-of-code","common","src","search.rs"],"content":"//! Iterative search algorithms for solutions in a problem space\n\nuse super::*;\nuse grid::Grid;\nuse grid::GridPos;\n\n/// Implements [Digkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n///\n/// This searches for the cheapest path from one point to another, given a starting point (or\n/// points) and a way to iteratively find next points. While this can be used for path-finding, it\n/// can also be used to solve many other problems, assuming their state can be modeled as points,\n/// the next steps can be iterated, and each step can be scored with some kind of priority.\n///\n/// # Example\n///\n/// Here's an example taken from the\n/// [wikipedia page](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm). We use strings for the\n/// nodes instead of integers to make things a bit clearer.\n///\n/// In this example, we supply a hash map directly when constructing the [`PrioritySearch`]. This\n/// works because the trait [`PrioritySearchVisitor`] is implemented directly in this case. It is\n/// also implemented for functions, so you can pass a closure, plus the trait can be implemented\n/// directly, of course.\n///\n/// ```\n/// # use aoc_common::*;\n/// # use aoc_common::search::*;\n/// // set up a data structure with a map of connected nodes and the distance between them\n/// let nodes: HashMap \u003c\u0026 str, Vec \u003c(\u0026 str, u64)\u003e\u003e = {\n///\n///    // use of Itertools::group_by requires a temporary...\n///    let nodes_group_by_temp = [\n///          // list of connected nodes and the distance between them\n///          (\"one\", \"two\", 7), (\"one\", \"three\", 9), (\"one\", \"six\", 14),\n///          (\"two\", \"three\", 10), (\"two\", \"four\", 15), (\"three\", \"four\", 11),\n///          (\"three\", \"six\", 2), (\"four\", \"five\", 6), (\"five\", \"six\", 8),\n///       ].into_iter ()\n///          // double up the connections to include the reverse\n///          .flat_map (|(node_1, node_2, dist)| [(node_1, node_2, dist), (node_2, node_1, dist)])\n///          // group by node_1 (requires sort)\n///          .sorted_by_key (|\u0026 (node_1, _, _)| node_1)\n///         .group_by (|\u0026 (node_1, _, _)| node_1);\n///\n///    // collect into a hash map from node_1 to (node_2, dist)\n///    nodes_group_by_temp.into_iter ()\n///       .map (|(node_1, group)| (\n///             node_1,\n///             group.map (|(_, node_2, dist)| (node_2, dist)).collect::\u003cVec \u003c_\u003e\u003e (),\n///          ))\n///       .collect ()\n///\n/// };\n///\n/// // create a PrioritySearch to traverse our nodes\n/// let mut search = PrioritySearch::with_hash_map (nodes);\n///\n/// // add the starting point with a total distance of 0\n/// search.push (\"one\", 0);\n///\n/// // verify the results\n/// assert_eq! (search.next (), Some ((\"one\", 0)));\n/// assert_eq! (search.next (), Some ((\"two\", 7)));\n/// assert_eq! (search.next (), Some ((\"three\", 9)));\n/// assert_eq! (search.next (), Some ((\"six\", 11)));\n/// assert_eq! (search.next (), Some ((\"five\", 19)));\n/// assert_eq! (search.next (), Some ((\"four\", 20)));\n/// assert_eq! (search.next (), None);\n/// ```\n\npub struct PrioritySearch \u003cNode, Pri, Visitor, Seen\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, Seen\u003e {\n\tvisitor: Visitor,\n\tinner: PrioritySearchInner \u003cNode, Pri, Seen\u003e,\n}\n\nimpl \u003cNode, Pri, Visitor\u003e PrioritySearch \u003cNode, Pri, Visitor, HashMap \u003cNode, PrioritySearchSeenState \u003cPri\u003e\u003e\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, HashMap \u003cNode, PrioritySearchSeenState \u003cPri\u003e\u003e\u003e {\n\tpub fn with_hash_map (visitor: Visitor) -\u003e Self {\n\t\tPrioritySearch {\n\t\t\tvisitor,\n\t\t\tinner: PrioritySearchInner {\n\t\t\t\tseen: HashMap::new (),\n\t\t\t\ttodo: BinaryHeap::new (),\n\t\t\t},\n\t\t}\n\t}\n}\n\nimpl \u003cNode, Pri, Visitor, const DIMS: usize\u003e PrioritySearch \u003cNode, Pri, Visitor, Grid \u003cVec \u003cPrioritySearchSeenState \u003cPri\u003e\u003e, Node, DIMS\u003e\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash + GridPos \u003cDIMS\u003e,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, Grid \u003cVec \u003cPrioritySearchSeenState \u003cPri\u003e\u003e, Node, DIMS\u003e\u003e {\n\tpub fn with_grid (origin: [isize; DIMS], size: [usize; DIMS], visitor: Visitor) -\u003e Self {\n\t\tlet grid = Grid::wrap (\n\t\t\titer::repeat (PrioritySearchSeenState::New)\n\t\t\t\t.take (size.iter ().product ())\n\t\t\t\t.collect (),\n\t\t\torigin,\n\t\t\tsize);\n\t\tPrioritySearch {\n\t\t\tvisitor,\n\t\t\tinner: PrioritySearchInner {\n\t\t\t\tseen: grid,\n\t\t\t\ttodo: BinaryHeap::new (),\n\t\t\t},\n\t\t}\n\t}\n}\n\nimpl \u003cNode, Pri, Visitor, Seen\u003e PrioritySearch \u003cNode, Pri, Visitor, Seen\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, Seen\u003e {\n\n\tpub fn len (\u0026 self) -\u003e usize { self.inner.todo.len () }\n\tpub fn is_empty (\u0026 self) -\u003e bool { self.len () == 0 }\n\n\tpub fn push (\u0026 mut self, node: Node, priority: Pri) -\u003e \u0026 mut Self {\n\t\tself.inner.push (node, priority);\n\t\tself\n\t}\n\n}\n\nimpl \u003cNode, Pri, Visitor, Seen\u003e Iterator for PrioritySearch \u003cNode, Pri, Visitor, Seen\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Copy + Debug + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e,\n\t\tVisitor: PrioritySearchVisitor \u003cNode, Pri, Seen\u003e {\n\n\ttype Item = Visitor::Item;\n\n\tfn next (\u0026 mut self) -\u003e Option \u003cSelf::Item\u003e {\n\t\tif let Some (WithPriority { priority, value: node }) = self.inner.pop () {\n\t\t\tlet adder = PrioritySearchAdder { inner: \u0026 mut self.inner };\n\t\t\treturn Some (self.visitor.visit (node, priority, adder));\n\t\t}\n\t\tNone\n\t}\n\n}\n\nstruct WithPriority \u003cVal, Pri\u003e {\n\tpriority: Pri,\n\tvalue: Val,\n}\n\nimpl \u003cVal, Pri\u003e PartialEq for WithPriority \u003cVal, Pri\u003e where Pri: PartialEq {\n\tfn eq (\u0026 self, other: \u0026 Self) -\u003e bool {\n\t\tself.priority.eq (\u0026 other.priority)\n\t}\n}\n\nimpl \u003cVal, Pri\u003e Eq for WithPriority \u003cVal, Pri\u003e where Pri: Eq {\n}\n\nimpl \u003cVal, Pri\u003e PartialOrd for WithPriority \u003cVal, Pri\u003e where Pri: PartialOrd {\n\tfn partial_cmp (\u0026 self, other: \u0026 Self) -\u003e Option \u003cOrdering\u003e {\n\t\tother.priority.partial_cmp (\u0026 self.priority)\n\t}\n}\n\nimpl \u003cVal, Pri\u003e Ord for WithPriority \u003cVal, Pri\u003e where Pri: Ord {\n\tfn cmp (\u0026 self, other: \u0026 Self) -\u003e Ordering {\n\t\tother.priority.cmp (\u0026 self.priority)\n\t}\n}\n\nstruct PrioritySearchInner \u003cNode, Pri, Seen\u003e {\n\tseen: Seen,\n\ttodo: BinaryHeap \u003cWithPriority \u003cNode, Pri\u003e\u003e,\n}\n\nimpl \u003cNode, Pri, Seen\u003e PrioritySearchInner \u003cNode, Pri, Seen\u003e\n\twhere\n\t\tNode: Clone + Eq + Hash,\n\t\tPri: Clone + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e {\n\tfn push (\u0026 mut self, node: Node, priority: Pri) {\n\t\tif self.seen.push (node.clone (), priority.clone ()) {\n\t\t\tself.todo.push (WithPriority { priority, value: node });\n\t\t}\n\t}\n\tfn pop (\u0026 mut self) -\u003e Option \u003cWithPriority \u003cNode, Pri\u003e\u003e {\n\t\twhile let Some (WithPriority { value: node, priority }) = self.todo.pop () {\n\t\t\tif self.seen.visited (\u0026 node) { continue }\n\t\t\treturn Some (WithPriority { value: node, priority });\n\t\t}\n\t\tNone\n\t}\n}\n\npub struct PrioritySearchAdder \u003c'a, Node, Pri, Seen\u003e {\n\tinner: \u0026 'a mut PrioritySearchInner \u003cNode, Pri, Seen\u003e,\n}\n\nimpl \u003c'a, Node, Pri, Seen\u003e PrioritySearchAdder \u003c'a, Node, Pri, Seen\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Debug + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e {\n\tpub fn add (\u0026 mut self, node: Node, priority: Pri) {\n\t\tself.inner.push (node, priority);\n\t}\n}\n\npub trait PrioritySearchVisitor \u003cNode, Pri, Seen\u003e {\n\ttype Item;\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tadder: PrioritySearchAdder \u003cNode, Pri, Seen\u003e,\n\t) -\u003e Self::Item;\n}\n\nimpl \u003cVisitorFn, Node, Pri, Item, Seen\u003e PrioritySearchVisitor \u003cNode, Pri, Seen\u003e for VisitorFn\n\twhere\n\t\tNode: Clone,\n\t\tPri: Clone + Ord,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e,\n\t\tVisitorFn: FnMut (Node, Pri, PrioritySearchAdder \u003cNode, Pri, Seen\u003e) -\u003e Item {\n\ttype Item = Item;\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tadder: PrioritySearchAdder \u003cNode, Pri, Seen\u003e,\n\t) -\u003e Self::Item {\n\t\tself (node, priority, adder)\n\t}\n}\n\nimpl \u003cNode, Pri, Seen, NextNodesIntoIter\u003e PrioritySearchVisitor \u003cNode, Pri, Seen\u003e\n\tfor HashMap \u003cNode, NextNodesIntoIter\u003e\n\twhere\n\t\tNode: Clone + Debug + Eq + Hash,\n\t\tPri: Clone + Debug + Ord + Add \u003cOutput = Pri\u003e,\n\t\tSeen: PrioritySearchSeen \u003cNode, Pri\u003e,\n\t\tfor \u003c'a\u003e \u0026 'a NextNodesIntoIter: IntoIterator \u003cItem = \u0026 'a (Node, Pri)\u003e {\n\ttype Item = (Node, Pri);\n\tfn visit (\n\t\t\u0026 mut self,\n\t\tnode: Node,\n\t\tpriority: Pri,\n\t\tmut adder: PrioritySearchAdder \u003cNode, Pri, Seen\u003e,\n\t) -\u003e Self::Item {\n\t\tif let Some (next_nodes) = self.get (\u0026 node) {\n\t\t\tfor (next_node, next_pri) in next_nodes.into_iter () {\n\t\t\t\tadder.add (next_node.clone (), priority.clone () + next_pri.clone ());\n\t\t\t}\n\t\t}\n\t\t(node, priority)\n\t}\n}\n\npub trait PrioritySearchSeen \u003cNode, Pri\u003e where Node: Clone, Pri: Clone + Ord {\n\tfn get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut PrioritySearchSeenState \u003cPri\u003e;\n\tfn push (\u0026 mut self, node: Node, priority: Pri) -\u003e bool {\n\t\tlet seen_state = self.get_mut (node);\n\t\tmatch seen_state.clone () {\n\t\t\tPrioritySearchSeenState::New =\u003e {\n\t\t\t\t* seen_state = PrioritySearchSeenState::Unvisited (priority);\n\t\t\t\ttrue\n\t\t\t},\n\t\t\tPrioritySearchSeenState::Unvisited (seen_priority) if priority \u003c seen_priority =\u003e {\n\t\t\t\t* seen_state = PrioritySearchSeenState::Unvisited (priority);\n\t\t\t\ttrue\n\t\t\t},\n\t\t\t_ =\u003e false,\n\t\t}\n\t}\n\tfn visited (\u0026 mut self, node: \u0026 Node) -\u003e bool {\n\t\tlet seen_state = self.get_mut (node.clone ());\n\t\tmatch seen_state.clone () {\n\t\t\tPrioritySearchSeenState::Visited =\u003e true,\n\t\t\t_ =\u003e {\n\t\t\t\t* seen_state = PrioritySearchSeenState::Visited;\n\t\t\t\tfalse\n\t\t\t},\n\t\t}\n\t}\n}\n\nimpl \u003cNode, Pri\u003e PrioritySearchSeen \u003cNode, Pri\u003e for HashMap \u003cNode, PrioritySearchSeenState \u003cPri\u003e\u003e\n\t\twhere Node: Clone + Eq + Hash, Pri: Clone + Ord {\n\tfn get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut PrioritySearchSeenState \u003cPri\u003e {\n\t\tself.entry (node).or_insert (PrioritySearchSeenState::New)\n\t}\n}\n\nimpl \u003cNode, Pri, const DIMS: usize\u003e PrioritySearchSeen \u003cNode, Pri\u003e\n\tfor Grid \u003cVec \u003cPrioritySearchSeenState \u003cPri\u003e\u003e, Node, DIMS\u003e\n\twhere\n\t\tNode: GridPos \u003cDIMS\u003e + Clone + Eq + Hash,\n\t\tPri: Clone + Ord {\n\tfn get_mut (\u0026 mut self, node: Node) -\u003e \u0026 mut PrioritySearchSeenState \u003cPri\u003e {\n\t\tGrid::get_mut (self, node).unwrap ()\n\t}\n}\n\n#[ derive (Clone) ]\npub enum PrioritySearchSeenState \u003cPri: Clone\u003e {\n\tNew,\n\tUnvisited (Pri),\n\tVisited,\n}\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":125,"address":[208576,208585],"length":1,"stats":{"Line":0},"fn_name":"len\u003caoc_2021_day_23::model::StateCompact, i64, aoc_2021_day_23::tools::run_part::{closure_env#0}, std::collections::hash::map::HashMap\u003caoc_2021_day_23::model::StateCompact, aoc_common::search::PrioritySearchSeenState\u003ci64\u003e, std::collections::hash::map::RandomState\u003e\u003e"},{"line":128,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":235,"address":[170208],"length":1,"stats":{"Line":5},"fn_name":"visit\u003caoc_2021_day_23::tools::run_part::{closure_env#0}, aoc_2021_day_23::model::StateCompact, i64, (aoc_2021_day_23::model::StateCompact, i64, arrayvec::arrayvec::ArrayVec\u003c(aoc_2021_day_23::model::StateCompact, i64), 28\u003e), std::collections::hash::map::HashMap\u003caoc_2021_day_23::model::StateCompact, aoc_common::search::PrioritySearchSeenState\u003ci64\u003e, std::collections::hash::map::RandomState\u003e\u003e"},{"line":241,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":8},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1},"fn_name":null}],"covered":46,"coverable":61},{"path":["/","home","runner","work","advent-of-code","advent-of-code","misc","codegen","src","lib.rs"],"content":"use std::collections::HashMap;\nuse std::env;\nuse std::error::Error;\nuse std::fs;\nuse std::fs::File;\nuse std::io::Write;\nuse std::iter;\nuse std::mem;\nuse std::path::PathBuf;\n\npub fn invoke () -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tprintln! (\"cargo:rerun-if-changed=build.rs\");\n\tprintln! (\"cargo:rerun-if-changed=.\");\n\tlet pkg_name = env::var (\"CARGO_PKG_NAME\") ?;\n\tif pkg_name == \"aoc-common\" {\n\t\tlet home = env::current_dir () ?;\n\t\tfor year in [\"2015\", \"2021\"] {\n\t\t\tenv::set_current_dir (format! (\"../{}\", year)) ?;\n\t\t\tprepare_year (year) ?;\n\t\t\tenv::set_current_dir (\u0026 home) ?;\n\t\t}\n\t} else {\n\t\tlet pkg_name_parts: Vec \u003c\u0026 str\u003e = pkg_name.split ('-').collect ();\n\t\tif pkg_name_parts.len () \u003c 2 { panic! () }\n\t\tif pkg_name_parts [0] != \"aoc\" { panic! () }\n\t\tlet year = pkg_name_parts [1];\n\t\tif pkg_name_parts.len () == 2 {\n\t\t\tprepare_year (year) ?\n\t\t} else if pkg_name_parts.len () == 4 {\n\t\t\tif pkg_name_parts [2] != \"day\" { panic! () }\n\t\t\tlet day = pkg_name_parts [3];\n\t\t\tprepare_day (year, day) ?\n\t\t} else { panic! () }\n\t}\n\tOk (())\n}\n\nfn prepare_year (year: \u0026 str) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tlet static_part = |template| {\n\t\treplace_placeholders (\n\t\t\ttemplate,\n\t\t\t\u0026 HashMap::from_iter (vec! [\n\t\t\t\t(\"${YEAR}\", year),\n\t\t\t]))\n\t};\n\tlet dynamic_part = |template| {\n\t\t(1 ..= 25)\n\t\t\t.filter_map (move |day|\n\t\t\t\tif PathBuf::from (format! (\"day-{:02}\", day)).exists () {\n\t\t\t\t\tSome (replace_placeholders (\n\t\t\t\t\t\ttemplate,\n\t\t\t\t\t\t\u0026 HashMap::from_iter (vec! [\n\t\t\t\t\t\t\t(\"${YEAR}\", year),\n\t\t\t\t\t\t\t(\"${DAY}\", \u0026 format! (\"{:02}\", day)),\n\t\t\t\t\t\t] ),\n\t\t\t\t\t))\n\t\t\t\t} else { None })\n\t\t\t.flatten ()\n\t};\n\twrite_file (\n\t\t\"src/lib.rs\",\n\t\titer::empty ()\n\t\t\t.chain (static_part (templates::YEAR_LIB [0]))\n\t\t\t.chain (dynamic_part (templates::YEAR_LIB [1]))\n\t\t\t.chain (static_part (templates::YEAR_LIB [2]))\n\t\t\t.chain (dynamic_part (templates::YEAR_LIB [3]))\n\t\t\t.chain (static_part (templates::YEAR_LIB [4])),\n\t) ?;\n\twrite_file (\n\t\t\"src/main.rs\",\n\t\tstatic_part (templates::YEAR_MAIN),\n\t) ?;\n\tOk (())\n}\n\nfn prepare_day (year: \u0026 str, day: \u0026 str) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\twrite_file (\n\t\t\"src/main.rs\",\n\t\treplace_placeholders (templates::DAY_MAIN, \u0026 HashMap::from_iter (vec! [\n\t\t\t(\"${YEAR}\", year),\n\t\t\t(\"${DAY}\", day),\n\t\t])),\n\t) ?;\n\tOk (())\n}\n\nfn write_file \u003cItem: AsRef \u003cstr\u003e, LinesIter: IntoIterator \u003cItem = Item\u003e\u003e (\n\tname: \u0026 str,\n\tlines: LinesIter,\n) -\u003e Result \u003c(), Box \u003cdyn Error\u003e\u003e {\n\tlet mut new_contents = String::new ();\n\tfor line in lines.into_iter () {\n\t\tlet line = line.as_ref ();\n\t\tnew_contents.push_str (line);\n\t\tnew_contents.push ('\\n');\n\t}\n\tlet old_contents = fs::read_to_string (name).unwrap_or_default ();\n\tif old_contents != new_contents {\n\t\tlet mut main_rs_file = File::create (name) ?;\n\t\twrite! (\u0026 mut main_rs_file, \"{}\", new_contents) ?;\n\t}\n\tOk (())\n}\n\nfn replace_placeholders (lines: \u0026 [\u0026 str], replacements: \u0026 HashMap \u003c\u0026 str, \u0026 str\u003e) -\u003e Vec \u003cString\u003e {\n\tlines.iter ().map (|line| {\n\t\tlet (output, buffer) = line.chars ().fold ((String::new (), String::new ()),\n\t\t\t|(mut output, mut buffer), letter| {\n\t\t\t\tif (buffer.is_empty () \u0026\u0026 letter == '$')\n\t\t\t\t\t\t|| (buffer.len () == 1 \u0026\u0026 letter == '{')\n\t\t\t\t\t\t|| buffer.len () \u003e 1 {\n\t\t\t\t\tbuffer.push (letter);\n\t\t\t\t\tif letter == '}' {\n\t\t\t\t\t\tlet replacement = replacements.get (buffer.as_str ()).unwrap_or_else (||\n\t\t\t\t\t\t\tpanic! (\"Replacement not found for: {}\", buffer),\n\t\t\t\t\t\t);\n\t\t\t\t\t\toutput.push_str (replacement);\n\t\t\t\t\t\tbuffer = String::new ();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toutput.push_str (mem::take (\u0026 mut buffer).as_str ());\n\t\t\t\t\toutput.push (letter);\n\t\t\t\t}\n\t\t\t\t(output, buffer)\n\t\t\t},\n\t\t);\n\t\tif ! buffer.is_empty () { panic! () }\n\t\toutput\n\t}).collect ()\n}\n\nmod templates {\n\n\tpub const YEAR_LIB: \u0026 [\u0026 [\u0026 str]] = \u0026 [\n\t\t\u0026 [\n\t\t\t\"use aoc_common::*;\",\n\t\t\t\"\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"pub use aoc_${YEAR}_day_${DAY} as day_${DAY};\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\",\n\t\t\t\"pub fn puzzle_metadata () -\u003e Vec \u003cBox \u003cdyn puzzle::Puzzle\u003e\u003e {\",\n\t\t\t\"\\tvec! [\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\\t\\tday_${DAY}::puzzle_metadata (),\",\n\t\t],\n\t\t\u0026 [\n\t\t\t\"\\t]\",\n\t\t\t\"}\",\n\t\t],\n\t];\n\n\tpub const YEAR_MAIN: \u0026 [\u0026 str] = \u0026 [\n\t\t\"use aoc_common::*;\",\n\t\t\"\",\n\t\t\"fn main () -\u003e GenResult \u003c()\u003e {\",\n\t\t\"\\tpuzzle::run_year_and_exit (\u0026 aoc_${YEAR}::puzzle_metadata (), true)\",\n\t\t\"}\",\n\t];\n\n\tpub const DAY_MAIN: \u0026 [\u0026 str] = \u0026 [\n\t\t\"use std::env;\",\n\t\t\"use std::ffi::OsString;\",\n\t\t\"\",\n\t\t\"use aoc_common::*;\",\n\t\t\"use aoc_${YEAR}_day_${DAY}::*;\",\n\t\t\"\",\n\t\t\"fn main () -\u003e GenResult \u003c()\u003e {\",\n\t\t\"\tlet args: Vec \u003cOsString\u003e = env::args_os ().collect ();\",\n\t\t\"\tpuzzle_metadata ().invoke (\u0026 args)\",\n\t\t\"}\",\n\t];\n\n}\n","traces":[{"line":11,"address":[62420,61245,59360],"length":1,"stats":{"Line":0},"fn_name":"invoke"},{"line":12,"address":[59367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[59418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[59630,59469],"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[59803,59598],"length":1,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[59843,60051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[60811,59971,60214,61130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[60698,60423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[60940,60659,60837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[60925,61074,61135],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[59817,61348],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[61489,61449,61386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[61598,61529,61455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[61563,61636],"length":1,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[62081,62306,61683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[62238,61728,62308,62399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[61756,62363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[61779,61849,61909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[61877,61963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[62176,62083,61986],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[62139,61811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[61289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[62845,62875,62448],"length":1,"stats":{"Line":0},"fn_name":"prepare_year"},{"line":39,"address":[62465],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[99294,99208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[99241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[99488,99655],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":47,"address":[99615,99544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[100018,99664,100778,99579],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":49,"address":[99707,100069,100048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[100719,100667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[100079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[100511,100634,100212,100096,100421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[100131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[100254,100468,100190],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[100586,100682,100062,100750],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[62517,62586,62924,63105,63282,62723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[62522,62607],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[62615,62762,62868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[62963,62886,63054,62778],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[62979,63235,63144,63064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[63160,63318,63245,63368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[63425],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[63650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[63728,64403],"length":1,"stats":{"Line":0},"fn_name":"prepare_day"},{"line":79,"address":[63787,63945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[63859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[63902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[64447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[102152,100800,102721,103516,101369,102192],"length":1,"stats":{"Line":0},"fn_name":"write_file\u003calloc::string::String, alloc::vec::Vec\u003calloc::string::String, alloc::alloc::Global\u003e\u003e"},{"line":91,"address":[100838,102230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[101380,100915,102307,102732,102415,101022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[101303,102655,101239,102591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[101327,102679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[102699,101347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[101430,102782],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[101531,101476,102883,102828],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[102937,101679,103034,101582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[101993,101659,103195,103351,101837,103014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[102889,101537],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[64464],"length":1,"stats":{"Line":0},"fn_name":"replace_placeholders"},{"line":106,"address":[64524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[103863,103590,103807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[105082,105126,104137,103796,104096,104716],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":109,"address":[104189,104244,104369,104407,104439,104309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[104334,104297],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[104395,104432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[104488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[104977,104499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[104509,104739,105152],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":115,"address":[105161],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[104805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[104832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[104466,104990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[105102],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[104555],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[103962,103988,103913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[103968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[104020,103981,103929,104083],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":79},{"path":["/","home","runner","work","advent-of-code","advent-of-code","src","lib.rs"],"content":"//! Advent of Code solutions by James Pharaoh\n//!\n//! [https://adventofcode.com/](https://adventofcode.com/)\n//!\n//! Home: [https://github.com/jamespharaoh/advent-of-code](https://github.com/jamespharaoh/advent-of-code)  \n\npub use aoc_2015 as year_2015;\npub use aoc_2021 as year_2021;\npub use aoc_common as common;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>